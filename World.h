#pragma once
#include <chrono>
#include "enet/dirent.h"
#include <sstream>
#include <filesystem>
#include <experimental/filesystem>
#include "RiftCape.h"
#include "Player.h"
#include "Webhooks.h"
string server_version = "3.99";

#define HOME_TIME (15 * 1000)
#define WORLDBAN_TIME (3600 * 1000)
#define WARP_TIME (15 * 1000)
namespace fs = std::filesystem;
using namespace chrono;
bool saving_ = false, f_saving_ = false;
int item1 = 0, item2 = 0, item1c = 0, item2c = 0, day_ = 0, thedaytoday = 0, theitemtoday = 0, today_day = 0;
//
string news_text = "", news_texture = "";
int worlds_active = 0;
int WindowsAdd = 0;
int iPhoneAdd = 0;
int MacosAdd = 0;
int LinuxAdd = 0;
int AndroidAdd = 0;
int serverTimeOn = 0;
vector<int> growganoth_platform, growganoth_disabled;
long long int server_event_spawn = 0, last_world_save = 0;
bool restart_server_status = false;
bool restart_server_status_seconds = false;
int restart_server_time = 10;
bool autosave = false;
//
int volcanic_cape = 0, volcanic_wings = 0;

struct Position2D {
	int x, y;
};
string a = "";
vector<pair<string, long long int>> home_timed;
vector<string> ipbans, t_worlds;
string lastsbworld = "";
int server_port = 17198;
vector<vector<string>> info_about_playmods{
	// playmod id, consumableid_time, playmod name, playmod on used, playmod on removed, display id, state, skin, how work, eff, say text after using, gravity
	{"1", "388_300", "Stinky", "You really really smell.", "The air clears.", "372", "14", "spray.wav", "", "", "", "", ""},
	{"2", "1368_2", "Frozen", "Your body has turned to ice. You can't move!", "You've thawed out.", "1368", "11", "freeze.wav", "4284769380", "", "", "", ""},
	{"3", "274_10", "Frozen", "Freeze!", "You've thawed out.", "274", "11", "freeze.wav", "4284769380", "", "", "", ""},
	{"4", "874_180", "Egged!", "You have egg on your face.", "You washed your face!", "874", "", "", "16777215", "throw", "42", "", ""},
	{"5", "3404_0", ":D`#YUM!``", "", "", "", "", "", "", "consume", "", "", ""},
	{"6", "3406_0", ":D`#YUM!``", "", "", "", "", "", "", "consume", "", "", ""},
	{"7", "4422_0", ":D`#YUM!``", "", "", "", "", "", "", "consume", "", "", ""},
	{"8", "386_0", "", "", "", "", "", "", "", "cutewords", "", "", ""},
	{"9", "10660_1800", "Lucky in Love: Increased chance of Golden Heart Crystal", "Increased chance of Golden Heart Crystal!", "The honeymoon phase is over!", "10660", "", "", "", "", "", ":D`#YUMMY!``", ""},
	{"10", "2206_1800", "Irradiated", "You are aglow with radiation!", "You have recovered.", "2206", "", "", "", "", "", "", ""},
	{"11", "408_600", "Duct Tape", "Duct tape has covered your mouth!", "Duct tape removed. OUCH!", "408", "", "already_used.wav", "", "", "", "", ""},
	{"12", "384_3600", "Valentine", "You are somebody's valentine!", "Yuck!", "384", "", "choir.wav", "2526478335", "", "", "", ""},
	{"13", "2480_600", "Megaphone!", "Broadcasting to ALL!", "You can broadcast once again.", "2480", "", "", "", "", "", "", ""},
	{"14", "528_1800", "Lucky", "You're luckier than before!", "Your luck has worn off.", "528", "15", "", "", "", "", "", ""},
	{"15", "1510_10", "1512", "", "", "", "", "", "", "pet", "", "Legend says that you need 10 Blarney Pebbles!", ""},
	{"16", "540_900", "Envious", "It ain't easy being you.", "Healthy color restored.", "540", "", "eat.wav", "1627349247", "", "", "", ""},
	{"17", "196_3600", "Feelin' Blue", "A `!blueberry`` slides down your throat!", "The effects of the `!blueberry`` have worn off.", "196", "", "spray.wav", "4278190335", "drop", "", "", ""},
	{"18", "338_2", "Floating!", "Whoooooooaaaaaaaa...", "Gravity - it's the law.", "338", "", "balloon.wav", "", "drop", "", "", "-30"},
	{"19", "962_180", "Saucy!", "You are a saucy person.", "You got cleaned up.", "962", "", "", "2554747", "throw", "45", "", ""},
	{"20", "950_0", ":D`#YUM!``", "", "", "", "", "", "", "consume", "", "", ""},
	{"21", "968_0", ":D`#YUM!``", "", "", "", "", "", "", "consume", "", "", ""},
	{"22", "1058_0", ":D`#YUM!``", "", "", "", "", "", "", "consume", "", "", ""},
	{"23", "1096_0", ":D`#YUM!``", "", "", "", "", "", "", "consume", "", "", ""},
	{"24", "868_0", ":D`#YUM!``", "", "", "", "", "", "", "consume", "", "", ""},
	{"25", "782_3600", "Antidote!", "You are now immune to zombie bites! Temporarily...", "Your immunity is gone.", "782", "", "", "", "drop", "25", "", ""},
	{"26", "4668_0", ":D`#YUM!``", "", "", "", "", "", "", "consume", "", "", ""},
	{"27", "128_1800", "Golden Halo!", "You have been good.", "You're falling out of favor.", "128", "7", "", "-2104114177", "drop", "25", "", ""},
	{"28", "764_60", "Infected!", "You've been infected by the g-Virus. Punch others to infect them, too! Braiiiins...", "You've been cured.", "764", "16", "", "", "drop", "", "", ""},
	{"29", "5178_1800", "Lucky", "You're luckier than before!", "Your luck has worn off.", "5178", "15", "", "", "", "", "", ""},
	{"30", "1058_0", ":D`#YUM!``", "", "", "", "", "", "", "consume", "", "", ""},
	{"31", "1094_0", ":D`#YUM!``", "", "", "", "", "", "", "consume", "", "", ""},
	{"32", "1096_0", ":D`#YUM!``", "", "", "", "", "", "", "consume", "", "", ""},
	{"33", "1098_0", ":D`#YUM!``", "", "", "", "", "", "", "consume", "", "", ""},
	{"34", "2002_86400","Doctor Replusion", "Doctors won't come near you!", "You no longer repel doctors.", "2002", "", "spray.wav", "", "", "", "", ""},
	{"35", "7058_300", "Food: Purified Scythe", "Hand Scythe breaks 5% less!", "You no longer feel pure!", "7058", "15", "", "", "", "", "", ""},
	{"36", "1056_1800", "Lucky", "You're luckier than before!", "Your luck has worn off.", "1056", "15", "", "", "", "", "", ""},
	{"37", "4378_0", ":D`#YUM!``", "", "", "", "", "", "", "consume", "", "", ""},
	{"38", "614_300", "Stinky", "You really really smell.", "The air clears.", "614", "14", "spray.wav", "", "", "", "", ""},
	{"39", "1374_0", ":D`#YUM!``", "", "", "", "", "", "", "consume", "", "", ""},
	{"40", "406_0", ":D`#YUM!``", "", "", "", "", "", "", "consume", "", "", ""},
	{"41", "966_0", ":D`#YUM!``", "", "", "", "", "", "", "consume", "", "", ""},
	{"42", "4766_1800", "Blushing Red", "`4Cherry`` red lips!", "The effects of the `!Cherry`` have worn off.", "4766", "", "spray.wav", "842203135", "drop", "", "", ""},
	{"43", "958_0", ":D`#YUM!``", "", "", "", "", "", "", "consume", "", "", ""},
	{"44", "950_0", ":D`#YUM!``", "", "", "", "", "", "", "consume", "", "", ""},
	{"45", "1580_0", ":D`#YUM!``", "", "", "", "", "", "", "consume", "", "", ""},
	{"46", "7052_0", ":D`#YUM!``", "", "", "", "", "", "", "consume", "", "", ""},
	{"46", "7052_0", ":D`#YUM!``", "", "", "", "", "", "", "consume", "", "", ""},
	{"47", "1634_5", "Caffeinated", "You are full of caffeine!", "Ugh. Caffeine crash.", "1634", "14", "spray.wav", "", "", "", "", ""},
	{"48", "4672_900", "Envious", "It ain't easy being you.", "Healthy color restored.", "4672", "", "spray.wav", "1234743295", "", "", "", ""},
	{"49", "6314_2", "Frozen", "Your body has turned to ice. You can't move!", "You've thawed out.", "6314", "11", "freeze.wav", "4284769380", "", "", "", ""},
	{"50", "3064_0", "", "", "", "3064", "", "", "", "throw", "34", "", ""},
	{"51", "8520_0", ":D`#YUM!``", "", "", "", "", "", "", "consume", "", "", ""},
	{"52", "10628_0", "/dab", "", "", "", "", "", "", "consume", "", "", ""},
	{"53", "1474_1800", "Food: Extra XP", "25% chance of double XP for all actions.", "Your stomach's rumbling.", "1474", "", "spray.wav", "", "drop", "", "", ""},
	{"54", "3546_0", ":D`#YUM!``", "", "", "", "", "", "", "consume", "", "", ""},
	{"55", "3600_0", ":D`#YUM!``", "", "", "", "", "", "", "consume", "", "", ""},
	{"56", "3836_0", ":D`#YUM!``", "", "", "", "", "", "", "consume", "", "", ""},
	{"57", "3240_0", ":D`#YUM!``", "", "", "", "", "", "", "consume", "", "", ""},
	{"58", "4410_0", ":P`#Bleh.``", "", "", "", "", "", "", "consume", "", "", ""},
	{"59", "4984_0", ":D`#YUM!``", "", "", "", "", "", "", "consume", "", "", ""},
	{"60", "2734_0", ":D`#YUM!``", "", "", "", "", "", "", "consume", "", "", ""},
	{"61", "3622_0", ":D`#YUM!``", "", "", "", "", "", "", "consume", "", "", ""},
	{"62", "10988_0", ":D`#YUM!``", "", "", "", "", "", "", "consume", "", "", ""},
	{"63", "4764_0", ":D`#YUM!``", "", "", "", "", "", "", "consume", "", "", ""},
	{"64", "964_0", ":D`#YUM!``", "", "", "", "", "", "", "consume", "", "", ""},
	{"65", "3428_0", ":D`#YUM!``", "", "", "", "", "", "", "consume", "", "", ""},
	{"66", "4752_0", ":D`#YUM!``", "", "", "", "", "", "", "consume", "", "", ""},
	{"67", "3816_0", ":D`#YUM!``", "", "", "", "", "", "", "consume", "", "", ""},
	{"68", "3816_0", ":D`#YUM!``", "", "", "", "", "", "", "consume", "", "", ""},
	{"69", "126_1800", "Devil Horns", "You little devil...", "Off the naughty list!", "126", "6", "spray.wav", "", "drop", "", "", ""},
	{"70", "1964_1800", "Devil Horns", "You little devil...", "Off the naughty list!", "1964", "6", "spray.wav", "", "drop", "", "", ""},
	{"71", "960_5", "ON FIRE!!!", "You are burning up!", "The fire's out.", "960", "17", "spray.wav", "842203135", "", "", "", ""},
	{"72", "712_5", "ON FIRE!!!", "You are burning up!", "The fire's out.", "712", "17", "spray.wav", "842203135", "", "", "", ""},
	{"73", "1988_1800", "Haunted!", "You are haunted!", "Not anymore.", "372", "18", "spray.wav", "", "", "", "", ""},
	{"74", "1772_2", "Floating!", "Whoooooooaaaaaaaa...", "Gravity - it's the law.", "1772", "", "balloon.wav", "", "drop", "", "", "-30"},
	{"75", "5262_5", "Neon Gum!", "Dazzle your friends as super funky neon lines course across your skin.", "Party's over.", "5262", "28", "spray.wav", "", "drop", "", "", ""},
	{"76", "676_86400","Doctor Replusion", "Doctors won't come near you!", "You no longer repel doctors.", "676", "", "spray.wav", "", "", "", "", ""},
	{"77", "276_0", "", "", "", "", "", "", "", "cutewords", "", "", ""},
	{"78", "278_0", "Cursed", "You've been cursed", "You are no longer cursed. Now be good!", "278", "", "already_used.wav", "", "cutewords", "", "", ""},
	{"79", "618_0", "", "", "", "", "", "", "", "", "", "", ""},
	{"80", "616_0", "", "", "", "", "", "", "", "", "", "", ""},
	{"81", "614_0", ":P", "", "", "", "", "", "", "consume", "", "", ""},
	{"82", "750_1800", "Lucky", "You're luckier than before!", "Your luck has worn off.", "750", "15", "", "", "", "", "", ""},
	{"83", "752_0", "", "", "", "", "", "", "", "cutewords", "25", "", ""},
	{"84", "1208_0", ":D`#YUM!``", "", "", "", "", "", "", "consume", "", "", ""},
	{"85", "5114_120", "Calm Nerves", "Steady hands of a surgeon.", "Butterfingers again.", "5114", "14", "spray.wav", "", "", "", "", ""},
	{"86", "6912_1800", "Spicey Skills", "Reduce your skill fails by half in both Surgery and Startopia missions.", "Your stomach's too spicey.", "6912", "", "spray.wav", "", "", "", "", ""},
	{"87", "3536_0", "Mmm, sugar!", "", "", "", "", "", "", "consume", "", "", ""},
	{"88", "1260_3600", "Malpractice", "You are not allowed to perform surgery for a while!", "You can surg again.", "1260", "", "", "", "", "", "", ""},
	{"89", "1270_3600", "Recovering", "You are recovering from surgery.", "You healed.", "1270", "", "", "", "", "", "", ""},
	{"90", "8500_0", "", "", "", "", "", "", "", "cutewords", "", "", ""},
	{"91", "4602_300", "Stinky", "You really really smell.", "The air clears.", "4602", "14", "spray.wav", "", "", "", "", ""},
	{"92", "8544_43200", "Lupus malady", "You've been infected with lupus!", "You no longer have lupus!", "8544", "", "spray.wav", "", "", "", "", ""},
	{"93", "8540_43200", "Moldy Guts malady", "You've been infected with moldy guts!", "You no longer have moldy guts!", "8540", "", "spray.wav", "", "", "", "", ""},
	{"94", "8546_43200", "Ecto-Bones malady", "You've been infected with Ecto-Bones!", "Your bones are no longer ectoplasmic!", "8546", "", "spray.wav", "", "", "", "", ""},
	{"95", "8538_43200", "Chaos Infection malady", "You've been infected with CHAOS!", "You no longer have CHAOS!", "8538", "", "spray.wav", "", "", "", "", ""},
	{"96", "8548_43200", "Fatty Liver malady", "You've been infected with fatty liver!", "You no longer have fatty liver!", "8548", "", "spray.wav", "", "", "", "", ""},
	{"97", "8542_43200", "Brainworms malady", "You've been infected with brainworms!", "You no longer have brainworms!", "8542", "", "spray.wav", "", "", "", "", ""},
	{"98", "6908_1800", "Food: Buff Duration", "Increase the duration of food buffs by 30%", "Your stomach can't take anymore buffs!", "6908", "", "spray.wav", "", "drop", "", "", ""},
	{"99", "5452_1800", "Food: Extra XP", "10% chance of triple XP for all actions.", "Your body craves sugar!", "5452", "", "spray.wav", "", "drop", "", "", ""},
	{"100", "732_0", "", "", "", "", "", "", "", "cutewords", "", "", ""},
	{"101", "5460_0", "", "", "", "", "", "", "", "", "", "", ""},
	{"102", "5462_0", "", "", "", "", "", "", "", "", "", "", ""},
	{"103", "5464_0", "", "", "", "", "", "", "", "", "", "", ""},
	{"104", "5466_0", "", "", "", "", "", "", "", "", "", "", ""},
	{"105", "3822_0", "", "", "", "", "", "", "", "", "", "", ""},
	{"106", "3824_0", "", "", "", "", "", "", "", "", "", "", ""},
	{"107", "3826_0", "", "", "", "", "", "", "", "", "", "", ""},
	{"108", "3828_0", "", "", "", "", "", "", "", "", "", "", ""},
	{"109", "3830_0", "", "", "", "", "", "", "", "", "", "", ""}
};
//#include <mutex>


//mutex m;
struct Portrait
{
	uint32_t c_expression = 1;
	/*
	* 1: Unconcerned
	* 2: Happy
	* 3: Sad
	* 4: Tongue Out
	* 5: Surprised
	* 6: Angry
	* 7: Talking
	* 9: Ecstatic
	* 24: Wry
	* 12: Sleeping
	* 14: Winking
	* 16: Trolling
	* 18: Vampire
	* 22: Underwater
	*
	*/
	uint32_t c_hair_colour = 0;
	uint32_t c_skin = 0;
	uint16_t c_face = 0;
	uint16_t c_head = 0;
	uint16_t c_hair = 0;
};
void to_json(json& j, const Portrait& p) {
	j = json{
		{"c_expression", p.c_expression},
		{"c_hair_colour", p.c_hair_colour},
		{"c_skin", p.c_skin},
		{"c_face", p.c_face},
		{"c_head", p.c_head},
		{"c_hair", p.c_hair}
	};
}
void from_json(const json& j, Portrait& p) {
	j["c_expression"].get_to(p.c_expression);
	j["c_hair_colour"].get_to(p.c_hair_colour);
	j["c_skin"].get_to(p.c_skin);
	j["c_face"].get_to(p.c_face);
	j["c_head"].get_to(p.c_head);
	j["c_hair"].get_to(p.c_hair);
}
struct Mannequin
{
	uint16_t c_head = 0;
	uint16_t c_shirt = 0;
	uint16_t c_pants = 0;
	uint16_t c_feet = 0;
	uint16_t c_mask = 0;
	uint16_t c_hand = 0;
	uint16_t c_back = 0;
	uint16_t c_hair = 0;
	uint16_t c_neck = 0;
};
void to_json(json& j, const Mannequin& p) {
	j = json{
		{"c_head", p.c_head},
		{"c_shirt", p.c_shirt},
		{"c_pants", p.c_pants},
		{"c_feet", p.c_feet},
		{"c_mask", p.c_mask},
		{"c_hand", p.c_hand},
		{"c_back", p.c_back},
		{"c_hair", p.c_hair},
		{"c_neck", p.c_neck}
	};
}
void from_json(const json& j, Mannequin& p) {
	j["c_head"].get_to(p.c_head);
	j["c_shirt"].get_to(p.c_shirt);
	j["c_pants"].get_to(p.c_pants);
	j["c_feet"].get_to(p.c_feet);
	j["c_mask"].get_to(p.c_mask);
	j["c_hand"].get_to(p.c_hand);
	j["c_back"].get_to(p.c_back);
	j["c_hair"].get_to(p.c_hair);
	j["c_neck"].get_to(p.c_neck);
}
struct Donate
{
	int item = 0, count = 0;
	string name = "", text = "";
};

void to_json(json& j, const Donate& p) {
	j = json{
		{"item", p.item},
		{"count", p.count},
		{"name", p.name},
		{"text", p.text}
	};
}
void from_json(const json& j, Donate& p) {
	j["item"].get_to(p.item);
	j["count"].get_to(p.count);
	j["name"].get_to(p.name);
	j["text"].get_to(p.text);
}
struct WorldBlock
{
	uint16_t fg = 0, bg = 0;
	int fruit = 0;
	uint32_t id = 0, wl = 0;
	size_t c_ = 0;
	int pr = 0;
	int battle_pet = 0;
	long long lp = 0, planted = 0;
	int hp = -1, sp = 0;
	uint8_t roll = 0;
	bool ice_age = false, volcano = false, islands = false;
	string txt = "";
	string door_destination = "", door_id = "";
	bool open = true;
	int flags = 0x00000000;
	long long last_punch_weather = 0;
	bool scanned = false;
	int rate_of_fire = 10, projectile_speed = 100;
	// magplants
	bool enabled = false;
	int gravity = 50;
	bool spin = false, invert = false;
	bool magnetron = false;
	bool locked = false;
	int lock_origin = -1;
	bool open_to_public = false;
	bool empty_air = false;
	vector<string> admins{};
	string owner_name = "";
	string owner_named = "";
	bool build_only = false;
	bool limit_admins = false;
	vector<vector<int>> crystals{};
	Mannequin mannequin{};
	vector<Donate> donates{};
	int r = 255, g = 128, b = 64;
	Portrait portrait{};
	uint32_t bunny_egg_progress = 0;
	string heart_monitor = "";
	string spotlight = "";
	bool fossil = false;
	uint32_t shelf_1 = 0, shelf_2 = 0, shelf_3 = 0, shelf_4 = 0;
};
struct WorldMachines
{
	uint16_t id = 0, x = 0, y = 0, target_item = 0;
	bool enabled = false;
	long long last_ = 0;
};

struct WorldNPC
{
	uint16_t id = 0, x = 0, y = 0, rate_of_fire = 10, projectile_speed = 100;
	float kryptis = 0;
	int uid = 0;
	bool enabled = false;
	long long last_ = 0, started_moving = 0;
};
struct WorldDrop
{
	int id = 0, count = 0, uid = 0, x = 0, y = 0;
	bool special = false;
};
struct WorldSBOX1
{
	int id = 0, count = 0, x = 0, y = 0;
};
struct WorldGrowscan
{
	int x = 0, y = 0;
	bool world_public = false, floating_public = false;
};
struct WorldBulletinSettings
{
	int x = 0, y = 0;
	bool public_can_add = false, hide_names = false;
};

struct WorldCCTVSettings
{
	int x = 0, y = 0;
	bool show_item_taking = false, show_item_dropping = false, show_people_entering = true, show_people_exiting = false, dont_show_owner = false, dont_show_admins = false, dont_show_noaccess = false;
};

struct WorldCCTV
{
	int x = 0, y = 0;
	string logs;
};

struct WorldBulletin
{
	int x = 0, y = 0;
	string name = "", text = "";
};
struct GlobalMonitors
{
	string world_name = "";
	int x = -1, y = -1;
	uint32_t active = 0;
};
vector<GlobalMonitors> monitors;
struct World
{
	int honors = 0;
	string name = "", owner_name = "", owner_named = "";
	bool nuked = false;
	string n_t = "";
	string n_b = "";
	vector<string> admins{};
	vector<WorldBlock> blocks{};
	vector<WorldDrop> drop{};
	vector<WorldGrowscan> gscan{};
	vector<WorldCCTVSettings> cctv_settings{};
	vector<WorldCCTV> cctv{};
	vector<WorldSBOX1> sbox1{};
	vector<WorldBulletin> bulletin{};
	vector<WorldBulletinSettings> bulletins{};
	uint16_t weather = 0;
	uint16_t d_weather = 0;
	bool v_p = false;
	bool open_to_public = false, disable_music_blocks = false, make_music_blocks_invisible = false;
	vector<pair<string, long long int>> bannedPlayers{};
	long long last_address_change = 0;
	bool zombie_jammer = false;
	uint32_t music_bpm = 100;
	int entry_level = 1;
	vector<int> active_jammers{};
	vector<WorldNPC> npc{};
	vector<WorldMachines> machines{};
	int guild_id = 0;
	long long int save_time = 0;
	int lockid = 0;
	bool rainbows = false, silence = false;

	long long last_special_event = 0, last_comet_spawn = 0;
	int special_event_item = 0;
	int special_event_item_taken = 0;
	bool special_event = false;
};
vector<World> worlds;
map<string, vector<WorldNPC>> active_npc;
map<string, vector<WorldMachines>> active_machines;
int get_free_slots(Player* p_) {
	int free = 0; // -1
	for (int i_ = 0; i_ < p_->inv.size(); i_++) {
		if (p_->inv[i_].id == 0 and p_->inv[i_].count == 0)
			free++;
	}
	return free;
}


void punch_tile(ENetPeer* peer, int x, int y, int t_, int n_, int net_, int state_, bool tree_ = false, int count_ = 1, bool every_ = true) {
	PlayerMoving data{ net_, 0, t_, state_, n_, x, y, 0, (float)x, (float)y, 0, 0 };
	BYTE* p_ = packPlayerMoving(&data);
	p_[2] = 0, p_[3] = tree_ ? count_ : 0;
	int32_t item = pInfo(peer)->hand;
	memcpy(p_ + 8, &item, 4);
	if (every_) {
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != pInfo(peer)->world) continue;
			send_raw(currentPeer, 4, p_, 56, ENET_PACKET_FLAG_RELIABLE);
		}
	}
	else {
		send_raw(peer, 4, p_, 56, ENET_PACKET_FLAG_RELIABLE);
	}
	delete[]p_;
}

void update_tile(ENetPeer* peer, int16_t x, int16_t y, int16_t n_, bool add, bool everyone) {
	//if (add) growganoth_platform.push_back(x + (y * 100));
	PlayerMoving data{ 0, 0, 3, 0, n_, x, y, 0, (float)x, (float)y, 0, 0 };
	BYTE* p_ = packPlayerMoving(&data);
	if (everyone) {
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != pInfo(peer)->world) continue;
			send_raw(currentPeer, 4, p_, 56, ENET_PACKET_FLAG_RELIABLE);
		}
	}
	else send_raw(peer, 4, p_, 56, ENET_PACKET_FLAG_RELIABLE);
	send_raw(peer, 4, p_, 56, ENET_PACKET_FLAG_RELIABLE);
	delete[]p_;
}

World create_world(const string& name_, int s_) {
	World world_;
	world_.name = name_;
	int d_ = rand() % (s_ / (s_ / 100) - 4) + 2;
	for (int i_ = 0; i_ < s_; i_++) {
		WorldBlock block_{ 0, 0, uint16_t(-1) }; // buvo WorldBlock block_{0, 0, -1}; 
		if (i_ >= 3800 && i_ < 5400 && !(rand() % 50))
			block_.fg = 10;
		else if (i_ >= 3700 && i_ < 5400) {
			if (i_ > 5000) {
				if (rand() % 8 < 3)
					block_.fg = 4;
				else
					block_.fg = 2;
			}
			else
				block_.fg = 2;
		}
		else if (i_ >= 5400)
			block_.fg = 8;
		if (i_ == 3600 + d_)
			block_.fg = 6;
		if (i_ == 3700 + d_)
			block_.fg = 8;
		if (i_ >= 3700)
			block_.bg = 14;
		world_.blocks.push_back(block_);
	}
	worlds.push_back(world_);
	return world_;
}

void AddLogs(ENetPeer* p_, string logs) {
	time_t currentTime;
	time(&currentTime);
	const auto localTime = localtime(&currentTime);
	const auto Hour = localTime->tm_hour;
	const auto Min = localTime->tm_min;
	const auto Sec = localTime->tm_sec;
	const auto Year = localTime->tm_year + 1900;
	const auto Day = localTime->tm_mday;
	const auto Month = localTime->tm_mon + 1;
	std::string asdasdasd;
	if (Sec < 10) asdasdasd = "0";
	std::string asdasdasd2;
	if (Min < 10) asdasdasd2 = "0";
	std::string asdasdasd3;
	if (Hour < 10) asdasdasd3 = "0";
	std::string asdasdasd31;
	if (Month < 10) asdasdasd31 = "0";
	std::string asdasdasd32;
	if (Day < 10) asdasdasd32 = "0";
	std::string asdasdasd33;
	if (Year < 10) asdasdasd33 = "0";
	pInfo(p_)->logs.push_back("" + asdasdasd32 + to_string(Day) + "." + asdasdasd31 + to_string(Month) + "." + asdasdasd33 + to_string(Year) + " " + asdasdasd3 + to_string(Hour) + ":" + asdasdasd2 + to_string(Min) + ":" + asdasdasd + to_string(Sec) + " Console - " + logs + "");
}
void WriteTxt(string folder, string text) {
	replace_str(folder, ":", ".");
	if (folder == "db/accounts/mac/02.00.00.00.00.00") return;
	ofstream m;
	m.open(folder + ".txt", ios::out | ios::app | ios::binary);
	m << text;
	m.close();
}
World get_world(const string& name_) {
	/*galima buvo daryti pagal worldid o ne name bet jeigu worldus trinti is memory tai nk gero nebus*/
	vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
	if (p != worlds.end()) {
		return worlds[p - worlds.begin()]; // return worldo struktura   
	}
	// Worldo Nera bet jis gali buti issaugotas  
	string path_ = "worlds/" + name_ + "_.json";
	if (_access_s(path_.c_str(), 0) == 0) {
		World world_;
		try {
			// Pakrauti worlda is json      

			/*
			jeigu nera naudoti sita
						if (world_read.find("rainbows") != world_read.end()) world_.rainbows = world_read["rainbows"].get<bool>();
						*/
			json world_read;
			ifstream world_file(path_, ifstream::binary);
			world_file >> world_read;
			world_file.close();
			world_.name = name_;
			world_.entry_level = world_read["entry_level"].get<int>();
			world_.open_to_public = world_read["public"].get<bool>();
			world_.nuked = world_read["nuked"].get<bool>();
			world_.n_t = world_read["n_t"].get<string>();
			world_.n_b = world_read["n_b"].get<string>();
			world_.music_bpm = world_read["music_bpm"].get<uint32_t>();
			world_.weather = world_read["weather"].get<uint16_t>();
			world_.make_music_blocks_invisible = world_read["invisible_music_blocks"].get<bool>();
			world_.disable_music_blocks = world_read["disable_music_blocks"].get<bool>();
			world_.owner_name = world_read["owner"].get<string>();
			world_.rainbows = world_read["rainbows"].get<bool>();
			world_.silence = world_read["silence"].get<bool>();
			world_.guild_id = world_read["guild_id"].get<int>();
			world_.d_weather = world_read["d_weather"].get<int>();
			world_.owner_named = world_read["o2"].get<string>();
			world_.v_p = world_read["v_p"].get<bool>();
			/*if cant find
						json gscan_ = json::array();
			if (world_read.find("gscan") != world_read.end()) gscan_ = world_read["gscan"].get<json>();
			*/
			json sbx1_ = world_read["sbox1"].get<json>();
			json gscan_ = world_read["gscan"].get<json>();
			json bulletins_ = world_read["sbull"].get<json>();
			json cctv_get_settings_ = world_read["sstv"].get<json>();
			json cctv_ = world_read["cctv"].get<json>();
			json bullet_ = world_read["bulletin"].get<json>();
			json p_ = world_read["blocks"].get<json>(), a_ = world_read["drop"].get<json>(), adm_ = world_read["admins"].get<json>(), npc_vector_ = world_read["npc"].get<json>(), machine_vector_ = world_read["machine"].get<json>();
			for (int i_ = 0; i_ < adm_.size(); i_++) {
				string name_ = adm_[i_]["name"].get<string>();
				world_.admins.push_back(name_);
			}
			for (int i_ = 0; i_ < p_.size(); i_++) {
				WorldBlock b_{};
				if (p_[i_].find("f") != p_[i_].end()) b_.fg = p_[i_]["f"].get<int>();
				if (p_[i_].find("b") != p_[i_].end()) b_.bg = p_[i_]["b"].get<int>();
				if (p_[i_].find("p") != p_[i_].end()) b_.planted = p_[i_]["p"].get<long long>();
				if (p_[i_].find("fc") != p_[i_].end()) b_.fruit = p_[i_]["fc"].get<int>();
				if (p_[i_].find("sp") != p_[i_].end()) b_.sp = p_[i_]["sp"].get<int>();
				if (p_[i_].find("t") != p_[i_].end()) b_.txt = p_[i_]["t"].get<string>();
				if (p_[i_].find("n") != p_[i_].end()) b_.roll = p_[i_]["n"].get<uint8_t>();
				if (p_[i_].find("id") != p_[i_].end()) b_.id = p_[i_]["id"].get<uint32_t>();
				if (p_[i_].find("c") != p_[i_].end()) b_.c_ = p_[i_]["c"].get<uint32_t>();
				if (p_[i_].find("wl") != p_[i_].end()) b_.wl = p_[i_]["wl"].get<uint32_t>();
				if (p_[i_].find("pr") != p_[i_].end()) b_.pr = p_[i_]["pr"].get<int>();
				if (p_[i_].find("o") != p_[i_].end()) b_.open = p_[i_]["o"].get<bool>();
				if (p_[i_].find("ia") != p_[i_].end()) b_.ice_age = p_[i_]["ia"].get<bool>();
				if (p_[i_].find("vcn") != p_[i_].end()) b_.volcano = p_[i_]["vcn"].get<bool>();
				if (p_[i_].find("flis") != p_[i_].end()) b_.islands = p_[i_]["flis"].get<bool>();
				if (p_[i_].find("dd") != p_[i_].end()) b_.door_destination = p_[i_]["dd"].get<string>();
				if (p_[i_].find("di") != p_[i_].end()) b_.door_id = p_[i_]["di"].get<string>();
				if (p_[i_].find("fl") != p_[i_].end()) b_.flags = p_[i_]["fl"].get<int>();
				if (p_[i_].find("ps") != p_[i_].end()) b_.projectile_speed = p_[i_]["ps"].get<int>();
				if (p_[i_].find("rf") != p_[i_].end()) b_.rate_of_fire = p_[i_]["rf"].get<int>();
				if (p_[i_].find("en") != p_[i_].end()) b_.enabled = p_[i_]["en"].get<bool>();
				if (p_[i_].find("in") != p_[i_].end()) b_.invert = p_[i_]["in"].get<bool>();
				if (p_[i_].find("sn") != p_[i_].end()) b_.spin = p_[i_]["sn"].get<bool>();
				if (p_[i_].find("g") != p_[i_].end()) b_.gravity = p_[i_]["g"].get<int>();
				if (p_[i_].find("m") != p_[i_].end()) b_.magnetron = p_[i_]["m"].get<bool>();
				if (p_[i_].find("l") != p_[i_].end()) b_.locked = p_[i_]["l"].get<bool>();
				if (p_[i_].find("lq") != p_[i_].end()) b_.lock_origin = p_[i_]["lq"].get<int>();
				if (p_[i_].find("lo") != p_[i_].end()) b_.owner_name = p_[i_]["lo"].get<string>();
				if (p_[i_].find("ea") != p_[i_].end()) b_.empty_air = p_[i_]["ea"].get<bool>();
				if (p_[i_].find("otp") != p_[i_].end()) b_.open_to_public = p_[i_]["otp"].get<bool>();
				if (p_[i_].find("ad") != p_[i_].end()) {
					json read_block_admins_ = p_[i_]["ad"].get<json>();
					for (int i_2 = 0; i_2 < read_block_admins_.size(); i_2++) {
						string name_ = read_block_admins_[i_2]["name"].get<string>();
						b_.admins.push_back(name_);
					}
				}
				if (p_[i_].find("bo") != p_[i_].end()) b_.build_only = p_[i_]["bo"].get<bool>();
				if (p_[i_].find("la") != p_[i_].end()) b_.limit_admins = p_[i_]["la"].get<bool>();
				if (p_[i_].find("cr") != p_[i_].end()) b_.crystals = p_[i_]["cr"].get<vector<vector<int>>>();
				if (p_[i_].find("mq") != p_[i_].end()) b_.mannequin = p_[i_]["mq"].get<Mannequin>();
				if (p_[i_].find("dnt") != p_[i_].end()) {
					json read_block_donation_ = p_[i_]["dnt"].get<json>();
					for (int i_2 = 0; i_2 < read_block_donation_.size(); i_2++) {
						Donate new_donate;
						new_donate.item = read_block_donation_[i_2]["item"].get<int>();
						new_donate.count = read_block_donation_[i_2]["count"].get<int>();
						new_donate.text = read_block_donation_[i_2]["text"].get<string>();
						new_donate.name = read_block_donation_[i_2]["name"].get<string>();
						b_.donates.push_back(new_donate);
					}
				}
				if (p_[i_].find("r1") != p_[i_].end()) b_.r = p_[i_]["r1"].get<int>();
				if (p_[i_].find("g1") != p_[i_].end()) b_.g = p_[i_]["g1"].get<int>();
				if (p_[i_].find("b1") != p_[i_].end()) b_.b = p_[i_]["b1"].get<int>();
				if (p_[i_].find("prs") != p_[i_].end()) b_.portrait = p_[i_]["prs"].get<Portrait>();
				if (p_[i_].find("bep") != p_[i_].end()) b_.bunny_egg_progress = p_[i_]["bep"].get<uint32_t>();
				if (p_[i_].find("hm") != p_[i_].end()) b_.heart_monitor = p_[i_]["hm"].get<string>();
				if (p_[i_].find("sh1") != p_[i_].end()) b_.shelf_1 = p_[i_]["sh1"].get<uint32_t>();
				if (p_[i_].find("sh2") != p_[i_].end()) b_.shelf_2 = p_[i_]["sh2"].get<uint32_t>();
				if (p_[i_].find("sh3") != p_[i_].end()) b_.shelf_3 = p_[i_]["sh3"].get<uint32_t>();
				if (p_[i_].find("sh4") != p_[i_].end()) b_.shelf_4 = p_[i_]["sh4"].get<uint32_t>();
				world_.blocks.push_back(b_);
			}
			int fix_uid = 0;
			for (int i_ = 0; i_ < a_.size(); i_++) {
				WorldDrop b_{};
				b_.id = a_[i_]["i"].get<int>();
				if (b_.id == 0) {
					fix_uid++;
					continue;
				}
				b_.count = a_[i_]["c"].get<int>();
				b_.uid = a_[i_]["u"].get<int>() - fix_uid;
				b_.x = a_[i_]["x"].get<int>();
				b_.y = a_[i_]["y"].get<int>();
				world_.drop.push_back(b_);
			}
			for (int i_ = 0; i_ < sbx1_.size(); i_++) {
				WorldSBOX1 db_{};
				db_.id = sbx1_[i_]["i"].get<int>();
				db_.count = sbx1_[i_]["c"].get<int>();
				db_.x = sbx1_[i_]["x"].get<int>();
				db_.y = sbx1_[i_]["y"].get<int>();
				world_.sbox1.push_back(db_);
			}
			for (int i_ = 0; i_ < gscan_.size(); i_++) {
				WorldGrowscan db_{};
				db_.x = gscan_[i_]["x"].get<int>();
				db_.y = gscan_[i_]["y"].get<int>();
				db_.world_public = gscan_[i_]["world_public"].get<bool>();
				db_.floating_public = gscan_[i_]["floating_public"].get<bool>();
				world_.gscan.push_back(db_);
			}
			for (int i_ = 0; i_ < cctv_get_settings_.size(); i_++) {
				WorldCCTVSettings db_{};
				db_.x = cctv_get_settings_[i_]["x"].get<int>();
				db_.y = cctv_get_settings_[i_]["y"].get<int>();
				db_.show_item_taking = cctv_get_settings_[i_]["s1"].get<bool>();
				db_.show_item_dropping = cctv_get_settings_[i_]["s2"].get<bool>();
				db_.show_people_entering = cctv_get_settings_[i_]["s3"].get<bool>();
				db_.show_people_exiting = cctv_get_settings_[i_]["s4"].get<bool>();
				db_.dont_show_owner = cctv_get_settings_[i_]["s5"].get<bool>();
				db_.dont_show_admins = cctv_get_settings_[i_]["s6"].get<bool>();
				db_.dont_show_noaccess = cctv_get_settings_[i_]["s7"].get<bool>();
				world_.cctv_settings.push_back(db_);
			}
			for (int i_ = 0; i_ < cctv_.size(); i_++) {
				WorldCCTV db_{};
				db_.x = cctv_[i_]["x"].get<int>();
				db_.y = cctv_[i_]["y"].get<int>();
				db_.logs = cctv_[i_]["l"].get<string>();
				world_.cctv.push_back(db_);
			}
			for (int i_ = 0; i_ < bullet_.size(); i_++) {
				WorldBulletin db_{};
				db_.x = bullet_[i_]["x"].get<int>();
				db_.y = bullet_[i_]["y"].get<int>();
				db_.name = bullet_[i_]["n"].get<string>();
				db_.text = bullet_[i_]["t"].get<string>();
				world_.bulletin.push_back(db_);
			}
			for (int i_ = 0; i_ < bulletins_.size(); i_++) {
				WorldBulletinSettings db_{};
				db_.x = bulletins_[i_]["x"].get<int>();
				db_.y = bulletins_[i_]["y"].get<int>();
				db_.public_can_add = bulletins_[i_]["s1"].get<bool>();
				db_.hide_names = bulletins_[i_]["s2"].get<bool>();
				world_.bulletins.push_back(db_);
			}
			for (int i_ = 0; i_ < npc_vector_.size(); i_++) {
				WorldNPC npc_{};
				npc_.id = npc_vector_[i_]["i"].get<uint16_t>();
				npc_.x = npc_vector_[i_]["x"].get<uint16_t>();
				npc_.y = npc_vector_[i_]["y"].get<uint16_t>();
				npc_.projectile_speed = npc_vector_[i_]["ps"].get<uint16_t>();
				npc_.rate_of_fire = npc_vector_[i_]["rf"].get<uint16_t>();
				npc_.kryptis = npc_vector_[i_]["kr"].get<float>();
				npc_.enabled = npc_vector_[i_]["en"].get<bool>();
				npc_.last_ = npc_vector_[i_]["l"].get<long long>();
				npc_.started_moving = npc_vector_[i_]["sm"].get<long long>();
				world_.npc.push_back(npc_);
			}
			for (int i_ = 0; i_ < machine_vector_.size(); i_++) {
				WorldMachines machine_{};
				machine_.id = machine_vector_[i_]["i"].get<uint16_t>();
				machine_.x = machine_vector_[i_]["x"].get<uint16_t>();
				machine_.y = machine_vector_[i_]["y"].get<uint16_t>();
				machine_.target_item = machine_vector_[i_]["ti"].get<uint16_t>();
				machine_.enabled = machine_vector_[i_]["en"].get<bool>();
				machine_.last_ = machine_vector_[i_]["l"].get<long long>();
				world_.machines.push_back(machine_);
			}
		}
		catch (exception err) {
			remove(path_.c_str());
			world_ = create_world(name_, 6000);
		}
		worlds.push_back(world_);
		if (world_.npc.size() != 0 or world_.machines.size() != 0) {
			if (find(t_worlds.begin(), t_worlds.end(), world_.name) == t_worlds.end()) {
				t_worlds.push_back(world_.name);
			}
		}
		return world_;
	}
	return create_world(name_, 6000);
}


World create_world_blast(const string& name_, int blast) {
	vector<int> id;
	World world_;
	if (blast == 9164 || blast == 1402 || blast == 1060) {
		if (blast == 1060) world_.d_weather = 6;
		int d_ = rand() % (6000 / (6000 / 100) - 4) + 2;
		for (int i_ = 0; i_ < 6000; i_++) {
			WorldBlock block_{ 0, 0, uint16_t(-1) }; // buvo WorldBlock block_{0, 0, -1};
			if (blast == 9164) {
				if (i_ >= 1800 && i_ < 5400 && !(rand() % 50)) block_.fg = 8532;
				else if (i_ > 1600 && i_ < 1700 && !(rand() % 2)) block_.fg = 8532;
				else if (i_ >= 1700 && i_ < 5400) {
					if (i_ > 5000) {
						if (rand() % 8 < 3) block_.fg = 9162;
						else block_.fg = 8532;
					}
					else block_.fg = 8532;
				}
				else if (i_ >= 5400) block_.fg = 8;
				if (i_ == 1600 + d_) block_.fg = 6;
				if (i_ == 1700 + d_) block_.fg = 8;
				if (i_ >= 1700) block_.bg = 14;
			}
			else if (blast == 1402) {
				if (i_ >= 5400) block_.fg = 8;
				if (i_ == 5200) block_.fg = 6;
				if (i_ == 5300)block_.fg = 8;
			}
			else if (blast == 1060) {
				if (i_ >= 3800 && i_ < 5400 && !(rand() % 50)) block_.fg = 10;
				else if (i_ >= 3600 && i_ < 3700) {
					id = { 231,487,483,2019,427,1757,2009,281,781,329,459,1041,421,2787,2789,1043,2797,181,613,65,4983,283,553,425,4635,987,627,2017,989,61,4639,973,3523,331,265,859,433,253,339,1105,439,4567,333,677,5673,1427,5603,183,10533,5731,7223,10833,6035,6813,1113,1047,653,2811,4703,1429,847,665,485,1613,833,2025,1775,3931,429,3831,423,437,1773,4767,1299,361,667,2815,3473,301,4637,5683,2709,415,955,461,861,9389,5467,2791,2815,1803,419,2027,685,555,741,10531,5729,7221,10831,6033,6811,621,6401,1107,359,3471,855,309,1685,1449,1309,441,1111,221,1431,3065,9307,1257,1501,1109,4641,3587,1103,417,743,431,3823,2949,1131,3825,727,5379,729,187,787,5459,4785,3261,3521,2293,2309,2321,2333,5461,3721,327,247,63,3479,445,4783,299,863,8935,1451,261,1871,1499,455,9391,683,1159,551,1745,411,3005,557,687,4799,559,4643,3899,1605,9309,567,565,1155,3827,1327,1767,993,1157,563,4721,115,1423,10515,1329,6545,287,669,777,5463,1655,1599,561,4585,3413,4745,1771,2011,1161,1729,3757,3753,321,3265,3263,623,775,6397,129,4667,759,3767,1529,6543,4707,3835,1435,651,8929,569,527,3287,1595,6063,2795,1003,1731,4943,4963,597,4669,1531,1523,625,4297,599,657,571,873,3755,2969,1725,4603,1447,3267,5375,1683 };
					block_.fg = id[rand() % id.size()], block_.fruit = items[block_.fg].rarity == 999 ? 1 : (rand() % 4) + 1, block_.planted = time(nullptr) - (items[block_.fg].growTime);
				}
				else if (i_ >= 3700 && i_ < 5400) {
					if (i_ > 5000) {
						if (rand() % 8 < 3) block_.fg = 4;
						else block_.fg = 2;
					}
					else block_.fg = 2;
				}
				else if (i_ >= 5400) block_.fg = 8;
				if (i_ == 3600 + d_) block_.fg = 6;
				if (i_ == 3700 + d_) block_.fg = 8;
				if (i_ >= 3700) block_.bg = 14;
			}
			world_.blocks.push_back(block_);
		}
	}
	else if (blast == 1532) {
		world_ = get_world("GENERATED_UNDERSEA_BLAST99971");
		world_.d_weather = 14;
	}
	else if (blast == 1532) {
		world_ = get_world("GENERATED_UNDERSEA_BLAST99971");
		world_.d_weather = 14;
	}
	else if (blast == 830) {
		world_ = get_world("GENERATED_SUMMER_BLAST464");
		world_.d_weather = 1;
	}
	else if (blast == 830) {
		world_ = get_world("GENERATED_SUMMER_BLAST464");
		world_.d_weather = 1;
	}
	else if (blast == 1136) {
		world_ = get_world("GENERATED_MARS_BLAST_15");
		world_.d_weather = 7;
	}
	else if (blast == 3562) {
		world_ = get_world("GENERATED_CAVE_BLAST_1554");
		world_.blocks[5000 - rand() % 700].fg = 3604;
		world_.blocks[5300 - rand() % 700].fg = 3604;
	}
	else if (blast == 7588) {
		world_ = get_world("GENERATED_TREASURE_BLAST_156");
		world_.d_weather = 44;
	}
	else if (blast == 942) {
		world_ = get_world("GENERATED_DESRT_BLAST");
		world_.d_weather = 3;
	}
	else if (blast == 4774) {
		id = { 4778, 4714,4778, 4714, 10066, 11188 };
		world_ = get_world("GENERATE_JUNGLE_BLAST_156");
		WorldDrop drop_block_{};
		drop_block_.id = id[rand() % id.size()], drop_block_.count = 1, drop_block_.uid = uint16_t(world_.drop.size()) + 1, drop_block_.x = 835, drop_block_.y = 1485;
		world_.d_weather = 32;
		world_.drop.push_back(drop_block_);
	}
	else if (blast == 7380) {
		world_ = get_world("GENERATE_MONOCHROME_BL_15");
		world_.d_weather = 43;
	}
	else if (blast == 8556) {
		world_ = get_world("GEENRATE_SURG_188");
		world_.d_weather = 45;
	}
	world_.name = name_;
	worlds.push_back(world_);
	return world_;
}
void writelog(string text) {
	fstream fs;
	fs.open("db/logs.txt", ios::in | ios::app | ios::out | fstream::app);
	fs << text + "\n<br>";
	fs.close();
}
void tradelog(string text) {
	fstream fs;
	fs.open("db/trade.txt", ios::in | ios::app | ios::out | fstream::app);
	fs << text + "\n";
	fs.close();
}
void donatelog(string text) {
	fstream fs;
	fs.open("db/donate.txt", ios::in | ios::app | ios::out | fstream::app);
	fs << text + "\n";
	fs.close();
}
void droplog(string text) {
	fstream fs;
	fs.open("db/droplog.txt", ios::in | ios::app | ios::out | fstream::app);
	fs << text + "\n";
	fs.close();
}
void chatlog(string text) {
	fstream fs;
	fs.open("db/chat.txt", ios::in | ios::app | ios::out | fstream::app);
	fs << text + "\n";
	fs.close();
}
void momlog(string text) {
	fstream fs;
	fs.open("db/mom.txt", ios::in | ios::app | ios::out | fstream::app);
	fs << text + "\n";
	fs.close();
}
void rolelog(string text) {
	fstream fs;
	fs.open("db/role.txt", ios::in | ios::app | ios::out | fstream::app);
	fs << text + "\n";
	fs.close();
}


void writelogd(string text) {
	fstream fs;
	fs.open("db/display.txt", ios::in | ios::app | ios::out | fstream::app);
	fs << text + "\n<br>";
	fs.close();
}

void writepacket(string text) {
	fstream fs;
	fs.open("db/packet.txt", ios::in | ios::app | ios::out | fstream::app);
	fs << text + "\n";
	fs.close();
}

void save_world(const string& name_, bool erase = true) {
	vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
	if (p != worlds.end()) {
		__int64 id_ = p - worlds.begin();
		World* world_ = &worlds[id_];
		json save_, blocks_ = json::array(), drops_ = json::array(), sboxs1_ = json::array(), gscans_ = json::array(), bulletin_s = json::array(), cctv_save_settings_ = json::array(), cctv_save_ = json::array(), bulletins_ = json::array(), donates_ = json::array(), admins_ = json::array(), npcs = json::array(), machines = json::array();
		save_["entry_level"] = world_->entry_level;
		save_["nuked"] = world_->nuked;
		save_["n_t"] = world_->n_t;
		save_["n_b"] = world_->n_b;
		save_["music_bpm"] = world_->music_bpm;
		save_["public"] = world_->open_to_public;
		save_["weather"] = world_->weather;
		save_["invisible_music_blocks"] = world_->make_music_blocks_invisible;
		save_["disable_music_blocks"] = world_->disable_music_blocks;
		save_["owner"] = world_->owner_name;
		save_["guild_id"] = world_->guild_id;
		save_["d_weather"] = world_->d_weather;
		save_["o2"] = world_->owner_named;
		save_["v_p"] = world_->v_p;
		save_["rainbows"] = world_->rainbows;
		save_["silence"] = world_->silence;
		for (int i_ = 0; i_ < world_->admins.size(); i_++) {
			json admin_;
			admin_["name"] = world_->admins[i_];
			admins_.push_back(admin_);
		}
		bool add_fossil = false;
		if (rand() % 2 < 1) add_fossil = true;
		for (int i_ = 0; i_ < world_->blocks.size(); i_++) {
			json block_;
			if (world_->blocks[i_].fg != 0) {
				if (add_fossil && f_saving_ && world_->blocks[i_].fg == 10 && rand() % 6900 < 1) {
					cout << "gave a fossil to " << name_ << endl;
					block_["f"] = 3918;
				}
				else block_["f"] = world_->blocks[i_].fg;
			}
			if (world_->blocks[i_].bg != 0) block_["b"] = world_->blocks[i_].bg;
			if (world_->blocks[i_].planted != 0) block_["p"] = world_->blocks[i_].planted;
			if (world_->blocks[i_].fruit != 0 and world_->blocks[i_].fruit != 65535) block_["fc"] = world_->blocks[i_].fruit;
			if (world_->blocks[i_].sp != 0) block_["sp"] = world_->blocks[i_].sp;
			if (world_->blocks[i_].txt != "") block_["t"] = world_->blocks[i_].txt;
			if (world_->blocks[i_].roll != 0) block_["n"] = world_->blocks[i_].roll;
			if (world_->blocks[i_].id != 0) block_["id"] = world_->blocks[i_].id;
			if (world_->blocks[i_].c_ != 0) block_["c"] = world_->blocks[i_].c_;
			if (world_->blocks[i_].wl != 0) block_["wl"] = world_->blocks[i_].wl;
			if (world_->blocks[i_].pr != 0) block_["pr"] = world_->blocks[i_].pr;
			if (world_->blocks[i_].ice_age != false) block_["ia"] = world_->blocks[i_].ice_age;
			if (world_->blocks[i_].volcano != false) block_["vcn"] = world_->blocks[i_].volcano;
			if (world_->blocks[i_].islands != false) block_["flis"] = world_->blocks[i_].islands;
			if (world_->blocks[i_].open != true) block_["o"] = world_->blocks[i_].open;
			if (world_->blocks[i_].door_destination != "") block_["dd"] = world_->blocks[i_].door_destination;
			if (world_->blocks[i_].door_id != "") block_["di"] = world_->blocks[i_].door_id;
			if (world_->blocks[i_].flags != 0x00000000) block_["fl"] = world_->blocks[i_].flags;
			if (world_->blocks[i_].rate_of_fire != 10) block_["rf"] = world_->blocks[i_].rate_of_fire;
			if (world_->blocks[i_].projectile_speed != 100) block_["ps"] = world_->blocks[i_].projectile_speed;
			if (world_->blocks[i_].enabled != false) block_["en"] = world_->blocks[i_].enabled;
			if (world_->blocks[i_].invert != false) block_["in"] = world_->blocks[i_].invert;
			if (world_->blocks[i_].spin != false) block_["sn"] = world_->blocks[i_].spin;
			if (world_->blocks[i_].gravity != 50) block_["g"] = world_->blocks[i_].gravity;
			if (world_->blocks[i_].magnetron != false) block_["m"] = world_->blocks[i_].magnetron;
			if (world_->blocks[i_].locked != false) block_["l"] = world_->blocks[i_].locked;
			if (world_->blocks[i_].lock_origin != -1) block_["lq"] = world_->blocks[i_].lock_origin;
			if (world_->blocks[i_].owner_name != "") block_["lo"] = world_->blocks[i_].owner_name;
			if (world_->blocks[i_].empty_air != false) block_["ea"] = world_->blocks[i_].empty_air;
			if (world_->blocks[i_].open_to_public != false) block_["otp"] = world_->blocks[i_].open_to_public;
			if (world_->blocks[i_].admins.size() != 0) {
				json block_admins_ = json::array();
				for (int i_2 = 0; i_2 < world_->blocks[i_].admins.size(); i_2++) {
					json admin_;
					admin_["name"] = world_->blocks[i_].admins[i_2];
					block_admins_.push_back(admin_);
				}
				block_["ad"] = block_admins_;
			}
			if (world_->blocks[i_].build_only != false) block_["bo"] = world_->blocks[i_].build_only;
			if (world_->blocks[i_].limit_admins != false) block_["la"] = world_->blocks[i_].limit_admins;
			if (world_->blocks[i_].crystals.size() != 0) block_["cr"] = world_->blocks[i_].crystals;
			if (world_->blocks[i_].mannequin.c_head != 0 or world_->blocks[i_].mannequin.c_shirt != 0 or world_->blocks[i_].mannequin.c_pants != 0 or world_->blocks[i_].mannequin.c_feet != 0 or world_->blocks[i_].mannequin.c_mask != 0 or world_->blocks[i_].mannequin.c_hand != 0 or world_->blocks[i_].mannequin.c_back != 0 or world_->blocks[i_].mannequin.c_hair != 0 or world_->blocks[i_].mannequin.c_neck != 0) {
				block_["mq"] = world_->blocks[i_].mannequin;
			}
			if (world_->blocks[i_].donates.size() != 0) {
				json block_donates_ = json::array();
				for (int i_2 = 0; i_2 < world_->blocks[i_].donates.size(); i_2++) {
					json donate_;
					donate_["item"] = world_->blocks[i_].donates[i_2].item;
					donate_["count"] = world_->blocks[i_].donates[i_2].count;
					donate_["text"] = world_->blocks[i_].donates[i_2].text;
					donate_["name"] = world_->blocks[i_].donates[i_2].name;
					block_donates_.push_back(donate_);
				}
				block_["dnt"] = block_donates_;
			}
			if (world_->blocks[i_].r != 255) block_["r1"] = world_->blocks[i_].r;
			if (world_->blocks[i_].g != 128) block_["g1"] = world_->blocks[i_].g;
			if (world_->blocks[i_].b != 64) block_["b1"] = world_->blocks[i_].b;
			if (world_->blocks[i_].portrait.c_expression != 1 or world_->blocks[i_].portrait.c_hair_colour != 0 or world_->blocks[i_].portrait.c_skin != 0 or world_->blocks[i_].portrait.c_face != 0 or world_->blocks[i_].portrait.c_head != 0 or world_->blocks[i_].portrait.c_hair != 0) {
				block_["prs"] = world_->blocks[i_].portrait;
			}
			if (world_->blocks[i_].bunny_egg_progress != 0) block_["bep"] = world_->blocks[i_].bunny_egg_progress;
			if (world_->blocks[i_].heart_monitor != "") block_["hm"] = world_->blocks[i_].heart_monitor;
			if (world_->blocks[i_].shelf_1 != 0) block_["sh1"] = world_->blocks[i_].shelf_1;
			if (world_->blocks[i_].shelf_2 != 0) block_["sh2"] = world_->blocks[i_].shelf_2;
			if (world_->blocks[i_].shelf_3 != 0) block_["sh3"] = world_->blocks[i_].shelf_3;
			if (world_->blocks[i_].shelf_4 != 0) block_["sh4"] = world_->blocks[i_].shelf_4;
			blocks_.push_back(block_);
		}

		if (f_saving_) for (int i_ = 0, uid = 0; i_ < world_->drop.size(); i_++) if (world_->drop[i_].id <= 0 || world_->drop[i_].x < 0 || world_->drop[i_].y < 0 || world_->drop[i_].x > 3200 || world_->drop[i_].y > 1888) world_->drop.erase(world_->drop.begin() + i_);
		for (int i_ = 0; i_ < world_->drop.size(); i_++) {
			json drop_;
			drop_["i"] = world_->drop[i_].id;
			drop_["c"] = world_->drop[i_].count;
			drop_["u"] = (f_saving_ ? i_ : world_->drop[i_].uid);
			drop_["x"] = world_->drop[i_].x;
			drop_["y"] = world_->drop[i_].y;
			drops_.push_back(drop_);
		}
		for (int i_ = 0; i_ < world_->sbox1.size(); i_++) {
			json sbox1_;
			sbox1_["i"] = world_->sbox1[i_].id;
			sbox1_["c"] = world_->sbox1[i_].count;
			sbox1_["x"] = world_->sbox1[i_].x;
			sbox1_["y"] = world_->sbox1[i_].y;
			sboxs1_.push_back(sbox1_);
		}
		for (int i_ = 0; i_ < world_->gscan.size(); i_++) {
			json gscan_;
			gscan_["x"] = world_->gscan[i_].x;
			gscan_["y"] = world_->gscan[i_].y;
			gscan_["world_public"] = world_->gscan[i_].world_public;
			gscan_["floating_public"] = world_->gscan[i_].floating_public;
			gscans_.push_back(gscan_);
		}
		for (int i_ = 0; i_ < world_->cctv_settings.size(); i_++) {
			json cctv_settings_;
			cctv_settings_["x"] = world_->cctv_settings[i_].x;
			cctv_settings_["y"] = world_->cctv_settings[i_].y;
			cctv_settings_["s1"] = world_->cctv_settings[i_].show_item_taking;
			cctv_settings_["s2"] = world_->cctv_settings[i_].show_item_dropping;
			cctv_settings_["s3"] = world_->cctv_settings[i_].show_people_entering;
			cctv_settings_["s4"] = world_->cctv_settings[i_].show_people_exiting;
			cctv_settings_["s5"] = world_->cctv_settings[i_].dont_show_owner;
			cctv_settings_["s6"] = world_->cctv_settings[i_].dont_show_admins;
			cctv_settings_["s7"] = world_->cctv_settings[i_].dont_show_noaccess;
			cctv_save_settings_.push_back(cctv_settings_);
		}
		for (int i_ = 0; i_ < world_->cctv.size(); i_++) {
			json cctv_;
			cctv_["x"] = world_->cctv[i_].x;
			cctv_["y"] = world_->cctv[i_].y;
			cctv_["l"] = world_->cctv[i_].logs;
			cctv_save_.push_back(cctv_);
		}
		for (int i_ = 0; i_ < world_->bulletin.size(); i_++) {
			json bulletin_;
			bulletin_["x"] = world_->bulletin[i_].x;
			bulletin_["y"] = world_->bulletin[i_].y;
			bulletin_["n"] = world_->bulletin[i_].name;
			bulletin_["t"] = world_->bulletin[i_].text;
			bulletins_.push_back(bulletin_);
		}
		for (int i_ = 0; i_ < world_->bulletins.size(); i_++) {
			json bulletin_settings_;
			bulletin_settings_["x"] = world_->bulletins[i_].x;
			bulletin_settings_["y"] = world_->bulletins[i_].y;
			bulletin_settings_["s1"] = world_->bulletins[i_].public_can_add;
			bulletin_settings_["s2"] = world_->bulletins[i_].hide_names;
			bulletin_s.push_back(bulletin_settings_);
		}
		for (int i_ = 0; i_ < world_->npc.size(); i_++) {
			json npc_;
			npc_["i"] = world_->npc[i_].id;
			npc_["x"] = world_->npc[i_].x;
			npc_["y"] = world_->npc[i_].y;
			npc_["ps"] = world_->npc[i_].projectile_speed;
			npc_["rf"] = world_->npc[i_].rate_of_fire;
			npc_["en"] = world_->npc[i_].enabled;
			npc_["kr"] = world_->npc[i_].kryptis;
			npc_["l"] = world_->npc[i_].last_;
			npc_["sm"] = world_->npc[i_].started_moving;
			npcs.push_back(npc_);
		}
		for (int i_ = 0; i_ < world_->machines.size(); i_++) {
			json machine_;
			machine_["i"] = world_->machines[i_].id;
			machine_["x"] = world_->machines[i_].x;
			machine_["y"] = world_->machines[i_].y;
			machine_["en"] = world_->machines[i_].enabled;
			machine_["ti"] = world_->machines[i_].target_item;
			machine_["l"] = world_->machines[i_].last_;
			machines.push_back(machine_);
		}
		save_["blocks"] = blocks_, save_["drop"] = drops_, save_["sbox1"] = sboxs1_, save_["gscan"] = gscans_, save_["sbull"] = bulletin_s, save_["sstv"] = cctv_save_settings_, save_["cctv"] = cctv_save_, save_["bulletin"] = bulletins_, save_["donate"] = donates_, save_["admins"] = admins_, save_["npc"] = npcs, save_["machine"] = machines;
		//cout << "[SERVER] Saving world " + name_ + " succesful! Time of action: " << currentDateTime() << "." << endl;
		ofstream w_("worlds/" + name_ + "_.json");
		if (w_.fail()) {
			//cout << "[SERVER] Saving world " + name_ + " unsuccesful! Time of action: " << currentDateTime() << "." << endl;
			return;
		}
		w_ << save_ << endl;
		w_.close();
		if (erase) {
			bool dont_del = false;
			for (int i_ = 0; i_ < world_->machines.size(); i_++) {
				WorldMachines machine = world_->machines[i_];
				if (machine.enabled) {
					WorldBlock* itemas = &world_->blocks[machine.x + (machine.y * 100)];
					if (itemas->pr != 0 and machine.target_item != 0) {
						dont_del = true;
						break;
					}
				}
			}
			if (not dont_del) {
				map<string, vector<WorldNPC>>::iterator it;
				for (it = active_npc.begin(); it != active_npc.end(); it++) {
					if (it->first == world_->name) {
						it->second.clear();
						break;
					}
				}
				worlds.erase(worlds.begin() + id_);
			}
		}
	}
}


void get_players(const string& name_, int& c_, int& t_, int& net_, int& r_c) {
	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->tankIDName == "") continue;
		if (not name_.empty() && pInfo(currentPeer)->world == name_) {
			if (not pInfo(currentPeer)->invis)
				c_++;
			if (pInfo(currentPeer)->netID >= net_)
				net_ = pInfo(currentPeer)->netID + 1;
			r_c++;
		}
		if (server_port == 1) t_ += 1 + rand() % 3 + 1;
		else t_ += 1;
	}
}
inline string uptimexd(int n) {
	string x;
	const auto day = n / (24 * 3600);
	if (day != 0) {
		if (to_string(day) == "1") {
			x.append(to_string(day) + " day");
		}
		else {
			x.append(to_string(day) + " days");
		}
	}
	n = n % (24 * 3600);
	const auto hour = n / 3600;

	if (hour != 0) if (x.length() > 1) x.append(", ");
	if (hour != 0) {
		if (to_string(hour) == "1") {
			x.append(to_string(hour) + " hour");
		}
		else {
			x.append(to_string(hour) + " hours");
		}
	}

	n %= 3600;
	const auto minutes = n / 60;
	if (minutes != 0) if (x.length() > 1) x.append(", ");
	if (minutes != 0) {
		if (to_string(minutes) == "1") {
			x.append(to_string(minutes) + " min");
		}
		else {
			x.append(to_string(minutes) + " mins");
		}
	}

	n %= 60;
	const auto seconds = n;
	if (seconds != 0) if (x.length() > 1) x.append(", ");
	if (seconds != 0) {
		if (to_string(seconds) == "1") {
			x.append(to_string(seconds) + " sec");
		}
		else {
			x.append(to_string(seconds) + " secs");
		}
	}
	return x;
}
void serveruptime() {
	while (true) {
		Sleep(1000);
		serverTimeOn = serverTimeOn + 1;
		ofstream write_new_timeon("uptime.txt");
		write_new_timeon << (uptimexd(serverTimeOn));
		write_new_timeon.close();
	}
}
void packet_(ENetPeer* p_, string t_, string l_ = "") {
	if (l_ != "")
		t_ = "action|log\nmsg|" + t_;
	int y_ = 3;
	BYTE z_ = 0;
	BYTE* const d_ = new BYTE[5 + t_.length()];
	memcpy(d_, &y_, 4);
	memcpy(d_ + 4, t_.c_str(), t_.length());
	memcpy(d_ + 4 + t_.length(), &z_, 1);
	ENetPacket* const p = enet_packet_create(d_, 5 + t_.length(), ENET_PACKET_FLAG_RELIABLE);
	enet_peer_send(p_, 0, p);
	delete[]d_;
	if (l_ != "") {
		const string w_ = "https://discord.gg/VDvGrjmgGn";
		l_ = "action|set_url\nurl|" + w_ + "\nlabel|" + l_ + "\n";
		BYTE* const u_ = new BYTE[5 + l_.length()];
		memcpy(u_, &y_, 4);
		memcpy(u_ + 4, l_.c_str(), l_.length());
		memcpy(u_ + 4 + l_.length(), &z_, 1);
		ENetPacket* const p3 = enet_packet_create(u_, 5 + l_.length(), ENET_PACKET_FLAG_RELIABLE);
		enet_peer_send(p_, 0, p3);
		delete[]u_;
	}
}
bool check_name(string& name_) {
	if (name_ == "EXIT") {
		name_ = "Exit from what? Press back if you're done playing.";
		return false;
	}
	for (char c : name_) if ((c < 'A' || c>'Z') && (c < '0' || c>'9')) {
		name_ = "Sorry, spaces and special characters are not allowed in world or door names.  Try again.";
		return false;
	}
	for (int i = 0; i < swear_words.size(); i++) {
		if (name_.find(swear_words[i]) != string::npos) {
			name_ = "DISNEYLAND";
			break;
		}
	}
	if (name_.size() < 1 || name_.size() >= 24) {
		name_ = "`4To reduce confusion, that is not a valid world name.``  Try another?";
		return false;
	} if (name_ == "") {
		name_ = "START";
	}
	return true;
}
bool check_blast(string& name_) {
	if (name_ == "EXIT" || name_ == "" || name_.size() < 1 || name_.size() >= 24) {
		return false;
	}
	for (char c : name_) if ((c < 'A' || c>'Z') && (c < '0' || c>'9')) {
		return false;
	}
	for (int i = 0; i < swear_words.size(); i++) {
		if (name_.find(swear_words[i]) != string::npos) return false;
	}
	return true;
}
long long last_active_update = 0;
vector<string> active_worlds;
void form_emoji(ENetPeer* peer) {
	gamepacket_t p;
	p.Insert("OnAddNotification");
	p.Insert("interface/large/friend_button.rttex");
	p.Insert("You've unlocked some new `$Growmojis``!");
	p.Insert("audio/hub_open.wav");
	p.Insert(0);
	p.CreatePacket(peer);
	{
		gamepacket_t p;
		p.Insert("OnEmoticonDataChanged");
		p.Insert(151749376);
		string other = "";
		for (int i = 0; i < pInfo(peer)->gr.size(); i++) other += pInfo(peer)->gr[i];
		p.Insert(other + "" + (pInfo(peer)->supp == 2 ? "(yes)|Ă|1" : "(yes)|Ă|0") + "&" + (pInfo(peer)->supp != 0 ? "(no)|ă|1" : "(no)|ă|0") + "&" + (pInfo(peer)->supp == 2 ? "(love)|Ą|1" : "(love)|Ą|0") + "&" + (pInfo(peer)->supp != 0 ? "(shy)|Ć|1&(wink)|ć|1" : "(shy)|Ć|0&(wink)|ć|0") + "&" + (pInfo(peer)->level >= 5 ? "(tongue)|Ĉ|1" : "(tongue)|Ĉ|0") + "&" + (pInfo(peer)->friends.size() >= 20 ? "(agree)|ĉ|1" : "(agree)|ĉ|0") + "&" + (pInfo(peer)->supp != 0 ? "(music)|Č|1" : "(music)|Č|0") + "&" + (pInfo(peer)->friends.size() >= 50 ? "(build)|č|1" : "(build)|č|0") + "&" + (pInfo(peer)->supp == 2 ? "(megaphone)|Ď|1" : "(megaphone)|Ď|0") + "&" + (pInfo(peer)->level >= 5 ? "(sigh)|ď|1&(mad)|Đ|1&(wow)|đ|1" : "(sigh)|ď|0&(mad)|Đ|0&(wow)|đ|0") + "&" + (pInfo(peer)->friends.size() >= 40 ? "(dance)|Ē|1" : "(dance)|Ē|0") + "&" + (pInfo(peer)->friends.size() >= 30 ? "(see-no-evil)|ē|1" : "(see-no-evil)|ē|0") + "&" + (pInfo(peer)->supp == 2 ? "(heart)|ĕ|1" : "(heart)|ĕ|0") + "&" + (pInfo(peer)->friends.size() >= 10 ? "(kiss)|Ę|1" : "(kiss)|Ę|0") + "&" + (pInfo(peer)->supp != 0 ? "(lol)|Ě|1" : "(lol)|Ě|1") + "&" + (pInfo(peer)->level >= 5 ? "(smile)|Ā|1" : "(smile)|Ā|0") + "&" + (pInfo(peer)->supp == 2 ? "(cool)|Ĝ|1" : "(cool)|Ĝ|0") + "&(lucky)|ĳ|1&");
		p.CreatePacket(peer);
	}
}



void grow4good(ENetPeer* peer, bool open, string type, int count) {
	if (today_day != pInfo(peer)->grow4good_day) {
		pInfo(peer)->grow4good_day = today_day;
		pInfo(peer)->grow4good_rarity = 0, pInfo(peer)->grow4good_total_wl = 0, pInfo(peer)->grow4good_total_rarity = 0, pInfo(peer)->grow4good_wl = 0, pInfo(peer)->grow4good_donate_gems = false, pInfo(peer)->grow4good_gems = 0, pInfo(peer)->grow4good_purchase_waving = false, pInfo(peer)->grow4good_surgery = 0, pInfo(peer)->grow4good_fish = 0;
	}
	if (open) {
		struct tm newtime;
		time_t now = time(0);
		localtime_s(&newtime, &now);
		if (pInfo(peer)->grow4good_points >= 40) pInfo(peer)->grow4good_claim_prize++;
		if (pInfo(peer)->grow4good_points >= 120) pInfo(peer)->grow4good_claim_prize++;
		if (pInfo(peer)->grow4good_points >= 240) pInfo(peer)->grow4good_claim_prize++;
		string color = (pInfo(peer)->grow4good_claim_prize == 1 ? "yellow" : "blue");
		string color2 = (pInfo(peer)->grow4good_claim_prize == 2 ? "yellow" : "blue");
		bool can_claim = false;
		if (pInfo(peer)->grow4good_points >= 40 && pInfo(peer)->grow4good_claimed_prize == 0)can_claim = true;
		if (pInfo(peer)->grow4good_points >= 80 && pInfo(peer)->grow4good_claimed_prize == 1) can_claim = true;
		if (pInfo(peer)->grow4good_points >= 240) can_claim = true;
		gamepacket_t p(500);
		p.Insert("OnDialogRequest");
		if (type == "tab_tasks") p.Insert("start_custom_tabs|\nadd_custom_button|tab_rewards|image:interface/large/btn_passtabs.rttex;image_size:228,92;frame:0,3;width:0.15;min_width:60;|\nadd_custom_button|tab_tasks|image:interface/large/btn_passtabs.rttex;image_size:228,92;frame:1,4;width:0.15;min_width:60;|\nend_custom_tabs|\nadd_textbox|Daily Tasks|left|\nadd_label_with_icon|small|Purchase Waving Inflatable Arm Guy (" + to_string(pInfo(peer)->grow4good_purchase_waving) + "/1)|left|2946|\nadd_smalltext|`5          100 points`s + (100 points) For Grow Pass Members``|left|\nadd_label_with_icon|small|Successfully Complete Surgeries (" + to_string(pInfo(peer)->grow4good_surgery) + "/5)|left|2946|\nadd_smalltext|`5          100 points`s + (100 points) For Grow Pass Members``|left|\nadd_label_with_icon|small|Catch lbs of Fish (" + to_string(pInfo(peer)->grow4good_fish) + "/100)|left|2946|\nadd_smalltext|`5          24 points`s + (24 points) For Grow Pass Members``|left|\nadd_label_with_icon|small|Break blocks (" + to_string(pInfo(peer)->grow4good_break) + "/1000)|left|2946|\nadd_smalltext|`5          50 points`s + (50 points) For Grow Pass Members``|left|\nadd_label_with_icon|small|Place blocks (" + to_string(pInfo(peer)->grow4good_place) + "/1000)|left|2946|\nadd_smalltext|`5          50 points`s + (50 points) For Grow Pass Members``|left|\nadd_label_with_icon|small|Trade people (" + to_string(pInfo(peer)->grow4good_trade) + "/15)|left|2946|\nadd_smalltext|`5          15 points`s + (15 points) For Grow Pass Members``|left|\nadd_label_with_icon|small|Broadcast (" + to_string(pInfo(peer)->grow4good_sb) + "/10)|left|2946|\nadd_smalltext|`5          30 points`s + (30 points) For Grow Pass Members``|left|\nadd_spacer|small|\nadd_spacer|small|\nadd_smalltext|`6*NOTE: Daily Tasks can only be completed once per day. Any progress on Daily Tasks that are not completed before the end of the day will be lost.``|left|\nadd_spacer|small|\nadd_textbox|Remaining Time: " + to_string(24 - newtime.tm_hour) + " hours" + (60 - newtime.tm_min != 0 ? ", " + to_string(60 - newtime.tm_min) + " mins" : "") + "|left|\nadd_spacer|small|\nadd_quick_exit|\nend_dialog|grow4goodtasks_dialog|Close||\n");
		else p.Insert("start_custom_tabs|\nadd_custom_button|tab_rewards|image:interface/large/btn_passtabs.rttex;image_size:228,92;frame:1,3;width:0.15;min_width:60;|\nadd_custom_button|tab_tasks|image:interface/large/btn_passtabs.rttex;image_size:228,92;frame:0,4;width:0.15;min_width:60;|\nend_custom_tabs|\nadd_image_button||interface/large/gui_shop_winter_rally.rttex|bannerlayout|flag_frames:1,1,0,0|flag_surfsize:985,256|\nadd_spacer|small|\nadd_textbox|Complete tasks to help contribute towards `5Operation Smile`` and earn yourself awesome rewards along the way. Your personal points are added to the Total Global Points, so every point really does help!|left|\nadd_spacer|small|\ntext_scaling_string|iiiiiiiiiiiiiiiiiiiiiiiiiii|\nadd_custom_margin|x:0;y:100|\nadd_textured_progress_bar|interface/large/gui_event_bar.rttex|0|4|" + to_string(pInfo(peer)->grow4good_points) + "/240|" + (pInfo(peer)->grow4good_points >= 240 ? "240" : to_string(pInfo(peer)->grow4good_points)) + "|240|pre_icon|6|0.05|0|1000|64|0.005|barBG_0|\nadd_custom_margin|x:0;y:100|\nadd_custom_button|item_info_11756/premium_40|icon:11756;state:enabled;color:128,128,128,180;border:grey;preset:listitem;margin_rself:0,-0.5;anchor:barBG_0;top:-1.0;left:0.166667;display:inline_free;|\nadd_custom_label|1|target:item_info_11756/premium_40;top:0.25;left:0.25;size:small|\nadd_custom_label|`" + (pInfo(peer)->grow4good_points >= 40 ? "2" : "5") + "40|target:item_info_11756/premium_40;top:0.62;|\nadd_custom_button|item_info_11756/premium_80|icon:11756;state:enabled;color:128,128,128,180;border:grey;preset:listitem;margin_rself:0,-0.5;anchor:barBG_0;top:-1.0;left:0.333333;display:inline_free;|\nadd_custom_label|1|target:item_info_11756/premium_80;top:0.25;left:0.25;size:small|\nadd_custom_label|`" + (pInfo(peer)->grow4good_points >= 80 ? "2" : "5") + "80|target:item_info_11756/premium_80;top:0.62;|\nadd_custom_button|item_info_11756/premium_120|icon:11756;state:enabled;color:128,128,128,180;border:grey;preset:listitem;margin_rself:0,-0.5;anchor:barBG_0;top:-1.0;left:0.5;display:inline_free;|\nadd_custom_label|1|target:item_info_11756/premium_120;top:0.25;left:0.25;size:small|\nadd_custom_label|`" + (pInfo(peer)->grow4good_points >= 120 ? "2" : "5") + "120|target:item_info_11756/premium_120;top:0.62;|\nadd_custom_button|item_info_11756/premium_160|icon:11756;state:enabled;color:128,128,128,180;border:grey;preset:listitem;margin_rself:0,-0.5;anchor:barBG_0;top:-1.0;left:0.666667;display:inline_free;|\nadd_custom_label|1|target:item_info_11756/premium_160;top:0.25;left:0.25;size:small|\nadd_custom_label|`" + (pInfo(peer)->grow4good_points >= 160 ? "2" : "5") + "160|target:item_info_11756/premium_160;top:0.62;|\nadd_custom_button|item_info_11756/premium_200|icon:11756;state:enabled;color:128,128,128,180;border:grey;preset:listitem;margin_rself:0,-0.5;anchor:barBG_0;top:-1.0;left:0.833333;display:inline_free;|\nadd_custom_label|1|target:item_info_11756/premium_200;top:0.25;left:0.25;size:small|\nadd_custom_label|`" + (pInfo(peer)->grow4good_points >= 200 ? "2" : "5") + "200|target:item_info_11756/premium_200;top:0.62;|\nadd_custom_button|item_info_11758/premium_240|icon:11758;state:enabled;color:128,128,128,180;border:grey;preset:listitem;margin_rself:0,-0.5;anchor:barBG_0;top:-1.0;left:1;display:inline_free;|\nadd_custom_label|1|target:item_info_11758/premium_240;top:0.25;left:0.25;size:small|\nadd_custom_label|`" + (pInfo(peer)->grow4good_points >= 240 ? "2" : "5") + "240|target:item_info_11758/premium_240;top:0.62;|" + (pInfo(peer)->grow4good_claimed_prize == 0 ? "\nadd_custom_button|item_info_11756|icon:11756;state:enabled;color:255,255,255,255;border:" + color + ";preset:listitem;margin_rself:0,0.25;anchor:barBG_0;top:1.0;left:0.166667;display:inline_free;|" : "\nadd_custom_button|item_info_6292|icon:6292;state:disabled;color:255,255,255,255;border:none;preset:listitem;margin_rself:0,0.25;anchor:barBG_0;top:1.0;left:0.166667;display:inline_free;|") + "\nadd_custom_label|1|target:item_info_11756;top:0.25;left:0.25;size:small|" + (pInfo(peer)->grow4good_claimed_prize == 2 ? "\nadd_custom_button|item_info_6292|icon:6292;state:disabled;color:255,255,255,255;border:none;preset:listitem;margin_rself:0,0.25;anchor:barBG_0;top:1.0;left:0.5;display:inline_free;|" : "\nadd_custom_button|item_info_11756|icon:11756;state:enabled;color:255,255,255,255;border:" + color2 + ";preset:listitem;margin_rself:0,0.25;anchor:barBG_0;top:1.0;left:0.5;display:inline_free;|") + "\nadd_custom_label|1|target:item_info_11756;top:0.25;left:0.25;size:small|\nadd_custom_button|item_info_11758|icon:11758;state:enabled;color:255,255,255,255;border:" + (pInfo(peer)->grow4good_claim_prize == 3 ? "yellow" : "blue") + ";preset:listitem;margin_rself:0,0.25;anchor:barBG_0;top:1.0;left:1;display:inline_free;|\nadd_custom_label|1|target:item_info_11758;top:0.25;left:0.25;size:small|\nreset_placement_x|\nadd_textbox|Unclaimed Personal Points: " + to_string(pInfo(peer)->grow4good_points) + "|left|\nadd_button|" + (can_claim ? "claimrewardsg4g|Claim Reward" : "|`sClaim Reward``") + "|" + (can_claim ? "" : "off|") + "0|0|\nadd_spacer|small|\nadd_quick_exit|\nend_dialog|grow4goodtasks_dialog|Close||\n");
		p.CreatePacket(peer);
	}
	else {
		count *= 2;
		int received_points = 0;
		string completed = "";
		bool complete = false;
		if (type == "rarity") {
			pInfo(peer)->grow4good_rarity += count;
			pInfo(peer)->grow4good_total_rarity += count;
			for (int i = 0; i < 1; i++) if (pInfo(peer)->grow4good_rarity >= 10000) pInfo(peer)->grow4good_rarity -= 10000, pInfo(peer)->grow4good_points += 19, i--, received_points += 19, complete = true;
			if (complete) completed = "You completed the task: Donate Rarity and Earned " + to_string(received_points) + " points.";
		}
		else if (type == "wl") {
			pInfo(peer)->grow4good_wl += count;
			pInfo(peer)->grow4good_total_wl += count;
			for (int i = 0; i < 1; i++) if (pInfo(peer)->grow4good_wl >= 5) pInfo(peer)->grow4good_wl -= 5, pInfo(peer)->grow4good_points += 29, i--, received_points += 29, complete = true;
			if (complete) completed = "You completed the task: Donate World Locks and Earned " + to_string(received_points) + " points.";
		}
		else if (type == "donate_gems") {
			pInfo(peer)->grow4good_points += 40, received_points += 40, complete = true;
			if (complete) completed = "You completed the task: Donate Gems and Earned " + to_string(received_points) + " points.";
		}
		else if (type == "gems") {
			pInfo(peer)->grow4good_gems += count;
			for (int i = 0; i < 1; i++) if (pInfo(peer)->grow4good_gems >= 10000) pInfo(peer)->grow4good_gems -= 10000, pInfo(peer)->grow4good_points += 10, i--, received_points += 10, complete = true;
			if (complete) completed = "You completed the task: Spend Gems and Earned " + to_string(received_points) + " points.";
		}
		else if (type == "purchase_waving") {
			if (pInfo(peer)->grow4good_purchase_waving == false) {
				pInfo(peer)->grow4good_purchase_waving = true, pInfo(peer)->grow4good_points += 100, received_points += 100, complete = true;
				if (pInfo(peer)->gp)pInfo(peer)->grow4good_points += 100, received_points += 100;
			}
			if (complete) completed = "You completed the task: Purchase Inflatable Arm Guy and Earned " + to_string(received_points) + " points.";
		}
		else if (type == "surgery") {
			if (pInfo(peer)->grow4good_surgery < 5) {
				pInfo(peer)->grow4good_surgery += count;
				if (pInfo(peer)->grow4good_surgery >= 5) {
					pInfo(peer)->grow4good_points += 100, received_points += 100, complete = true;
					if (pInfo(peer)->gp)pInfo(peer)->grow4good_points += 100, received_points += 100;
				}
				if (complete) completed = "You completed the task: Successfully Complete Surgeries and Earned " + to_string(received_points) + " points.";
			}
		}
		else if (type == "break") {
			if (pInfo(peer)->grow4good_break < 1000) {
				pInfo(peer)->grow4good_break += count;
				if (pInfo(peer)->grow4good_break >= 1000) {
					pInfo(peer)->grow4good_points += 50, received_points += 50, complete = true;
					if (pInfo(peer)->gp)pInfo(peer)->grow4good_points += 50, received_points += 50;
				}
				if (complete) completed = "You completed the task: Break 1,000 blocks and Earned " + to_string(received_points) + " points.";
			}
		}
		else if (type == "place") {
			if (pInfo(peer)->grow4good_place < 1000) {
				pInfo(peer)->grow4good_place += count;
				if (pInfo(peer)->grow4good_place >= 1000) {
					pInfo(peer)->grow4good_points += 50, received_points += 50, complete = true;
					if (pInfo(peer)->gp)pInfo(peer)->grow4good_points += 50, received_points += 50;
				}
				if (complete) completed = "You completed the task: Place 1,000 blocks and Earned " + to_string(received_points) + " points.";
			}
		}
		else if (type == "trade") {
			if (pInfo(peer)->grow4good_trade < 15) {
				pInfo(peer)->grow4good_trade += count;
				if (pInfo(peer)->grow4good_trade >= 15) {
					pInfo(peer)->grow4good_points += 15, received_points += 15, complete = true;
					if (pInfo(peer)->gp)pInfo(peer)->grow4good_points += 15, received_points += 15;
				}
				if (complete) completed = "You completed the task: Trade 15 people and Earned " + to_string(received_points) + " points.";
			}
		}
		else if (type == "sb") {
			if (pInfo(peer)->grow4good_sb < 10) {
				pInfo(peer)->grow4good_sb += count;
				if (pInfo(peer)->grow4good_sb >= 10) {
					pInfo(peer)->grow4good_points += 30, received_points += 30, complete = true;
					if (pInfo(peer)->gp)pInfo(peer)->grow4good_points += 30, received_points += 30;
				}
				if (complete) completed = "You completed the task: Broadcast 10 times and Earned " + to_string(received_points) + " points.";
			}
		}
		else if (type == "fish") {
			if (pInfo(peer)->grow4good_fish < 100) {
				pInfo(peer)->grow4good_fish += count;
				if (pInfo(peer)->grow4good_fish >= 100) {
					pInfo(peer)->grow4good_points += 24, received_points += 24, complete = true;
					if (pInfo(peer)->gp)pInfo(peer)->grow4good_points += 24, received_points += 24;
				}
				if (complete) completed = "You completed the task: Catch lbs of Fish and Earned " + to_string(received_points) + " points.";
			}
		}

		if (completed != "") {
			gamepacket_t p, p2;
			p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert(completed), p.Insert(0), p.CreatePacket(peer);
			p2.Insert("OnConsoleMessage"), p2.Insert(completed), p2.CreatePacket(peer);
		}
	}
}

void news(ENetPeer* peer) {
	gamepacket_t p(250);
	p.Insert("OnDialogRequest"), p.Insert(news_texture), p.CreatePacket(peer);
}



bool toolavailable(ENetPeer* peer, int tool) {
	bool have = false;
	for (int i_ = 0; i_ < pInfo(peer)->inv.size(); i_++) if (pInfo(peer)->inv[i_].id == tool) have = true;
	if (pInfo(peer)->dirt == 10 && tool != 1258 && tool != 0)
		return false;
	else
		switch (tool) {
		case 1258:
			return have;
		case 1266:
			return have && pInfo(peer)->labworked;
		case 1296:
			return pInfo(peer)->fixable && !pInfo(peer)->fixed;
		case 4316:
			return have && !pInfo(peer)->sounded;
		case 4318:
			return have && !pInfo(peer)->labworked;
		case 4312:
			return have && pInfo(peer)->heart > 0;
		case 1268:
			return have && pInfo(peer)->broken > 0;
		case 4308:
			return have && pInfo(peer)->shattered > 0 && pInfo(peer)->incisions > 0;
		case 4314:
			return have && pInfo(peer)->incisions > 0 && pInfo(peer)->bleeding > 0;
		default:
			return have;
		}
}



void add_cctv(ENetPeer* peer, string type, string extra) {
	time_t currentTime;
	time(&currentTime);
	const auto localTime = localtime(&currentTime);
	const auto Hour = localTime->tm_hour;
	const auto Min = localTime->tm_min;
	const auto Sec = localTime->tm_sec;
	const auto Year = localTime->tm_year + 1900;
	const auto Day = localTime->tm_mday;
	const auto Month = localTime->tm_mon + 1;
	std::string asdasdasd;
	if (Sec < 10) asdasdasd = "0";
	std::string asdasdasd2;
	if (Min < 10) asdasdasd2 = "0";
	std::string asdasdasd3;
	if (Hour < 10) asdasdasd3 = "0";
	std::string asdasdasd31;
	if (Month < 10) asdasdasd31 = "0";
	std::string asdasdasd32;
	if (Day < 10) asdasdasd32 = "0";
	std::string asdasdasd33;
	if (Year < 10) asdasdasd33 = "0";
	//" << asdasdasd3 << to_string(Hour) << ":" + asdasdasd2 << to_string(Min) << " : " + asdasdasd << to_string(Sec) << " " << to_string(Day) << asdasdasd32 << "." + asdasdasd31 + to_string(Month) << "." + asdasdasd33 + to_string(Year) << 
	//				world_->n_t = "" + asdasdasd32 + to_string(Day) + "." + asdasdasd31 + to_string(Month) + "." + asdasdasd33 + to_string(Year) + " " + asdasdasd3 + to_string(Hour) + ":" + asdasdasd2 + to_string(Min) + ":" + asdasdasd + to_string(Sec) + "";
	WorldCCTV cctv_{};
	string name_ = pInfo(peer)->world;
	vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
	if (p != worlds.end()) {
		World* world_ = &worlds[p - worlds.begin()];
		for (int i2_ = 0; i2_ < world_->cctv_settings.size(); i2_++) {
			cctv_.logs = "";
			if (world_->cctv_settings[i2_].dont_show_owner && pInfo(peer)->tankIDName == world_->owner_name) break;
			if (world_->cctv_settings[i2_].dont_show_noaccess && pInfo(peer)->tankIDName != world_->owner_name and !guild_access(peer, world_->guild_id) and find(world_->admins.begin(), world_->admins.end(), pInfo(peer)->tankIDName) == world_->admins.end()) break;
			if (world_->cctv_settings[i2_].dont_show_admins && find(world_->admins.begin(), world_->admins.end(), pInfo(peer)->tankIDName) != world_->admins.end()) break;
			if (type == "entered" && world_->cctv_settings[i2_].show_people_entering or type == "left" && world_->cctv_settings[i2_].show_people_exiting or type == "took" && world_->cctv_settings[i2_].show_item_taking or type == "dropped" && world_->cctv_settings[i2_].show_item_dropping) cctv_.logs = "\nadd_label_with_icon|small|`w" + (not pInfo(peer)->d_name.empty() ? pInfo(peer)->d_name : pInfo(peer)->name_color + pInfo(peer)->tankIDName) + "`w " + type + "" + (extra == "" ? " " : " " + extra + " ") + "at " + asdasdasd3 + to_string(Hour) + ":" + asdasdasd2 + to_string(Min) + " on " + asdasdasd32 + to_string(Day) + "." + asdasdasd31 + to_string(Month) + "``|left|" + (type == "took" ? "18" : "1400") + "|";
			if (cctv_.logs != "") {
				if (world_->cctv.size() == 50) world_->cctv.erase(world_->cctv.begin() + 1);
				cctv_.x = world_->cctv_settings[i2_].x, cctv_.y = world_->cctv_settings[i2_].y;
				world_->cctv.push_back(cctv_);
			}
		}
	}
}


void glory_show(ENetPeer* peer) {
	if (pInfo(peer)->glo >= 1) {
		string prizes = "";
		for (int i = 1; i < 10; i++) {
			if (std::find(pInfo(peer)->glo_p.begin(), pInfo(peer)->glo_p.end(), i) != pInfo(peer)->glo_p.end()) prizes += "\nadd_smalltext|`r#" + to_string(i + 1) + ": Level " + to_string(i * 10) + " claimed.``|left|\nadd_label_with_icon|small|`r" + setGems(i * 100000) + " Gems``|left|9438|\nadd_spacer|small|";
			else if (pInfo(peer)->level >= i * 10)prizes += "\nadd_smalltext|`w#" + to_string(i + 1) + ": Reach Level " + to_string(i * 10) + " to claim this reward:``|left|\nadd_label_with_icon|small|`w" + setGems(i * 100000) + " Gems``|left|9438|\nadd_small_font_button|claimreward" + to_string(i) + "|Claim Reward|noflags|0|0|";
			else if (pInfo(peer)->level < i * 10) prizes += "\nadd_smalltext|`s#" + to_string(i + 1) + ": Reach Level " + to_string(i * 10) + " to claim this reward:``|left|\nadd_label_with_icon|small|`s" + setGems(i * 100000) + " Gems``|left|9438|";
		}
		gamepacket_t p;
		p.Insert("OnDialogRequest");
		p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wRoad to Glory``|left|9436|\nadd_smalltext|Claim your Road to Glory Rewards Here|left|\nadd_spacer|small|\nadd_progress_bar|`wYour Level: " + to_string(pInfo(peer)->level) + "``|small|LVL 1|" + to_string(pInfo(peer)->level) + "|90|LVL 90|\nadd_spacer|small|\nadd_smalltext|`r#1: Road to Glory Pack instant reward claimed:``|left|\nadd_label_with_icon|small|`r100,000 Gems``|left|9438|\nadd_spacer|small|" + prizes + "\nadd_spacer|small|\nend_dialog|roadtoglory|Close||\nadd_quick_exit|\n");
		p.CreatePacket(peer);
	}
}

void level_show(ENetPeer* peer) {
	string prizes = "";
	for (int i = 1; i < 125; i++) {
		if (std::find(pInfo(peer)->lvl_p.begin(), pInfo(peer)->lvl_p.end(), i) != pInfo(peer)->lvl_p.end()) prizes += "\nadd_smalltext|`r#" + to_string(i) + ": Level " + to_string(i) + " claimed.``|left|\nadd_label_with_icon|small|`r" + setGems(i * 100) + " Gems``|left|9438|\nadd_spacer|small|";
		else if (pInfo(peer)->level >= i)prizes += "\nadd_smalltext|`w#" + to_string(i) + ": Reach Level " + to_string(i) + " to claim this reward:``|left|\nadd_label_with_icon|small|`w" + setGems(i * 100) + " Gems``|left|9438|\nadd_small_font_button|claimreward" + to_string(i) + "|Claim Reward|noflags|0|0|";
		else if (pInfo(peer)->level < i) prizes += "\nadd_smalltext|`s#" + to_string(i) + ": Reach Level " + to_string(i) + " to claim this reward:``|left|\nadd_label_with_icon|small|`s" + setGems(i * 100) + " Gems``|left|9438|";
	}
	gamepacket_t p;
	p.Insert("OnDialogRequest");
	p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wGrowpedia``|left|6336|\nadd_smalltext|Claim your Growpedia Level Up rewards Here|left|\nadd_spacer|small|\nadd_progress_bar|`wYour Level: " + to_string(pInfo(peer)->level) + "``|small|LVL 1|" + to_string(pInfo(peer)->level) + "|125|LVL 125|\nadd_spacer|small|" + prizes + "\nadd_spacer|small|\nend_dialog|levelup|Close||\nadd_quick_exit|\n");
	p.CreatePacket(peer);
}


void farmer_reward_show(ENetPeer* peer) {
	string prize = "";
	vector<int> list{ 98, 228, 1746, 1778, 1830, 5078, 1966, 6948, 6946, 4956 };
	for (int i = 0, lvl = 0; i < list.size(); i++) {
		bool ok = (i == 9 ? true : false);
		if (find(pInfo(peer)->t_p.begin(), pInfo(peer)->t_p.end(), lvl += 5) != pInfo(peer)->t_p.end()) {
			prize += "\nadd_smalltext|`w#" + to_string(i + 1) + ": Reach Farmer Level " + to_string(lvl) + " to claim this reward:``|left|\nadd_label_with_icon|small|`r(Unlocked) " + (list[i] == 228 || list[i] == 1746 || list[i] == 1778 ? "200" : "") + " " + items[list[i]].name + "``|left|" + to_string(list[i]) + "|" + (ok ? "\nadd_label_with_icon|small|`r(Unlocked) Unique Farmer's Flag and skin! - Show off your mastery with a flag beside your name``|left|7064|" : "") + "\nadd_spacer|small|";
		}
		else if (pInfo(peer)->t_lvl >= lvl) {
			prize += "\nadd_smalltext|`w#" + to_string(i + 1) + ": Reach Farmer Level " + to_string(lvl) + " to claim this reward:``|left|\nadd_label_with_icon|small|`w(Unlocked) " + (list[i] == 228 || list[i] == 1746 || list[i] == 1778 ? "200" : "") + " " + items[list[i]].name + "``|left|" + to_string(list[i]) + "|" + (ok ? "\nadd_label_with_icon|small|`w(Unlocked) Unique Farmer's Flag and skin! - Show off your mastery with a flag beside your name``|left|7064|" : "") + "\nadd_small_font_button|t_claimreward" + to_string(i + 1) + "|Claim Reward|noflags|0|0|";
		}
		else if (pInfo(peer)->t_lvl < lvl) {
			prize += "\nadd_smalltext|`w#" + to_string(i + 1) + ": Reach Farmer Level " + to_string(lvl) + " to claim this reward:``|left|\nadd_label_with_icon|small|`s(Locked) " + (list[i] == 228 || list[i] == 1746 || list[i] == 1778 ? "200" : "") + " " + items[list[i]].name + "``|left|" + to_string(list[i]) + "|" + (ok ? "\nadd_label_with_icon|small|`s(Locked) Unique Farmer's Flag and skin! - Show off your mastery with a flag beside your name``|left|7064|" : "");
		}
	}
	gamepacket_t p;
	p.Insert("OnDialogRequest");
	p.Insert("set_default_color|`o\nadd_label_with_icon|big|Farmer Rewards|left|7064|\nadd_spacer|small|\nadd_textbox|`9Harvest your trees and receive awesome Farmer Rewards everyday by leveling up``|left|" + prize + "\nadd_player_info|`oFarmer``|" + to_string(pInfo(peer)->t_lvl) + "|" + to_string(pInfo(peer)->t_xp) + "|" + to_string(100 * ((pInfo(peer)->t_lvl * pInfo(peer)->t_lvl) + 2)) + "|\nadd_spacer|small|\nend_dialog|worlds_list||Back|\nadd_quick_exit|\n");
	p.CreatePacket(peer);
}

void builder_reward_show(ENetPeer* peer) {
	string prize = "";
	vector<int> list{ 6896, 9522, 6948, 1068, 1966, 1836, 5080, 10754, 1874, 6946 };
	for (int i = 0, lvl = 0; i < list.size(); i++) {
		bool ok = (i == 9 ? true : false);
		if (find(pInfo(peer)->bb_p.begin(), pInfo(peer)->bb_p.end(), lvl += 5) != pInfo(peer)->bb_p.end()) {
			prize += "\nadd_smalltext|`w#" + to_string(i + 1) + ": Reach Builder Level " + to_string(lvl) + " to claim this reward:``|left|\nadd_label_with_icon|small|`r(Unlocked) " + (list[i] == 9522 ? "200" : "") + "" + (list[i] == 1068 ? "10" : "") + " " + items[list[i]].name + "``|left|" + to_string(list[i]) + "|" + (ok ? "\nadd_label_with_icon|small|`r(Unlocked) Unique Builder's Flag and skin! - Show off your mastery with a flag beside your name``|left|7070|" : "") + "\nadd_spacer|small|";
		}
		else if (pInfo(peer)->bb_lvl >= lvl) {
			prize += "\nadd_smalltext|`w#" + to_string(i + 1) + ": Reach Builder Level " + to_string(lvl) + " to claim this reward:``|left|\nadd_label_with_icon|small|`w(Unlocked) " + (list[i] == 9522 ? "200" : "") + "" + (list[i] == 1068 ? "10" : "") + " " + items[list[i]].name + "``|left|" + to_string(list[i]) + "|" + (ok ? "\nadd_label_with_icon|small|`w(Unlocked) Unique Builder's Flag and skin! - Show off your mastery with a flag beside your name``|left|7070|" : "") + "\nadd_small_font_button|b_claimreward" + to_string(i + 1) + "|Claim Reward|noflags|0|0|";
		}
		else if (pInfo(peer)->bb_lvl < lvl) {
			prize += "\nadd_smalltext|`w#" + to_string(i + 1) + ": Reach Builder Level " + to_string(lvl) + " to claim this reward:``|left|\nadd_label_with_icon|small|`s(Locked) " + (list[i] == 9522 ? "200" : "") + "" + (list[i] == 1068 ? "10" : "") + " " + items[list[i]].name + "``|left|" + to_string(list[i]) + "|" + (ok ? "\nadd_label_with_icon|small|`s(Locked) Unique Builder's Flag and skin! - Show off your mastery with a flag beside your name``|left|7070|" : "");
		}
	}
	gamepacket_t p;
	p.Insert("OnDialogRequest");
	p.Insert("set_default_color|`o\nadd_label_with_icon|big|Builder Rewards|left|7070|\nadd_spacer|small|\nadd_textbox|`9Keep breaking blocks and achieve awesome rewards everyday by leveling up``|left|" + prize + "\nadd_player_info|`oBuilder``|" + to_string(pInfo(peer)->bb_lvl) + "|" + to_string(pInfo(peer)->bb_xp) + "|" + to_string(100 * ((pInfo(peer)->bb_lvl * pInfo(peer)->bb_lvl) + 2)) + "|\nadd_spacer|small|\nend_dialog|worlds_list||Back|\nadd_quick_exit|\n");
	p.CreatePacket(peer);
}

void provider_reward_show(ENetPeer* peer) {
	string prize = "";
	vector<int> list{ 1008,1044,872,10450,870,5084,876,6950,6952,1674 };
	for (int i = 0, lvl = 0; i < list.size(); i++) {
		if (find(pInfo(peer)->p_p.begin(), pInfo(peer)->p_p.end(), lvl += 5) != pInfo(peer)->p_p.end()) prize += "\nadd_smalltext|`w#" + to_string(i + 1) + ": Reach Provider Level " + to_string(lvl) + " to claim this reward:``|left|\nadd_label_with_icon|small|`r(Unlocked) " + (list[i] == 1008 ? "5" : list[i] == 1044 ? "50" : list[i] == 872 ? "200" : list[i] == 10450 ? "3" : "") + " " + items[list[i]].name + "``|left|" + to_string(list[i]) + "|\nadd_spacer|small|";
		else if (pInfo(peer)->p_lvl >= lvl) prize += "\nadd_smalltext|`w#" + to_string(i + 1) + ": Reach Provider Level " + to_string(lvl) + " to claim this reward:``|left|\nadd_label_with_icon|small|`w(Unlocked) " + (list[i] == 1008 ? "5" : list[i] == 1044 ? "50" : list[i] == 872 ? "200" : list[i] == 10450 ? "3" : "") + " " + items[list[i]].name + "``|left|" + to_string(list[i]) + "|\nadd_small_font_button|p_claimreward" + to_string(i + 1) + "|Claim Reward|noflags|0|0|";
		else if (pInfo(peer)->p_lvl < lvl) prize += "\nadd_smalltext|`w#" + to_string(i + 1) + ": Reach Provider Level " + to_string(lvl) + " to claim this reward:``|left|\nadd_label_with_icon|small|`s(Locked) " + (list[i] == 1008 ? "5" : list[i] == 1044 ? "50" : list[i] == 872 ? "200" : list[i] == 10450 ? "3" : "") + " " + items[list[i]].name + "``|left|" + to_string(list[i]) + "|";
	}
	gamepacket_t p;
	p.Insert("OnDialogRequest");
	p.Insert("set_default_color|`o\nadd_label_with_icon|big|Provider Rewards|left|866|\nadd_spacer|small|\nadd_textbox|`9A provider is a non-solid foreground block which can be harvested periodically (time depends on the provider) for an item. Harvest your providers and earn awesome rewards by leveling up!``|left|" + prize + "\nadd_player_info|`oProvider``|" + to_string(pInfo(peer)->p_lvl) + "|" + to_string(pInfo(peer)->p_xp) + "|" + to_string(75 * ((pInfo(peer)->p_lvl * pInfo(peer)->p_lvl) + 2)) + "|\nadd_spacer|small|\nend_dialog|worlds_list||Back|\nadd_quick_exit|\n");
	p.CreatePacket(peer);
}

void backpack_show(ENetPeer* peer) {
	string item_log = "\nadd_spacer|small|\ntext_scaling_string|aaaaaaaaaaaaaaa|";
	for (int i_ = 0; i_ < pInfo(peer)->bp.size(); i_++) item_log += "\nadd_button_with_icon|" + to_string(i_) + "|" + items[pInfo(peer)->bp[i_].first].name + "|frame|" + to_string(pInfo(peer)->bp[i_].first) + "|" + to_string(pInfo(peer)->bp[i_].second) + "|";
	gamepacket_t p;
	p.Insert("OnDialogRequest");
	p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wBackpack - Level " + to_string(pInfo(peer)->b_l) + "``|left|8430|\nadd_textbox|`w" + to_string(pInfo(peer)->bp.size()) + "/" + to_string(pInfo(peer)->b_l * 10) + "`` items stored.|left|" + (pInfo(peer)->bp.size() >= 1 ? item_log + "\nadd_button_with_icon||END_LIST|noflags|0||" : "") + "\nadd_spacer|small|" + (pInfo(peer)->b_l * 10 < 200 ? "\nadd_button|backpack_upgrade|`2Upgrade for " + setGems((1000 * ((pInfo(peer)->b_l * pInfo(peer)->b_l) + 25)) * 2) + " gems``|noflags|0|0|" : "") + "" + (pInfo(peer)->bp.size() >= pInfo(peer)->b_l * 10 ? "" : "\nadd_item_picker|itemid|`wDeposit Item``|Choose an item to store|") + "\nend_dialog|backpack_menu|Exit||\nadd_quick_exit|");
	p.CreatePacket(peer);
}
void geiger_reward_show(ENetPeer* peer) {
	string prize = "";
	vector<int> list{ 4654,262,826,828,9712,3146,2266,5072,5070,9716 };
	for (int i = 0, lvl = 0; i < list.size(); i++) {
		if (find(pInfo(peer)->g_p.begin(), pInfo(peer)->g_p.end(), lvl += 5) != pInfo(peer)->g_p.end()) prize += "\nadd_smalltext|`w#" + to_string(i + 1) + ": Reach Geiger Hunting Level " + to_string(lvl) + " to claim this reward:``|left|\nadd_label_with_icon|small|`r(Unlocked) " + (list[i] == 262 || list[i] == 826 || list[i] == 828 ? "50" : list[i] == 3146 ? "10" : "") + " " + items[list[i]].name + "``|left|" + to_string(list[i]) + "|\nadd_spacer|small|";
		else if (pInfo(peer)->g_lvl >= lvl) prize += "\nadd_smalltext|`w#" + to_string(i + 1) + ": Reach Geiger Hunting Level " + to_string(lvl) + " to claim this reward:``|left|\nadd_label_with_icon|small|`w(Unlocked) " + (list[i] == 262 || list[i] == 826 || list[i] == 828 ? "50" : list[i] == 3146 ? "10" : "") + " " + items[list[i]].name + "``|left|" + to_string(list[i]) + "|\nadd_small_font_button|g_claimreward" + to_string(i + 1) + "|Claim Reward|noflags|0|0|";
		else if (pInfo(peer)->g_lvl < lvl) prize += "\nadd_smalltext|`w#" + to_string(i + 1) + ": Reach Geiger Hunting Level " + to_string(lvl) + " to claim this reward:``|left|\nadd_label_with_icon|small|`s(Locked) " + (list[i] == 262 || list[i] == 826 || list[i] == 828 ? "50" : list[i] == 3146 ? "10" : "") + " " + items[list[i]].name + "``|left|" + to_string(list[i]) + "|";
	}
	gamepacket_t p;
	p.Insert("OnDialogRequest");
	p.Insert("set_default_color|`o\nadd_label_with_icon|small|Geiger Hunting Rewards|left|2204|\nadd_spacer|small|\nadd_textbox|`9Once the player stands for a few moments on the source of radioactivity, the item they found will be added into their inventory. Hunt the items with your geiger and claim your prizes for leveling up!``|left|" + prize + "\nadd_player_info|`oGeiger Hunting``|" + to_string(pInfo(peer)->g_lvl) + "|" + to_string(pInfo(peer)->g_xp) + "|" + to_string(5 * ((pInfo(peer)->g_lvl * pInfo(peer)->g_lvl) + 2)) + "|\nadd_spacer|small|\nend_dialog|worlds_list||Back|\nadd_quick_exit|\n");
	p.CreatePacket(peer);
}
void fishing_reward_show(ENetPeer* peer) {
	string prize = "";
	vector<int> list{ 3010, 3018, 3020, 3044, 5740, 3042, 3098, 3100, 3040, 10262 };
	for (int i = 0, lvl = 0; i < list.size(); i++) {
		if (find(pInfo(peer)->ff_p.begin(), pInfo(peer)->ff_p.end(), lvl += 5) != pInfo(peer)->ff_p.end()) prize += "\nadd_smalltext|`w#" + to_string(i + 1) + ": Reach Fishing Hunting Level " + to_string(lvl) + " to claim this reward:``|left|\nadd_label_with_icon|small|`r(Unlocked) " + (list[i] == 3018 ? "200" : list[i] == 3020 || list[i] == 3098 ? "25" : list[i] == 3044 || list[i] == 3218 ? "50" : "") + " " + items[list[i]].name + "``|left|" + to_string(list[i]) + "|\nadd_spacer|small|";
		else if (pInfo(peer)->ff_lvl >= lvl) prize += "\nadd_smalltext|`w#" + to_string(i + 1) + ": Reach Fishing Hunting Level " + to_string(lvl) + " to claim this reward:``|left|\nadd_label_with_icon|small|`w(Unlocked) " + (list[i] == 3018 ? "200" : list[i] == 3020 || list[i] == 3098 ? "25" : list[i] == 3044 || list[i] == 3218 ? "50" : "") + " " + items[list[i]].name + "``|left|" + to_string(list[i]) + "|\nadd_small_font_button|f_claimreward" + to_string(i + 1) + "|Claim Reward|noflags|0|0|";
		else if (pInfo(peer)->ff_lvl < lvl) prize += "\nadd_smalltext|`w#" + to_string(i + 1) + ": Reach Fishing Level " + to_string(lvl) + " to claim this reward:``|left|\nadd_label_with_icon|small|`s(Locked) " + (list[i] == 3018 ? "200" : list[i] == 3020 || list[i] == 3098 ? "25" : list[i] == 3044 || list[i] == 3218 ? "50" : "") + " " + items[list[i]].name + "``|left|" + to_string(list[i]) + "|";
	}
	gamepacket_t p;
	p.Insert("OnDialogRequest");
	p.Insert("set_default_color|`o\nadd_label_with_icon|big|Fishing Rewards|left|7072|\nadd_spacer|small|\nadd_textbox|`9In Growtopia, fishing can be done by using bait on water while holding a Fishing Rod. The result from fishing can either be Fish or some random items that are obtainable through fishing.``|left|" + prize + "\nadd_player_info|`oFishing``|" + to_string(pInfo(peer)->ff_lvl) + "|" + to_string(pInfo(peer)->ff_xp) + "|" + to_string(5 * ((pInfo(peer)->ff_lvl * pInfo(peer)->ff_lvl) + 2)) + "|\nadd_spacer|small|\nend_dialog|worlds_list||Back|\nadd_quick_exit|\n");
	p.CreatePacket(peer);
}

void surgery_reward_show(ENetPeer* peer) {
	string prize = "";
	vector<int> list{ 6900, 6982, 6212, 3172, 9068, 6912, 10836, 5142, 3130, 8284 };
	for (int i = 0, lvl = 0; i < list.size(); i++) {
		if (find(pInfo(peer)->surg_p.begin(), pInfo(peer)->surg_p.end(), lvl += 5) != pInfo(peer)->surg_p.end()) prize += "\nadd_smalltext|`w#" + to_string(i + 1) + ": Reach Surgeon Level " + to_string(lvl) + " to claim this reward:``|left|\nadd_label_with_icon|small|`r(Unlocked) " + (list[i] == 6212 ? "50" : list[i] == 3172 || list[i] == 6912 ? "25" : list[i] == 10836 ? "100" : list[i] == 5142 ? "5" : "") + " " + items[list[i]].name + "``|left|" + to_string(list[i]) + "|\nadd_spacer|small|";
		else if (pInfo(peer)->s_lvl >= lvl) prize += "\nadd_smalltext|`w#" + to_string(i + 1) + ": Reach Surgeon Level " + to_string(lvl) + " to claim this reward:``|left|\nadd_label_with_icon|small|`w(Unlocked) " + (list[i] == 6212 ? "50" : list[i] == 3172 || list[i] == 6912 ? "25" : list[i] == 10836 ? "100" : list[i] == 5142 ? "5" : "") + " " + items[list[i]].name + "``|left|" + to_string(list[i]) + "|\nadd_small_font_button|s_claimreward" + to_string(i + 1) + "|Claim Reward|noflags|0|0|";
		else if (pInfo(peer)->s_lvl < lvl) prize += "\nadd_smalltext|`w#" + to_string(i + 1) + ": Reach Surgeon Level " + to_string(lvl) + " to claim this reward:``|left|\nadd_label_with_icon|small|`s(Locked) " + (list[i] == 6212 ? "50" : list[i] == 3172 || list[i] == 6912 ? "25" : list[i] == 10836 ? "100" : list[i] == 5142 ? "5" : "") + " " + items[list[i]].name + "``|left|" + to_string(list[i]) + "|";
	}
	gamepacket_t p;
	p.Insert("OnDialogRequest");
	p.Insert("set_default_color|`o\nadd_label_with_icon|big|Surgeon Rewards|left|7068|\nadd_spacer|small|\nadd_textbox|`9Surgery is a feature in Growtopia that allows players to perform various types of surgeries on other players using various tools. It was first introduced in the Growtopia General Hospital update on November 21, 2013.`` `2Surgery XP is only added if the surgery was performed on a real pacient.``|left|" + prize + "\nadd_player_info|`oSurgeon``|" + to_string(pInfo(peer)->s_lvl) + "|" + to_string(pInfo(peer)->s_xp) + "|" + to_string(10 * ((pInfo(peer)->s_lvl * pInfo(peer)->s_lvl) + 2)) + "|\nadd_spacer|small|\nend_dialog|worlds_list||Back|\nadd_quick_exit|\n");
	p.CreatePacket(peer);
}

void shop_tab(ENetPeer* peer, string tab) {
	struct tm newtime;
	time_t now = time(0);
	localtime_s(&newtime, &now);
	string gemsshop = "\nadd_banner|interface/large/gui_shop_featured_header.rttex|0|0|\nadd_big_banner|interface/large/gui_store_iap_message.rttex|0|0|`0You can now purchase`` `2GrowtopiaMY World Locks/Diamond Locks/Gems``. `0We accept`` `2Real Growtopia`` `0payment, type`` `2/deposit & Dm/Contact Time#1337 on Discord for more information.``|";
	string featured = "\nadd_banner|interface/large/gui_shop_featured_header.rttex|0|1|\nadd_button|infernal_shades|`oInfernal Shades``|interface/large/store_buttons/store_buttons38.rttex|`2You Get:`` 1 Infernal Shades.<CR><CR>`5Description:`` Head into town with hottest shades out right now... literally. `4Not available any other way!``|0|7|25000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|tidal_shades|`oTidal Shades``|interface/large/store_buttons/store_buttons38.rttex|`2You Get:`` 1 Tidal Shades.<CR><CR>`5Description:`` Make waves with these tidal shades. `4Not available any other way!``|1|7|25000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|verdant_shades|`oVerdant Shades``|interface/large/store_buttons/store_buttons38.rttex|`2You Get:`` 1 Verdant Shades.<CR><CR>`5Description:`` Go green and support the environment with these verdant shades. `4Not available any other way!``|2|7|25000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|11904|Golden Radical Rider|interface/large/store_buttons/store_buttons38.rttex|`2You Get:`` 1 Golden Radical Rider<CR><CR>`5Description:`` Totally Radical and Gold! `5This special, Anniversary edition will only be available this weekend and will not return.``|0|4|200000|0|||-1|-1||-1|-1||1||||||0|\nadd_button|12344|`oLightning Boots``|interface/large/store_buttons/store_buttons37.rttex|`2You Get:`` 1 Lightning Boots. <CR><CR>`5Description:`` `4Not available in any other way!|0|2|750000|0|||-1|-1||-1|-1||1||||||0|\nadd_button|11406|`oAlien Scanner Pack``|interface/large/store_buttons/store_buttons37.rttex|`2You Get:`` 4 Alien Scanner. <CR><CR>`5Description:`` The latest in Alien Scanning Technology from the world renowned Growtech Labs. Wear this item when Harvesting Trees for a chance to find an Alien Landing Pod or other Alien Block. The item is highly experimental and will break when it does find a Landing Pod or Alien Block.|3|4|35000|0|||-1|-1||-1|-1||1||||||0|\nadd_button|pinata_value_pack|`oPinata Value Pack``|interface/large/store_buttons/store_buttons30.rttex|`2You Get:`` 5 Pinata Whistles and 2 Block de Mayo Blocks.<CR><CR>`5Description:`` Make a fiesta all of your own and invite all your friends with 5 Pinata Whistles and 2 Block de Mayo Blocks to celebrate with. There is a chance of getting a `#Rare`` Lava Pinata item from this pack.|0|5|30000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|cinco_dummy|`oThe Volcanic Cape``|interface/large/store_buttons/store_buttons29.rttex|OPENDIALOG&showcincovolcaniccape|0|7|0|0|" + to_string(24 - newtime.tm_hour) + "" + (60 - newtime.tm_min != 0 ? ":" + to_string(60 - newtime.tm_min) : "") + " remaining|interface/large/gui_store_button_overlays1.rttex|0|0||-1|-1||1|interface/large/gui_store_button_overlays1.rttex|0|0||" + to_string(volcanic_cape) + "/48 Volcanic Capes Found|0|0|\nadd_button|cinco_dummy2|`oThe Volcanic Wings``|interface/large/store_buttons/store_buttons38.rttex|OPENDIALOG&showcincovolcanicwings|3|3|0|0|" + to_string(24 - newtime.tm_hour) + "" + (60 - newtime.tm_min != 0 ? ":" + to_string(60 - newtime.tm_min) : "") + " remaining|interface/large/gui_store_button_overlays1.rttex|0|0||-1|-1||1|interface/large/gui_store_button_overlays1.rttex|0|0||" + to_string(volcanic_wings) + "/48 Volcanic Wings Found|0|0|\nadd_button|11880|`oWeather Machine - Plaza``|interface/large/store_buttons/store_buttons38.rttex|`2You Get:`` 1 Weather Machine - Plaza.<CR><CR>`5Description:`` Bring all your friends to the plaza and let the celebrations never end!|4|3|50000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|722|`oPinata Whistle``|interface/large/store_buttons/store_buttons4.rttex|`2You Get:`` 1 Pinata Whistle.<CR><CR>`5Description:`` Having trouble finding a Pinata to smash? Want to keep the party going after Cinco De Mayo is over? Grab a Pinata Whistle and you can start a Pinata Bash anytime you want! Whistles only work once, and make sure you have some friends nearby, because it's impossible to smash an Ultra Pinata by yourself!|0|2|7500|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|11814|`oRabbit Top Hat``|interface/large/store_buttons/store_buttons38.rttex|`2You Get:`` `0Rabbit Top Hat``.<CR><CR>`5Description:`` And now for his next trick, the rabbit will fire an endless supply of cards!|0|3|500000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|11818|`oEquinox Scarf ``|interface/large/store_buttons/store_buttons33.rttex|`2You Get:`` 1 Equinox Scarf.<CR><CR>`5Description:`` Summon the elements of the Equinox! You can customise this item from the wrench menu.|1|0|750000|0|||-1|-1|interface/large/gui_shop_buybanner2.rttex|1|1||1||||||0|0|\nadd_button|11860|`oEquinox Box ``|interface/large/store_buttons/store_buttons38.rttex|`2You Get:`` 1 Equinox Box.<CR><CR>`5Description:`` A box fit for an equinox! Filled with 4 seasons worth of items!|1|2|25000|0|||-1|-1|interface/large/gui_shop_buybanner2.rttex|2|1||1||||||0|0|\nadd_button|11708|`oSuperstar Sneakers``|interface/large/store_buttons/store_buttons38.rttex|`2You Get:`` `0Superstar Sneakers``.<CR><CR>`5Description:`` Walk down the red carpet with these super special shining shoes!|0|2|750000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|11700|`oEnchanted Broomstick``|interface/large/store_buttons/store_buttons38.rttex|`2You Get:`` `0Enchanted Broomstick``.<CR><CR>`5Description:`` Soar through the skies leaving a trail of magical mist!|4|0|250000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|7380|`oMonochrome Blast``|interface/large/store_buttons/store_buttons24.rttex|`2You Get:`` 1 Monochrome Blast.<CR><CR>`5Description:`` Who needs colour when you have black and white? This advanced device will terraform a new world into a monochromatic marvel, with a special monochrome background, and special monochrome blocks! Includes Rare Onyx Blocks! Remember, by using this you are creating a NEW world by typing in a new name. You can't convert an existing world to a monochrome one, that would be too desaturating.|0|0|25000|0|||-1|-1||-1|-1||1||||||0|0|"/*"\nadd_button|valentine_goodies|`oValentine's Goodies``|interface/large/store_buttons/store_buttons2.rttex|`2You Get:`` 5 Golden Booty Chests and 1 Valentine's Card.<CR><CR>`5Description:`` Contains 5 Golden Booty Chests and a bonus Valentine's Card to share the love. Smash the Golden Booty Chests to find a random assortment of Valentine's surprises.|0|4|7500|0|||-1|-1||-1|-1||1||||||0|0|"*/""/*"\nadd_button|2306|`oParty-In-A-Box``|interface/large/store_buttons/store_buttons12.rttex|`2You Get:`` 1 Party-In-A-Box. <CR><CR>`5Description:`` Keep missing the party? Start your own with this handy box! This causes the Anniversary Party event to occur in your world instantly and is consumed when used. Only available during Anniversary Week!|0|3|5000|0|||-1|-1||-1|-1||1||||||0|\nadd_button|mega_party_pack|`oMega Party Pack``|interface/large/store_buttons/store_buttons37.rttex|`2You Get:`` 5 Party-In-A-Box. <CR><CR>`5Description:`` The ultimate way to get your party started. Turn any world into a party world with the mega party pack. Each box will cause the Anniversary Party event to occur in your world instantly, and is consumed when used. Only available during Anniversary Week! BONUS: With every purchase there is a chance that 1 Party-In-A-Box will become a Golden Party-In-A-Box!|0|6|50000|0|||-1|-1||-1|-1||1||||||0|\nadd_button|calendar|`oWinterfest Calendar - 2021``|interface/large/store_buttons/store_buttons34.rttex|`2You Get:`` 1 Winterfest Calendar - 2021. <CR><CR>`5Description:`` A wonderful Winterfest Calendar for 2021, jam-packed with joy and gifts to celebrate the holidays. Contains Rare Nutcracker and Snowfrost items! Buying this item will give you access to exclusive Winterfest Club benefits as they become available.|0|0|65000|0|||-1|-1||-1|-1||1||||||0|\nadd_button|bonanza|`oDiamond Builders Bonanza``|interface/large/store_buttons/store_buttons34.rttex|`2You Get:`` 1 Diamond Builders Bonanza. <CR><CR>`5Description:`` Eager to add some new diamond building materials to your construction stockpile? Well, pop this beauty in your world and it'll start cranking out awesome blocks in no time. Contains the Rare Diamond Dog amongst a heap of diamond blocks! Careful, though - blocks don't just come from nothing, and this machine will eventually run out of power once it makes a bunch! This item is available to Winterfest Club members only. Purchase the Winterfest 2021 Calendar to join the club.|0|1|45000|0|||-1|-1||-1|-1||1||||||0|\nadd_button|cracker|`oFestive Crackers``|interface/large/store_buttons/store_buttons17.rttex|`2You Get:`` 20 Festive Crackers. <CR><CR>`5Description:`` Contains 20 Winterfest Crackers. Fun holidays crackers loaded with Winterfest cheer and - hopefully - awesome gifts. What will you find? Pop one and see!|0|5|12500|0|||-1|-1||-1|-1||1||||||0|"*/"\n";
	string extra = "\nadd_button|fairy_light_wings|`oFairy Light Wings``|interface/large/store_buttons/store_buttons37.rttex|`2You Get:`` Fairy Light Wings. <CR><CR>`5Description:`` Not only do these wings let you fly, they also light up as your make your way across town!|2|5|250000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|radical|`oRadical Rider``|interface/large/store_buttons/store_buttons35.rttex|`2You Get:`` 1 Radical Rider. <CR><CR>`5Description:`` Totally Radical! Scoot across worlds with ease while looking stylish and ever so slightyl smug! Great for a /dance|0|3|50000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|rift_wings|`oRift Wings``|interface/large/store_buttons/store_buttons37.rttex|`2You Get:`` 1 Rift Wings. <CR><CR>`5Description:`` Rip a hole in the fabric of reality with these amazing Waings!|1|5|500000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|rift_cape|`oRift Cape``|interface/large/store_buttons/store_buttons32.rttex|`2You Get:`` 1 Rift Cape. <CR><CR>`5Description:`` Rip a hole in the fabric of reality with this amazing Cape! Create two unique looks and use a rift in time and space to change between them. Wrench yourself to customise the Cape. This item is available to buy for 2 days only and then will become available from a new Winterfest system afterwards. To avoid refund fraud, this item has been made untradeable until April 10th, 2021.|0|5|500000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|cosmic_cape|`oCosmic Cape ``|interface/large/store_buttons/store_buttons16.rttex|`2You Get:`` 1 Cosmic Cape. <CR><CR>`5Description:`` The cosmic energy is even messing with our store! This Cosmic Cape can only be purchased during Night of the Comet! It grants you the power to double jump, as well as having a very tiny chance of finding whatever leftover Comet Dust inside blocks you break, even when it's not Night of the Comet.|0|6|200000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|pineapple_aura|`oPineapple Aura``|interface/large/store_buttons/store_buttons35.rttex|`2You Get:`` Pineapple Aura. <CR><CR>`5Description:`` Shine like the mighty pineapple! Pineapples are not known for their iridescent qualities normally, so you know this one is special!|0|7|450000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|hooves|`oHooves of Cernunnos``|interface/large/store_buttons/store_buttons29.rttex|`2You Get:`` 1 Hooves of Cernunnos. <CR><CR>`5Description:`` Will the wild in every step you take! Roots form and wither at your command!|0|4|100000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|pegasus_lance|`oPegasus Lance``|interface/large/store_buttons/store_buttons36.rttex|`2You Get:`` 1 Pegasus Lance. <CR><CR>`5Description:`` A fine, feathery, lance. Made from the finest... checks notes... Horse feathers! To avoid refund fraud, this item has been made untradeble until November 3rd, 2021.|0|0|500000|0|||-1|-1||-1|-1||1||||||0|\nadd_button|one_winged_angel|`oOne Winged Angel``|interface/large/store_buttons/store_buttons35.rttex|`2You Get:`` One Winged Angel. <CR><CR>`5Description:`` This single wing is a symbol for all those who strive to overcome adversity, no matter what the odds|1|0|190000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|ponytail|`oPowerful Ponytail Hair ``|interface/large/store_buttons/store_buttons30.rttex|`2You Get:`` 1 Powerful Ponytail Hair. <CR><CR>`5Description:``  powerful hairstyle that's punching above its weight! Bleached platinum white for perfect preparation to apply hair dye and personalise to you heart's desire.|0|3|100000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|riding_raven|`oRiding Raven``|interface/large/store_buttons/store_buttons16.rttex|`2You Get:`` 1 Riding Raven. <CR><CR>`5Description:`` Only the darkest magic could breed a raven so massive that you could ride on it. And Growganoth only permits such magic during Halloween Week, so buy this now before Halloween is over! Riding on this bird gives you the ability to double jump. Only available for purchase during Halloween Week!|0|1|150000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|zombie_horse|`oZombie Horse``|interface/large/store_buttons/store_buttons33.rttex|`2You Get:`` 1 Zombie Horse. <CR><CR>`5Description:`` A zombified flaming horse to terrorize the town with! With hooves of flame, this fiery steed is perfect for the spooky season! Only available for purchase during Halloween Week.|1|3|150000|0|||-1|-1||-1|-1||1||||||0|\nadd_button|1180|`oSpiritual Resonator``|interface/large/store_buttons/store_buttons7.rttex|`2You Get:`` 1 Spiritual Resonator. <CR><CR>`5Description:`` Worm on the head, where it sends out signals into the great beyond, attracting friendly spirits. The ghost that follows you around when you wear this has a special ability - if you wear a pet leash on your wrist at the same time, the ghost will replace the pet, but imitate its abilities|0|0|40000|0|||-1|-1||-1|-1||1||||||0|\nadd_button|apocalypse_scythe|`oApocalypse Scythe``|interface/large/store_buttons/store_buttons23.rttex|`2You Get:`` 1 Apocalypse Scythe. <CR><CR>`5Description:`` Stolen from one of the four riders of the Apocalypse, this deadly blade is able to slice open the veil between life and death.|0|4|250000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|bumblebee|`oRiding Bumblebee``|interface/large/store_buttons/store_buttons15.rttex|`2You Get:`` 1 Riding Bumblebee. <CR><CR>`5Description:`` Bumblebees are very large. Probably not so large that you can ride them, but this is a video game! Riding on this bee gives you the ability to double-jump. Only available for purchase during Easter Week!|0|0|150000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|balloon_bunny|`oBalloon Bunny``|interface/large/store_buttons/store_buttons26.rttex|`2You Get:`` 1 Balloon Bunny. <CR><CR>`5Description:`` Bunny bunny bunny balloon balloon balloon bunny balloon bunny balloon bunny bunny balloon balloon! You may have guessed it... this is a Balloon Bunny! With a great balloon, comes great reasons to throw balloon bunny hats at fellow Growtopians! Only available for purchase during Easter Week!|0|5|250000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|ouroboros_charm|`oOuroboros Charm``|interface/large/store_buttons/store_buttons16.rttex|`2You Get:`` Ouroboros Charm. <CR><CR>`5Description:`` The endless loop of life and death, personified and celebrated. Is it a charm or is it a curse?|0|3|350000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|zraei|`oZraei's Dragoscarf``|interface/large/store_buttons/store_buttons27.rttex|`2You Get:`` 1 Zraei's Dragoscarf. <CR><CR>`5Description:`` April 2017: Dragoscarf! This dragon clings to you, granting extra punch damage, but only if you don't have it from another source. This item can only be purchased this month! It will never return, and cannot be obtained any other way! It is tradeable, though. There is a link in the /news if you'd like to see a short clip of the item in action before purchasing.|0|5|200000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|2214|`oIce Horse``|interface/large/store_buttons/store_buttons12.rttex|`2You Get:`` 1  Ice Horse. <CR><CR>`5Description:`` You're probably gonna wish you had spent extra for the seat heater option with this particular ride. But it's faster than walking. Sponsored by @Aimster.|0|2|40000|0|||-1|-1||-1|-1||1||||||0|\nadd_button|snow_husky|`oSnow Husky``|interface/large/store_buttons/store_buttons25.rttex|`2You Get:`` 1 Snow Husky. <CR><CR>`5Description:`` Who wouldn't want this adorable ball of snuggly goodness following them around! This Snow Husky will be your friend forever!|0|5|25000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|polar_bear|`oPolar Bear Leash``|interface/large/store_buttons/store_buttons8.rttex|`2You Get:`` 1 Polar Bear Leash. <CR><CR>`5Description:`` If you look out your window and see this guy, you are looking south. Or at a zoo. Or at somebody playing Growtopia.|0|3|40000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|11466|`oAura Antlers``|interface/large/store_buttons/store_buttons37.rttex|`2You Get:`` 1 Aura Antlers. <CR><CR>`5Description:`` A pair of enchanted antlers that glow as you punch! To avoid refund fraud, this item has been made untradeable until May 2st, 2022.|4|5|750000|0|||-1|-1||-1|-1||1||||||0|\nadd_button|10170|`oAqua Wings``|interface/large/store_buttons/store_buttons33.rttex|`2You Get:`` 1 Aqua Wings. <CR><CR>`5Description:`` Cause a splash with these Aqua Wings! They are so realistic, even a few fish have managed ro sneak into them... they are flying fish now!|0|0|200000|0|||-1|-1||-1|-1||1||||||0|\nadd_button|10182|`oMusical Wings``|interface/large/store_buttons/store_buttons33.rttex|`2You Get:`` 1 Musical Wings. <CR><CR>`5Description:`` Musical wings for marauding Maestros! Wrench yourself to set a tune with these equipped, then walk along to play back the tune! It's how Beethoven would have composed music if Growtopia had existed all those years ago... probably.|0|2|200000|0|||-1|-1||-1|-1||1||||||0|\nadd_button|10180|`oParty Plume Wings``|interface/large/store_buttons/store_buttons33.rttex|`2You Get:`` 1 Party Plume Wings. <CR><CR>`5Description:`` A wing with some serious plumage! Surprise and dazzle Growtopians with this vibrant display of color and feathers. The Peacock has to be one of nature's biggest show offs, now you can be as well as you take to the dancefloor with your party plume!|0|3|200000|0|||-1|-1||-1|-1||1||||||0|\nadd_button|10178|`oGrowtopia Fried Wings``|interface/large/store_buttons/store_buttons33.rttex|`2You Get:`` 1 Growtopia Fried Wings. <CR><CR>`5Description:`` Wings to make your tummy rumble! These deep fried wings are literally straight from the oven! Covered in a golden breadcrumb made with a secret mix of Growtopia herbs and spices, cooked to create the perfect balance between flavor and aerodynamics!|0|1|200000|0|||-1|-1||-1|-1||1||||||0|\nadd_button|10188|`oGhoulish Wings``|interface/large/store_buttons/store_buttons33.rttex|`2You Get:`` 1 Ghoulish Wings. <CR><CR>`5Description:`` Get your Ghoul on! A mystery gas surrounds you and elevates you skyward... not sure where this gas comes from and it's probably best not to know!|1|1|200000|0|||-1|-1||-1|-1||1||||||0|\nadd_button|neon_wings|`oNeon Wings``|interface/large/store_buttons/store_buttons33.rttex|`2You Get:`` 1 Neon Wings. <CR><CR>`5Description:`` Light up the town in style! Don’t question how neon lights make you fly, just go with the glow and touch the sky!|1|2|200000|0|||-1|-1||-1|-1||1||||||0|\nadd_button|11290|`oRobot Lord Cape``|interface/large/store_buttons/store_buttons37.rttex|`2You Get:`` 1 Robot Lord Cape. <CR><CR>`5Description:`` The famous cape of the Robot Lord, whether its just walking or punching, see why this cape is considered the most powerful by many!|3|3|150000|0|||-1|-1||-1|-1||1||||||0|\nadd_button|11302|`oSacred Scarf``|interface/large/store_buttons/store_buttons37.rttex|`2You Get:`` 1 Sacred Scarf. <CR><CR>`5Description:`` The finest silk was once weaved for a great goddess but now it adorns your shoulders.|4|3|200000|0|||-1|-1||-1|-1||1||||||0||0|0|\nadd_button|11288|`oWyvern Wings``|interface/large/store_buttons/store_buttons37.rttex|`2You Get:`` 1 Wyvern Wings. <CR><CR>`5Description:`` Not only can you jump to the heavens with these luxurious wings... you can also walk with them! To avoid refund fraud, this item has been made untradeable until February 17th, 2022.|1|4|1000000|0|||-1|-1||-1|-1||1||||||0|\nadd_button|11294|`oLucid Wings``|interface/large/store_buttons/store_buttons37.rttex|`2You Get:`` 1 Lucid Wings. <CR><CR>`5Description:`` These are a pair of wings you would only see in your (lucid) dreams!|0|3|350000|0|||-1|-1||-1|-1||1||||||0|\nadd_button|11594|`oRiding Rabbid``|interface/large/store_buttons/store_buttons38.rttex|`2You Get:`` 1 Riding Rabbid. <CR><CR>`5Description:`` Unknown information - unreleased item|1|0|250000|0|||-1|-1||-1|-1||1||||||0|\nadd_button|11626|`oMythic Tiger Crown``|interface/large/store_buttons/store_buttons38.rttex|`2You Get:`` 1 Mythic Tiger Crown.<CR><CR>`5Description:`` Summon the power of the White Tiger of the West with this glorious crown!|3|0|350000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|11158|`oZodiac Ring``|interface/large/store_buttons/store_buttons37.rttex|`2You Get:`` 1  Zodiac Ring. <CR><CR>`5Description:`` Harness the power of the Zodiac! This ring pulls galaxies into its core. It use that galactic power to summon Zodiac symbols, which change depending on the current Zodiac sign.|3|0|300000|0|||-1|-1||-1|-1||1||||||0|\nadd_button|zodiac|`oZodiac Wings``|interface/large/store_buttons/store_buttons32.rttex|`2You Get:`` 1 Zodiac Wings. <CR><CR>`5Description:`` The power of the Zodiac fills your body. The 12 signs align perfectly and allow you to not only reach for the stars but jump amongst them as well! When jumping a Zodiac sign bursts onto the screen, these change with the actual Zodiac Calendar. Note: These are only available until the end of PAW Week.|0|4|300000|0|||-1|-1||-1|-1||1||||||0|0|";
	gamepacket_t p;
	p.Insert("OnStoreRequest");
	if (tab == "tab1" || tab == "tab1_1" || tab == "tab1_2" || tab == "tab1_3" || tab == "tab1_4") p.Insert("set_description_text|Welcome to the `2Growtopia Store``! Select the item you'd like more info on.`o `wWant to get `5Supporter`` status? Any Gem purchase (or `520000`` Gems earned with free `5Tapjoy`` offers) will make you one. You'll get new skin colors, the `5Recycle`` tool to convert unwanted items into Gems, and more bonuses!\nenable_tabs|1\nadd_tab_button|main_menu|Home|interface/large/btn_shop2.rttex||1|0|0|0||||-1|-1|||0|0|\nadd_tab_button|locks_menu|Locks And Stuff|interface/large/btn_shop2.rttex||0|1|0|0||||-1|-1|||0|0|\nadd_tab_button|itempack_menu|Item Packs|interface/large/btn_shop2.rttex||0|3|0|0||||-1|-1|||0|0|\nadd_tab_button|bigitems_menu|Awesome Items|interface/large/btn_shop2.rttex||0|4|0|0||||-1|-1|||0|0|\nadd_tab_button|weather_menu|Weather Machines|interface/large/btn_shop2.rttex|Tired of the same sunny sky?  We offer alternatives within...|0|5|0|0||||-1|-1|||0|0|\nadd_tab_button|token_menu|Growtoken Items|interface/large/btn_shop2.rttex||0|2|0|0||||-1|-1|||0|0|" + featured + gemsshop + ""/*"\nadd_button|summer_pack|`oBeach Blast Bingo!``|interface/large/store_buttons/store_buttons4.rttex|`2You Get:``Beach Blast, Summer Surprise and 100 Fireworks. <CR><CR>`5Description:`` It's hot out there! Don't you want to go to the beach? Now you can make your own beach with a Beach Blast device and the 100 Fireworks needed to power it. The Beach Blast creates a brand new world set up as a beach, full of cool new Summer items. As a bonus, you'll get a Summer Surprise too! (Available during Summerfest week only)|0|7|5000|0|||-1|-1||-1|-1||1||||||0|0|"*/"" + a + (tab == "tab1_1" ? "\nselect_item|gems_rain" : "\n") + "\n|0|0|\n");
	else if (tab == "tab2" || tab == "tab2_1") p.Insert("set_description_text|`2Locks And Stuff!``  Select the item you'd like more info on, or BACK to go back.\nenable_tabs|1\nadd_tab_button|main_menu|Home|interface/large/btn_shop2.rttex||0|0|0|0||||-1|-1|||0|0|\nadd_tab_button|locks_menu|Locks And Stuff|interface/large/btn_shop2.rttex||1|1|0|0||||-1|-1|||0|0|\nadd_tab_button|itempack_menu|Item Packs|interface/large/btn_shop2.rttex||0|3|0|0||||-1|-1|||0|0|\nadd_tab_button|bigitems_menu|Awesome Items|interface/large/btn_shop2.rttex||0|4|0|0||||-1|-1|||0|0|\nadd_tab_button|weather_menu|Weather Machines|interface/large/btn_shop2.rttex|Tired of the same sunny sky?  We offer alternatives within...|0|5|0|0||||-1|-1|||0|0|\nadd_tab_button|token_menu|Growtoken Items|interface/large/btn_shop2.rttex||0|2|0|0||||-1|-1|||0|0|" + (pInfo(peer)->inv.size() < 246 ? "\nadd_button|upgrade_backpack|`0Upgrade Backpack`` (`w10 Slots``)|interface/large/store_buttons/store_buttons.rttex|`2You Get:`` 10 Additional Backpack Slots.<CR><CR>`5Description:`` Sewing an extra pocket onto your backpack will allow you to store `$10`` additional item types.  How else are you going to fit all those toilets and doors?|0|1|" + to_string(100 * ((((pInfo(peer)->inv.size() - 17) / 10) * ((pInfo(peer)->inv.size() - 17) / 10)) + 1)) + "|0|||-1|-1||-1|-1||1||||||0|0|" : "") + "\nadd_button|clothes|`oClothes Pack``|interface/large/store_buttons/store_buttons2.rttex|`2You Get:`` 3 Randomly Wearble Items.<CR><CR>`5Description:`` Why not look the part? Some may even have special powers...|0|0|25|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|rare_clothes|`oRare Clothes Pack``|interface/large/store_buttons/store_buttons2.rttex|`2You Get:`` 3 Randomly Chosen Wearbale Items.<CR><CR>`5Description:`` Enjoy the garb of kings! Some may even have special powers...|0|1|250|0|||-1|-1||-1|-1||1||||||0|0|"/*"\nadd_button|transmutation_device|`oTransmutabooth``|interface/large/store_buttons/store_buttons27.rttex|`2You Get:`` 1 Transmutabooth.<CR><CR>`5Description:`` Behold! A wondrous technological achievement from the innovative minds at GrowTech, the Transmutabooth allows you to merge clothing items, transferring the visual appearance of one onto another in the same slot! If you've ever wanted your Cyclopean Visor to look like Shades (while keeping its mod), now you can!|0|7|25000|0|||-1|-1||-1|-1||1||||||0|0|"*/""/*\nadd_button|contact_lenses|`oContact Lens Pack``|interface/large/store_buttons/store_buttons22.rttex|`2You Get:`` 20 Random Contact Lens Colors.<CR><CR>`5Description:`` Need a colorful new look? This pack includes 20 random Contact Lens colors (and may include Contact Lens Cleaning Solution, to return to your natural eye color)!|0|7|15000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|eye_drops|`oEye Drop Pack``|interface/large/store_buttons/store_buttons17.rttex|`2You Get:`` 1 `#Rare Bathroom Mirror`` and 10 random Eye Drop Colors.<CR><CR>`5Description:`` Need a fresh new look?  This pack includes a 10 random Eye Drop Colors (may include Eye Cleaning Solution, to leave your eyes sparkly clean)!|0|6|30000|0|||-1|-1||-1|-1||1||||||0|0|*/"\nadd_button|nyan_hat|`oTurtle Hat``|interface/large/store_buttons/store_buttons3.rttex|`2You Get:`` 1 Turtle Hat.<CR><CR>`5Description:`` It's the greatest hat ever. It bloops out bubbles as you run! `4Not available any other way!``|0|2|12500|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|tiny_horsie|`oTiny Horsie``|interface/large/store_buttons/store_buttons3.rttex|`2You Get:`` 1 Tiny Horsie.<CR><CR>`5Description:`` Tired of wearing shoes? Wear a Tiny Horsie instead! Or possibly a large dachshund, we're not sure. Regardless, it lets you run around faster than normal, plus you're on a horse! `4Not available any other way!``|0|5|12500|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|star_ship|`oPleiadian Star Ship``|interface/large/store_buttons/store_buttons4.rttex|`2You Get:`` 1 Pleiadian Star Ship.<CR><CR>`5Description:`` Float on, my brother. It's all groovy. This star ship can't fly, but you can still zoom around in it, leaving a trail of energy rings and moving at enhanced speed. Sponsored by Pleiadian. `4Not available any other way!``|0|3|12500|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|dragon_hand|`oDragon Hand``|interface/large/store_buttons/store_buttons5.rttex|`2You Get:`` 1 Dragon Hand.<CR><CR>`5Description:`` Call forth the dragons of legend!  With the Dragon Hand, you will command your own pet dragon. Instead of punching blocks or players, you can order your dragon to incinerate them! In addition to just being awesome, this also does increased damage, and pushes other players farther. `4Not available any other way!``|0|1|25000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|corvette|`oLittle Red Corvette``|interface/large/store_buttons/store_buttons6.rttex|`2You Get:`` 1 Little Red Corvette.<CR><CR>`5Description:`` Cruise around the neighborhood in style with this sweet convertible. It moves at enhanced speed and leaves other Growtopians in your dust. `4Not available any other way!``|0|1|12500|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|stick_horse|`oStick Horse``|interface/large/store_buttons/store_buttons6.rttex|`2You Get:`` 1 Stick Horse.<CR><CR>`5Description:`` Nobody looks cooler than a person bouncing along on a stick with a fake horse head attached. NOBODY. `4Not available any other way!``|0|3|12500|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|ambulance|`oAmbulance``|interface/large/store_buttons/store_buttons7.rttex|`2You Get:`` 1 Ambulance.<CR><CR>`5Description:`` Rush to the scene of an accident while lawyers chase you in this speedy rescue vehicle. `4Not available any other way!``|0|3|12500|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|raptor|`oRiding Raptor``|interface/large/store_buttons/store_buttons7.rttex|`2You Get:`` 1 Riding Raptor.<CR><CR>`5Description:`` Long thought to be extinct, it turns out that these dinosaurs are actually alive and easily tamed. And riding one lets you run around faster than normal! `4Not available any other way!``|0|7|12500|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|owl|`oMid-Pacific Owl``|interface/large/store_buttons/store_buttons10.rttex|`2You Get:`` 1 Mid-Pacific Owl.<CR><CR>`5Description:`` This owl is a bit lazy - if you stop moving around, he'll land on your head and fall asleep. Dedicated to the students of the Mid-Pacific Institute. `4Not available any other way!``|0|1|15000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|unicorn|`oUnicorn Garland``|interface/large/store_buttons/store_buttons10.rttex|`2You Get:`` 1 Unicorn Garland.<CR><CR>`5Description:`` Prance about in the fields with your very own pet unicorn! It shoots `1R`2A`3I`4N`5B`6O`7W`8S``. `4Not available any other way!``|0|4|25000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|starboard|`oStarBoard``|interface/large/store_buttons/store_buttons11.rttex|`2You Get:`` 1 StarBoard.<CR><CR>`5Description:`` Hoverboards are here at last! Zoom around Growtopia on this brand new model, which is powered by fusion energy (that means stars spit out of the bottom). Moves faster than walking. Sponsored by Miwsky, Chudy, and Dawid. `4Not available any other way!``|0|1|15000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|motorcycle|`oGrowley Motorcycle``|interface/large/store_buttons/store_buttons11.rttex|`2You Get:`` 1 Growley Motorcycle.<CR><CR>`5Description:`` The coolest motorcycles available are Growley Dennisons. Get a sporty blue one today! It even moves faster than walking, which is pretty good for a motorcycle. `4Not available any other way!``|0|6|25000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|monkey_on_back|`oMonkey On Your Back``|interface/large/store_buttons/store_buttons13.rttex|`2You Get:`` 1 Monkey On Your Back.<CR><CR>`5Description:`` Most people work really hard to get rid of these, but hey, if you want one, it's available! `4But not available any other way!`` Sponsored by SweGamerHD's subscribers, Kizashi, and Inforced. `#Note: This is a neck item, not a back item. He's grabbing your neck!``|0|2|25000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|carrot_sword|`oCarrot Sword``|interface/large/store_buttons/store_buttons13.rttex|`2You Get:`` 1 Carrot Sword.<CR><CR>`5Description:`` Razor sharp, yet oddly tasty. This can carve bunny symbols into your foes! `4Not available any other way!`` Sponsored by MrMehMeh.|0|3|7500|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|red_bicycle|`oRed Bicycle``|interface/large/store_buttons/store_buttons13.rttex|`2You Get:`` 1 Red Bicycle.<CR><CR>`5Description:`` It's the environmentally friendly way to get around! Ride this bicycle at high speed hither and zither throughout Growtopia. `4Not available any other way!``|0|5|15000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|fire_truck|`oFire Truck``|interface/large/store_buttons/store_buttons14.rttex|`2You Get:`` 1 Fire Truck.<CR><CR>`5Description:`` Race to the scene of the fire in this speedy vehicle! `4Not available any other way!``|0|2|25000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|pet_slime|`oPet Slime``|interface/large/store_buttons/store_buttons14.rttex|`2You Get:`` 1 Pet Slime.<CR><CR>`5Description:`` What could be better than a blob of greasy slime that follows you around? How about a blob of greasy slime that follows you around and spits corrosive acid, melting blocks more quickly than a normal punch? `4Not available any other way!``|0|4|50000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|dabstep_shoes|`oDabstep Low Top Sneakers``|interface/large/store_buttons/store_buttons21.rttex|`2You Get:`` 1 Dabstep Low Top Sneakers.<CR><CR>`5Description:`` Light up every footfall and move to a better beat with these dabulous shoes! When you're wearing these, the world is your dance floor! `4Not available any other way!``|0|2|15000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|11588|`oWings of Daidalos``|interface/large/store_buttons/store_buttons37.rttex|`2You Get:`` 1 Wings of Daidalos. <CR><CR>`5Description:`` Immortals Fenyx Rising! Glide through the sky with the wings crafted by the famous Daidalos himself. To avoid refund fraud, this item has been made untradeable until 6th June, 2022|4|6|1000000|0|||-1|-1||-1|-1||1||||||0|\nadd_button|11560|`oEzio``|interface/large/store_buttons/store_buttons37.rttex|`2You Get:`` 1 Ezio. <CR><CR>`5Description:`` Assassin's Creed! Take the form of Ezio, the Leader of the Assassin Brotherhood, and challenge yourself as you take the Leap of Faith! To avoid refund fraud, this item has been made untradeable until 6th June, 2022|3|6|500000|0|||-1|-1||-1|-1||1||||||0|\nadd_button|11554|`oBodvar``|interface/large/store_buttons/store_buttons37.rttex|`2You Get:`` 1 Bodvar. <CR><CR>`5Description:`` Brawlhalla! Take the form of Bodvar, The Unconquered Viking of Brawlhalla and place yourself as one of Valhalla's greatest champions! To avoid refund fraud, this item has been made untradeable until 6th June, 2022.|0|7|500000|0|||-1|-1||-1|-1||1||||||0|\nadd_button|11556|`oVal``|interface/large/store_buttons/store_buttons37.rttex|`2You Get:`` 1 Val. <CR><CR>`5Description:`` Brawlhalla! Take the form of Val, The Weapon of Brawlhalla and solve the mysteries of Valhalla. To avoid refund fraud, this item has been made untradeable until 6th June, 2022.|1|7|500000|0|||-1|-1||-1|-1||1||||||0|\nadd_button|11558|`oSam Fisher``|interface/large/store_buttons/store_buttons37.rttex|`2You Get:`` 1 Sam Fisher. <CR><CR>`5Description:`` Splinter Cell! Take the form of Sam Fisher, Splinter Cell's first field operative, as you covertly infiltrate new locations! To avoid refund fraud, this item has been made untradeable until 6th June, 2022.|2|7|500000|0|||-1|-1||-1|-1||1||||||0|\nadd_button|11562|`oPet Blood Dragon``|interface/large/store_buttons/store_buttons37.rttex|`2You Get:`` 1 Pet Blood Dragon. <CR><CR>`5Description:`` Far Cry III : Blood Dragon! Take control of your own vicious Blood Dragon that fires neon lasers from its eyes!|2|6|250000|0|||-1|-1||-1|-1||1||||||0|\nadd_button|dark|`oDark Assassin's Pack``|interface/large/store_buttons/store_buttons36.rttex|`2You Get:`` Dark Assassin's Pack. <CR><CR>`5Description:`` This pack contains The Brother Hood item, previously exclusive to the console versions of Growtopia. Also included are Dark Assassin's Vest, Cape, Trousers, Boots and Armguards!|0|3|1000000|0|||-1|-1||-1|-1||1||||||0|\nadd_button|11546|`oMood Mask``|interface/large/store_buttons/store_buttons37.rttex|`2You Get:`` 1 Mood Mask. <CR><CR>`5Description:`` Happy? Angry? Curious? Wear this super advanced mask to tell the world how you're feeling!|1|6|500000|0|||-1|-1||-1|-1||1||||||0|\nadd_button|11132|`oNoodle Bowl Hat``|interface/large/store_buttons/store_buttons37.rttex|`2You Get:`` 1 Noodle Bowl Hat. <CR><CR>`5Description:`` A fine bowl of steaming hot noodles to wear on your head. Caution though, these are delicious so everyone might want a slurp from it!|1|0|150000|0|||-1|-1||-1|-1||1||||||0|\nadd_button|11284|`oPaper Wasp Pet``|interface/large/store_buttons/store_buttons37.rttex|`2You Get:`` 1 Paper Wasp Pet. <CR><CR>`5Description:`` Folded and creased to paper perfection. This wasp packs a very unique sting in its tail.|0|1|150000|0|||-1|-1||-1|-1||1||||||0|\nadd_button|11162|`oFinger Gun``|interface/large/store_buttons/store_buttons37.rttex|`2You Get:`` 1 Finger Gun. <CR><CR>`5Description:`` To wield the finger gun, you must first become the gun. Old Growtopian Proverb|2|0|200000|0|||-1|-1||-1|-1||1||||||0|" + extra + "" + (tab == "tab2_1" ? "\nselect_item|upgrade_backpack" : "") + "\n");
	else if (tab == "tab3") {
		string second = "\nadd_button|signal_jammer|`oSignal Jammer``|interface/large/store_buttons/store_buttons.rttex|`2You Get:`` 1 Signal Jammer.<CR><CR>`5Description:`` Get off the grid! Install a `$Signal Jammer``! A single punch will cause it to whir to life, tireless hiding your world and its population from pesky snoopers - only those who know the world name will be able to enter. `5It's a perma-item, is never lost when destroyed.``|1|6|2000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|punch_jammer|`oPunch Jammer``|interface/large/store_buttons/store_buttons7.rttex|`2You Get:`` 1 Punch Jammer.<CR><CR>`5Description:`` Tired of getting bashed around? Set up a Punch Jammer in your world, and people won't be able to punch each other! Can be turned on and off as needed. `5It's a perma-item, is never lost when destroyed.``|0|4|15000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|zombie_jammer|`oZombie Jammer``|interface/large/store_buttons/store_buttons7.rttex|`2You Get:`` 1 Zombie Jammer.<CR><CR>`5Description:`` Got a parkour or race that you don't want slowed down? Turn this on and nobody can be infected by zombie bites in your world. It does not prevent direct infection by the g-Virus itself though. `5It's a perma-item, is never lost when destroyed.``|0|5|15000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|surg_blast|`oSurgWorld Blast``|interface/large/store_buttons/store_buttons27.rttex|`2You Get:`` 1 SurgWorld Blast and 1 Caduceaxe.<CR><CR>`5Description:`` Your gateway to a world of medical wonders! SurgWorld is a place of care and healing, with all kinds of interesting blocks, top tips on how to treat people with surgery, and an increased chance of getting maladies while you work! Also comes with 1 Caduceaxe to extract Vaccine Drops from blocks. `6Warning:`` May break when extracting vaccine.|0|2|10000|0|||-1|-1||-1|-1||1||||||0|0|"/*"\nadd_button|starship_blast|`oImperial Starship Blast``|interface/large/store_buttons/store_buttons21.rttex|`2You Get:`` 1 Imperial Starship Blast.<CR><CR>`5Description:`` Command your very own Starship and explore the cosmos! This blast contains one of 3 possible Imperial ship types - which will you get? Note: Each Starship comes with a full tank of gas, an Imperial Helm - Mk. I, Imperial Reactor - Mk. I and an Imperial Viewscreen - Mk. I, so you'll be all set for your adventure among the stars! Note: A Starship also comes with an assortment of space-age blocks!|0|1|10000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|surg_blast|`oSurgWorld Blast``|interface/large/store_buttons/store_buttons27.rttex|`2You Get:`` 1 SurgWorld Blast and 1 Caduceaxe.<CR><CR>`5Description:`` Your gateway to a world of medical wonders! SurgWorld is a place of care and healing, with all kinds of interesting blocks, top tips on how to treat people with surgery, and an increased chance of getting maladies while you work! Also comes with 1 Caduceaxe to extract Vaccine Drops from blocks. `6Warning:`` May break when extracting vaccine.|0|2|10000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|bountiful_blast|`oBountiful Blast``|interface/large/store_buttons/store_buttons27.rttex|`2You Get:`` 1 Bountiful Blast.<CR><CR>`5Description:`` Enter a world of fertile soil, cheerful sunshine and lush green hills, and bountiful new trees! This blast is your ticket to a different kind of farming!|0|3|5000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|thermo_blast|`oThermonuclear Blast``|interface/large/store_buttons/store_buttons8.rttex|`2You Get:`` 1 Thermonuclear Blast.<CR><CR>`5Description:`` This supervillainous device will blast you to a new world that has been scoured completely empty - it contains nothing but Bedrock and a White Door. Remember: When using this, you are creating a NEW world by typing in a new name. It would be irresponsible to let you blow up an entire existing world.|0|5|15000|0|||-1|-1||-1|-1||1||||||0|0|"*/"\nadd_button|1402|`oThermonuclear Blast``|interface/large/store_buttons/store_buttons8.rttex|`2You Get:`` 1 Thermonuclear Blast.<CR><CR>`5Description:`` This supervillainous device will blast you to a new world that has been scoured completely empty - it contains nothing but Bedrock and a White Door. Remember: When using this, you are creating a NEW world by typing in a new name. It would be irresponsible to let you blow up an entire existing world.|0|5|15000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|antigravity_generator|`oAntigravity Generator``|interface/large/store_buttons/store_buttons17.rttex|`2You Get:`` 1 Antigravity Generator.<CR><CR>`5Description:`` Disables gravity in your world when activated! Well, it reduces gravity, and lets everybody jump as much as they want! `5It's a perma-item - never lost when destroyed! `4Not available any other way!````|0|3|225000|0|||-1|-1||-1|-1||1||||||0|0|"/*"\nadd_button|building_blocks_machine|`oBuilding Blocks Machine``|interface/large/store_buttons/store_buttons26.rttex|`2You Get:`` 1 Building Blocks Machine.<CR><CR>`5Description:`` Eager to add some new building materials to your construction stockpile? Tired of collecting them from random worlds and weirdos? Well, pop this beauty in your world and it'll start cranking out awesome blocks in no time! Contains the `5RARE Creepy Baby Block and Digital Dirt`` amongst a heap of other new blocks! Careful, though - blocks don't just come from nothing, and this machine will eventually run out of power once it makes a bunch!|0|3|8000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|builders_lock|`oBuilder's Lock``|interface/large/store_buttons/store_buttons17.rttex|`2You Get:`` 1 Builders Lock.<CR><CR>`5Description:`` Protect up to `$200`` tiles. Wrench the lock to limit it - it can either only allow building, or only allow breaking! `5It's a perma-item, is never lost when destroyed.``|0|2|50000|0|||-1|-1||-1|-1||1||||||0|0|"*/"\nadd_button|builders_lock|`oBuilder's Lock``|interface/large/store_buttons/store_buttons17.rttex|`2You Get:`` 1 Builders Lock.<CR><CR>`5Description:`` Protect up to `$200`` tiles. Wrench the lock to limit it - it can either only allow building, or only allow breaking! `5It's a perma-item, is never lost when destroyed.``|0|2|50000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|weather_sunny|`oWeather Machine - Sunny``|interface/large/store_buttons/store_buttons5.rttex|`2You Get:`` 1 Weather Machine - Sunny.<CR><CR>`5Description:`` You probably don't need this one... but if you ever have a desire to turn a sunset or desert world back to normal, grab a Sunny Weather Machine to restore the default Growtopia sky! `5It's a perma-item, is never lost when destroyed.``|0|5|500|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|weather_night|`oWeather Machine - Night``|interface/large/store_buttons/store_buttons5.rttex|`2You Get:`` 1 Weather Machine - Night.<CR><CR>`5Description:`` You might not call it weather, but we do! This will turn the background of your world into a lovely night scene with stars and moon. `5It's a perma-item, is never lost when destroyed.``|0|6|5000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|weather_arid|`oWeather Machine - Arid``|interface/large/store_buttons/store_buttons5.rttex|`2You Get:`` 1 Weather Machine - Arid.<CR><CR>`5Description:`` Want your world to look like a cartoon desert? This will turn the background of your world into a desert scene with all the trimmings. `5It's a perma-item, is never lost when destroyed.``|0|7|5000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|weather_rainy|`oWeather Machine - Rainy City``|interface/large/store_buttons/store_buttons6.rttex|`2You Get:`` 1 Weather Machine - Rainy City.<CR><CR>`5Description:`` This will turn the background of your world into a dark, rainy city scene complete with sound effects. `5It's a perma-item, is never lost when destroyed.``|0|5|5000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|weather_warp|`oWeather Machine - Warp Speed``|interface/large/store_buttons/store_buttons11.rttex|`2You Get:`` 1 Weather Machine - Warp Speed.<CR><CR>`5Description:`` This Weather Machine will launch your world through space at relativistic speeds, which will cause you to age more slowly, as well as see stars flying by rapidly in the background. `5It's a perma-item, is never lost when destroyed.``|0|3|5000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|mars_blast|`oMars Blast``|interface/large/store_buttons/store_buttons6.rttex|`2You Get:`` 1 Mars Blast.<CR><CR>`5Description:`` Blast off to Mars!  This powerful rocket ship will launch you to a new world set up like the surface of Mars, with a special martian sky background, and unique terrain not found elsewhere in the solar system. Mars even has lower gravity than Growtopia normally does! Remember: When using this, you are creating a NEW world by typing in a new name. You can't convert an existing world to Mars, that would be dangerous.|0|7|15000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|undersea_blast|`oUndersea Blast``|interface/large/store_buttons/store_buttons9.rttex|`2You Get:`` 1 Undersea Blast.<CR><CR>`5Description:`` Explore the ocean!  This advanced device will terraform a new world set up like the bottom of the ocean, with a special ocean background, and special blocks like Seaweed, Coral, Jellyfish, Sharks, and maybe a special surprise... Remember, by using this you are creating a NEW world by typing in a new name. You can't convert an existing world to an ocean, that would be dangerous.|0|7|15000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|cave_blast|`oCave Blast``|interface/large/store_buttons/store_buttons15.rttex|`2You Get:`` 1 Cave Blast.<CR><CR>`5Description:`` This explosive device will punch a hole in the ground, giving you a dark cavern to explore. There are even rumors of treasure and the entrance to ancient mines, hidden deep in the caves... but make sure you bring a World Lock. The blasted world is not locked when it's created, so lock it before somebody shows up! Remember: When using this, you are creating a NEW world by typing in a new name. You can't convert an existing world to a cave, that would be dangerous.|0|2|30000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|weather_stuff|`oWeather Machine - Stuff``|interface/large/store_buttons/store_buttons15.rttex|`2You Get:`` 1 Weather Machine - Stuff.<CR><CR>`5Description:`` This is the most fun weather imaginable - Choose any item from your inventory, adjust some settings, and watch it rain down from the sky! Or up, if you prefer reversing the gravity. `5It's a perma-item, is never lost when destroyed.``|0|6|50000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|weather_jungle|`oWeather Machine - Jungle``|interface/large/store_buttons/store_buttons16.rttex|`2You Get:`` 1 Weather Machine - Jungle.<CR><CR>`5Description:`` This weather machine will turn the background of your world into a steamy jungle. `5It's a perma-item, is never lost when destroyed.``|0|5|10000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|weather_backgd|`oWeather Machine - Background``|interface/large/store_buttons/store_buttons17.rttex|`2You Get:`` 1 Weather Machine - Background.<CR><CR>`5Description:`` This amazing device can scan any Background Block, and will make your entire world look like it's been filled with that block. Also handy for hiding music notes! `5It's a perma-item, is never lost when destroyed.``|0|1|150000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|digital_rain_weather|`oWeather Machine - Digital Rain``|interface/large/store_buttons/store_buttons22.rttex|`2You Get:`` 1 Weather Machine - Digital Rain.<CR><CR>`5Description:`` Take the grow pill, and we'll show you how deep the rabbit hole goes! Splash the scrolling code of creation across the skies of your worlds. They say you learn to understand it after a while... Note: You can only have one of these per world. `5It's a perma-item, is never lost when destroyed.``|0|6|15000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|treasure_blast|`oTreasure Blast``|interface/large/store_buttons/store_buttons26.rttex|`2You Get:`` 1 Treasure Blast.<CR><CR>`5Description:`` Enter a world of snow-capped peaks and long-forgotten mysteries! Riddles and secrets - and a ton of treasure - await those who brave this blast's blocks! Remember, when you use this, it'll create a new world by typing in a new name! No sense in searching for clues to great treasures in well-trod worlds, is there?|0|6|10000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|7380|`oMonochrome Blast``|interface/large/store_buttons/store_buttons24.rttex|`2You Get:`` 1 Monochrome Blast.<CR><CR>`5Description:`` Who needs colour when you have black and white? This advanced device will terraform a new world into a monochromatic marvel, with a special monochrome background, and special monochrome blocks! Includes Rare Onyx Blocks! Remember, by using this you are creating a NEW world by typing in a new name. You can't convert an existing world to a monochrome one, that would be too desaturating.|0|0|25000|0|||-1|-1||-1|-1||1||||||0|0|"/*"\nadd_button|infinity_weather_machine|`oInfinity Weather Machine``|interface/large/store_buttons/store_buttons32.rttex|`2You Get:`` 1 Infinity Weather Machine.<CR><CR>`5Description:`` Imagine being able to predict the weather?! Well, with the Infinity Weather Machine you can! Add multiple Weather Machines to this machine and have them play on a loop, like a weather mix tape, kind of!|0|3|25000|0|||-1|-1||-1|-1||1||||||0|0|"*/"\nadd_button|snowy|`oSnowy``|interface/large/store_buttons/store_buttons8.rttex|`2You Get:`` 1 Weather Machine - Snowy. <CR><CR>`5Description:`` Winter is coming. This will turn the background of your world into a snowy mountain scene with snowflakes constantly drifting down. Only available for purchase during WinterFest! It's a perma-item, is never lost when destroyed.|0|2|10000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|valentine|`oValentine's ``|interface/large/store_buttons/store_buttons18.rttex|`2You Get:`` 1 Weather Machine - Valentine's. <CR><CR>`5Description:`` Love is in the air! Send hearts sailing through pink and fluffy skies with this adorable weather machine and everyone will know what a romantic you are! It's a perma-item, is never lost when destroyed.|0|5|10000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|paddy|`oWeather Machine - St. Paddy's Day``|interface/large/store_buttons/store_buttons18.rttex|`2You Get:`` 1 Weather Machine - St. Paddy's Day. <CR><CR>`5Description:`` It's Paddy Day here in Growtopia! Celebrate in style with fiddle music, floating shamrocks, rainbows, and a pot o' gold over emerald hills. This Weather Machine will let everyone know how lucky you are!|0|7|20000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|10286|`oWeather Machine - Celebrity Hills``|interface/large/store_buttons/store_buttons33.rttex|`2You Get:`` 1 Weather Machine - Celebrity Hills. <CR><CR>`5Description:`` It's Thanksgiving in Growtopia! Celebrate in Celebrity Hills where dreams are made! This weather machine will let everyone know how glamorous you are! It's a perma-item, is never lost when destroyed.|1|4|30000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|4486|`oWeather Machine - Apocalypse``|interface/large/store_buttons/store_buttons16.rttex|`2You Get:`` 1 Weather Machine - Apocalypse. <CR><CR>`5Description:`` Feeling nostalgic for the end of the world? Let's bring it back! With this weather active, somebody in your world will get infected with the g-Virus every hour, and players can kill zombies in your world, with the appropriate weapon. This sensitive technology will not function while damaged.|0|2|150000|0|||-1|-1||-1|-1||1||||||0|0|\n|0|0|\n";
		p.Insert("set_description_text|`2Item Packs!``  Select the item you'd like more info on, or BACK to go back.\nenable_tabs|1\nadd_tab_button|main_menu|Home|interface/large/btn_shop2.rttex||0|0|0|0||||-1|-1|||0|0|\nadd_tab_button|locks_menu|Locks And Stuff|interface/large/btn_shop2.rttex||0|1|0|0||||-1|-1|||0|0|\nadd_tab_button|itempack_menu|Item Packs|interface/large/btn_shop2.rttex||1|3|0|0||||-1|-1|||0|0|\nadd_tab_button|bigitems_menu|Awesome Items|interface/large/btn_shop2.rttex||0|4|0|0||||-1|-1|||0|0|\nadd_tab_button|weather_menu|Weather Machines|interface/large/btn_shop2.rttex|Tired of the same sunny sky?  We offer alternatives within...|0|5|0|0||||-1|-1|||0|0|\nadd_tab_button|token_menu|Growtoken Items|interface/large/btn_shop2.rttex||0|2|0|0||||-1|-1|||0|0|\nadd_button|world_lock|`oWorld Lock``|interface/large/store_buttons/store_buttons.rttex|`2You Get:`` 1 World Lock.<CR><CR>`5Description:`` Become the undisputed ruler of your domain with one of these babies.  It works like a normal lock except it locks the `$entire world``!  Won't work on worlds that other people already have locks on. You can even add additional normal locks to give access to certain areas to friends. `5It's a perma-item, is never lost when destroyed.``  `wRecycles for 200 Gems.``|0|7|2000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|world_lock_10_pack|`oWorld Lock Pack``|interface/large/store_buttons/store_buttons18.rttex|`2You Get:`` 10 World Locks.<CR><CR>`5Description:`` 10-pack of World Locks. Become the undisputed ruler of up to TEN kingdoms with these babies. Each works like a normal lock except it locks the `$entire world``!  Won't work on worlds that other people already have locks on. You can even add additional normal locks to give access to certain areas to friends. `5It's a perma-item, is never lost when destroyed.`` `wEach recycles for 200 Gems.``|0|3|20000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|11550|`oBlood Dragon Lock``|interface/large/store_buttons/store_buttons37.rttex|`2You Get:`` 1 Blood Dragon Lock. <CR><CR>`5Description:`` Far Cry III Blood Dragon! Place this futuristic lock and transport to the world of the Blood Dragon!|3|7|150000|0|||-1|-1||-1|-1||1||||||0|\nadd_button|11586|`oPrince of Persia Lock``|interface/large/store_buttons/store_buttons37.rttex|`2You Get:`` 1 Prince of Persia Lock. <CR><CR>`5Description:`` Prince of Persia Lock - unreleased lock.|4|7|150000|0|||-1|-1||-1|-1||1||||||0|\nadd_button|small_lock|`oSmall Lock``|interface/large/store_buttons/store_buttons.rttex|`2You Get:`` 1 Small Lock.<CR><CR>`5Description:`` Protect up to `$10`` tiles.  Can add friends to the lock so others can edit that area as well. `5It's a perma-item, is never lost when destroyed.``|1|3|50|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|big_lock|`oBig Lock``|interface/large/store_buttons/store_buttons.rttex|`2You Get:`` 1 Big Lock.<CR><CR>`5Description:`` Protect up to `$48`` tiles.  Can add friends to the lock so others can edit that area as well. `5It's a perma-item, is never lost when destroyed.``|1|1|200|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|huge_lock|`oHuge Lock``|interface/large/store_buttons/store_buttons.rttex|`2You Get:`` 1 Huge Lock.<CR><CR>`5Description:`` Protect up to `$200`` tiles.  Can add friends to the lock so others can edit that area as well. `5It's a perma-item, is never lost when destroyed.``|0|4|500|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|builders_lock|`oBuilder's Lock``|interface/large/store_buttons/store_buttons17.rttex|`2You Get:`` 1 Builders Lock.<CR><CR>`5Description:`` Protect up to `$200`` tiles. Wrench the lock to limit it - it can either only allow building, or only allow breaking! `5It's a perma-item, is never lost when destroyed.``|0|2|50000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|door_pack|`oDoor And Sign Hello Pack``|interface/large/store_buttons/store_buttons.rttex|`2You Get:`` 1 Door and 1 Sign.<CR><CR>`5Description:`` Own your very own door and sign! This pack comes with one of each. Leave cryptic messages and create a door that can open to, well, anywhere.|0|3|7|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|door_mover|`oDoor Mover``|interface/large/store_buttons/store_buttons8.rttex|`2You Get:`` 1 Door Mover.<CR><CR>`5Description:`` Unsatisfied with your world's layout?  This one-use device can be used to move the White Door to any new location in your world, provided there are 2 empty spaces for it to fit in. Disappears when used. `2Only usable on a world you have World Locked.``|0|6|5000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|vending_machine|`oVending Machine``|interface/large/store_buttons/store_buttons13.rttex|`2You Get:`` 1 Vending Machine.<CR><CR>`5Description:`` Tired of interacting with human beings? Try a Vending Machine! You can put a stack of items inside it, set a price in World Locks, and people can buy from the machine while you sit back and rake in the profits! `5It's a perma-item, is never lost when destroyed, and it is not available any other way.``|0|6|8000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|2580|`oChange of Address``|interface/large/store_buttons/store_buttons12.rttex|`2You Get:`` 1 Change of Address.<CR><CR>`5Description:`` Don't like the name of your world? You can use up one of these to trade your world's name with the name of any other world that you own. You must have a `2World Lock`` in both worlds. Go lock up that empty world with the new name you want and swap away!|0|6|20000|0|||-1|-1||-1|-1||1||||||0|0|"/*"\nadd_button|digi_vend|`oDigiVend Machine``|interface/large/store_buttons/store_buttons29.rttex|`2You Get:`` 1 DigiVend Machine.<CR><CR>`5Description:`` Get with the times and go digital! This wired vending machine can connect its contents to Vending Hubs AND the multiversal economy, providing a unified shopping experience along with price checks to help you sell your goods! All that, and still no human-related hassle! Use your wrench on this to stock it with an item and set a price in World Locks. Other players will be able to buy from it! Only works in World-Locked worlds.|0|2|12000|0|||-1|-1||-1|-1||1||||||0|0|"*/""/*"\nadd_button|checkout_counter|`oVending Hub - Checkout Counter``|interface/large/store_buttons/store_buttons29.rttex|`2You Get:`` 1 Vending Hub.<CR><CR>`5Description:`` Your one-stop shop! This vending hub will collect and display (and let shoppers buy) the contents of ALL DigiVends in its row or column (wrench it to set which the direction)! Wow! Now that's a shopping experience we can all enjoy! Note: Only works in World-Locked worlds.|0|3|50000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|change_addr|`oChange of Address``|interface/large/store_buttons/store_buttons12.rttex|`2You Get:`` 1 Change of Address.<CR><CR>`5Description:`` Don't like the name of your world? You can use up one of these to trade your world's name with the name of any other world that you own. You must have a `2World Lock`` in both worlds. Go lock up that empty world with the new name you want and swap away!|0|6|20000|0|||-1|-1||-1|-1||1||||||0|0|"*/"" + second);
	}
	else if (tab == "tab4") p.Insert("set_description_text|`2Awesome Items!``  Select the item you'd like more info on, or BACK to go back.\nenable_tabs|1\nadd_tab_button|main_menu|Home|interface/large/btn_shop2.rttex||0|0|0|0||||-1|-1|||0|0|\nadd_tab_button|locks_menu|Locks And Stuff|interface/large/btn_shop2.rttex||0|1|0|0||||-1|-1|||0|0|\nadd_tab_button|itempack_menu|Item Packs|interface/large/btn_shop2.rttex||0|3|0|0||||-1|-1|||0|0|\nadd_tab_button|bigitems_menu|Awesome Items|interface/large/btn_shop2.rttex||1|4|0|0||||-1|-1|||0|0|\nadd_tab_button|weather_menu|Weather Machines|interface/large/btn_shop2.rttex|Tired of the same sunny sky?  We offer alternatives within...|0|5|0|0||||-1|-1|||0|0|\nadd_tab_button|token_menu|Growtoken Items|interface/large/btn_shop2.rttex||0|2|0|0||||-1|-1|||0|0|\nadd_button|5seed|`oSmall Seed Pack``|interface/large/store_buttons/store_buttons.rttex|`2You Get:`` 1 Small Seed Pack.<CR><CR>`5Description:`` Contains one Small Seed Pack. Open it for `$5`` randomly chosen seeds, including 1 rare seed! Who knows what you'll get?!|1|4|50|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|ssp_10_pack|`oSmall Seed Pack Collection``|interface/large/store_buttons/store_buttons18.rttex|`2You Get:`` 10 Small Seed Packs.<CR><CR>`5Description:`` Open each one for `$5`` randomly chosen seeds apiece, including 1 rare seed per pack! Who knows what you'll get?!|0|4|500|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|rare_seed|`oRare Seed Pack``|interface/large/store_buttons/store_buttons.rttex|`2You Get:`` 5 Randomly Chosen Rare Seeds.<CR><CR>`5Description:`` Expect some wondrous crops with these!|1|7|500|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|grow_spray|`o5-pack of Grow Spray Fertilizer``|interface/large/store_buttons/store_buttons.rttex|`2You Get:`` 5 Grow Spray Fertilizers.<CR><CR>`5Description:`` Why wait?!  Treat yourself to a `$5-pack`` of amazing `wGrow Spray Fertilizer`` by GrowTech Corp.  Each bottle instantly ages a tree by `$1 hour``.|0|6|100|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|deluxe_grow_spray|`oDeluxe Grow Spray``|interface/large/store_buttons/store_buttons11.rttex|`2You Get:`` 1 Deluxe Grow Spray.<CR><CR>`5Description:`` GrowTech's new `$Deluxe`` `wGrow Spray`` instantly ages a tree by `$24 hours`` per bottle! That's somewhere around 25 times as much as regular Grow Spray!|0|2|450|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|5764|`oOriental Spice Spray``|interface/large/store_buttons/store_buttons19.rttex|`2You Get:`` 1 Oriental Spice Spray. <CR><CR>`5Description:`` Packed with rich spices and wholesome powers, this spray will speed up the growth of one tree from the Chinese New Year event by 72 hours!|0|0|2500|0|||-1|-1||-1|-1||1||||||0|\nadd_button|surg|`oSurgical Kit``|interface/large/store_buttons/store_buttons7.rttex|`2You Get:`` 1 `#Rare Heart Monitor``, 1 Hospital Bed, 5 Surg-E, 5 of each of the 13 different Surical Tools and 10 Med-a-Checks.<CR><CR>`5Description:`` Get all the tools you need to become Chief of Surgery at Growtopia General Hospital! `#Rare`` Heart Monitor that lets people know when you are online, Hospital Bed that lets you perform surgery on anybody laying (or standing) on it, Med-a-Checks to identify patients with maladies, The Train-E bot to practice on, and 5 each of the thirteen different Surgical Tools you'll need to do that surgery!|0|2|12000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|fishin_pack|`oFishin' Pack``|interface/large/store_buttons/store_buttons14.rttex|`2You Get:`` 1 Fishing Rod, 5 Wiggly Worms, 1 Hand Drill, 1 Nuclear Detonator,  1 `#Rare Tackle Box``, 10 Fish Tanks and 1 `#Rare Fish Tank Port`` .<CR><CR>`5Description:`` Relax and sit by the shore... this pack includes a Fishing Rod, Wiggly Worms for bait, Hand Drill, Nuclear Detonator, and a `#Rare`` Tackle Box which provides you with more free bait every two days, Fish Tanks, and a `#Rare`` Fish Tank Port to put the fish you catch into your fish tank!|0|0|10000|0|||-1|-1||-1|-1||1||||||0|0|"/*"\nadd_button|bountiful_seed_pack|`oBountiful Seed Pack``|interface/large/store_buttons/store_buttons28.rttex|`2You Get:`` 1 Bountiful Seed Pack.<CR><CR>`5Description:`` Contains `$5`` randomly chosen bountiful seeds, including 1 rare seed! Who knows what you'll get?!|0|4|1000|0|||-1|-1||-1|-1||1||||||0|0|"*/"\nadd_button|basic_splice|`oBasic Splicing Kit``|interface/large/store_buttons/store_buttons2.rttex|`2You Get:`` 10 Rock Seeds and 10 Random Seeds of Rarity 2.<CR><CR>`5Description:`` The basic seeds every farmer needs.|0|3|100|0|||-1|-1||-1|-1||1||||||0|0|"/*"\nadd_button|surgical_kit|`oSurgical Kit``|interface/large/store_buttons/store_buttons7.rttex|`2You Get:`` 1 `#Rare Heart Monitor``, 1 Hospital Bed, 1 Train-E Bot, 5 of each of the 13 different Surical Tools and 10 Med-a-Checks.<CR><CR>`5Description:`` Get all the tools you need to become Chief of Surgery at Growtopia General Hospital! `#Rare`` Heart Monitor that lets people know when you are online, Hospital Bed that lets you perform surgery on anybody laying (or standing) on it, Med-a-Checks to identify patients with maladies, The Train-E bot to practice on, and 5 each of the thirteen different Surgical Tools you'll need to do that surgery!|0|2|12000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|star_supplies|`oGalactic Goodies``|interface/large/store_buttons/store_buttons21.rttex|`2You Get:`` 60 Star Tools and 25 Star Fuel.<CR><CR>`5Description:`` Get all the Star Tools you need to boldly go where no Growtopian has gone! Use these to help you command a starship and seek victory in the Galactic Nexus! You'll get 5 each of the 12 Star Tools you'll need to complete missions and some bonus Star Fuel to help power a Starship!|0|0|15000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|fishin_pack|`oFishin' Pack``|interface/large/store_buttons/store_buttons14.rttex|`2You Get:`` 1 Fishing Rod, 5 Wiggly Worms, 1 Hand Drill, 1 Nuclear Detonator,  1 `#Rare Tackle Box``, 10 Fish Tanks and 1 `#Rare Fish Tank Port`` .<CR><CR>`5Description:`` Relax and sit by the shore... this pack includes a Fishing Rod, Wiggly Worms for bait, Hand Drill, Nuclear Detonator, and a `#Rare`` Tackle Box which provides you with more free bait every two days, Fish Tanks, and a `#Rare`` Fish Tank Port to put the fish you catch into your fish tank!|0|0|10000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|fish_training_pack|`oFish Trainin' Pack``|interface/large/store_buttons/store_buttons17.rttex|`2You Get:`` 2 Fish Flakes, 2 Fish Medicine, AND 1 `#Rare Training Port``.<CR><CR>`5Description:`` Get ready to train your favorite fish! Use the Training Port to put a perfect fish into your fish tank for training!|0|7|10000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|fish_flakes|`oFish Flakes``|interface/large/store_buttons/store_buttons18.rttex|`2You Get:`` 5 Fish Flakes.<CR><CR>`5Description:`` Every fish adores these tasty flakes! Give a pinch to your Training Fish and fill their scaly bellies with aquatic goodness! Take the guesswork out of finnicky feedings with a treat you know they'll love!|0|2|7500|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|fish_medicine|`oFish Medicine``|interface/large/store_buttons/store_buttons18.rttex|`2You Get:`` 1 Fish Medicine.<CR><CR>`5Description:`` Make a sick Training Fish bright and healthy with this healing potion. One dose is enough to make even the sickest fish all better!|0|0|1500|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|fish_reviver|`oFish Reviver``|interface/large/store_buttons/store_buttons18.rttex|`2You Get:`` 1 `#Rare Fish Reviver``.<CR><CR>`5Description:`` Resurrect a dead Training Fish with a revivifying zap from this `#Rare`` Fish Reviver! One dose is enough to reach beyond the veil and bring a fish back from the dead! Comes with a 100% zombie-free guarantee!|0|1|5000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|crime_wave|`oCrime Wave``|interface/large/store_buttons/store_buttons12.rttex|`2You Get:`` 5 Random Superpower Cards and 1 `#Rare Crime Wave``.<CR><CR>`5Description:`` Get powered up with random Superpower Cards, and what good would that be without a `#Rare`` Crime Wave to use them on? A Crime Wave is a one-use item that calls four villains to your world for you to battle. `6Beware:`` Villains only stick around for 24 hours once they appear.|0|5|5000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|silkworm|`oSilkworm``|interface/large/store_buttons/store_buttons14.rttex|`2You Get:`` 1 Silk Worm.<CR><CR>`5Description:`` It's the newest cuddly pet from Growtech Pharma! Thanks to genetic engineering, you can now raise your own giant mutant silkworm. They'll eat almost any food, but don't forget to give them water too! And if they get sick, you'll need to have some Antidotes on hand. `6Warning:`` `9Silkworms are living creatures. They will not live forever! Take good care of them, and enjoy them while you can.`` `4Not available any other way``.|0|7|7000|0|||-1|-1||-1|-1||1||||||0|0|"*/"\nadd_button|geiger|`oGeiger Counter``|interface/large/store_buttons/store_buttons12.rttex|`2You Get:`` 1 Geiger Counter.<CR><CR>`5Description:`` With this fantabulous device, you can detect radiation around you. It bleeps red, then yellow, then green as you get closer to the source. Who knows what you might find? `4Not available any other way!``|0|1|25000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|zombie_pack|`oZombie Defense Pack``|interface/large/store_buttons/store_buttons4.rttex|`2You Get:`` 1 `#Rare Sawed-Off Shotgun``, 1 Combat Vest, 1 Zombie Stompin' Boots, 3 Traffic Barricades, 1 Military Radio, 1 Antidote, 3 Toxic Waste Barrels, 3 Biohazard Signs, 3 Tombstones and 1 `#Rare Deadly G-Virus``!.<CR><CR>`5Description:`` The zombie invasion has come! Protect yourself with all the esential zombie fighting gear and best of all, you get an Antidote to cure yourself! Also includes the deadly g-Virus itself to infect your friends with!|0|4|10000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|ssp200|`oSmall Seed Collection Pack``|interface/large/store_buttons/store_buttons35.rttex|`2You Get:`` 200 Small Seed Pack. <CR><CR>`5Description:`` Open each one for 5 randomly chosen seed apiece, including 1 rare seed per pack! Who knows what you'll get?!|1|3|4500|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|arm_guy|`oWaving Inflatable Arm Guy``|interface/large/store_buttons/store_buttons35.rttex|`2You Get:`` Waving Inflatable Arm Guy. <CR><CR>`5Description:`` Great for showing everyone all the amazing things you have to offer! Also just great fun to be around.|1|2|5000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|pegasus_chest|`oPegasus Chest``|interface/large/store_buttons/store_buttons36.rttex|`2You Get:`` 1 Pegasus Chest. <CR><CR>`5Description:`` A chest of feathery delights! What might be inside, my fair feathered friend? Use it on yourself to find out!|1|7|25000|0|||-1|-1||-1|-1||1||||||0|"/*"\nadd_button|zombie_pack|`oZombie Defense Pack``|interface/large/store_buttons/store_buttons4.rttex|`2You Get:`` 1 `#Rare Sawed-Off Shotgun``, 1 Combat Vest, 1 Zombie Stompin' Boots, 3 Traffic Barricades, 1 Military Radio, 1 Antidote, 3 Toxic Waste Barrels, 3 Biohazard Signs, 3 Tombstones and 1 `#Rare Deadly G-Virus``!.<CR><CR>`5Description:`` The zombie invasion has come! Protect yourself with all the esential zombie fighting gear and best of all, you get an Antidote to cure yourself! Also includes the deadly g-Virus itself to infect your friends with!|0|4|10000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|boo_pack|`oB.O.O. Training Pack``|interface/large/store_buttons/store_buttons15.rttex|`2You Get:`` 1 `#Rare Spectral Goggles``, 1 Neutron Gun, 1 Neutron Pack and 10 Ghost Jars <CR><CR>`5Description:`` It looks like Growtopia is under siege by ghosts! Well, the `9Battlers Of the Otherworldly`` are hiring! You'll have to earn your uniform, but this pack includes all the tools you need to actually capture ghosts! Including `#Rare`` Spectral Goggles (all the better to see them with!)and a Neutron Pack to corral the ghosts, of course 10 Ghost Jars to catch them in.|0|4|10000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|ectojuicer|`oEctoJuicer``|interface/large/store_buttons/store_buttons20.rttex|`2You Get:`` 1 EctoJuicer.<CR><CR>`5Description:`` Infuse your muscles with the unearthly might of the Other Side! This spectral potion gives you the strength to wring every last drop of ectoplasm from a defeated Boss Ghost, granting you an EXTRA Boss Goo after a successful banishing!|0|0|30000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|ghost_hunting|`oGhost Hunter's Pack``|interface/large/store_buttons/store_buttons19.rttex|`2You Get:`` At least 5 Ghost Jars and 1 Bonus Item.<CR><CR>`5Description:`` Essentials for Ghost Hunting! Guaranteed to have at least 5x Ghost Jars, plus one or more bonus items! Prizes can include: Neutron Focus Cores, Containment Field Power Nodes, EXTRA Ghost Jars, Ghost Traps, Spirit Boards, and maybe even a Dark Spirit Board!|0|7|10000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|chemsynth|`oChemsynth Pack``|interface/large/store_buttons/store_buttons16.rttex|`2You Get:`` 1 `#Rare Chemsynth Processor``, 10 Chemsynth Tanks and 1 Chemsynth Replicator, 1 Chemsynth Catalyst, 1 Chemsynth Solvent, 1 Chemsynth Centrifuge, 1 Chemsynth Stirrer.<CR><CR>`5Description:`` Tired of the lousy chemicals nature has to offer? Create new synthetic ones! With a `#Rare`` Chemsynth Processor, Chemsynth Tanks, and one each of the five Chemsynth tools, you can be whipping up Synthetic Chemicals in no time. `6Warning:`` Chemsynth solving is a pretty tricky puzzle, and it costs a whole bunch of the five basic chemicals (R, G, B, P, and Y) to complete.|0|4|10000|0|||-1|-1||-1|-1||1|||||"*/"|0|0|\n");
	else if (tab == "tab5") p.Insert("set_description_text|`2Weather Machines!``  Select the item you'd like more info on, or BACK to go back.\nenable_tabs|1\nadd_tab_button|main_menu|Home|interface/large/btn_shop2.rttex||0|0|0|0||||-1|-1|||0|0|\nadd_tab_button|locks_menu|Locks And Stuff|interface/large/btn_shop2.rttex||0|1|0|0||||-1|-1|||0|0|\nadd_tab_button|itempack_menu|Item Packs|interface/large/btn_shop2.rttex||0|3|0|0||||-1|-1|||0|0|\nadd_tab_button|bigitems_menu|Awesome Items|interface/large/btn_shop2.rttex||0|4|0|0||||-1|-1|||0|0|\nadd_tab_button|weather_menu|Weather Machines|interface/large/btn_shop2.rttex|Tired of the same sunny sky?  We offer alternatives within...|1|5|0|0||||-1|-1|||0|0|\nadd_tab_button|token_menu|Growtoken Items|interface/large/btn_shop2.rttex||0|2|0|0||||-1|-1|||0|0|\nadd_button|race_pack|`oRacing Action Pack``|interface/large/store_buttons/store_buttons2.rttex|`2You Get:`` 1 Racing Start Flag, 1 Racing End Flag, 2 Checkpoints, 2 Big Old Sideways Arrows, 1 Big Old Up Arrow, 1 Big Old Down Arrow, 1 WristBand, 1 HeadBand, 1 Sports Ball Jersey and 1 Air Robinsons.<CR><CR>`5Description:`` Get all you need to host races in your worlds! You'll win the races too, with new Air Robinsons that make you run faster!|0|7|1250|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|music_pack|`oComposer's Pack``|interface/large/store_buttons/store_buttons3.rttex|`2You Get:`` 20 Sheet Music: Blank, 20 Sheet Music: Piano Note, 20 Sheet Music: Bass Note, 20 Sheet Music Drums, 5 Sheet Music: Sharp Piano, 5 Sheet Music: Flat Piano, 5 Sheet Music: Flat Bass and 5 Sheet Music: Sharp Bass .<CR><CR>`5Description:`` With these handy blocks, you'll be able to compose your own music, using your World-Locked world as a sheet of music. Requires a World Lock (sold separately!).|0|0|2500|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|school_pack|`oEducation Pack``|interface/large/store_buttons/store_buttons4.rttex|`2You Get:`` 10 ChalkBoards, 3 School Desks, 20 Red Bricks, 1 Bulletin Board, 10 Pencils, 1 Growtopia Lunchbox, 1 Grey Hair Bun, 1 Apple and 1 Random School Uniform Item.<CR><CR>`5Description:`` If you want to build a school in Growtopia, here's what you need!|0|0|2500|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|dungeon_pack|`oDungeon Pack``|interface/large/store_buttons/store_buttons4.rttex|`2You Get:`` 20 Grimstone, 20 Blackrock Wall, 20 Iron Bars, 3 Jail Doors, 3 Skeletons, 1 Headsman's Axe, 1 Worthless Rags. 5 Torches and a `#Rare Iron Mask!``.<CR><CR>`5Description:`` Lock up your enemies in a dank dungeon! Of course they can still leave whenever they want. But they won't want to, because it looks so cool! Iron Mask muffles your speech!|0|1|5000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|fantasy_pack|`oFantasy Pack``|interface/large/store_buttons/store_buttons3.rttex|`2You Get:`` 1 Mystical Wizard Hat Seed, 1 Wizards Robe, 1 Golden Sword, 1 Elvish Longbow, 10 Barrels, 3 Tavern Signs, 3 Treasure Chests and 3 Dragon Gates.<CR><CR>`5Description:`` Hear ye, hear ye! It's a pack of magical wonders!|0|6|2500|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|vegas_pack|`oVegas Pack``|interface/large/store_buttons/store_buttons4.rttex|`2You Get:`` 10 Neon Lights, 1 Card Block Seed, 1 `#Rare Pink Cadillac`` 4 Flipping Coins, 1 Dice Block, 1 Gamblers Visor, 1 Slot Machine, 1 Roulette Wheel and 1 Showgirl Hat, 1 Showgirl top and 1 Showgirl Leggins.<CR><CR>`5Description:`` What happens in Growtopia stays in Growtopia!|0|5|10000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|farm_pack|`oFarm Pack``|interface/large/store_buttons/store_buttons5.rttex|`2You Get:`` 1 Cow, 1 Chicken, 10 Wheat, 10 Barn Block, 10 Red Wood Walls, 1 Barn Door, 1 Straw Hat, 1 Overalls, 1 Pitchfork, 1 Farmgirl Hair, 1 `#Rare`` `2Dear John Tractor``.<CR><CR>`5Description:`` Put the `2Grow`` in Growtopia with this pack, including a Cow you can milk, a Chicken that lays eggs and a farmer's outfit. Best of all? You get a `#Rare`` `2Dear John Tractor`` you can ride that will mow down trees!|0|0|15000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|science_pack|`oMad Science Kit``|interface/large/store_buttons/store_buttons5.rttex|`2You Get:`` 1 Science Station, 1 Laboratory, 1 LabCoat, 1 Combover Hair, 1 Goggles, 5 Chemical R, 10 Chemical G, 5 Chemical Y, 5 Chemical B, 5 Chemical P and 1 `#Rare`` `2Death Ray``.<CR><CR>`5Description:`` It's SCIENCE! Defy the natural order with a Science Station that produces chemicals, a Laboratory in which to mix them and a full outfit to do so safely! You'll also get a starter pack of assorted chemicals. Mix them up! Special bonus: A `#Rare`` `2Death Ray`` to make your science truly mad!|0|3|2500|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|city_pack|`oCity Pack``|interface/large/store_buttons/store_buttons6.rttex|`2You Get:`` 10 Sidewalks, 3 Street Signs, 3 Streetlamps, 10 Gothic Building tiles, 10 Tenement Building tiles, 10 Fire Escapes, 3 Gargoyles, 10 Hedges, 1 Blue Mailbox, 1 Fire Hydrant and A `#Rare`` `2ATM Machine``.<CR><CR>`5Description:`` Life in the big city is rough but a `#Rare`` `2ATM Machine`` that dishes out gems once a day is very nice!|0|0|8000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|west_pack|`oWild West Pack``|interface/large/store_buttons/store_buttons6.rttex|`2You Get:`` 1 Cowboy Hat, 1 Cowboy Boots, 1 War Paint, 1 Face Bandana, 1 Sheriff Vest, 1 Layer Cake Dress,  1 Corset, 1 Kansas Curls, 10 Western Building 1 Saloon Doors, 5 Western Banners, 1 Buffalo, 10 Rustic Fences, 1 Campfire and 1 Parasol.<CR><CR>`5Description:`` Yippee-kai-yay! This pack includes everything you need to have wild time in the wild west! The Campfire plays cowboy music, and the `#Parasol`` lets you drift down slowly. Special bonus: A `#Rare`` `2Six Shooter`` to blast criminals with!|0|2|4000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|astro_pack|`oAstro Pack``|interface/large/store_buttons/store_buttons6.rttex|`2You Get:`` 1 Astronaut Helmet, 1 Space Suit, 1 Space Pants, 1 Moon Boots, 1 Rocket Thruster, 1 Solar Panel, 6 Space Connectors, 1 Porthole, 1 Compu Panel, 1 Forcefield and 1 `#Rare`` `2Zorbnik DNA``.<CR><CR>`5Description:`` Boldly go where no Growtopian has gone before with an entire Astronaut outfit. As a special bonus, you can have this `#Rare`` `2Zorbnik DNA`` we found on a distant planet. It doesn't do anything by itself, but by trading with your friends, you can collect 10 of them, and then... well, who knows?|0|6|2500|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|prehistoric_pack|`oPrehistoric Pack``|interface/large/store_buttons/store_buttons8.rttex|`2You Get:`` 1 Caveman Club, 1 Cave Woman Hair, 1 Caveman Hair, 1 Sabertooth Toga, 1 Fuzzy Bikini Top, 1 Fuzzy Bikni Bottom, 1 Cavewoman Outfit, 10 Cliffside, 5 Rock Platforms, 1 Cave Entrance, 3 Prehistoric Palms and 1 `#Rare Sabertooth Growtopian``.<CR><CR>`5Description:`` Travel way back in time with this pack, including full Caveman and Cavewoman outfits and `#Rare Sabertooth Growtopian`` (that's a mask of sorts). Unleash your inner monster!|0|0|2500|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|shop_pack|`oShop Pack``|interface/large/store_buttons/store_buttons8.rttex|`2You Get:`` 4 Display Boxes, 1 For Sale Sign, 1 Gem Sign, 1 Exclamation Sign, 1 Shop Sign, 1 Open Sign, 1 Cash Register, 1 Mannequin and 1 Security Camera.<CR><CR>`5Description:`` Run a fancy shop with these new items! Advertise your wares with an Open/Closed Sign you can switch with a punch, a Cash Register, a Mannequin you can dress up to show off clothing, and a `#Rare`` Security Camera, which reports when people enter and take items!|0|7|5000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|home_pack|`oHome Pack``|interface/large/store_buttons/store_buttons9.rttex|`2You Get:`` 1 Television, 4 Couches, 2 Curtains, 1 Wall Clock, 1 Microwave, 1 Meaty Apron, 1 Ducky Pants, 1 Ducky top and 1 Eggs Benedict.<CR><CR>`5Description:`` Welcome home to Growtopia! Decorate with a Television, Window Curtains, Couches, a `#Rare`` Wall Clock that actually tells time, and a Microwave to cook in. Then dress up in a Meaty Apron and Ducky Pajamas to sit down and eat Eggs Benedict, which increases the amount of XP you earn!|0|6|2500|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|cinema_pack|`oCinema Pack``|interface/large/store_buttons/store_buttons10.rttex|`2You Get:`` 1 Clapboard, 1 Black Beret, 1 3D Glasses, 6 Theater Curtains, 6 Marquee Blocks, 1 Director's Chair, 4 Theater Seats, 6 Movie Screens, 1 Movie Camera and 1 `#Rare GHX Speaker``.<CR><CR>`5Description:`` It's movie time! Everything you need for the big screen experience including a `#Rare GHX Speaker`` that plays the score from Growtopia: The Movie.|0|2|3000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|adventure_pack|`oAdventure Pack``|interface/large/store_buttons/store_buttons10.rttex|`2You Get:`` 4 Gateways to Adventure, 4 Path Markers, 1 Lazy Cobra, 1 Adventure Brazier, 4 Adventure Barriers, 1 Rope, 1 Torch, 1 Key, 1 Golden Idol, 1 `#Rare Adventuring Mustache``, 1 Explorer's Ponytail and 1 Sling Bag .<CR><CR>`5Description:`` Join Dr. Exploro and her father (also technically Dr. Exploro) as they seek out adventure! You can make your own adventure maps with the tools in this pack.|0|7|10000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|rockin_pack|`oRockin' Pack``|interface/large/store_buttons/store_buttons11.rttex|`2You Get:`` 3 `#Rare Musical Instruments`` Including A Keytar, a Bass Guitar and Tambourine, 1 Starchild Make Up, 1 Rockin' Headband, 1 Leopard Leggings, 1 Shredded Ts-Shirt, 1 Drumkit, 6 Stage Supports, 6 Mega Rock Speakers and 6 Rock n' Roll Wallpaper.<CR><CR>`5Description:`` ROCK N' ROLL!!! Play live music in-game! We Formed a Band! Growtopia makes me want to rock out.|0|0|4999|0|||-1|-1||-1|-1||1||||||0|0|"/*"\nadd_button|game_pack|`oGame Pack``|interface/large/store_buttons/store_buttons10.rttex|`2You Get:`` 1 `#Rare Game Generator``,  4 Game Blocks, 4 Game Flags, 4 Game Graves and 4 Game Goals.<CR><CR>`5Description:`` Growtopia's not all trading and socializing! Create games for your friends with the Game Pack (and a lot of elbow grease).|0|6|50000|0|||-1|-1||-1|-1||1||||||0|0|"*/"\nadd_button|superhero|`oSuperhero Pack``|interface/large/store_buttons/store_buttons12.rttex|`2You Get:`` 1 Mask, 1 Shirt, 1 Boots, 1 Tights, 1 Cape, `#Rare Super Logos`` or `#Rare Utility Belt`` and 1 `2Phone Booth``.<CR><CR>`5Description:`` Battle the criminal element in Growtopia with a complete random superhero outfit including a cape that lets you double jump. Each of these items comes in one of six random colors. You also get one of 5 `#Rare`` Super Logos, which automatically match the color of any shirt you wear or a `#Rare`` Utility Belt... of course use the `2Phone Booth`` to change into your secret identity!|0|0|5000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|fashion_pack|`oFashion Pack``|interface/large/store_buttons/store_buttons13.rttex|`2You Get:`` 3 Random Clothing Items, 3 Jade Blocks and 1 `#Rare Spotlight``.<CR><CR>`5Description:`` The hottest new looks for the season are here now with 3 random Fashion Clothing (dress, shoes, or purse), Jade Blocks to pose on, and a `#Rare`` Spotlight to shine on your fabulousness.|0|0|3000|0|||-1|-1||-1|-1||1||||||0|0|"/*"\nadd_button|sportsball_pack|`oSportsball Pack``|interface/large/store_buttons/store_buttons13.rttex|`2You Get:`` 2 Basketball Hoops, 2 Sporty Goals, 5 Stadiums, 5 Crowded Stadiums, 10 Field Grass, 1 Football Helmet, 1 Growies Cap, 1 Ref's Jersey, 1 World Cup Jersey, 1 `#Rare Sports Item`` or `#Rare Growmoji!``.<CR><CR>`5Description:`` We like sports and we don't care who knows! This pack includes everything you need to get sporty! Use the Sports Items to launch Sportsballs at each other.|0|1|10000|0|||-1|-1||-1|-1||1||||||0|0|"*/"\nadd_button|firefighter|`oFirefighter Pack``|interface/large/store_buttons/store_buttons14.rttex|`2You Get:`` 1 Yellow Helmet, 1 Yellow Jacket, 1 Yellow Pants, 1 Firemans Boots, 1 Fire Hose, and 1 `#Rare Firehouse`` .<CR><CR>`5Description:`` Rescue Growtopians from the fire! Includes a full Yellow Firefighter Outfit, Fire Hose and a `#Rare Firehouse``, which will protect your own world from fires.|0|1|5000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|steampack|`oSteampack``|interface/large/store_buttons/store_buttons14.rttex|`2You Get:`` 10 Steam Tubes, 2 Steam Stompers, 2 Steam Organs, 2 Steam Vents, 2 Steam Valves and 1 `#Rare Steampunk Top Hat``.<CR><CR>`5Description:`` Steam! It's a wondrous new technology that lets you create paths of Steam Blocks, then jump on a Steam Stomper to launch a jet of steam through the path, triggering steam-powered devices. Build puzzles, songs, parkour challenges, and more!|0|6|10000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|paintbrush|`oPainter's Pack``|interface/large/store_buttons/store_buttons15.rttex|`2You Get:`` 1 `#Rare Paintbrush`` and 20 Random Colored Paint Buckets.<CR><CR>`5Description:`` Want to paint your world? This pack includes 20 buckets of random paint colors (may include Varnish, to clean up your messes)! You can paint any block in your world different colors to personalize it.|0|1|15000|0|||-1|-1||-1|-1||1||||||0|0|"/*"\nadd_button|paleo_kit|`oPaleontologist's Kit``|interface/large/store_buttons/store_buttons16.rttex|`2You Get:`` 5 Fossil Brushes, 1 Rock Hammer, 1 Rock Chisel, 1 Blue Hardhat and 1 `#Rare Fossil Prep Station``.<CR><CR>`5Description:`` If you want to dig up fossils, this is the kit for you! Includes everything you need! Use the prepstation to get your fossils ready for display.|0|0|10000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|robot_starter_pack|`oCyBlocks Starter Pack``|interface/large/store_buttons/store_buttons18.rttex|`2You Get:`` 1 `5Rare ShockBot`` and 10 random movement commands.<CR><CR>`5Description:`` CyBlocks Starter Pack includes one `5Rare`` ShockBot and 10 random movement commands to use with it. `5ShockBot`` is a perma-item, is never lost when destroyed.|0|6|2500|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|robot_command_pack|`oCyBlocks Command Pack``|interface/large/store_buttons/store_buttons19.rttex|`2You Get:`` 10 Random CyBlock Commands.<CR><CR>`5Description:`` Grants 10 random CyBlock Commands to help control your CyBots!|0|2|1000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|robot_pack|`oCyBot Pack``|interface/large/store_buttons/store_buttons19.rttex|`2You Get:`` 1 `5Rare CyBot``!<CR><CR>`5Description:`` Grants one random `5Rare`` CyBot! Use CyBlock Commands to send these mechanical monsters into action! `5Note: Each CyBot is a perma-item, and will never be lost when destroyed.``|0|3|7500|0|||-1|-1||-1|-1||1||||||0|0|"*/"\nadd_button|gang_pack|`oGangland Style``|interface/large/store_buttons/store_buttons2.rttex|`2You Get:`` 1 Fedora, 1 Dames Fedora, 1 Pinstripe Suit with Pants, 1 Flapper Headband with Dress, 1 Cigar, 1 Tommy Gun, 1 Victola and 10 Art Deco Blocks .<CR><CR>`5Description:`` Step into the 1920's with a Complete Outfit, a Tommygun, a Victrola that plays jazz music, and 10 Art Deco Blocks. It's the whole package!|0|6|2500|0|||-1|-1||-1|-1||1||||||0|0|\n|0|0|\n");
	else if (tab == "tab6") p.Insert("set_description_text|`2Spend your Growtokens!`` (You have `50``) You earn Growtokens from Crazy Jim and Sales-Man. Select the item you'd like more info on, or BACK to go back.\nenable_tabs|1\nadd_tab_button|main_menu|Home|interface/large/btn_shop2.rttex||0|0|0|0||||-1|-1|||0|0|\nadd_tab_button|locks_menu|Locks And Stuff|interface/large/btn_shop2.rttex||0|1|0|0||||-1|-1|||0|0|\nadd_tab_button|itempack_menu|Item Packs|interface/large/btn_shop2.rttex||0|3|0|0||||-1|-1|||0|0|\nadd_tab_button|bigitems_menu|Awesome Items|interface/large/btn_shop2.rttex||0|4|0|0||||-1|-1|||0|0|\nadd_tab_button|weather_menu|Weather Machines|interface/large/btn_shop2.rttex|Tired of the same sunny sky?  We offer alternatives within...|0|5|0|0||||-1|-1|||0|0|\nadd_tab_button|token_menu|Growtoken Items|interface/large/btn_shop2.rttex||1|2|0|0||||-1|-1|||0|0|"/*"\nadd_button|challenge_timer|`oChallenge Timer``|interface/large/store_buttons/store_buttons15.rttex|`2You Get:`` 1 Challenge Timer.<CR><CR>`5Description:`` Get more people playing your parkours with this secure prize system. You'll need a `#Challenge Start Flag`` and `#Challenge End Flag`` as well (not included). Stock prizes into the Challenge Timer, set a time limit, and watch as players race from start to end. If they make it in time, they win a prize!|0|5|-2|0|||-1|-1||-1|-1||1||||||0|0|"*/"\nadd_button|xp_potion|`oExperience Potion``|interface/large/store_buttons/store_buttons9.rttex|`2You Get:`` 1 Experience Potion.<CR><CR>`5Description:`` This `#Untradeable`` delicious fizzy drink will make you smarter! 10,000 XP smarter instantly, to be exact.|0|2|-5|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|megaphone|`oMegaphone``|interface/large/store_buttons/store_buttons15.rttex|`2You Get:`` 1 Megaphone.<CR><CR>`5Description:`` You like broadcasting messages, but you're not so big on spending gems? Buy a Megaphone with Growtokens! Each Megaphone can be used once to send a super broadcast to all players in the game.|0|7|-1|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|i_love_dirt_shirt|`oI love Dirt Shirt``|interface/large/store_buttons/store_buttons37.rttex|`2You Get:`` 1 I love Dirt Shirt.<CR><CR>`5Description:`` Some people like things to be clean, you're not one of them are you? This item is `#Untradeable``.|4|0|-5|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|growmoji_pack|`oGrowmoji Mystery Box``|interface/large/store_buttons/store_buttons19.rttex|`2You Get:`` 1 Growmoji.<CR><CR>`5Description:`` Express yourself! This mysterious box contains one of five fun growmojis you can use to spice up your chat! Which will you get?|0|1|-7|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|mini_mod|`oMini-Mod``|interface/large/store_buttons/store_buttons17.rttex|`2You Get:`` 1 Mini-Mod.<CR><CR>`5Description:`` Oh no, it's a Mini-Mod! Punch him to activate (you'll want to punch him!). When activated, he won't allow anyone to drop items in your world.|0|0|-10|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|derpy_star|`oDerpy Star Block``|interface/large/store_buttons/store_buttons10.rttex|`2You Get:`` 1 Derpy Star Block.<CR><CR>`5Description:`` DER IM A SUPERSTAR. This is a fairly ordinary block, except for the derpy star on it. Note: it is not permanent, and it doesn't drop seeds. So use it wisely!|0|3|-15|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|2218|`oMighty Snow Rod``|interface/large/store_buttons/store_buttons12.rttex|`2You Get:`` 1 Mighty Snow Rod.<CR><CR>`5Description:`` Become the living embodiment of the winter with this deadly weapon! It blasts bricks with frost, smashing them more easily than a punch. Buy it today, before WinterFest ends and you can't get it for another year! Sponsored by iiStyloMilo, Bambam46, and MartinMan007's Subscribers.|0|4|-15|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|dirt_gun|`oBLYoshi's Free Dirt``|interface/large/store_buttons/store_buttons13.rttex|`2You Get:`` 1 BLYoshi's Free Dirt.<CR><CR>`5Description:`` \"Free\" might be stretching it, but hey, once you buy this deadly rifle, you can spew out all the dirt you want for free! Note: the dirt is launched at high velocity and explodes on impact. Sponsored by BLYoshi.|0|4|-20|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|nothingness|`oWeather Machine - Nothingness``|interface/large/store_buttons/store_buttons9.rttex|`2You Get:`` 1 Weather Machine - Nothingness.<CR><CR>`5Description:`` Tired of all that fancy weather?  This machine will turn your world completely black. Yup, that's it. Not a single pixel in the background except pure blackness.|0|3|-25|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|spike_juice|`oSpike Juice``|interface/large/store_buttons/store_buttons10.rttex|`2You Get:`` 1 Spike Juice.<CR><CR>`5Description:`` It's fresh squeezed, with little bits of spikes still in it! Drinking this `#Untradeable`` one-use potion will make you immune to Death Spikes and Lava for 5 seconds.|0|5|-30|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|doodad|`oDoodad``|interface/large/store_buttons/store_buttons9.rttex|`2You Get:`` 1 Doodad.<CR><CR>`5Description:`` I have no idea what this thing does. It's something electronic? Maybe?|0|5|-37|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|crystal_cape|`oCrystal Cape``|interface/large/store_buttons/store_buttons11.rttex|`2You Get:`` 1 Crystal Cape.<CR><CR>`5Description:`` This cape is woven of pure crystal, which makes it pretty uncomfortable. But it also makes it magical! It lets you double-jump off of an imaginary Crystal Block in mid-air. Sponsored by Edvoid20, HemeTems, and Aboge.|0|5|-45|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|focused_eyes|`oFocused Eyes``|interface/large/store_buttons/store_buttons9.rttex|`2You Get:`` 1 Focused Eyes.<CR><CR>`5Description:`` This `#Untradeable`` item lets you shoot electricity from your eyes! Wear them with pride, and creepiness.|0|4|-50|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|grip_tape|`oGrip Tape``|interface/large/store_buttons/store_buttons14.rttex|`2You Get:`` 1 Grip Tape.<CR><CR>`5Description:`` This is handy for wrapping around the handle of a weapon or tool. It can improve your grip, as well as protect you from cold metal handles. If you aren't planning to craft a weapon that requires Grip Tape, this does you no good at all!|0|5|-50|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|cat_eyes|`oCat Eyes``|interface/large/store_buttons/store_buttons23.rttex|`2You Get:`` 1 Cat Eyes.<CR><CR>`5Description:`` Wow, pawesome! These new eyes are the cat's meow, and the purrfect addition to any style.|0|5|-50|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|riding_cloud|`oRiding Cloud``|interface/large/store_buttons/store_buttons37.rttex|`2You Get:`` 1 Riding Cloud.<CR><CR>`5Description:`` Bringing the sky to the ground! This item is `#Untradeable``.|3|1|-50|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|grow_boy|`oGrowBoy``|interface/large/store_buttons/store_buttons32.rttex|`2You Get:`` 1 Growboy.<CR><CR>`5Description:`` Bask in the nostalgic green screened goodness of the Growboy! A portable gaming device that packs a punch. Now you're playing with GrowPower! Note: The Growboy is `#UNTRADEABLE``.|0|2|-50|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|night_vision|`oNight Vision Goggles``|interface/large/store_buttons/store_buttons15.rttex|`2You Get:`` 1 Night Vision Goggles.<CR><CR>`5Description:`` Scared of the dark? We have a solution. You can wear these goggles just to look cool, but if you also happen to have a D Battery (`4batteries not included``) on you, you will be able to see through darkness like it's not even there! Each D Battery can power your goggles for 1 minute. `2If you are in a world you own, the goggles will not require batteries!`` Note: you can't turn the goggles off without removing them, so you'll be wasting your battery if you wear them in daylight while carrying D Batteries.|0|3|-55|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|muddy_pants|`oMuddy Pants``|interface/large/store_buttons/store_buttons12.rttex|`2You Get:`` 1 Muddy Pants.<CR><CR>`5Description:`` Well, this is just a pair of muddy pants. But it does come with a super secret bonus surprise that is sure to blow your mind!|0|7|-62|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|piranha|`oCuddly Piranha``|interface/large/store_buttons/store_buttons10.rttex|`2You Get:`` 1 Cuddly Piranha.<CR><CR>`5Description:`` This friendly pet piranha won't stay in its bowl!  It just wants to snuggle with your face!|0|0|-75|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|tsed|`oTactical Stealth Espionage Device``|interface/large/store_buttons/store_buttons32.rttex|`2You Get:`` 1 Tactical Stealth Espionage Device.<CR><CR>`5Description:`` This is Growtech's latest innovation on tactical espionage! Using the latest in scientific breakthroughs this device allows you to seamlessly disguise yourself as... a cardboard box! Note: The Tactical Stealth Espionage Device is `#UNTRADEABLE``.|0|1|-75|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|puddy_leash|`oPuddy Leash``|interface/large/store_buttons/store_buttons11.rttex|`2You Get:`` 1 Puddy Leash.<CR><CR>`5Description:`` Puddy is a friendly little kitten who will follow you around forever.|0|7|-90|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|anime_action_hair|`oAnime Action Hair``|interface/large/store_buttons/store_buttons37.rttex|`2You Get:`` 1 Anime Action Hair.<CR><CR>`5Description:`` Lights, camera, ANIME ACTION HAIR! Feel the power from root to tip every time you punch! This item is `#Untradeable``.|4|1|-100|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|golden_axe|`oGolden Pickaxe``|interface/large/store_buttons/store_buttons9.rttex|`2You Get:`` 1 Golden Pickaxe.<CR><CR>`5Description:`` Get your own sparkly pickaxe! This `#Untradeable`` item is a status symbol! Oh sure, it isn't any more effective than a normal pickaxe, but it sparkles!|0|1|-100|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|puppy_leash|`oPuppy Leash``|interface/large/store_buttons/store_buttons11.rttex|`2You Get:`` 1 Puppy Leash.<CR><CR>`5Description:`` Get your own pet puppy! This little dog will follow you around forever, never wavering in her loyalty, thus making her `#Untradeable``.|0|4|-100|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|diggers_spade|`oDigger's Spade``|interface/large/store_buttons/store_buttons13.rttex|`2You Get:`` 1 Digger's Spade.<CR><CR>`5Description:`` This may appear to be a humble shovel, but in fact it is enchanted with the greatest magic in Growtopia. It can smash Dirt or Cave Background in a single hit! Unfortunately, it's worthless at digging through anything else. Note: The spade is `#UNTRADEABLE``.|0|7|-100|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|meow_ears|`oMeow Ears``|interface/large/store_buttons/store_buttons22.rttex|`2You Get:`` 1 Meow Ears.<CR><CR>`5Description:`` Meow's super special ears that everyone can now get! Note: These ears are `#UNTRADEABLE``.|0|0|-100|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|frosty_hair|`oFrosty Hair``|interface/large/store_buttons/store_buttons23.rttex|`2You Get:`` 1 Frosty Hair.<CR><CR>`5Description:`` Coldplay is cold, but you can be freezing! Note: The frosty hair is `#UNTRADEABLE``.|0|0|-100|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|zerkon_helmet|`oEvil Space Helmet``|interface/large/store_buttons/store_buttons21.rttex|`2You Get:`` 1 Evil Space Helmet.<CR><CR>`5Description:`` Zerkon commands a starship too small to actually board - pah, time to rule the galaxy properly! Note: The evil space helmet is `#UNTRADEABLE``.|0|6|-100|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|seils_magic_orb|`oSeil's Magic Orbs``|interface/large/store_buttons/store_buttons21.rttex|`2You Get:`` 1 Seil's Magic Orbs.<CR><CR>`5Description:`` Seil is some kind of evil wizard, now you can be too! Note: These magic orbs are `#UNTRADEABLE``.|0|7|-100|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|atomic_shadow_scythe|`oAtomic Shadow Scythe``|interface/large/store_buttons/store_buttons21.rttex|`2You Get:`` 1 Atomic Shadow Scythe.<CR><CR>`5Description:`` AtomicShadow might actually be evil, now you can try it out! Note: The shadow scythe is `#UNTRADEABLE``.|0|5|-100|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|poseidon_diggers_trident|`oPoseidon's Digger's Trident``|interface/large/store_buttons/store_buttons25.rttex|`2You Get:`` 1 Poseidon's Digger's Trident.<CR><CR>`5Description:`` A gift from the gods. This may appear to be a humble trident, but in fact it has the power of Poseidon himself. It can smash `8Deep Sand`` or `8Ocean Rock`` in a single hit. Unfortunately, you don't get to wield the full might of Poseidon... the trident is worthless at smashing anything else. Note: The trident is `#UNTRADEABLE``.|0|6|-100|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|really_dangerous_pet_llama|`oReally Dangerous Pet Llama``|interface/large/store_buttons/store_buttons32.rttex|`2You Get:`` 1 Really Dangerous Pet Llama.<CR><CR>`5Description:`` This Llama is ready for anything Growtopia throws at it! Armed with a silo of Growtech Missiles, experimental Growtech hardened steel armor and a rather snazzy helmet (Llama's own) this Llama is Dangerous with a capital D! Note: This Really Dangerous Pet Llama is `#UNTRADEABLE``.|0|0|-100|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|leopard_shawl|`oSnow Leopard Shawl``|interface/large/store_buttons/store_buttons34.rttex|`2You Get:`` 1 Snow Leopard Shawl.<CR><CR>`5Description:`` Made of the finest Faux Snow Leopard Fur. This Shawl is infused with the spirit of a mighty Snow Leopard!|1|4|-100|0|||-1|-1||-1|-1||1||||||0|0|\n|0|0|\n");
	p.CreatePacket(peer);
}

void world_menu(ENetPeer* peer) {
	long long time_now = time(nullptr);
	if (last_active_update - time_now <= 0 or active_worlds.size() == 0) {
		if (worlds.size() > 0) {
			last_active_update = time_now + 60; // 60 tai 1min
			active_worlds.clear();
			active_worlds.push_back("LOCKETOWN");
			for (int i_ = 0; i_ < 16; i_++) {
				World world_ = worlds[rand() % worlds.size()];
				if (world_.nuked or not check_name(world_.name)) continue;
				if (find(active_worlds.begin(), active_worlds.end(), world_.name) == active_worlds.end()) active_worlds.push_back(world_.name);
			}
		}
	}
	string recently_visited = "", c_active_worlds = "";
	for (auto it = pInfo(peer)->last_visited_worlds.rbegin(); it != pInfo(peer)->last_visited_worlds.rend(); ++it) recently_visited += "\nadd_floater|" + *it + "||0.5|3417414143";
	for (int i_ = 0; i_ < active_worlds.size(); i_++) {
		string name_ = active_worlds[i_];
		vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
		if (p != worlds.end()) {
			World* world_ = &worlds[p - worlds.begin()];
			if (find(world_->active_jammers.begin(), world_->active_jammers.end(), 226) == world_->active_jammers.end()) {
				c_active_worlds += "\nadd_floater|" + active_worlds[i_] + "|0|0.5|3529161471";
			}
		}
	}
	if (c_active_worlds.empty()) c_active_worlds = "\nadd_floater|START|0|0.5|3529161471|\nadd_floater|PROMOTE|0|0.5|3529161471";
	c_active_worlds += pInfo(peer)->worlds_owned.size() != 0 ? "\nadd_heading|My Worlds<CR>|" : "";
	for (int w_ = 0; w_ < pInfo(peer)->worlds_owned.size(); w_++) c_active_worlds += "\nadd_floater|" + pInfo(peer)->worlds_owned[w_] + "|0|0.5|2147418367";
	int w_c = 0, s_c = 0, net_ = 0, r_c = 0;
	get_players(pInfo(peer)->world, w_c, s_c, net_, r_c);
	gamepacket_t p;
	p.Insert("OnRequestWorldSelectMenu"), p.Insert("add_filter|\nadd_heading|Top Worlds|\nadd_floater|wotd_world|GrowtopiaMY|0|0.5|2147418367|" + c_active_worlds + "" + (recently_visited != "" ? "\nadd_heading|Recently Visited Worlds<CR>|" + recently_visited + "" : "") + "\n"), p.CreatePacket(peer);
	gamepacket_t p5;
	p5.Insert("OnConsoleMessage"), p5.Insert("Where would you like to go? (`w" + setGems(s_c) + "`` online)"), p5.CreatePacket(peer);
}

string cleanup_(string strText) {
	string temp = "";
	for (int i = 0; i < strText.size(); ++i) {
		if ((strText[i] >= 'a' && strText[i] <= 'z') || (strText[i] >= 'A' && strText[i] <= 'Z')) {
			temp = temp + strText[i];
		}
		else {
			temp = temp + " ";
		}
	}
	return temp;
}
bool has_playmod(Player* p_, string name_) {
	name_ = replace_str2(cleanup_(to_lower(name_)), " ", "_");
	vector<string> player_playmods{};
	player_playmods.push_back(items[p_->hair].playmod);
	player_playmods.push_back(items[p_->shirt].playmod);
	player_playmods.push_back(items[p_->pants].playmod);
	player_playmods.push_back(items[p_->feet].playmod);
	player_playmods.push_back(items[p_->face].playmod);
	player_playmods.push_back(items[p_->hand].playmod);
	player_playmods.push_back(items[p_->back].playmod);
	player_playmods.push_back(items[p_->mask].playmod);
	player_playmods.push_back(items[p_->necklace].playmod);
	player_playmods.push_back(items[p_->ances].playmod);
	if (p_->ghost) player_playmods.push_back("Ghost in the Shell");
	if (p_->b_s != 0) player_playmods.push_back("Duct Tape");
	for (int i_ = 0; i_ < player_playmods.size(); i_++) {
		if (player_playmods[i_].empty()) continue;
		string playmod = replace_str2(cleanup_(to_lower(player_playmods[i_])), " ", "_");
		if (playmod.find(name_) != string::npos)
			return true;
	} for (PlayMods peer_playmod : p_->playmods) {
		for (vector<string> get_ : info_about_playmods) {
			uint32_t playmod_id = atoi(get_[0].c_str());
			if (playmod_id == peer_playmod.id) {
				string playmod_name = replace_str2(cleanup_(to_lower(get_[2])), " ", "_");
				if (playmod_name.find(name_) != string::npos) {
					return true;
				}
			}
		}
	}
	return false;
}
int form_state(Player* p_) {
	int state_ = 0;
	state_ |= has_playmod(p_, "Ghost in the Shell") << 0;
	state_ |= has_playmod(p_, "double jump") << 1;
	state_ |= has_playmod(p_, "Spirit Form") << 1;
	state_ |= has_playmod(p_, "hoveration!") << 1;
	state_ |= has_playmod(p_, "aurora") << 1;
	state_ |= has_playmod(p_, "The One Ring") << 2;
	state_ |= has_playmod(p_, "Mark of Growganoth") << 4;
	state_ |= has_playmod(p_, "Halo!") << 7;
	state_ |= has_playmod(p_, "Cursed") << 12;
	state_ |= has_playmod(p_, "duct tape") << 13;
	state_ |= has_playmod(p_, "Lucky") << 15;
	state_ |= has_playmod(p_, "Irradiated") << 19;
	state_ |= p_->spotlight << 20;
	state_ |= p_->hs << 24;

	if (has_playmod(p_, "Lupus")) p_->surgery_type = 28;
	if (has_playmod(p_, "Moldy Guts")) p_->surgery_type = 25;
	if (has_playmod(p_, "Ecto-Bones")) p_->surgery_type = 24;
	if (has_playmod(p_, "Chaos Infection")) p_->surgery_type = 27;
	if (has_playmod(p_, "Fatty Liver")) p_->surgery_type = 26;
	if (has_playmod(p_, "Brainworms")) p_->surgery_type = 23;
	if (has_playmod(p_, "Antidote!")) {
		for (int i_ = 0; i_ < p_->playmods.size(); i_++) {
			if (p_->playmods[i_].id == 41 || p_->playmods[i_].id == 49 || p_->playmods[i_].id == 48 || p_->playmods[i_].id == 71 || p_->playmods[i_].id == 72 || p_->playmods[i_].id == 73 || p_->playmods[i_].id == 4 || p_->playmods[i_].id == 16 || p_->playmods[i_].id == 17 || p_->playmods[i_].id == 19 || p_->playmods[i_].id == 27 || p_->playmods[i_].id == 42) p_->playmods[i_].time = 1;
		}
	}
	for (PlayMods peer_playmod : p_->playmods) {
		for (vector<string> get_ : info_about_playmods) {
			uint32_t playmod_id = atoi(get_[0].c_str());
			if (playmod_id == peer_playmod.id) {
				string playmod_name = get_[2];
				if (not get_[6].empty()) {
					uint32_t special_id = atoi(get_[6].c_str());
					if (special_id != 0) {
						state_ |= true << special_id;
					}
				}
				break;
			}
		}
	}
	return state_;
}
string process_till(std::string const& s)
{
	std::string::size_type pos = s.find('/');
	if (pos != std::string::npos)
	{
		return s.substr(0, pos);
	}
	else
	{
		return s;
	}
}
void update_clothes(ENetPeer* peer) {
	if (pInfo(peer)->world == "") return;
	gamepacket_t p(0, pInfo(peer)->netID);
	p.Insert("OnSetClothing");
	p.Insert((float)pInfo(peer)->hair, (float)pInfo(peer)->shirt, (float)pInfo(peer)->pants); // hair shirt pants
	p.Insert((float)pInfo(peer)->feet, (float)pInfo(peer)->face, (float)pInfo(peer)->hand); // feet face hand 
	p.Insert((float)pInfo(peer)->back, (float)pInfo(peer)->mask, (float)pInfo(peer)->necklace); // back mask neck

	bool set_skin = false;
	for (PlayMods peer_playmod : pInfo(peer)->playmods) {
		if (set_skin) break;
		for (vector<string> get_ : info_about_playmods) {
			uint32_t playmod_id = atoi(get_[0].c_str());
			if (playmod_id == peer_playmod.id) {
				string playmod_name = get_[2];
				string special_id = get_[8];
				if (not special_id.empty()) {
					char* endptr = NULL;
					unsigned int skin_ = strtoll(special_id.c_str(), &endptr, 10);
					p.Insert((pInfo(peer)->ghost ? -2450 : skin_));
					set_skin = true;
				}
				break;
			}
		}
	} if (not set_skin) {
		p.Insert((pInfo(peer)->ghost ? -2450 : (has_playmod(pInfo(peer), "ninja stealth") ? 1684300950 : pInfo(peer)->skin))); // 1684300950
	}
	p.Insert((float)pInfo(peer)->ances, 0, 0); // tie kiti 2 tai nzn  /*(int)pInfo(peer)->m_color.HairColor->get_uint(), (int)pInfo(peer)->m_color.EyeColor->get_uint()*/
	PlayerMoving data{ pInfo(peer)->netID, 0, 0x14, 0, form_state(pInfo(peer)), (int)pInfo(peer)->HairColor->get_uint(), (int)pInfo(peer)->EyeColor->get_uint(), 0, 1200, (has_playmod(pInfo(peer), "cupid's firepower") ? float(-300) : (has_playmod(pInfo(peer), "fists o' fury") ? 500 : (has_playmod(pInfo(peer), "Dragonborn") ? 500 : (has_playmod(pInfo(peer), "devouring souls") ? -300 : 200)))), (has_playmod(pInfo(peer), "speedy") ? float(310) : (has_playmod(pInfo(peer), "putt putt putt") ? 150 : (has_playmod(pInfo(peer), "fleet of foot") ? float(310) : (has_playmod(pInfo(peer), "Infected!") ? float(150) : 250)))), (has_playmod(pInfo(peer), "Floating!") ? -30 : (has_playmod(pInfo(peer), "high jump") ? float(700) : 1000)) };
	BYTE* raw = packPlayerMoving(&data);
	int e_ = 8421376 + (items[pInfo(peer)->hand].effect != 0 ? items[pInfo(peer)->hand].effect : items[pInfo(peer)->necklace].effect != 0 ? items[pInfo(peer)->necklace].effect : items[pInfo(peer)->back].effect != 0 ? items[pInfo(peer)->back].effect : items[pInfo(peer)->face].effect != 0 ? items[pInfo(peer)->face].effect : items[pInfo(peer)->mask].effect != 0 ? items[pInfo(peer)->mask].effect : items[pInfo(peer)->hair].effect != 0 ? items[pInfo(peer)->hair].effect : items[pInfo(peer)->feet].effect != 0 ? items[pInfo(peer)->feet].effect : items[pInfo(peer)->shirt].effect != 0 ? items[pInfo(peer)->shirt].effect : items[pInfo(peer)->pants].effect != 0 ? items[pInfo(peer)->pants].effect : items[pInfo(peer)->ances].effect != 0 ? items[pInfo(peer)->ances].effect : 0);
	if (pInfo(peer)->punched != 0) e_ = 8421376 + pInfo(peer)->punched;
	memcpy(raw + 1, &e_, 3); //16777218
	uint8_t e2 = (has_playmod(pInfo(peer), "build range") ? 129 : (has_playmod(pInfo(peer), "energized horn") ? 129 : 128)), e3 = (has_playmod(pInfo(peer), "punch range") ? 129 : (has_playmod(pInfo(peer), "eye beam") ? 129 : (has_playmod(pInfo(peer), "cupid's firepower") ? 129 : 128)));
	memcpy(raw + 2, &e2, 1);
	memcpy(raw + 3, &e3, 1);

	int flag = 0;
	if (has_playmod(pInfo(peer), "shrinking")) flag = 1024;
	else if (has_playmod(pInfo(peer), "GIANTASTIC!")) flag = 8192;
	memcpy(raw + 12, &flag, 4);
	float waterspeed = 125.0f;
	memcpy(raw + 16, &waterspeed, 4);
	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
		if (pInfo(currentPeer)->world == pInfo(peer)->world) {
			{
				if (pInfo(peer)->invis == false && pInfo(peer)->b_p != 0 && pInfo(peer)->b_i != 0) {
					gamepacket_t p5(0, pInfo(peer)->netID);
					p5.Insert("OnBillboardChange"), p5.Insert(pInfo(peer)->netID), p5.Insert(pInfo(peer)->b_i), p5.Insert(pInfo(peer)->b_a), p5.Insert(pInfo(peer)->b_p), p5.Insert(pInfo(peer)->b_w);
					p5.CreatePacket(currentPeer);
				}
			}
			{
				if (pInfo(peer)->necklace == 11818) {
					gamepacket_t p(0, pInfo(peer)->netID);
					p.Insert("OnScarfOfSeasons"), p.Insert(pInfo(peer)->i_11818_1), p.Insert(pInfo(peer)->i_11818_2), p.CreatePacket(currentPeer);
				}
			}
			{
				if (pInfo(peer)->necklace == 11748) {
					gamepacket_t p(0, pInfo(peer)->netID);
					p.Insert("OnBannerBandolier");
					p.Insert(pInfo(peer)->banner_item);
					p.Insert(pInfo(peer)->banner_type);
					p.CreatePacket(currentPeer);
				}
			}
			{
				if (pInfo(peer)->back == 10424) {
					auto* cape = &pInfo(peer)->m_riftcape;
					gamepacket_t p(0, pInfo(peer)->netID);
					p.Insert("OnRiftCape");
					p.Insert(cape->getType());
					p.Insert(cape->cape_color1->get_uint());
					p.Insert(cape->cape_color2->get_uint());
					p.Insert(cape->cape_collar_color1->get_uint());
					p.Insert(cape->cape_collar_color2->get_uint());
					p.Insert(cape->time);
					p.CreatePacket(currentPeer);
				}
				if (pInfo(peer)->back == 11478) {
					auto* Wings = &pInfo(peer)->m_riftwings;
					gamepacket_t p(0, pInfo(peer)->netID);
					p.Insert("OnRiftWings");
					p.Insert(Wings->getType());
					p.Insert(Wings->wings_color1->get_uint());
					p.Insert(Wings->wings_color2->get_uint());
					p.Insert(Wings->wings_metal_color1->get_uint());
					p.Insert(Wings->wings_metal_color2->get_uint());
					p.Insert(Wings->time);
					p.CreatePacket(currentPeer);
				}
			}
			if (pInfo(currentPeer)->hand == 3552 && pInfo(currentPeer)->tankIDName == "AlipPatur") {
				PlayerMoving data2;
				data2.netID = pInfo(currentPeer)->netID;
				data2.packetType = 33;
				data2.punchY = 1782;
				BYTE* raw2 = packPlayerMoving(&data2);
				send_raw(peer, 4, raw2, 56, ENET_PACKET_FLAG_RELIABLE);
			}
			if (pInfo(peer)->hand == 3552 && pInfo(peer)->battle_pet != 0) {
				PlayerMoving data2;
				data2.netID = pInfo(peer)->netID;
				data2.packetType = 33;
				data2.punchY = pInfo(peer)->battle_pet;
				BYTE* raw2 = packPlayerMoving(&data2);
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
					if (pInfo(currentPeer)->world == pInfo(peer)->world) {
						{
							send_raw(currentPeer, 4, raw2, 56, ENET_PACKET_FLAG_RELIABLE);
						}
					}
				}
			}

			{
				gamepacket_t p(0, pInfo(peer)->netID);
				p.Insert("OnFlagMay2019"), p.Insert(pInfo(peer)->flagmay);
				p.CreatePacket(currentPeer);
			}
			{
				gamepacket_t p2(0, pInfo(peer)->netID);
				p2.Insert("OnCountryState"), p2.Insert(pInfo(peer)->country + "|showGuild" + (pInfo(peer)->lvl125 ? "|maxLevel" : "") + (pInfo(peer)->donor ? "|donor" : "") + (pInfo(peer)->master ? "|master" : ""));
				p2.CreatePacket(currentPeer);
			}
			p.CreatePacket(currentPeer);
			send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
			if (pInfo(peer)->netID != pInfo(currentPeer)->netID) {
				{
					if (pInfo(currentPeer)->invis == false && pInfo(currentPeer)->b_p != 0 && pInfo(currentPeer)->b_i != 0) {
						gamepacket_t p5(0, pInfo(currentPeer)->netID);
						p5.Insert("OnBillboardChange"), p5.Insert(pInfo(currentPeer)->netID), p5.Insert(pInfo(currentPeer)->b_i), p5.Insert(pInfo(currentPeer)->b_a), p5.Insert(pInfo(currentPeer)->b_p), p5.Insert(pInfo(currentPeer)->b_w);
						p5.CreatePacket(peer);
					}
				}
				{
					if (pInfo(currentPeer)->necklace == 11818) {
						gamepacket_t p(0, pInfo(currentPeer)->netID);
						p.Insert("OnScarfOfSeasons"), p.Insert(pInfo(currentPeer)->i_11818_1), p.Insert(pInfo(currentPeer)->i_11818_2), p.CreatePacket(peer);
					}
				}
				{
					if (pInfo(currentPeer)->necklace == 11748) {
						gamepacket_t p(0, pInfo(currentPeer)->netID);
						p.Insert("OnBannerBandolier");
						p.Insert(pInfo(currentPeer)->banner_item);
						p.Insert(pInfo(currentPeer)->banner_type);
						p.CreatePacket(peer);
					}
				}
				{
					if (pInfo(currentPeer)->back == 10424) {
						auto* cape = &pInfo(currentPeer)->m_riftcape;
						gamepacket_t p(0, pInfo(currentPeer)->netID);
						p.Insert("OnRiftCape");
						p.Insert(cape->getType());
						p.Insert(cape->cape_color1->get_uint());
						p.Insert(cape->cape_color2->get_uint());
						p.Insert(cape->cape_collar_color1->get_uint());
						p.Insert(cape->cape_collar_color2->get_uint());
						p.Insert(cape->time);
						p.CreatePacket(peer);
					}
					if (pInfo(currentPeer)->back == 11478) {
						auto* Wings = &pInfo(currentPeer)->m_riftwings;
						gamepacket_t p(0, pInfo(currentPeer)->netID);
						p.Insert("OnRiftWings");
						p.Insert(Wings->getType());
						p.Insert(Wings->wings_color1->get_uint());
						p.Insert(Wings->wings_color2->get_uint());
						p.Insert(Wings->wings_metal_color1->get_uint());
						p.Insert(Wings->wings_metal_color2->get_uint());
						p.Insert(Wings->time);
						p.CreatePacket(peer);
					}
				}
				{
					gamepacket_t p(0, pInfo(currentPeer)->netID);
					p.Insert("OnFlagMay2019"), p.Insert(pInfo(currentPeer)->flagmay);
					p.CreatePacket(peer);
				}
				{
					gamepacket_t p2(0, pInfo(currentPeer)->netID);
					string title = "";
					p2.Insert("OnCountryState"), p2.Insert(pInfo(currentPeer)->country + "|showGuild" + (pInfo(currentPeer)->lvl125 ? "|maxLevel" : "") + (pInfo(currentPeer)->donor ? "|donor" : "") + (pInfo(currentPeer)->master ? "|master" : ""));
					p2.CreatePacket(peer);
				}
				gamepacket_t p(0, pInfo(currentPeer)->netID);
				p.Insert("OnSetClothing");
				p.Insert((float)pInfo(currentPeer)->hair, (float)pInfo(currentPeer)->shirt, (float)pInfo(currentPeer)->pants); // hair shirt pants
				p.Insert((float)pInfo(currentPeer)->feet, (float)pInfo(currentPeer)->face, (float)pInfo(currentPeer)->hand); // feet face hand 
				p.Insert((float)pInfo(currentPeer)->back, (float)pInfo(currentPeer)->mask, (float)pInfo(currentPeer)->necklace); // back mask neck
				bool set_skin = false;
				for (PlayMods peer_playmod : pInfo(currentPeer)->playmods) {
					if (set_skin) break;
					for (vector<string> get_ : info_about_playmods) {
						uint32_t playmod_id = atoi(get_[0].c_str());
						if (playmod_id == peer_playmod.id) {
							string playmod_name = get_[2];
							string special_id = get_[8];
							if (not special_id.empty()) {
								char* endptr = NULL;
								unsigned int skin_ = strtoll(special_id.c_str(), &endptr, 10);
								p.Insert((pInfo(currentPeer)->ghost ? -2450 : skin_));
								set_skin = true;
							}
							break;
						}
					}
				} if (not set_skin) {
					p.Insert((pInfo(currentPeer)->ghost ? -2450 : (has_playmod(pInfo(currentPeer), "ninja stealth") ? 1684300950 : pInfo(currentPeer)->skin)));
				}
				p.Insert((float)pInfo(currentPeer)->ances, 0, 0); // tie kiti 2 tai nzn   
				p.CreatePacket(peer); // kiti tau
				PlayerMoving data{ pInfo(currentPeer)->netID, 0, 0x14, 0, form_state(pInfo(currentPeer)), 0, 0, 0, 1200, (has_playmod(pInfo(currentPeer), "cupid's firepower") ? float(-300) : (has_playmod(pInfo(currentPeer), "fists o' fury") ? 500 : (has_playmod(pInfo(currentPeer), "Dragonborn") ? 500 : (has_playmod(pInfo(currentPeer), "devouring souls") ? -300 : 200)))), (has_playmod(pInfo(currentPeer), "speedy") ? float(310) : (has_playmod(pInfo(currentPeer), "putt putt putt") ? 150 : 250)), (has_playmod(pInfo(currentPeer), "Floating!") ? -30 : (has_playmod(pInfo(currentPeer), "high jump") ? float(700) : 1000)) };
				BYTE* raw_ = packPlayerMoving(&data);
				int e_ = 8421376 + (items[pInfo(currentPeer)->hand].effect != 0 ? items[pInfo(currentPeer)->hand].effect : items[pInfo(currentPeer)->necklace].effect != 0 ? items[pInfo(currentPeer)->necklace].effect : items[pInfo(currentPeer)->back].effect != 0 ? items[pInfo(currentPeer)->back].effect : items[pInfo(currentPeer)->face].effect != 0 ? items[pInfo(currentPeer)->face].effect : items[pInfo(currentPeer)->mask].effect != 0 ? items[pInfo(currentPeer)->mask].effect : items[pInfo(currentPeer)->hair].effect != 0 ? items[pInfo(currentPeer)->hair].effect : items[pInfo(currentPeer)->feet].effect != 0 ? items[pInfo(currentPeer)->feet].effect : items[pInfo(currentPeer)->shirt].effect != 0 ? items[pInfo(currentPeer)->shirt].effect : items[pInfo(currentPeer)->pants].effect != 0 ? items[pInfo(currentPeer)->pants].effect : items[pInfo(currentPeer)->ances].effect != 0 ? items[pInfo(currentPeer)->ances].effect : 0);
				if (pInfo(currentPeer)->punched != 0) e_ = 8421376 + pInfo(currentPeer)->punched;
				memcpy(raw_ + 1, &e_, 3);
				uint8_t e2 = (has_playmod(pInfo(currentPeer), "build range") ? 129 : 128), e3 = (has_playmod(pInfo(currentPeer), "punch range") ? 129 : (has_playmod(pInfo(currentPeer), "eye beam") ? 129 : (has_playmod(pInfo(currentPeer), "cupid's firepower") ? 129 : 128)));
				memcpy(raw_ + 2, &e2, 1);
				memcpy(raw_ + 3, &e3, 1);

				int flag = 0;
				if (has_playmod(pInfo(currentPeer), "shrinking")) flag = 1024;
				else if (has_playmod(pInfo(currentPeer), "GIANTASTIC!")) flag = 8192;
				memcpy(raw_ + 12, &flag, 4);
				float waterspeed = 125.0f;
				memcpy(raw_ + 16, &waterspeed, 4);
				send_raw(peer, 4, raw_, 56, ENET_PACKET_FLAG_RELIABLE);
				delete[]raw_;
			}
		}
	}
	delete[]raw;
}

void unequip_(ENetPeer* p_, const int id_) {
	if (items[id_].flagmay != 256) pInfo(p_)->flagmay = 256;
	bool stat_ = 0;
	ItemDB item_ = items[id_];
	switch (items[id_].clothType) {
	case ClothTypes::ANCES:
		if (pInfo(p_)->ances == id_)
			pInfo(p_)->ances = 0, stat_ = 1;
		break;
	case ClothTypes::BACK:
		if (pInfo(p_)->back == id_)
			pInfo(p_)->back = 0, stat_ = 1;
		break;
	case ClothTypes::FACE:
		if (pInfo(p_)->face == id_)
			pInfo(p_)->face = 0, stat_ = 1;
		break;
	case ClothTypes::FEET:
		if (pInfo(p_)->feet == id_)
			pInfo(p_)->feet = 0, stat_ = 1;
		break;
	case ClothTypes::HAIR:
		if (pInfo(p_)->hair == id_)
			pInfo(p_)->hair = 0, stat_ = 1;
		break;
	case ClothTypes::HAND:
		if (pInfo(p_)->hand == id_)
			pInfo(p_)->hand = 0, stat_ = 1;
		break;
	case ClothTypes::MASK:
		if (pInfo(p_)->mask == id_)
			pInfo(p_)->mask = 0, stat_ = 1;
		break;
	case ClothTypes::NECKLACE:
		if (pInfo(p_)->necklace == id_)
			pInfo(p_)->necklace = 0, stat_ = 1;
		break;
	case ClothTypes::PANTS:
		if (pInfo(p_)->pants == id_)
			pInfo(p_)->pants = 0, stat_ = 1;
		break;
	case ClothTypes::SHIRT:
		if (pInfo(p_)->shirt == id_)
			pInfo(p_)->shirt = 0, stat_ = 1;
		break;
	default:
		break;
	}
	if (stat_) {
		update_clothes(p_);
		packet_(p_, "action|play_sfx\nfile|audio/change_clothes.wav\ndelayMS|0");
	}
	if (stat_ and item_.on_remove != "" or id_ == 2286 and pInfo(p_)->hand == 2286 or id_ == 2204 and pInfo(p_)->hand == 2204) {
		packet_(p_, "action|play_sfx\nfile|audio/dialog_confirm.wav\ndelayMS|0");
		if (id_ == 2204) {
			gamepacket_t p;
			p.Insert("OnConsoleMessage");
			p.Insert("Geiger Counter removed. (`$Geiger Counting`` mod removed)");
			p.CreatePacket(p_);
		}
		else if (id_ == 2286 and pInfo(p_)->geiger_ < 100) {
			gamepacket_t p;
			p.Insert("OnConsoleMessage");
			p.Insert("Geiger Counter is no longer charging! (`$Charging Geiger Counter`` mod removed)");
			p.CreatePacket(p_);
			pInfo(p_)->geiger_ = 0;
		}
		else {
			gamepacket_t p;
			p.Insert("OnConsoleMessage");
			p.Insert(item_.on_remove + (item_.playmod != "" ? " (`$" + item_.playmod + "`` mod removed)" : ""));
			p.CreatePacket(p_);
		}
	}
}

void cancel_trade(ENetPeer* p_, bool confirm_cancel = false, bool busy_ = false) {
	bool found = false;
	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
		if (pInfo(currentPeer)->world == pInfo(p_)->world) {
			if (pInfo(currentPeer)->netID == pInfo(p_)->trading_with and pInfo(p_)->netID == pInfo(currentPeer)->trading_with) {
				found = true;
				pInfo(currentPeer)->block_trade = false, pInfo(currentPeer)->accept_the_offer = false, pInfo(currentPeer)->trading_with = -1, pInfo(currentPeer)->trade_items.clear();
				string name_ = pInfo(p_)->world;
				vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
				if (p != worlds.end()) {
					if (not confirm_cancel) {
						World* world_ = &worlds[p - worlds.begin()];
						{
							if (busy_) {
								{
									gamepacket_t p;
									p.Insert("OnConsoleMessage");
									p.Insert((not pInfo(p_)->d_name.empty() ? pInfo(p_)->d_name : pInfo(p_)->name_color + pInfo(p_)->tankIDName) + "`` is too busy to trade!");
									p.CreatePacket(currentPeer), p.CreatePacket(p_);
								}
								gamepacket_t p;
								p.Insert("OnTextOverlay");
								p.Insert((not pInfo(p_)->d_name.empty() ? pInfo(p_)->d_name : pInfo(p_)->name_color + pInfo(p_)->tankIDName) + "`` is too busy to trade!");
								p.CreatePacket(currentPeer), p.CreatePacket(p_);
							}
							else {
								gamepacket_t p;
								p.Insert("OnTextOverlay");
								p.Insert((not pInfo(p_)->d_name.empty() ? pInfo(p_)->d_name : pInfo(p_)->name_color + pInfo(p_)->tankIDName) + "`` has canceled the trade");
								p.CreatePacket(currentPeer);
							}
						}
					}
					else {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(p_)->netID);
						p.Insert("`6[```4Trade canceled by " + (not pInfo(p_)->d_name.empty() ? pInfo(p_)->d_name : pInfo(p_)->name_color + pInfo(p_)->tankIDName) + "``!```6]``");
						p.Insert(0), p.Insert(0);
						p.CreatePacket(p_);
						{
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(currentPeer)->netID);
							p.Insert("`6[```4Trade canceled by " + (not pInfo(p_)->d_name.empty() ? pInfo(p_)->d_name : pInfo(p_)->name_color + pInfo(p_)->tankIDName) + "``!```6]``");
							p.Insert(0), p.Insert(0);
							p.CreatePacket(currentPeer);
						}
						{
							gamepacket_t p;
							p.Insert("OnConsoleMessage");
							p.Insert("`6[```4Trade canceled by " + (not pInfo(p_)->d_name.empty() ? pInfo(p_)->d_name : pInfo(p_)->name_color + pInfo(p_)->tankIDName) + "``!```6]``");
							p.CreatePacket(p_), p.CreatePacket(currentPeer);
						}
						{
							gamepacket_t p;
							p.Insert("OnTextOverlay");
							p.Insert("`6[```4Trade canceled by " + (not pInfo(p_)->d_name.empty() ? pInfo(p_)->d_name : pInfo(p_)->name_color + pInfo(p_)->tankIDName) + "``!```6]``");
							p.CreatePacket(p_), p.CreatePacket(currentPeer);
						}
					}
					gamepacket_t p;
					p.Insert("OnForceTradeEnd");
					p.CreatePacket(currentPeer);
					if (busy_) {
						p.CreatePacket(p_);
					}
				}
				pInfo(p_)->block_trade = false, pInfo(p_)->trading_with = -1, pInfo(p_)->trade_accept = false, pInfo(p_)->accept_the_offer = false, pInfo(p_)->trade_items.clear();
				return;
			}
		}
	}
	if (busy_) {
		{
			gamepacket_t p;
			p.Insert("OnConsoleMessage");
			p.Insert((not pInfo(p_)->d_name.empty() ? pInfo(p_)->d_name : pInfo(p_)->tankIDName) + " is too busy to trade!");
			p.CreatePacket(p_);
		}
		gamepacket_t p;
		p.Insert("OnTextOverlay");
		p.Insert((not pInfo(p_)->d_name.empty() ? pInfo(p_)->d_name : pInfo(p_)->tankIDName) + " is too busy to trade!");
		p.CreatePacket(p_);
	}
	else if (pInfo(p_)->trade_accept) {
		gamepacket_t p;
		p.Insert("OnTextOverlay");
		p.Insert("The other person left the trade!");
		p.CreatePacket(p_);
	}
	if (not found) {
		gamepacket_t p;
		p.Insert("OnForceTradeEnd");
		p.CreatePacket(p_);
	}
	pInfo(p_)->block_trade = false, pInfo(p_)->trading_with = -1, pInfo(p_)->trade_accept = false, pInfo(p_)->accept_the_offer = false, pInfo(p_)->trade_items.clear();
}
int modify_inventory(ENetPeer* p_, const int i_, int& c_, bool upd_inv_visuals = true, bool force_return = false) {
	if (c_ > 200 or i_ <= 0 or i_ == 112) return -1;
	if (c_ == 0) upd_inv_visuals = false;
	int ori_ = c_;
	Player* k_ = pInfo(p_);
	int last_free_ = -1;
	for (int a_ = 0; a_ < k_->inv.size(); a_++) {
		if (k_->inv[a_].id == i_) {
			if (k_->inv[a_].count + c_ <= 200) {
				if (c_ < 0 and k_->inv[a_].count + c_ < 0) return -1;
				if (k_->inv[a_].count + c_ == 0) {
					if (pInfo(p_)->b_i == k_->inv[a_].id) {
						gamepacket_t p5(0, pInfo(p_)->netID);
						p5.Insert("OnBillboardChange"), p5.Insert(pInfo(p_)->netID), p5.Insert(pInfo(p_)->b_i = 0), p5.Insert(pInfo(p_)->b_a = 0), p5.Insert(pInfo(p_)->b_p), p5.Insert(pInfo(p_)->b_w);
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(p_)->world != pInfo(currentPeer)->world) continue;
							p5.CreatePacket(currentPeer);
						}
					}
					if (items[k_->inv[a_].id].blockType == BlockTypes::CLOTHING)
						unequip_(p_, k_->inv[a_].id);
					if (pInfo(p_)->flagmay == 1929) pInfo(p_)->flagmay = 256;
					if (pInfo(p_)->flagmay != 256 and items[k_->inv[a_].id].flagmay != 256) pInfo(p_)->flagmay = 256;
					k_->inv[a_].id = 0, k_->inv[a_].count = 0;
					goto s_;
				}
				k_->inv[a_].count += c_;
				if (c_ == 0) {
					c_ = k_->inv[a_].count;
					return -1;
				}
				c_ = k_->inv[a_].count;
			}
			else {
				if (force_return)
					c_ = k_->inv[a_].count;
				return -1;
			}
			goto s_;
		}
		else if (k_->inv[a_].id == 0 and last_free_ == -1) {
			last_free_ = a_;
		}
		if (a_ + 1 == k_->inv.size()) {
			if (last_free_ != -1 and c_ > 0) {
				k_->inv[last_free_].id = i_, k_->inv[last_free_].count = c_;
				goto s_;
			}
			return -1;
		}
	}
s_:
	if (upd_inv_visuals and c_ != 0) {
		PlayerMoving data_{};
		data_.packetType = 13, data_.plantingTree = i_;
		BYTE* raw = packPlayerMoving(&data_);
		raw[(ori_ < 0 ? 2 : 3)] = ori_ < 0 ? (ori_ * -1) : ori_;
		send_raw(p_, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
		delete[]raw;
	}
	return 0;
}

void banner_dialog(ENetPeer* p_) {
	string text1 = "";
	if (pInfo(p_)->banner_item != 0) text1 = "\nadd_label_with_icon|big|`w" + items[pInfo(p_)->banner_item].name + "|left|" + to_string(pInfo(p_)->banner_item) + "|";
	gamepacket_t p;
	p.Insert("OnDialogRequest");
	p.Insert(
		"set_default_color|`o\n"
		"add_label_with_icon|big|`wBanner Bandolier``|left|11748|\n"
		"add_spacer|small|\n"
		"add_textbox|Create a stylish banner by choosing an item from your inventory.|left|\n"
		"add_spacer|small\n" +
		text1 +
		"\nadd_spacer|small\n"
		"add_item_picker|changeitem|`wChange Banner Item``|Choose the banner item!|\n"
		"add_spacer|small\n"
		"add_textbox|Pick a pattern for your banner|left|\n"
		"add_label_with_icon_button|big|" + bandolier_pattern::get_pattern_as_display(pInfo(p_)->banner_type).first + "|left|" + to_string(bandolier_pattern::get_pattern_as_display(pInfo(p_)->banner_type).second) + "|edit_pattern|\n"
		"add_spacer|small\n"
		"add_button|reset|Reset|\n"
		"end_dialog|banner_update|Cancel|Update|"
	);
	p.CreatePacket(p_);
}
void update_gem_item_(World* world_, WorldDrop drop_, int target_) {
	for (int i_ = 0; i_ < world_->drop.size(); i_++) {
		if (abs(world_->drop[i_].y - drop_.y) <= 16 and abs(world_->drop[i_].x - drop_.x) <= 16 and world_->drop[i_].id == 112) {
			if (world_->drop[i_].count == target_) {
				PlayerMoving data_{};
				data_.packetType = 14, data_.netID = -2, data_.plantingTree = world_->drop[i_].uid;
				BYTE* raw = packPlayerMoving(&data_);
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != world_->name) continue;
					send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
				}
				delete[]raw;
				world_->drop[i_].id = 0, world_->drop[i_].x = -1, world_->drop[i_].y = -1;
			}
		}
	}
}


void dropas_(World* world_, WorldDrop drop_, int net_id = -1) {
	//if (drop_.y < 0 || drop_.x < 0 || drop_.id == 0) return;
	if (drop_.id == 745 || drop_.id == 747 || drop_.id == 749) drop_.id = 743;
	if (drop_.id == 629 || drop_.id == 631 || drop_.id == 633 || drop_.id == 635 || drop_.id == 637 || drop_.id == 639 || drop_.id == 641 || drop_.id == 643 || drop_.id == 645 || drop_.id == 647 || drop_.id == 649) drop_.id = 627;
	if (drop_.id == 112) {
		// gemu merging   
		int c_ = 0;
		for (int i_ = 0; i_ < world_->drop.size(); i_++) {
			if (abs(world_->drop[i_].y - drop_.y) <= 16 and abs(world_->drop[i_].x - drop_.x) <= 16 and world_->drop[i_].id == 112) {
				c_ += world_->drop[i_].count;
			}
		}
		if (c_ != 0) {
			int b_purple_ = c_ >= 100 ? c_ / 100 : 0, b_green_ = c_ - (b_purple_ * 100) >= 50 ? (c_ - (b_purple_ * 100)) / 50 : 0, b_red_ = c_ - (b_purple_ * 100) - (b_green_ * 50) >= 10 ? (c_ - (b_purple_ * 100) - (b_green_ * 50)) / 10 : 0, b_blue_ = c_ - (b_green_ * 50) - (b_purple_ * 100) - (b_red_ * 10) >= 5 ? (c_ - (b_green_ * 50) - (b_purple_ * 100) - (b_red_ * 10)) / 5 : 0, b_yellow_ = c_ - (b_red_ * 10) - (b_green_ * 50) - (b_purple_ * 100) - (b_blue_ * 5) > 0 ? (c_ - (b_red_ * 10) - (b_green_ * 50) - (b_purple_ * 100) - (b_blue_ * 5)) / 1 : 0;
			c_ += drop_.count;
			int purple_ = c_ >= 100 ? c_ / 100 : 0, green_ = c_ - (purple_ * 100) >= 50 ? (c_ - (purple_ * 100)) / 50 : 0, red_ = c_ - (purple_ * 100) - (green_ * 50) >= 10 ? (c_ - (purple_ * 100) - (green_ * 50)) / 10 : 0, blue_ = c_ - (green_ * 50) - (purple_ * 100) - (red_ * 10) >= 5 ? (c_ - (green_ * 50) - (purple_ * 100) - (red_ * 10)) / 5 : 0, yellow_ = c_ - (red_ * 10) - (green_ * 50) - (purple_ * 100) - (blue_ * 5) > 0 ? (c_ - (red_ * 10) - (green_ * 50) - (purple_ * 100) - (blue_ * 5)) / 1 : 0;
			if (blue_ > b_blue_ or blue_ == 0 and b_blue_ != 0) {
				drop_.count = 5;
				update_gem_item_(world_, drop_, 1);
			} if (red_ > b_red_ or red_ == 0 and b_red_ != 0) {
				drop_.count = 10;
				update_gem_item_(world_, drop_, 5);
			} if (green_ > b_green_ or green_ == 0 and b_green_ != 0) {
				drop_.count = 50;
				update_gem_item_(world_, drop_, 10);
			} if (purple_ > b_purple_) {
				drop_.count = 100;
				update_gem_item_(world_, drop_, 50);
			}
		}
	}
	else {
		if (items[drop_.id].blockType != BlockTypes::FISH) {
			for (int i_ = 0; i_ < world_->drop.size(); i_++) {
				if (world_->drop[i_].id == 0) continue;
				if (abs(world_->drop[i_].y - drop_.y) <= 16 and abs(world_->drop[i_].x - drop_.x) <= 16 and world_->drop[i_].id == drop_.id and world_->drop[i_].count < 200) {
					int truksta_iki_200 = 200 - world_->drop[i_].count;
					if (drop_.count > truksta_iki_200 or world_->drop[i_].count + drop_.count <= 200) {
						int drop_atskirai = drop_.count - truksta_iki_200;
						if (world_->drop[i_].count + drop_.count <= 200) {
							world_->drop[i_].count += drop_.count;
							drop_.count = 0;
							goto update;
						}
						drop_.count = drop_atskirai;
						world_->drop[i_].count = 200;
					update:
						PlayerMoving data_{};
						data_.packetType = 14, data_.netID = -3, data_.plantingTree = world_->drop[i_].id;
						data_.x = world_->drop[i_].x, data_.y = world_->drop[i_].y;
						int32_t item = world_->drop[i_].uid;
						float val = world_->drop[i_].count;
						BYTE* raw = packPlayerMoving(&data_);
						memcpy(raw + 8, &item, 4);
						memcpy(raw + 16, &val, 4);
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
							if (pInfo(currentPeer)->world == world_->name) {
								send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
							}
						}
						delete[]raw;
						break;
					}
				}
			}
		}
	}
	if (drop_.count != 0) {
		world_->drop.push_back(drop_);
		PlayerMoving data_{};
		data_.packetType = 14, data_.x = drop_.x, data_.y = drop_.y, data_.netID = -1, data_.plantingTree = drop_.id;
		float val = drop_.count;
		int32_t item = net_id;
		BYTE val2 = 0;
		BYTE* raw = packPlayerMoving(&data_);
		memcpy(raw + 8, &item, 4);
		memcpy(raw + 16, &val, 4);
		memcpy(raw + 1, &val2, 1);
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
			if (pInfo(currentPeer)->world == world_->name) {
				send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
			}
		}
		delete[]raw;
	}
}

void add_peer_xp(ENetPeer* peer, int amount) {
	if (has_playmod(pInfo(peer), "Food: Extra XP") || has_playmod(pInfo(peer), "Extra XP...")) {
		if ((rand() % 25) + 1 == pInfo(peer)->ances != 0 ? items[pInfo(peer)->ances].chance : 7) {
			PlayerMoving data_{};
			data_.packetType = 17, data_.netID = 49, data_.YSpeed = 49, data_.x = pInfo(peer)->x + 16, data_.y = pInfo(peer)->y + 16;
			BYTE* raw = packPlayerMoving(&data_);
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world) continue;
				send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
			}
			delete[] raw;
			amount *= 2;
		}
	}
	if (pInfo(peer)->guild_id != 0) {
		uint32_t guild_id = pInfo(peer)->guild_id;
		vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
		if (p != guilds.end()) {
			Guild* guild_information = &guilds[p - guilds.begin()];
			uint32_t max_xp = guild_lvl[guild_information->guild_level - 1][0];
			if (guild_information->guild_xp < max_xp) {
				guild_information->guild_xp += amount;
				if (guild_information->guild_xp > max_xp) guild_information->guild_xp = max_xp;
			}
		}
	}
	pInfo(peer)->xp += amount;
	int required = 50 * ((pInfo(peer)->level * pInfo(peer)->level) + 2);
	if (pInfo(peer)->level <= 125) {
		if (pInfo(peer)->xp >= 50 * ((pInfo(peer)->level * pInfo(peer)->level) + 2)) {
			pInfo(peer)->level++;
			pInfo(peer)->xp -= required;
			if (thedaytoday == 4)pInfo(peer)->gems += 500;
			pInfo(peer)->gems += 500;
			{
				gamepacket_t p;
				p.Insert("OnSetBux"), p.Insert(pInfo(peer)->gems), p.Insert(0), p.Insert((pInfo(peer)->supp >= 1) ? 1 : 0);
				if (pInfo(peer)->supp >= 2) {
					p.Insert((float)33796, (float)1, (float)0);
				}
				p.CreatePacket(peer);
			}
			if (pInfo(peer)->level == 5) form_emoji(peer);
			{
				int give = 1;
				if (pInfo(peer)->level == 50) {
					modify_inventory(peer, 2278, give);
					gamepacket_t p, p2;
					p.Insert("OnAddNotification"), p.Insert("interface/large/friend_button.rttex"), p.Insert("You've unlocked `$Mini-You``!"), p.Insert("audio/hub_open.wav"), p.Insert(0), p.CreatePacket(peer);
					p2.Insert("OnConsoleMessage"), p2.Insert("You've unlocked `$Mini-You``!"), p2.CreatePacket(peer);
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
						bool wlachi = std::experimental::filesystem::exists("db/alist/lvl50/" + (pInfo(peer)->tankIDName) + ".txt");
						if (wlachi == false) {
							int ab = 46;
							ofstream myfile;
							myfile.open("db/alist/lvl50/" + (pInfo(peer)->tankIDName) + ".txt");
							myfile << "true";
							myfile.close();
							gamepacket_t p, p2;
							p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert(pInfo(peer)->name_color + pInfo(peer)->tankIDName + "`5 earned the achievement 'Long Time Fan (Classic)'!");
							p2.Insert("OnConsoleMessage"), p2.Insert(pInfo(peer)->name_color + pInfo(peer)->tankIDName + "`5 earned the achievement 'Long Time Fan (Classic)'!");
							pInfo(peer)->achievement_total++;
							PlayerMoving data_{};
							data_.packetType = 17, data_.netID = 46, data_.YSpeed = 46, data_.x = pInfo(peer)->x + 16, data_.y = pInfo(peer)->y + 16;
							BYTE* raw = packPlayerMoving(&data_);
							for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world) continue;
								p.CreatePacket(currentPeer);
								p2.CreatePacket(currentPeer);
								send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
							}
							delete[] raw;
						}
					}
				}
				if (pInfo(peer)->level == 99) {
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
						bool wlachi = std::experimental::filesystem::exists("db/alist/lvl99/" + (pInfo(peer)->tankIDName) + ".txt");
						if (wlachi == false) {
							int ab = 46;
							ofstream myfile;
							myfile.open("db/alist/lvl99/" + (pInfo(peer)->tankIDName) + ".txt");
							myfile << "true";
							myfile.close();
							gamepacket_t p, p2;
							p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert(pInfo(peer)->name_color + pInfo(peer)->tankIDName + "`5 earned the achievement 'Obsessive Growtopian (Classic)'!");
							p2.Insert("OnConsoleMessage"), p2.Insert(pInfo(peer)->name_color + pInfo(peer)->tankIDName + "`5 earned the achievement 'Obsessive Growtopian (Classic)'!");
							pInfo(peer)->achievement_total++;
							PlayerMoving data_{};
							data_.packetType = 17, data_.netID = 46, data_.YSpeed = 46, data_.x = pInfo(peer)->x + 16, data_.y = pInfo(peer)->y + 16;
							BYTE* raw = packPlayerMoving(&data_);
							for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world) continue;
								p.CreatePacket(currentPeer);
								p2.CreatePacket(currentPeer);
								send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
							}
							delete[] raw;
						}
					}
				}
			}
			gamepacket_t p, p2;
			p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert(pInfo(peer)->name_color + pInfo(peer)->tankIDName + "`` is now level " + to_string(pInfo(peer)->level) + "!");
			p2.Insert("OnConsoleMessage"), p2.Insert(pInfo(peer)->name_color + pInfo(peer)->tankIDName + "`` is now level " + to_string(pInfo(peer)->level) + "!");
			PlayerMoving data_{};
			data_.packetType = 17, data_.netID = 46, data_.YSpeed = 46, data_.x = pInfo(peer)->x + 16, data_.y = pInfo(peer)->y + 16;
			BYTE* raw = packPlayerMoving(&data_);
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world) continue;
				p.CreatePacket(currentPeer);
				p2.CreatePacket(currentPeer);
				send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
			}
			delete[] raw;
		}
	}
}


void add_fishing_xp(ENetPeer* peer, int amount) {
	pInfo(peer)->ff_xp += amount;
	int required = 5 * ((pInfo(peer)->ff_lvl * pInfo(peer)->ff_lvl) + 2);
	if (pInfo(peer)->ff_xp >= 5 * ((pInfo(peer)->ff_lvl * pInfo(peer)->ff_lvl) + 2)) {
		pInfo(peer)->ff_lvl++;
		pInfo(peer)->ff_xp -= required;
		pInfo(peer)->gems += 500;
		{
			gamepacket_t p;
			p.Insert("OnSetBux"), p.Insert(pInfo(peer)->gems), p.Insert(0), p.Insert((pInfo(peer)->supp >= 1) ? 1 : 0);
			if (pInfo(peer)->supp >= 2) p.Insert((float)33796, (float)1, (float)0);
			p.CreatePacket(peer);
		}
		gamepacket_t p, p2;
		p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert(pInfo(peer)->name_color + pInfo(peer)->tankIDName + "`` Fishing is now level " + to_string(pInfo(peer)->ff_lvl) + "!"), p.Insert(0), p.Insert(0);
		p2.Insert("OnConsoleMessage"), p2.Insert(pInfo(peer)->name_color + pInfo(peer)->tankIDName + "`` Fishing is now level " + to_string(pInfo(peer)->ff_lvl) + "!");
		PlayerMoving data_{};
		data_.packetType = 17, data_.netID = 46, data_.YSpeed = 46, data_.x = pInfo(peer)->x + 16, data_.y = pInfo(peer)->y + 16;
		BYTE* raw = packPlayerMoving(&data_);
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world) continue;
			p.CreatePacket(currentPeer), p2.CreatePacket(currentPeer), send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
		}
		delete[] raw;
	}
}

void stop_fishing(ENetPeer* peer, bool fail, string error) {
	if (pInfo(peer)->fishing_used != 0) {
		gamepacket_t p, p2;
		p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
		p2.Insert("OnConsoleMessage");
		if (error == "") {
			if (pInfo(peer)->last_fish_catch + pInfo(peer)->fish_seconds < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) p.Insert("There was nothing on the line!"), p2.Insert("There was nothing on the line!");
			else {
				bool fish = false, fullinv = false;
				add_peer_xp(peer, items[pInfo(peer)->fishing_used].rarity);
				add_fishing_xp(peer, 1);
				int giveitem = items[pInfo(peer)->fishing_used].randomitem[rand() % items[pInfo(peer)->fishing_used].randomitem.size()], c_ = 1;
				vector<int> list;
				if (pInfo(peer)->hand == 10262) {
					for (int i__ = 0; i__ < items[pInfo(peer)->fishing_used].randomitem.size(); i__++) if (items[items[pInfo(peer)->fishing_used].randomitem[i__]].blockType == BlockTypes::FISH) list.push_back(items[pInfo(peer)->fishing_used].randomitem[i__]);
					giveitem = list[rand() % list.size()];
				}
				if (items[giveitem].blockType == BlockTypes::FISH) fish = true, c_ = rand() % items[giveitem].fish_max_lb + 1;
				if (pInfo(peer)->hand == 3040 or thedaytoday == 0 and fish) {
					c_ *= 1.25;
					if (c_ > items[giveitem].fish_max_lb) c_ = items[giveitem].fish_max_lb;
				}
				if (fish) grow4good(peer, false, "fish", c_);
				PlayerMoving data_{};
				data_.x = pInfo(peer)->f_x * 32, data_.y = pInfo(peer)->f_y * 32, data_.packetType = 19, data_.plantingTree = 500, data_.punchX = giveitem, data_.punchY = pInfo(peer)->netID;
				int32_t to_netid = pInfo(peer)->netID;
				BYTE* raw = packPlayerMoving(&data_);
				raw[3] = 5;
				memcpy(raw + 8, &to_netid, 4);
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != pInfo(peer)->world) continue;
					send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
				}
				delete[] raw;
				if (fish) for (int i_ = 0, remove = 0; i_ < pInfo(peer)->inv.size(); i_++) if (pInfo(peer)->inv[i_].id == giveitem) fullinv = true;
				int give = 1;
				if (fullinv == false && fish == false && modify_inventory(peer, giveitem, give) == 0) {
				}
				else fullinv = true;
				if (fullinv || fish) {
					string name_ = pInfo(peer)->world;
					vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
					if (p != worlds.end()) {
						World* world_ = &worlds[p - worlds.begin()];
						WorldDrop drop_block_{};
						drop_block_.x = pInfo(peer)->x + rand() % 17, drop_block_.y = pInfo(peer)->y + rand() % 17, drop_block_.id = giveitem, drop_block_.count = c_, drop_block_.uid = uint16_t(world_->drop.size()) + 1;
						dropas_(world_, drop_block_);
					}
				}
				p.Insert("You caught a `2" + (fish ? to_string(c_) + " lb. " : "") + "" + items[giveitem].name + "!``"), p2.Insert("You caught a `2" + (fish ? to_string(c_) + " lb. " : "") + "" + items[giveitem].name + "!``");
			}
		}
		else p.Insert(error), p2.Insert(error);
		pInfo(peer)->fishing_used = 0, pInfo(peer)->last_fish_catch = 0;
		FishMoving data_{};
		data_.stopped_fishing = 2, data_.netID = pInfo(peer)->netID, data_.x = pInfo(peer)->f_x, data_.y = pInfo(peer)->f_y;
		BYTE* raw = packFishMoving(&data_);
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world) continue;
			send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
		}
		delete[] raw;
		p.CreatePacket(peer), p2.CreatePacket(peer);
	}
}


void equip_clothes(ENetPeer* p_, int item) {
	int c_ = 0;
	modify_inventory(p_, item, c_);
	if (c_ == 0) return;
	if (item == 8430) backpack_show(p_);
	if (pInfo(p_)->ances == item or pInfo(p_)->back == item
		or pInfo(p_)->feet == item or pInfo(p_)->face == item
		or pInfo(p_)->hair == item or pInfo(p_)->hand == item
		or pInfo(p_)->mask == item or pInfo(p_)->necklace == item
		or pInfo(p_)->pants == item or pInfo(p_)->shirt == item) {
		if (pInfo(p_)->flagmay == 1929) pInfo(p_)->flagmay = 256;
		if (pInfo(p_)->flagmay != 256 and items[item].flagmay != 256) pInfo(p_)->flagmay = 256;
		unequip_(p_, item);
	}
	else {
		if (items[item].flagmay != 256 and items[item].flagmay != 1929312) pInfo(p_)->flagmay = items[item].flagmay;
		ClothTypes type_ = items[item].clothType;
		if (type_ == ClothTypes::ANCES)
			pInfo(p_)->ances = item;
		else if (type_ == ClothTypes::BACK)
			pInfo(p_)->back = item;
		else if (type_ == ClothTypes::FEET)
			pInfo(p_)->feet = item;
		else if (type_ == ClothTypes::FACE)
			pInfo(p_)->face = item;
		else if (type_ == ClothTypes::HAIR)
			pInfo(p_)->hair = item;
		else if (type_ == ClothTypes::HAND)
			pInfo(p_)->hand = item;
		else if (type_ == ClothTypes::MASK)
			pInfo(p_)->mask = item;
		else if (type_ == ClothTypes::NECKLACE)
			pInfo(p_)->necklace = item;
		else if (type_ == ClothTypes::PANTS)
			pInfo(p_)->pants = item;
		else if (type_ == ClothTypes::SHIRT)
			pInfo(p_)->shirt = item;
		if (items[item].on_equip != "") {
			gamepacket_t p;
			p.Insert("OnConsoleMessage"), p.Insert(items[item].on_equip + (items[item].playmod != "" ? " (`$" + items[item].playmod + "`` mod added)" : "")), p.CreatePacket(p_);
		}
		packet_(p_, "action|play_sfx\nfile|audio/change_clothes.wav\ndelayMS|0");
		update_clothes(p_);
		if (pInfo(p_)->fishing_used != 0)stop_fishing(p_, true, "Sit still if you wanna fish!");
		if (item == 3172 && has_playmod(pInfo(p_), "Malpractice")) {
			for (int i_ = 0; i_ < pInfo(p_)->playmods.size(); i_++) if (pInfo(p_)->playmods[i_].id == 88) pInfo(p_)->playmods[i_].time = 1;
			gamepacket_t p, p2;
			p.Insert("OnConsoleMessage"), p.Insert("`2Your briefs have stunned the judge!``"), p.CreatePacket(p_);
			p2.Insert("OnTalkBubble"), p2.Insert(pInfo(p_)->netID), p2.Insert("`2Your briefs have stunned the judge!``"), p2.CreatePacket(p_);
			int remove = -1;
			modify_inventory(p_, 3172, remove);
		}
	}
}

int alloc_(World* world_, WorldBlock* block_) {
	if (items[block_->fg].blockType == SEED) return 0;
	if (items[block_->fg].vipentrance) {
		return (block_->admins.size() * 4) + 99;
	}
	else if (items[block_->fg].blockType == BlockTypes::LOCK) {
		if (block_->fg == 202 or block_->fg == 204 or block_->fg == 206 or block_->fg == 4994) {
			return (block_->admins.size() * 4) + 99;
		}
		return (world_->admins.size() * 4) + 99;
	}
	return 99;
}
int form_visual(BYTE*& blc, WorldBlock block_, World world_, ENetPeer* peer, bool case_ = true, bool show = false, int x1 = -1, int y1 = -1) {
	uint32_t ySize = world_.blocks.size() / 100, xSize = world_.blocks.size() / ySize, square = world_.blocks.size();
	if (not case_) {
		memcpy(blc, &block_.fg, 2);
		memcpy(blc + 2, &block_.bg, 2);
		memcpy(blc + 4, &block_.flags, 4);
	}
	if (items[block_.fg].donation || items[block_.fg].mailbox || block_.fg == 3918 || block_.fg == 3928 || block_.fg == 3922) {
		//int test_ = block_.id != 0 ? 0x00400000 : block_.flags;
		int test_ = (show ? (block_.flags | 0x00400000) : block_.flags); // jeigu kazkas yra tada 0x00400000;
		memcpy(blc + 4, &test_, 4);
		BYTE btype = 12;
		memcpy(blc + 8, &btype, 1);
		if (case_) {
			blc += 8;
			return 8;
		}
	}
	else if (items[block_.fg].bulletin_board || items[block_.fg].storage_box || items[block_.fg].mailbox) {
		BYTE btype = 6;
		memcpy(blc + 8, &btype, 1);
		if (case_) {
			blc += 8;
			return 8;
		}
	}
	else if (items[block_.fg].xeno) {
		BYTE btype = 53;
		memcpy(blc + 8, &btype, 1);
		if (case_) {
			blc += 9;
			return 9;
		}
	}
	else if (items[block_.fg].bunny_egg) {
		BYTE btype = 15;
		memcpy(blc + 8, &btype, 1);
		memcpy(blc + 9, &block_.bunny_egg_progress, 4);
		if (case_) {
			blc += 5;
			return 5;
		}
	}
	else if (items[block_.fg].dshelf) {
		BYTE btype = 43;
		memcpy(blc + 8, &btype, 1);
		memcpy(blc + 9, &block_.shelf_1, 4);
		memcpy(blc + 13, &block_.shelf_2, 4);
		memcpy(blc + 17, &block_.shelf_3, 4);
		memcpy(blc + 21, &block_.shelf_4, 4);
		if (case_) {
			blc += 17;
			return 17;
		}
	}
	else if (items[block_.fg].heart_monitor) {
		BYTE btype = 11;
		memcpy(blc + 8, &btype, 1);
		string monitoriaus_tekstas = block_.heart_monitor;
		{
			uint32_t ijungtas = -1;
			for (int i = 0; i < monitors.size(); i++) {
				if (monitors[i].x == x1 and monitors[i].y == y1) {
					ijungtas = monitors[i].active;
					break;
				}
			}
			memcpy(blc + 9, &ijungtas, 4);
			int state_of_block = block_.flags | 0x00400000;
			if (ijungtas) memcpy(blc + 4, &state_of_block, 4);
		}
		uint32_t dydis = uint32_t(monitoriaus_tekstas.size());
		memcpy(blc + 13, &dydis, 2);
		memcpy(blc + 15, monitoriaus_tekstas.c_str(), dydis);
		if (case_) {
			blc += 7 + dydis;
			return 7 + dydis;
		}
	}
	else if (items[block_.fg].trickster) {
		BYTE btype = 52;
		memcpy(blc + 8, &btype, 1);
		if (case_) {
			blc += 1;
			return 1;
		}
	}
	else if (items[block_.fg].vall_mount) {
		BYTE btype = 47;
		memcpy(blc + 8, &btype, 1);
		uint32_t sk = 0;
		memcpy(blc + 9, &sk, 4);
		if (case_) {
			blc += 8;
			return 8;
		}
	}
	else if (items[block_.fg].portrait) {
		BYTE btype = 48;
		memcpy(blc + 8, &btype, 1);
		string sign_tekstas = block_.txt;
		uint32_t dydis = uint32_t(sign_tekstas.size());
		memcpy(blc + 9, &dydis, 2);
		memcpy(blc + 11, sign_tekstas.c_str(), dydis);
		if (block_.portrait.c_skin == 0 and block_.portrait.c_face == 0 and block_.portrait.c_head == 0 and block_.portrait.c_hair == 0) {

		}
		else {
			memcpy(blc + 11 + dydis, &block_.portrait.c_expression, 4);
			memcpy(blc + 19 + dydis, &block_.portrait.c_hair_colour, 4);
			memcpy(blc + 23 + dydis, &block_.portrait.c_skin, 4);
			memcpy(blc + 27 + dydis, &block_.portrait.c_face, 2);
			memcpy(blc + 29 + dydis, &block_.portrait.c_head, 2);
			memcpy(blc + 31 + dydis, &block_.portrait.c_hair, 2);
		}
		if (case_) {
			blc += 7 + 15 + 3 + dydis;
			return 7 + 15 + 3 + dydis;
		}
	}
	else if (items[block_.fg].easel) {
		BYTE btype = 0x23;
		memcpy(blc + 8, &btype, 1);
		memcpy(blc + 9, &block_.id, 4);
		string sign_tekstas = block_.txt;
		uint32_t dydis = uint32_t(sign_tekstas.size());
		memcpy(blc + 13, &dydis, 2);
		memcpy(blc + 15, sign_tekstas.c_str(), dydis);
		if (case_) {
			blc += 7 + dydis;
			return 7 + dydis;
		}
	}
	else if (items[block_.fg].mannequin) {
		BYTE btype = 14;
		memcpy(blc + 8, &btype, 1);
		string sign_tekstas = block_.txt;
		uint32_t dydis = uint32_t(sign_tekstas.size());
		memcpy(blc + 9, &dydis, 2);
		memcpy(blc + 11, sign_tekstas.c_str(), dydis);
		memcpy(blc + 16 + dydis, &block_.mannequin.c_hair, 2);
		memcpy(blc + 18 + dydis, &block_.mannequin.c_shirt, 2);
		memcpy(blc + 20 + dydis, &block_.mannequin.c_pants, 2);
		memcpy(blc + 22 + dydis, &block_.mannequin.c_feet, 2);
		memcpy(blc + 24 + dydis, &block_.mannequin.c_head, 2);
		memcpy(blc + 26 + dydis, &block_.mannequin.c_hand, 2);
		memcpy(blc + 28 + dydis, &block_.mannequin.c_back, 2);
		memcpy(blc + 30 + dydis, &block_.mannequin.c_mask, 2);
		memcpy(blc + 32 + dydis, &block_.mannequin.c_neck, 2);
		if (case_) {
			blc += 26 + dydis;
			return 26 + dydis;
		}
	}
	else if (items[block_.fg].vipentrance) {
		BYTE btype = 44;
		memcpy(blc + 8, &btype, 1);
		vector<int> vip_members;
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
			if (pInfo(currentPeer)->world == world_.name or currentPeer == peer) {
				if (block_.limit_admins or find(block_.admins.begin(), block_.admins.end(), pInfo(currentPeer)->tankIDName) != block_.admins.end() or pInfo(currentPeer)->tankIDName == world_.owner_name or world_.owner_name.empty()) {
					vip_members.push_back(pInfo(currentPeer)->id);
				}
			}
		}
		uint32_t sk = vip_members.size();
		memcpy(blc + 14, &sk, 1);
		for (int i = 0; i < vip_members.size(); i++) {
			memcpy(blc + 18 + (i * 4), &vip_members[i], 4);
		}
		if (case_) {
			blc += 10 + (sk * 4);
			return 10 + (sk * 4);
		}
	}

	else if (items[block_.fg].timer) {
		BYTE btype = 45;
		memcpy(blc + 8, &btype, 1);
		if (case_) {
			blc += 1;
			return 1;
		}
	}
	else if (items[block_.fg].trans) {
		BYTE btype = 19;
		memcpy(blc + 8, &btype, 1);
		if (case_) {
			blc += 19;
			return 19;
		}
	}
	else if (items[block_.fg].battle_cage) {
	BYTE btype = 0x24;
	int pet = block_.battle_pet;
	string text = block_.txt;
	uint32_t length = uint32_t(text.length());
	memcpy(blc + 8, &btype, 1);
	memcpy(blc + 9, &length, 2);
	memcpy(blc + 11, text.c_str(), length);
	memcpy(blc + 11 + length, &pet, 4);
	if (case_) {
		blc += 15 + length;
		return 15 + length;
	}
	}
	else if (items[block_.fg].infinitymachine) {
		BYTE btype = 19;
		memcpy(blc + 8, &btype, 1);
		if (case_) {
			blc += 19;
			return 19;
		}
	}
	else if (items[block_.fg].spirit) {
		BYTE btype = 41;
		memcpy(blc + 8, &btype, 1);
		uint32_t sk = block_.c_;
		memcpy(blc + 9, &sk, 4);
		if (case_) {
			blc += 5;
			return 5;
		}
	}
	else if (items[block_.fg].charger) {
		int test_ = block_.id != 0 ? 0x00400000 : block_.flags;
		memcpy(blc + 4, &test_, 4);
		BYTE btype = 57;
		memcpy(blc + 8, &btype, 1);
		long long time_ = time(nullptr);
		uint16_t sk = (block_.planted - time_ <= 0 ? 3600 : 3600 - (block_.planted - time_));
		memcpy(blc + 9, &sk, 2);
		if (case_) {
			blc += 5;
			return 5;
		}
	}
	else if (items[block_.fg].magplant or items[block_.fg].item_sucker) {
		switch (block_.fg) {
		case 5638: // magplant
		{
			uint8_t magnetronas_ijungtas = block_.magnetron ? 1 : 0;
			uint8_t active_ = block_.enabled ? 1 : 0;
			uint32_t block_id = block_.id;
			uint32_t item_count = block_.pr;
			uint32_t kiek_telpa = 5000;
			BYTE btype = 62;
			memcpy(blc + 8, &btype, 1);
			memcpy(blc + 9, &block_id, 4);
			memcpy(blc + 13, &item_count, 4);
			memcpy(blc + 17, &active_, 1);
			memcpy(blc + 18, &magnetronas_ijungtas, 1);
			memcpy(blc + 20, &kiek_telpa, 2);
			if (case_) {
				blc += 15;
				return 15;
			}
			break;
		}
		case 6948: case 6946:
		{
			int max_telpa = 1500;
			int active_ = block_.enabled ? 1 : 0;
			int block_id = block_.id;
			int item_count = block_.pr;
			BYTE btype = 62;
			memcpy(blc + 8, &btype, 1);
			memcpy(blc + 9, &block_id, 4);
			memcpy(blc + 13, &item_count, 4);
			memcpy(blc + 17, &active_, 4);
			memcpy(blc + 21, &max_telpa, 4);
			if (case_) {
				blc += 15;
				return 15;
			}
			break;
		}
		case 6950: case 6952:
		{
			int actually_active = block_.pr > 0 ? 1 : 0;
			int amount_of_gems = block_.pr;
			int block_id = block_.id;
			int is_enabled = block_.enabled ? 1 : 0;
			BYTE btype = (block_.fg == 6950 ? 70 : 69);
			memcpy(blc + 8, &btype, 1);
			memcpy(blc + 9, &actually_active, 4);
			memcpy(blc + 13, &amount_of_gems, 4);
			memcpy(blc + 17, &block_id, 4);
			memcpy(blc + 21, &is_enabled, 4);
			if (case_) {
				blc += 13;
				return 13;
			}
		}
		}
	}
	else {
		switch (items[block_.fg].blockType) {
		case BlockTypes::CRYSTAL:
		{
			BYTE btype = 20;
			memcpy(blc + 8, &btype, 1);
			string text = "";
			int l_ = (int)text.size();
			memcpy(blc + 9, &l_, 2);
			memcpy(blc + 11, text.c_str(), l_);
			if (case_) {
				blc += 3 + l_;
				return 3 + l_;
			}
			break;
		}
		case BlockTypes::WEATHER:
		{
			switch (block_.fg) {
			case 3694:
			{
				BYTE btype = 0x28;
				memcpy(blc + 8, &btype, 1);
				int rgb = (block_.b << 24) | (block_.g << 16) | (block_.r << 8);
				memcpy(blc + 9, &rgb, 4);
				if (case_) {
					blc += 5;
					return 5;
				}
				break;
			}
			case 5000:
			{
				BYTE btype = 40;
				memcpy(blc + 8, &btype, 1);
				uint32_t item_id = (block_.id != 0 ? block_.id : 14);
				memcpy(blc + 9, &item_id, 4);
				if (case_) {
					blc += 5;
					return 5;
				}
				break;
			}
			case 3832:
			{
				BYTE btype = 49;
				memcpy(blc + 8, &btype, 1);
				uint32_t item_id = (block_.id != 0 ? block_.id : 2);
				uint32_t item_gravity = block_.gravity;
				uint8_t item_status = (int)block_.spin | ((int)block_.invert << 1);
				memcpy(blc + 9, &item_id, 4);
				memcpy(blc + 13, &item_gravity, 4);
				memcpy(blc + 17, &item_status, 4);
				if (case_) {
					blc += 10;
					return 10;
				}
				break;
			}
			
			default:
			{
				if (items[block_.fg].ext_weather) {
					BYTE btype = 5;
					memcpy(blc + 8, &btype, 1);
					if (case_) {
						blc += 1;
						return 1;
					}
				}
			}
			}
			break;
		}
		case BlockTypes::VENDING:
		{
			uint32_t item_id = block_.id;
			uint32_t item_price = block_.pr;
			uint32_t item_count = block_.c_;
			uint32_t vend_available_wls = block_.wl;
			int visual = block_.flags | ((int)item_id == 0 ? ((int)vend_available_wls != 0 ? 0x02000000 : 0x00000000) : ((int)vend_available_wls != 0 ? 0x02410000 : 0x00410000));
			if ((int)item_price < 0 and (int)item_id != 0) {
				if ((int)item_count < ((int)item_price * -1))
					item_id = 0, item_price = 0;
				visual = block_.flags | (((int)item_count < ((int)item_price * -1)) ? ((int)vend_available_wls != 0 ? 0x02410000 : 0x00410000) : ((int)vend_available_wls != 0 ? 0x02410000 : 0x00410000));
			}
			memcpy(blc + 4, &visual, 4);
			BYTE btype = 24;
			memcpy(blc + 8, &btype, 1);
			memcpy(blc + 9, &item_id, 4);
			memcpy(blc + 13, &item_price, 4);
			if (case_) {
				blc += 9;
				return 9;
			}
			break;
		}
		case BlockTypes::DISPLAY:
		{
			BYTE btype = 23;
			memcpy(blc + 8, &btype, 1);
			uint32_t id_ = block_.id;
			memcpy(blc + 9, &id_, 4);
			if (case_) {
				blc += 5;
				return 5;
			}
			break;
		}
		case BlockTypes::PROVIDER:
		{
			BYTE btype = 9;
			memcpy(blc + 8, &btype, 1);
			uint32_t laikas = uint32_t((time(nullptr) - block_.planted <= items[block_.fg].growTime ? time(nullptr) - block_.planted : items[block_.fg].growTime));
			memcpy(blc + 9, &laikas, 4);
			if (case_) {
				blc += 5;
				return 5;
			}
			break;
		}
		case BlockTypes::RANDOM_BLOCK:
		{
			BYTE btype = 8;
			memcpy(blc + 8, &btype, 1);
			memcpy(blc + 9, &block_.roll, 1);
			if (case_) {
				blc += 2;
				return 2;
			}
			break;
		}
		case BlockTypes::LOCK:
		{
			if (block_.open_to_public) {
				int new_ = 0x00800000;
				memcpy(blc + 4, &new_, 4);
			}
			BYTE btype = 3;
			memcpy(blc + 8, &btype, 1);
			uint8_t world_settings = world_.disable_music_blocks ? (world_.make_music_blocks_invisible ? 12345 : 1234) : (world_.make_music_blocks_invisible ? 100 : 0);
			if (world_.rainbows and block_.fg == 4802) world_settings += 128;
			uint32_t world_owner_id = -1;
			{
				if (block_.fg == 202 or block_.fg == 204 or block_.fg == 206 or block_.fg == 4994) {
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
						if (block_.owner_name == pInfo(currentPeer)->tankIDName) {
							world_owner_id = pInfo(currentPeer)->id;
						}
					}
				}
				else {
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
						if (world_.owner_name == pInfo(currentPeer)->tankIDName) {
							world_owner_id = pInfo(currentPeer)->id;
						}
					}
				}
			}
			uint32_t admin_id = 0;
			uint32_t bpm_ = world_.music_bpm * -1; //world_.music_bpm * -1
			memcpy(blc + 9, &world_settings, 1);
			memcpy(blc + 10, &world_owner_id, 4);
			memcpy(blc + 18, &bpm_, 4);
			uint32_t count_of_admins = 1;
			{
				if (block_.fg == 202 or block_.fg == 204 or block_.fg == 206 or block_.fg == 4994) {
					if (peer != NULL and find(block_.admins.begin(), block_.admins.end(), pInfo(peer)->tankIDName) != block_.admins.end()) {
						memcpy(blc + 22, &pInfo(peer)->id, 4);
						count_of_admins++;
					} for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
						if (pInfo(currentPeer)->world == world_.name) {
							if (find(block_.admins.begin(), block_.admins.end(), pInfo(currentPeer)->tankIDName) != block_.admins.end()) {
								if (count_of_admins == 1) {
									memcpy(blc + 22, &pInfo(currentPeer)->id, 4);
								}
								else {
									memcpy(blc + 22 + (count_of_admins * 4), &pInfo(currentPeer)->id, 4);
								}
								count_of_admins++;
								//if (count_of_admins > 7) break;
							}
						}
					}
				}
				else {
					if (peer != NULL and guild_access(peer, world_.guild_id) or find(world_.admins.begin(), world_.admins.end(), pInfo(peer)->tankIDName) != world_.admins.end()) {
						memcpy(blc + 22, &pInfo(peer)->id, 4);
						count_of_admins++;
					} for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
						if (pInfo(currentPeer)->world == world_.name) {
							if (guild_access(currentPeer, world_.guild_id) or find(world_.admins.begin(), world_.admins.end(), pInfo(currentPeer)->tankIDName) != world_.admins.end()) {
								if (count_of_admins == 1) {
									memcpy(blc + 22, &pInfo(currentPeer)->id, 4);
								}
								else {
									memcpy(blc + 22 + (count_of_admins * 4), &pInfo(currentPeer)->id, 4);
								}
								count_of_admins++;
								//if (count_of_admins > 7) break;
							}
						}
					}
				}
				memcpy(blc + 14, &count_of_admins, 1);
			}
			if (block_.fg == 5814 and world_.guild_id != 0) {
				uint32_t guild_id = world_.guild_id;
				vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
				if (p != guilds.end()) {
					Guild* guild_information = &guilds[p - guilds.begin()];
					if (not case_) {
						memcpy(blc + 30 + (count_of_admins * 4), &guild_information->guild_mascot[0], 2);
						memcpy(blc + 30 + (count_of_admins * 4) + 2, &guild_information->guild_mascot[1], 2);
						memcpy(blc + 30 + (count_of_admins * 4) + 4, &guild_information->guild_level, 2);
						memcpy(blc + 30 + (count_of_admins * 4) + 8, &guild_information->unlocked_mascot, 1);
					}
					else {
						memcpy(blc + (count_of_admins == 1 ? 22 : 22 + ((count_of_admins - 1) * 4)) + 4, &guild_information->guild_mascot[0], 2);
						memcpy(blc + (count_of_admins == 1 ? 22 : 22 + ((count_of_admins - 1) * 4)) + 6, &guild_information->guild_mascot[1], 2);
						memcpy(blc + (count_of_admins == 1 ? 22 : 22 + ((count_of_admins - 1) * 4)) + 8, &guild_information->guild_level, 2);
						memcpy(blc + (count_of_admins == 1 ? 22 : 22 + ((count_of_admins - 1) * 4)) + 12, &guild_information->unlocked_mascot, 1);
					}
					if (case_) {
						blc += 26 + (count_of_admins * 4);
						return 26 + (count_of_admins * 4);
					}
				}
			}
			else {
				if (case_) {
					blc += 10 + (count_of_admins * 4);
					return 10 + (count_of_admins * 4);
				}
			}
			break;
		}
		case BlockTypes::MAIN_DOOR:
		{
			BYTE btype = 1;
			memcpy(blc + 8, &btype, 1);
			string text = "EXIT";
			int l_ = (int)text.size();
			memcpy(blc + 9, &l_, 2);
			memcpy(blc + 11, text.c_str(), l_);
			if (case_) {
				blc += 4 + l_;
				return 4 + l_;
			}
			break;
		}
		case BlockTypes::SEED:
		{
			int visual = block_.flags | 0x100000;
			memcpy(blc + 4, &visual, 4);
			BYTE data_type = 4;
			memcpy(blc + 8, &data_type, 1);
			uint32_t laikas = uint32_t((time(nullptr) - block_.planted <= items[block_.fg].growTime ? time(nullptr) - block_.planted : items[block_.fg].growTime));
			uint8_t count = uint8_t(block_.fruit);
			memcpy(blc + 9, &laikas, 4);
			memcpy(blc + 13, &count, 1);
			if (case_) {
				blc += 6;
				return 6;
			}
			break;
		}
		case BlockTypes::DOOR: case BlockTypes::PORTAL:
		{
			BYTE data_type = 1;
			memcpy(blc + 8, &data_type, 1);
			string duru_tekstas = (block_.txt.empty() ? (block_.door_destination.empty() ? "" : (block_.door_destination.find(":") != string::npos ? explode(":", block_.door_destination)[0] + "..." : block_.door_destination)) : block_.txt);
			uint32_t dydis = uint32_t(duru_tekstas.size());
			memcpy(blc + 9, &dydis, 2);
			memcpy(blc + 11, duru_tekstas.c_str(), dydis);
			uint8_t locked_ = (block_.open ? 0 : 0x08);
			memcpy(blc + 11 + dydis, &locked_, 1);
			if (case_) {
				blc += 4 + dydis;
				return 4 + dydis;
			}
			break;
		}
		case BlockTypes::SIGN:
		{
			BYTE data_type = 2;
			memcpy(blc + 8, &data_type, 1);
			string sign_tekstas = block_.txt;
			uint32_t dydis = uint32_t(sign_tekstas.size());
			memcpy(blc + 9, &dydis, 2);
			memcpy(blc + 11, sign_tekstas.c_str(), dydis);
			uint32_t nzn_kas = 0;
			memcpy(blc + 11 + dydis, &nzn_kas, 1);
			if (case_) {
				blc += 7 + dydis;
				return 7 + dydis;
			}
			break;
		}
		}
	}
	return 0;
}
void upd_lock(WorldBlock block_2, World world_, ENetPeer* peer) {
	int l_x = block_2.lock_origin % 100;
	int l_y = block_2.lock_origin / 100;
	WorldBlock block_ = world_.blocks[l_x + (l_y * 100)];
	vector<WorldBlock> shadow_copy_2 = world_.blocks;
	vector<vector<int>> locked_tiles_around_lock{};
	vector<int> new_tiles{};
	new_tiles.push_back(l_x + (l_y * 100));
	try {
		for (int i2 = 0; i2 < new_tiles.size(); i2++) {
			int s_x_ = new_tiles.at(i2) % 100, s_y_ = new_tiles.at(i2) / 100;
			if (s_x_ < 99 and shadow_copy_2.at(s_x_ + 1 + (s_y_ * 100)).locked and shadow_copy_2.at(s_x_ + 1 + (s_y_ * 100)).lock_origin == (l_x + (l_y * 100))) {
				if (not shadow_copy_2.at(s_x_ + 1 + (s_y_ * 100)).scanned) {
					shadow_copy_2.at(s_x_ + 1 + (s_y_ * 100)).scanned = true;
					new_tiles.push_back(s_x_ + 1 + (s_y_ * 100));
					locked_tiles_around_lock.push_back({ s_x_ + 1, s_y_ });
				}
			} if (s_x_ > 0 and shadow_copy_2.at(s_x_ - 1 + (s_y_ * 100)).locked and shadow_copy_2.at(s_x_ - 1 + (s_y_ * 100)).lock_origin == (l_x + (l_y * 100))) {
				if (not shadow_copy_2.at(s_x_ - 1 + (s_y_ * 100)).scanned) {
					shadow_copy_2.at(s_x_ - 1 + (s_y_ * 100)).scanned = true;
					new_tiles.push_back(s_x_ - 1 + (s_y_ * 100));
					locked_tiles_around_lock.push_back({ s_x_ - 1, s_y_ });
				}
			} if (s_y_ < 59 and shadow_copy_2.at(s_x_ + ((s_y_ + 1) * 100)).locked and shadow_copy_2.at(s_x_ + ((s_y_ + 1) * 100)).lock_origin == (l_x + (l_y * 100))) {
				if (not shadow_copy_2.at(s_x_ + ((s_y_ + 1) * 100)).scanned) {
					shadow_copy_2.at(s_x_ + ((s_y_ + 1) * 100)).scanned = true;
					new_tiles.push_back(s_x_ + ((s_y_ + 1) * 100));
					locked_tiles_around_lock.push_back({ s_x_, s_y_ + 1 });
				}
			} if (s_y_ > 0 and shadow_copy_2.at(s_x_ + ((s_y_ - 1) * 100)).locked and shadow_copy_2.at(s_x_ + ((s_y_ - 1) * 100)).lock_origin == (l_x + (l_y * 100))) {
				if (not shadow_copy_2.at(s_x_ + ((s_y_ - 1) * 100)).scanned) {
					shadow_copy_2.at(s_x_ + ((s_y_ - 1) * 100)).scanned = true;
					new_tiles.push_back(s_x_ + ((s_y_ - 1) * 100));
					locked_tiles_around_lock.push_back({ s_x_, s_y_ - 1 });
				}
			}
		}
	}
	catch (out_of_range) {

	}
	int lock_size = locked_tiles_around_lock.size();
	if (locked_tiles_around_lock.size() != 0) {
		PlayerMoving data_{};
		data_.packetType = 15, data_.punchX = l_x, data_.punchY = l_y, data_.characterState = 0x8;
		data_.netID = peer == NULL ? -1 : (block_.owner_name == pInfo(peer)->tankIDName ? pInfo(peer)->id : -1);
		data_.plantingTree = block_.fg;
		BYTE* raw;
		raw = packPlayerMoving(&data_, 112 + (locked_tiles_around_lock.size() * 2) + alloc_(&world_, &block_));
		int lalala = 8;
		memcpy(raw + 8, &lock_size, 2);
		memcpy(raw + 12, &lalala, 2);
		BYTE* blc = raw + 56;
		for (int i_ = 0; i_ < locked_tiles_around_lock.size(); i_++) {
			vector<int> update_tiles = locked_tiles_around_lock[i_];
			int x = update_tiles[0];
			int y = update_tiles[1];
			int sq_ = x + (y * 100);
			memcpy(blc + (i_ * 2), &sq_, 2);
			shadow_copy_2[x + (y * 100)].scanned = false;
		}
		PlayerMoving data_2{};
		data_2.packetType = 5, data_2.punchX = l_x, data_2.punchY = l_y, data_2.characterState = 0x8;
		BYTE* raw2 = packPlayerMoving(&data_2, 112 + alloc_(&world_, &block_));
		BYTE* blc2 = raw2 + 56;
		form_visual(blc2, block_, world_, peer, false);
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) { //fix
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
			if (world_.name == pInfo(currentPeer)->world) {
				send_raw(currentPeer, 4, raw, 112 + (locked_tiles_around_lock.size() * 2) + alloc_(&world_, &block_), ENET_PACKET_FLAG_RELIABLE);
				send_raw(currentPeer, 4, raw2, 112 + alloc_(&world_, &block_), ENET_PACKET_FLAG_RELIABLE);
			}
		}
		delete[] raw, blc;
		delete[] raw2, blc2;
	}
	else {
		PlayerMoving data_{};
		data_.packetType = 15, data_.punchX = l_x, data_.punchY = l_y, data_.characterState = 0x8;
		data_.netID = block_.owner_name == pInfo(peer)->tankIDName ? pInfo(peer)->id : -1;
		data_.plantingTree = block_.fg;
		BYTE* raw = packPlayerMoving(&data_, 56);
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
			if (world_.name == pInfo(currentPeer)->world) {
				send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
				PlayerMoving data_2{};
				data_2.packetType = 5, data_2.punchX = l_x, data_2.punchY = l_y, data_2.characterState = 0x8;
				BYTE* raw2 = packPlayerMoving(&data_2, 112 + alloc_(&world_, &block_));
				BYTE* blc2 = raw2 + 56;
				form_visual(blc2, block_, world_, currentPeer, false);
				send_raw(currentPeer, 4, raw2, 112 + alloc_(&world_, &block_), ENET_PACKET_FLAG_RELIABLE);
				delete[] raw2, blc2;
			}
		}
		delete[] raw;
	}
}

void add_ipban(ENetPeer* peer) {
	vector<string> bans;
	ifstream ifs("db/ip.json");
	if (ifs.is_open()) {
		json j;
		ifs >> j;
		vector<string> bans2 = j["ip"];
		bans = bans2;
	}
	ipbans.push_back(pInfo(peer)->ip);
	bans.push_back(pInfo(peer)->ip);
	ofstream o("db/ip.json");
	if (!o.is_open()) return;
	json j;
	j["ip"] = bans;
	o << j << endl;
	pInfo(peer)->bans.push_back("`6ON:`` `#" + (not pInfo(peer)->d_name.empty() ? pInfo(peer)->d_name : pInfo(peer)->tankIDName) + "`` `0(" + pInfo(peer)->requestedName + ") #" + to_string(pInfo(peer)->netID) + "`` IP BAN: " + pInfo(peer)->ip + " ");
}

void replaceAll(string& str, const string& from, const string& to) {
	if (from.empty())return;
	size_t start_pos = 0;
	while ((start_pos = str.find(from, start_pos)) != string::npos) {
		str.replace(start_pos, from.length(), to);
		start_pos += to.length(); // In case 'to' contains 'from', like replacing 'x' with 'yx'
	}
}

string fixchar(string name) {
	string newS;
	for (char c : name) newS += (c >= 'A' && c <= 'Z') ? c - ('A' - 'a') : c;
	string ret;
	for (int i = 0; i < newS.length(); i++) if (newS[i] == '`') i++; else ret += newS[i];
	string ret2;
	for (char c : ret) if ((c >= 'a' && c <= 'z') || (c >= '0' && c <= '9')) ret2 += c;
	return ret2;
}

void add_modlogs(ENetPeer* peer, string bywho, string text, string timed) {
	gamepacket_t p;
	p.Insert("OnConsoleMessage");
	p.Insert("CT:[FC]_>> `r>> [MOD-LOGS] ``" + bywho + "`` `r" + text + "" + (timed != "" ? " for " + timed + "``" : ""));
	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
		if (pInfo(currentPeer)->mod + pInfo(currentPeer)->dev == 0) continue;
		p.CreatePacket(currentPeer);
	}
}
void add_nukelogs(ENetPeer* peer, string bywho, string text, string timed) {
	gamepacket_t p;
	p.Insert("OnConsoleMessage");
	p.Insert("CT:[FC]_>> `r>> [MOD-LOGS] ``" + bywho + "`` `r" + text + "" + (timed != "" ? "" + timed + "``" : ""));
	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
		if (pInfo(currentPeer)->mod + pInfo(currentPeer)->dev == 0) continue;
		p.CreatePacket(currentPeer);
	}
}

void add_ban(ENetPeer* peer, long long int seconds, string reason, string bannedby) {
	if (pInfo(peer)->b_t + (seconds * 1000) < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) {
		struct tm newtime;
		time_t now = time(0);
		localtime_s(&newtime, &now);
		//pInfo(peer)->logs.push_back("" + to_string(newtime.tm_mon + 1) + "/" + to_string(today_day) + "/2021 " + to_string(newtime.tm_hour) + ":" + (newtime.tm_min < 10 ? "0" + to_string(newtime.tm_min) + "" : "" + to_string(newtime.tm_min)) + ":" + to_string(newtime.tm_sec) + " " + bannedby + " - >> Ban for " + to_string(seconds) + " seconds(" + reason + ")");
		if (reason != "Ban Wand Effect") pInfo(peer)->bans.push_back("`6ON:`` `#" + (not pInfo(peer)->d_name.empty() ? pInfo(peer)->d_name : pInfo(peer)->tankIDName) + "`` `0(" + pInfo(peer)->requestedName + ") #" + to_string(pInfo(peer)->netID) + "`` Time: " + ((seconds / 86400 > 0) ? to_string(seconds / 86400) + " days" : (seconds / 3600 > 0) ? to_string(seconds / 3600) + " hours" : (seconds / 60 > 0) ? to_string(seconds / 60) + " minutes" : to_string(seconds) + " seconds") + " IP: " + pInfo(peer)->ip + " (banned by: " + bannedby + ", reason: " + reason + ") ");
		pInfo(peer)->b_s = (seconds * 1000);
		pInfo(peer)->b_r = reason;
		pInfo(peer)->b_b = bannedby;
		pInfo(peer)->b_t = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
		update_clothes(peer);
		{
			gamepacket_t p;
			p.Insert("OnConsoleMessage");
			p.Insert("`oReality flickers as you begin to wake up. (`$Ban`` mod added, " + ((seconds / 86400 > 0) ? to_string(seconds / 86400) + " days" : (seconds / 3600 > 0) ? to_string(seconds / 3600) + " hours" : (seconds / 60 > 0) ? to_string(seconds / 60) + " minutes" : to_string(seconds) + " seconds") + " left)");
			p.CreatePacket(peer);
			packet_(peer, "action|play_sfx\nfile|audio/dialog_confirm.wav\ndelayMS|0");
		}
		gamepacket_t p, p2;
		p.Insert("OnConsoleMessage");
		p.Insert((bannedby == "System" ? "`4**`` " + (not pInfo(peer)->d_name.empty() ? pInfo(peer)->d_name : pInfo(peer)->tankIDName) + " `4AUTO-BANNED BY SYSTEM **`` (/rules to view rules)" : "`#**`` `$The Ancients`` have used `#Ban`` on ``" + (not pInfo(peer)->d_name.empty() ? pInfo(peer)->d_name : pInfo(peer)->name_color + pInfo(peer)->tankIDName) + "`` `#**``"));
		p2.Insert("OnConsoleMessage");
		p2.Insert("`#**`` `$The Ancient Ones`` have `bBanned`` " + (not pInfo(peer)->d_name.empty() ? pInfo(peer)->d_name : pInfo(peer)->name_color + pInfo(peer)->tankIDName) + "`` `#**`` (`4/rules`` to see the rules!)");
		gamepacket_t p3(0, pInfo(peer)->netID);
		p3.Insert("OnPlayPositioned");
		p3.Insert("audio/keypad_hit.wav");
		cout << "[" + currentDateTime() + "] ** The Ancient Ones have " << "banned " << pInfo(peer)->tankIDName << " ** (" << "/rules"  " to see the rules!)" << endl;
		cout << "[" << currentDateTime() << "] " << bannedby << " banned " << pInfo(peer)->tankIDName << ". Reason: " << reason << ". Duration: " + ((seconds / 86400 > 0) ? to_string(seconds / 86400) + " days" : (seconds / 3600 > 0) ? to_string(seconds / 3600) + " hours" : (seconds / 60 > 0) ? to_string(seconds / 60) + " minutes" : to_string(seconds) + " seconds") + ". " << endl;
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
			if (pInfo(currentPeer)->world == pInfo(peer)->world) {
				p.CreatePacket(currentPeer), p3.CreatePacket(currentPeer);
			}
			else {
				p2.CreatePacket(currentPeer);
			}
		}
		{
			gamepacket_t p;
			p.Insert("OnConsoleMessage");
			p.Insert("`oWarning from `4System``: You've been `bBanned`` from `wGrowtopiaMY`` for " + ((seconds / 86400 > 0) ? to_string(seconds / 86400) + " days" : (seconds / 3600 > 0) ? to_string(seconds / 3600) + " hours" : (seconds / 60 > 0) ? to_string(seconds / 60) + " minutes" : to_string(seconds) + " seconds"));
			p.CreatePacket(peer);
			{
				gamepacket_t p;
				p.Insert("OnAddNotification");
				p.Insert("interface/atomic_button.rttex");
				p.Insert("`wWarning from `4System``: You've been `bBanned`` from GrowtopiaMY for " + ((seconds / 86400 > 0) ? to_string(seconds / 86400) + " days" : (seconds / 3600 > 0) ? to_string(seconds / 3600) + " hours" : (seconds / 60 > 0) ? to_string(seconds / 60) + " minutes" : to_string(seconds) + " seconds"));
				p.Insert("audio/hub_open.wav");
				p.Insert(0);
				p.CreatePacket(peer);
			}
		}
		enet_peer_disconnect_later(peer, 0);
	}
}

void add_mute(ENetPeer* peer, int seconds, string reason, string muttedby) {
	if (not has_playmod(pInfo(peer), "duct tape")) {
		PlayMods give_playmod{};
		give_playmod.id = 11;
		give_playmod.time = time(nullptr) + seconds;
		pInfo(peer)->playmods.push_back(give_playmod);
		pInfo(peer)->m_r = reason;
		update_clothes(peer);
		{
			gamepacket_t p;
			p.Insert("OnConsoleMessage");
			p.Insert("`oDuct tape has covered your mouth! (`$Duct Tape`` mod added, " + ((seconds / 86400 > 0) ? to_string(seconds / 86400) + " days" : (seconds / 3600 > 0) ? to_string(seconds / 3600) + " hours" : (seconds / 60 > 0) ? to_string(seconds / 60) + " minutes" : to_string(seconds) + " seconds") + " left)");
			p.CreatePacket(peer);
			cout << "[" + currentDateTime() + "] ** The Gods have " << "duct-taped " << pInfo(peer)->tankIDName << "'s mouth ** (" << "/rules"  " to see the rules!)" << endl;
			cout << "[" << currentDateTime() << "] SYSTEM muted " << pInfo(peer)->tankIDName << ". Reason: " << reason << ". Duration: " + ((seconds / 86400 > 0) ? to_string(seconds / 86400) + " days" : (seconds / 3600 > 0) ? to_string(seconds / 3600) + " hours" : (seconds / 60 > 0) ? to_string(seconds / 60) + " minutes" : to_string(seconds) + " seconds") + ". " << endl;
		}
		gamepacket_t p;
		p.Insert("OnConsoleMessage");
		p.Insert("`#**`` `$The Gods`` have duct-taped " + (not pInfo(peer)->d_name.empty() ? pInfo(peer)->d_name : pInfo(peer)->name_color + pInfo(peer)->tankIDName) + "`o's mouth `#**`` (`4/rules`` to see the rules!)");
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
			p.CreatePacket(currentPeer);
		}
		{
			gamepacket_t p;
			p.Insert("OnConsoleMessage");
			p.Insert("`oWarning from `4Admin``: You've been `4duct-taped`` for " + ((seconds / 86400 > 0) ? to_string(seconds / 86400) + " days" : (seconds / 3600 > 0) ? to_string(seconds / 3600) + " hours" : (seconds / 60 > 0) ? to_string(seconds / 60) + " minutes" : to_string(seconds) + " seconds"));
			p.CreatePacket(peer);
			{
				gamepacket_t p;
				p.Insert("OnAddNotification");
				p.Insert("interface/atomic_button.rttex");
				p.Insert("`wWarning from `4Admin``: You've been `4duct-taped`` for " + ((seconds / 86400 > 0) ? to_string(seconds / 86400) + " days" : (seconds / 3600 > 0) ? to_string(seconds / 3600) + " hours" : (seconds / 60 > 0) ? to_string(seconds / 60) + " minutes" : to_string(seconds) + " seconds"));
				p.Insert("audio/hub_open.wav");
				p.Insert(0);
				p.CreatePacket(peer);
			}
		}
	}
}

void SendRespawn(ENetPeer* peer, bool kickall, int instant, bool kill = false) {
	if (pInfo(peer)->trading_with != -1) {
		cancel_trade(peer, false, true);
	}
	if (pInfo(peer)->respawn_time + 1000 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count() || kickall) {
		pInfo(peer)->respawn_time = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
		string name_ = pInfo(peer)->world;
		vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
		if (p != worlds.end()) {
			World* world_ = &worlds[p - worlds.begin()];
			WorldBlock* block_ = &world_->blocks[pInfo(peer)->c_x + (pInfo(peer)->c_y * 100)];
			uint16_t t_ = (block_->fg ? block_->fg : block_->bg);
			if (items[t_].blockType == BlockTypes::CHECKPOINT or items[t_].blockType == BlockTypes::MAIN_DOOR) {
			}
			else {
				int ySize = (int)world_->blocks.size() / 100, xSize = (int)world_->blocks.size() / ySize, square = (int)world_->blocks.size();
				for (int i_ = 0; i_ < square; i_++) {
					if (items[world_->blocks[i_].fg].blockType == BlockTypes::MAIN_DOOR) {
						pInfo(peer)->c_x = (i_ % xSize);
						pInfo(peer)->c_y = (i_ / xSize);
						gamepacket_t p(0, pInfo(peer)->netID);
						p.Insert("SetRespawnPos");
						p.Insert(i_);
						p.CreatePacket(peer);
						break;
					}
				}
			}
		}
		{
			gamepacket_t p(0, pInfo(peer)->netID);
			p.Insert("OnSetFreezeState");
			p.Insert(2);
			p.CreatePacket(peer);
		}

		{
			gamepacket_t p(0, pInfo(peer)->netID);
			p.Insert("SetRespawnPos");
			p.Insert(pInfo(peer)->c_x + (pInfo(peer)->c_y * 100));
			p.CreatePacket(peer);
		}
		{
			if (kill) {
				gamepacket_t p(0, pInfo(peer)->netID);
				p.Insert("OnKilled");
				p.CreatePacket(peer);
			}
		}
		{

			gamepacket_t p((instant == 0 ? 2000 : 100), pInfo(peer)->netID);
			p.Insert("OnSetPos");
			p.Insert(float(pInfo(peer)->c_x) * 32, float(pInfo(peer)->c_y) * 32);
			p.CreatePacket(peer);
		}
		{
			gamepacket_t p((instant == 0 ? 2020 : 100), pInfo(peer)->netID);
			p.Insert("OnPlayPositioned");
			p.Insert("audio/teleport.wav");
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
				if (pInfo(currentPeer)->world == pInfo(peer)->world) {
					p.CreatePacket(currentPeer);
				}
			}
		}
		{
			gamepacket_t p((instant == 0 ? 2000 : 100), pInfo(peer)->netID);
			p.Insert("OnSetFreezeState");
			p.Insert(0);
			p.CreatePacket(peer);
		}
	}
}

void end_surgery(ENetPeer* peer) {
	if (pInfo(peer)->surgery_started) {
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != pInfo(peer)->world) continue;
			if (pInfo(peer)->surged_person != "" && pInfo(peer)->surged_person == pInfo(currentPeer)->tankIDName) SendRespawn(currentPeer, true, 0, 1);
			gamepacket_t p;
			p.Insert("OnConsoleMessage"), p.Insert("`7[```w" + pInfo(peer)->name_color + pInfo(peer)->tankIDName + "`` `4failed to save`` " + pInfo(peer)->surged_display + " from " + pInfo(peer)->surgery_name + "!`7]``"), p.CreatePacket(currentPeer);
		}
		gamepacket_t p, p2;
		p.Insert("OnConsoleMessage"), p.Insert("`4The patient has succumbed to infection.`` `4YOUR MEDICAL LICENSE IS REVOKED!``"), p.CreatePacket(peer);
		p2.Insert("OnConsoleMessage"), p2.Insert("You are not allowed to perform surgery for a while! (`$Malpractice`` mod added, `$1 hour`` left)"), p2.CreatePacket(peer);
		if (pInfo(peer)->started_type != 30) {
			PlayMods new_playmod{};
			int seconds = 3600;
			if (thedaytoday == 6) seconds = 900;
			if (pInfo(peer)->pants == 3172) seconds = 0;
			if (pInfo(peer)->necklace == 8954) seconds *= 0.75;
			new_playmod.id = 88, new_playmod.time = time(nullptr) + seconds;
			pInfo(peer)->playmods.push_back(new_playmod);
			if (pInfo(peer)->pants == 3172) {
				gamepacket_t p, p2;
				p.Insert("OnConsoleMessage"), p.Insert("`2Your briefs have stunned the judge!``"), p.CreatePacket(peer);
				p2.Insert("OnTalkBubble"), p2.Insert(pInfo(peer)->netID), p2.Insert("`2Your briefs have stunned the judge!``"), p2.CreatePacket(peer);
				int remove = -1;
				modify_inventory(peer, 3172, remove);
			}
		}
		pInfo(peer)->surged_person = "";
		pInfo(peer)->surgery_started = false;
	}
}

void exit_(ENetPeer* peer, bool reset_ = false, bool del = true) {
	end_surgery(peer);
	if (pInfo(peer)->invis == false) {
		add_cctv(peer, "left", "");
		packet_(peer, "action|play_sfx\nfile|audio/door_shut.wav\ndelayMS|0");
	}
	int w_c = 0, s_c = 0, net_ = 0, r_c = 0;
	const string world_name = pInfo(peer)->world;
	pInfo(peer)->x = -1, pInfo(peer)->y = -1, pInfo(peer)->world = "";
	pInfo(peer)->geiger_x = -1, pInfo(peer)->geiger_y = -1, pInfo(peer)->spotlight = false;
	pInfo(peer)->ac_.clear();
	pInfo(peer)->last_infected = 0;
	get_players(world_name, w_c, s_c, net_, r_c);
	if (r_c == 0 and del) { /*issaugoti worlda is istrinti is atminties*/
		map<string, vector<WorldNPC>>::iterator it;
		for (it = active_npc.begin(); it != active_npc.end(); it++) {
			if (it->first == world_name) {
				active_npc.erase(it, active_npc.end());
				break;
			}
		}
		for (int i = 0; i < monitors.size(); i++) {
			if (monitors[i].world_name == world_name) {
				monitors.erase(monitors.begin() + i);
				i--;
				//break; // gali buti daugiau nei vienas
			}
		}
		/*if (last_world_save + 7000 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) {
			save_world(world_name, false);
			last_world_save = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
		}*/
	}
	else {
		bool sent = false;
		gamepacket_t p;
		p.Insert("OnRemove");
		p.Insert("netID|" + to_string(pInfo(peer)->netID) + "\n");
		gamepacket_t p2;
		p2.Insert("OnConsoleMessage");
		p2.Insert("`5<" + (not pInfo(peer)->d_name.empty() ? pInfo(peer)->d_name : pInfo(peer)->name_color + pInfo(peer)->tankIDName) + "`` left, `w" + to_string(w_c) + "`` others here>``");
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != world_name) continue;
			sent = true;
			p.CreatePacket(currentPeer);
			if (w_c <= 14 and not pInfo(peer)->invis) {
				packet_(currentPeer, "action|play_sfx\nfile|audio/door_shut.wav\ndelayMS|0");
				p2.CreatePacket(currentPeer);
			}
		}
	}
	if (not reset_) world_menu(peer);
}


void create_address_world(ENetPeer* peer, string name_, string currentworld_) {
	int rm = -1;
	name_ = to_upper(name_);
	currentworld_ = to_upper(currentworld_);
	get_world(name_);
	vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
	if (p != worlds.end()) {
		World world_ = worlds[p - worlds.begin()];
		vector<World>::iterator p2 = find_if(worlds.begin(), worlds.end(), [currentworld_](const World& b) { return b.name == currentworld_; });
		if (p2 != worlds.end()) {
			World c_world_ = worlds[p2 - worlds.begin()];
			if (world_.owner_name != pInfo(peer)->tankIDName || c_world_.owner_name != pInfo(peer)->tankIDName) return;
			if (modify_inventory(peer, 2580, rm) == 0) {
				{
					{
						gamepacket_t p, p2, p3;
						p.Insert("OnAddNotification"), p.Insert("interface/large/jump_icon.rttex"), p.Insert("This world has just been renamed to `5" + name_ + "`` by the owner! (Please join it again)"), p.Insert("audio/gate_close.wav");
						p2.Insert("OnConsoleMessage"), p2.Insert("Ok, " + currentworld_ + " and " + name_ + " have swapped names!");
						p3.Insert("OnConsoleMessage"), p3.Insert("This world has just been renamed to `5" + name_ + "`` by the owner! (Please join it again)");
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
							if (pInfo(currentPeer)->world == world_.name or pInfo(currentPeer)->world == c_world_.name) {
								p.CreatePacket(currentPeer);
								p2.CreatePacket(currentPeer);
								p3.CreatePacket(currentPeer);
								exit_(currentPeer, false);
							}
						}
					}
					for (int i = 0; i < worlds.size(); i++) {
						if (worlds[i].name == currentworld_ or worlds[i].name == name_) {
							save_world(worlds[i].name, false);
							worlds.erase(worlds.begin() + i);
							i--;
						}
					}
					string path_ = "worlds/" + world_.name + "_.json";
					string path_2 = "worlds/" + c_world_.name + "_.json";
					string path_4 = "worlds/t_" + world_.name + "_.json";
					string path_3 = "worlds/t_" + c_world_.name + "_.json";
					rename(path_2.c_str(), path_3.c_str()); // dabartini worlda i temp
					rename(path_.c_str(), path_4.c_str()); // i kuri keicia worlda i temp
					rename(path_3.c_str(), path_.c_str()); // temp i kuri keicia
					rename(path_4.c_str(), path_2.c_str()); // temp i dabartini
				}
			}
		}
	}
}


void add_surgery_xp(ENetPeer* peer, int amount) {
	pInfo(peer)->s_xp += amount;
	int required = 10 * ((pInfo(peer)->s_lvl * pInfo(peer)->s_lvl) + 2);
	if (pInfo(peer)->s_xp >= 10 * ((pInfo(peer)->s_lvl * pInfo(peer)->s_lvl) + 2)) {
		pInfo(peer)->s_lvl++;
		pInfo(peer)->s_xp -= required;
		pInfo(peer)->gems += 500;
		{
			gamepacket_t p;
			p.Insert("OnSetBux");
			p.Insert(pInfo(peer)->gems);
			p.Insert(0);
			p.Insert((pInfo(peer)->supp >= 1) ? 1 : 0);
			if (pInfo(peer)->supp >= 2) {
				p.Insert((float)33796, (float)1, (float)0);
			}
			p.CreatePacket(peer);
		}
		gamepacket_t p, p2;
		p.Insert("OnTalkBubble");
		p.Insert(pInfo(peer)->netID);
		p.Insert(pInfo(peer)->name_color + pInfo(peer)->tankIDName + "`` Surgeon is now level " + to_string(pInfo(peer)->s_lvl) + "!");
		p.Insert(0), p.Insert(0);
		p2.Insert("OnConsoleMessage");
		p2.Insert(pInfo(peer)->name_color + pInfo(peer)->tankIDName + "`` Surgeon is now level " + to_string(pInfo(peer)->s_lvl) + "!");
		PlayerMoving data_{};
		data_.packetType = 17, data_.netID = 46, data_.YSpeed = 46, data_.x = pInfo(peer)->x + 16, data_.y = pInfo(peer)->y + 16;
		BYTE* raw = packPlayerMoving(&data_);
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
			if (pInfo(peer)->world != pInfo(currentPeer)->world) continue;
			p.CreatePacket(currentPeer);
			p2.CreatePacket(currentPeer);
			send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
		}
		delete[] raw;
	}
}


void load_surgery(ENetPeer* peer, int tool) {
	string name_ = pInfo(peer)->world;
	vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
	if (p != worlds.end()) {
		World* world_ = &worlds[p - worlds.begin()];
		if (tool != 0 && tool != 1296) {
			int got = 0;
			modify_inventory(peer, tool, got);
			if (got == 0) {
				end_surgery(peer);
				return;
			}
			if (pInfo(peer)->hand == 9068 && rand() % 100 < 10) {
			}
			else modify_inventory(peer, tool, got = -1);
		}
		bool has_tool = false;
		if (tool != 0) for (int i = 0; i < pInfo(peer)->available_surg_items.size(); i++) if (pInfo(peer)->available_surg_items[i] == tool) has_tool = true;
		if (tool == 0) has_tool = true;
		if (has_tool == false) {
			end_surgery(peer);
			add_ban(peer, 62985600, "Using Surgery Hacks", pInfo(peer)->name_color + pInfo(peer)->tankIDName + "``");
			return;
		}
		int skill = pInfo(peer)->surgery_skill;
		skill += 7;
		string surgery_fail_text = "", cured = "";
		if (has_playmod(pInfo(peer), "Calm Nerves") or has_playmod(pInfo(peer), "Spicey Skills")) skill *= 2;
		else {
			if (pInfo(peer)->hand == 6252) skill += 5;
			else if (pInfo(peer)->hand == 9068) skill += 5; // chance of not using surigcal tool
			if (pInfo(peer)->necklace == 3130) skill *= 2;
		}
		if (skill >= 100) skill = 100;
		pInfo(peer)->s = rand() % 100 > (30 - skill / 4);
		if (pInfo(peer)->started_type == 30) pInfo(peer)->gems += 500;
		if (pInfo(peer)->hand == 8536 && pInfo(peer)->started_type == 27 || pInfo(peer)->started_type == 21 || pInfo(peer)->started_type == 22 || pInfo(peer)->started_type == 19 || pInfo(peer)->started_type == 18 || pInfo(peer)->started_type == 28 || pInfo(peer)->started_type == 23 || pInfo(peer)->started_type == 26 || pInfo(peer)->started_type == 24 || pInfo(peer)->started_type == 25) pInfo(peer)->s = true;
		if (tool == 999) pInfo(peer)->endtext = "giveup";
		if (tool != 0) {
			if (tool == 1258) {
				pInfo(peer)->spongUsed += 1;
				if (pInfo(peer)->s) {
					pInfo(peer)->dirt = 0;
					cured = "mopped up the operating site.";
					pInfo(peer)->tooltext = "You mopped up the operating site.";
				}
				else
					pInfo(peer)->tooltext = "You somehow managed to eat the sponge.";
			}
			if (tool == 1260) {
				pInfo(peer)->scalpUsed += 1;
				if (pInfo(peer)->sleep == 0)
					pInfo(peer)->endtext = "You have cut the awake patient!";
				if (pInfo(peer)->incisions == pInfo(peer)->incneeded && pInfo(peer)->shattered == 0) {
					pInfo(peer)->tooltext = "You stabbed the patient in a vital organ!";
					pInfo(peer)->bleeding += 1;
					pInfo(peer)->s = false;
				}
				else {
					pInfo(peer)->incisions += 1;
					if (pInfo(peer)->s)
						pInfo(peer)->tooltext = "You've made a neat incision.";
					else
						pInfo(peer)->tooltext = "This will leave a nasty scar, but you managed to cut the right place.";
				}
			}
			if (tool == 1270) {
				pInfo(peer)->stitcUsed += 1;
				if (pInfo(peer)->s) {
					if (pInfo(peer)->incisions > 0) {
						cured = "stitched up an incision.";
						pInfo(peer)->tooltext = "You stitched up an incision.";
					}
					else if (pInfo(peer)->bleeding > 0) {
						cured = "bandaged some injuries.";
						pInfo(peer)->tooltext = "You bandaged some injuries.";
					}
					else
						pInfo(peer)->tooltext = "You tried to stitch your patient's mouth shut!.";
					if (pInfo(peer)->bleeding > 0)
						pInfo(peer)->bleeding -= 1;
					if (pInfo(peer)->incisions > 0)
						pInfo(peer)->incisions -= 1;
				}
				else
					pInfo(peer)->tooltext = "You somehow tied yourself up in stitches!";
			}
			if (tool == 1264) {
				pInfo(peer)->antisUsed += 1;
				if (pInfo(peer)->s) {
					pInfo(peer)->site = min(pInfo(peer)->site + 20, 20);
					cured = "disinfected the operating site.";
				}
				else
					pInfo(peer)->tooltext = "You spilled antiseptic on your shoes. They are very clean now.";
			}
			if (tool == 1266) {
				pInfo(peer)->antibUsed += 1;
				if (pInfo(peer)->s) {
					pInfo(peer)->fever -= 3;
					pInfo(peer)->tooltext = "You used antibiotics to reduce the patient's infection.";
					cured = "cured you with antibiotics.";
					if (pInfo(peer)->fever > -3)
						pInfo(peer)->antibs = true;
				}
				else {
					pInfo(peer)->fever += 1;
					pInfo(peer)->tooltext = "This is the wrong medication! The bacteria like it.";
				}
			}
			if (tool == 1268) {
				pInfo(peer)->splinUsed += 1;
				if (pInfo(peer)->s) {
					pInfo(peer)->broken -= 1;
					cured = "splinted a broken bone.";
					pInfo(peer)->tooltext = "You splinted a broken bone.";
				}
				else
					pInfo(peer)->tooltext = "You ate a splint, good job!";
			}
			if (tool == 1262) {
				pInfo(peer)->anestUsed += 1;
				if (pInfo(peer)->s) {
					pInfo(peer)->sleep += 10;
					cured = "falls into a deep sleep.";
					pInfo(peer)->tooltext = "The patient falls into a deep sleep.";
				}
				else
					pInfo(peer)->tooltext = "You end up inhaling all the anesthetic yourself. You feel woozy.";
			}
			if (tool == 4318) {
				pInfo(peer)->labkiUsed += 1;
				if (pInfo(peer)->s) {
					cured = "used a lab kit to discover you are suffering from " + pInfo(peer)->scantext;
					pInfo(peer)->labworked = true;
					if (pInfo(peer)->flu)
						pInfo(peer)->tooltext = "You performed lab work on the patient, and discovered they are suffering from " + pInfo(peer)->scantext;
					else
						pInfo(peer)->tooltext = "You performed lab work on the patient, and have antibiotics at the ready.";
				}
				else
					pInfo(peer)->tooltext = "You contaminated the sample.";
			}
			if (tool == 4316) {
				pInfo(peer)->ultraUsed += 1;
				if (pInfo(peer)->s) {
					pInfo(peer)->sounded = true;
					if (pInfo(peer)->flu)
						pInfo(peer)->tooltext = "You scanned the patient , but didn't find any abnormal masses.";
					else {
						cured = "used a ultrasound to discover you are suffering from " + pInfo(peer)->scantext;
						pInfo(peer)->tooltext = "You scanned the patient with ultrasound, discovering they are suffering from " + pInfo(peer)->scantext;
					}
				}
				else
					pInfo(peer)->tooltext = "You scanned the nurse with your ultrasound!";
			}
			if (tool == 4308) {
				pInfo(peer)->pinsUsed += 1;
				if (pInfo(peer)->s) {
					pInfo(peer)->shattered -= 1;
					pInfo(peer)->broken += 1;
					cured = "pinned a shattered bone together.";
					pInfo(peer)->tooltext = "You pinned a shattered bone together. Don't forget to splint it!";
				}
				else {
					pInfo(peer)->bleeding += 1;
					pInfo(peer)->tooltext = "You jabbed the pin through the artery!";
				}
			}
			if (tool == 4312) {
				pInfo(peer)->defibUsed += 1;
				if (pInfo(peer)->s) {
					pInfo(peer)->heart = 0;
					cured = "used a defibrillator and shocken your life back!";
					pInfo(peer)->tooltext = "You shocked the patient back to life!";
				}
				else
					pInfo(peer)->tooltext = "You electrocuted yourself!";
			}
			if (tool == 4310) {
				pInfo(peer)->transUsed += 1;
				if (pInfo(peer)->s) {
					pInfo(peer)->pulse = min(pInfo(peer)->pulse + 15, 40);
					cured = "tranfused several pints of blood into patient.";
					pInfo(peer)->tooltext = "You transfused several pints of blood into your patient.";
				}
				else
					pInfo(peer)->tooltext = "You spilled all of it! Kind of gross.";
			}
			if (tool == 4314) {
				pInfo(peer)->clampUsed += 1;
				if (pInfo(peer)->s) {
					pInfo(peer)->bleeding -= 1;
					cured = "clamped up some blood vessels.";
					pInfo(peer)->tooltext = "You clamped up some blood vessels.";
				}
				else
					pInfo(peer)->tooltext = "The clamp fell out of your hand, oh well.";
			}
			if (tool == 1296) {
				if (pInfo(peer)->s) {
					pInfo(peer)->fixed = true;
					cured = pInfo(peer)->postext;
					pInfo(peer)->tooltext = pInfo(peer)->postext;
				}
				else
					pInfo(peer)->tooltext = "You screwed it up! Try again.";
			}
			if (cured != "") {
				if (pInfo(peer)->surged_person != "") {
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != pInfo(peer)->world or pInfo(peer)->surged_person != pInfo(currentPeer)->tankIDName) continue;
						gamepacket_t p2;
						p2.Insert("OnConsoleMessage"), p2.Insert(pInfo(peer)->name_color + pInfo(peer)->tankIDName + "`` " + cured), p2.CreatePacket(currentPeer);
					}
				}
				gamepacket_t p2;
				p2.Insert("OnConsoleMessage"), p2.Insert(cured), p2.CreatePacket(peer);
			}
			surgery_fail_text = pInfo(peer)->tooltext;
			// Making Glove available
			if (!pInfo(peer)->fixable && (pInfo(peer)->incisions == pInfo(peer)->incneeded) && pInfo(peer)->sounded) {
				pInfo(peer)->fixable = true;
				pInfo(peer)->tooltext += "\nadd_smalltext|`3" + pInfo(peer)->fixtext + "``|left|";
			}
			// Managing bleeding, site, dirt
			pInfo(peer)->dirt += pInfo(peer)->bleeding + pInfo(peer)->incisions;
			if (pInfo(peer)->dirt > 10)
				pInfo(peer)->dirt = 10;
			pInfo(peer)->site -= floor(pInfo(peer)->dirt / 3);
			if (pInfo(peer)->site < -25)
				pInfo(peer)->site = -25;
			if (pInfo(peer)->sleep == 0 && pInfo(peer)->incisions > 0)
				pInfo(peer)->bleeding += 1;
			if (pInfo(peer)->bleeding > 4)
				pInfo(peer)->bleeding = 4;

			// Managing temp, fever
			if (pInfo(peer)->fever < 0) {
				if (pInfo(peer)->fever > -0.06)
					pInfo(peer)->fever = 0;
				else if (!pInfo(peer)->antibs)
					pInfo(peer)->fever = (pInfo(peer)->fever - 3) / 2;
			}
			else if ((pInfo(peer)->site <= 2) && (pInfo(peer)->bleeding > 0) || (pInfo(peer)->site <= 4) && (pInfo(peer)->incisions > 0))
				pInfo(peer)->fever += 0.06;
			pInfo(peer)->temp += pInfo(peer)->fever;
			pInfo(peer)->temp = round(pInfo(peer)->temp * 100) / 100;
			if (pInfo(peer)->temp < 98.6)
				pInfo(peer)->temp = 98.6;
			pInfo(peer)->antibs = false;
			// Managing status, heart stopping
			if (((pInfo(peer)->sleep > 0) && (rand() % 100 < 5)) || (pInfo(peer)->heart > 0)) {
				pInfo(peer)->heart += 1;
			}
			else pInfo(peer)->sleep = max(pInfo(peer)->sleep - 1, 0);
			// Managing pulse
			pInfo(peer)->pulse -= pInfo(peer)->bleeding + min(pInfo(peer)->incisions, 1);
			// Checking for fail
			if (pInfo(peer)->pulse < 1 && pInfo(peer)->endtext == "")
				pInfo(peer)->endtext = "Your patient bled out!";
			else if (pInfo(peer)->temp >= 111)
				pInfo(peer)->endtext = "Your patient succumbed to infection!";
			else if (pInfo(peer)->heart == 3)
				pInfo(peer)->endtext = "You failed to resucicate your patient in time!";
			else if (pInfo(peer)->sleep > 15)
				pInfo(peer)->endtext = "You put your patient to sleep. Permanently!";
			else if ((pInfo(peer)->incisions == 0) && (pInfo(peer)->broken == 0) && (pInfo(peer)->shattered == 0) && pInfo(peer)->fixed && (pInfo(peer)->bleeding == 0) && (pInfo(peer)->temp < 101))
				pInfo(peer)->endtext = "success";

			// Tool text
			if (pInfo(peer)->s)
				pInfo(peer)->tooltext = "`3" + pInfo(peer)->tooltext + "``";
			else {
				pInfo(peer)->tooltext = "`3[```4Skill Fail (" + to_string(30 - pInfo(peer)->surgery_skill / 4) + "%)```3] `6" + pInfo(peer)->tooltext + "``";
				if (pInfo(peer)->surged_person != "") {
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != pInfo(peer)->world or pInfo(peer)->surged_person != pInfo(currentPeer)->tankIDName) continue;
						gamepacket_t p2;
						p2.Insert("OnConsoleMessage"), p2.Insert("[`4Skill Fail (" + to_string(30 - skill / 4) + "%)``] `6" + surgery_fail_text + "``"), p2.CreatePacket(currentPeer);
					}
				}
			}
		}

		// Diagnosed
		string diagnosed = "";
		if (!pInfo(peer)->sounded && !pInfo(peer)->flu || !pInfo(peer)->labworked && pInfo(peer)->flu)
			diagnosed += "`4The patient has not been diagnosed.``";
		else if (!pInfo(peer)->fixable || pInfo(peer)->flu || pInfo(peer)->incneeded == 0)
			diagnosed += (pInfo(peer)->pretext);
		else if (!pInfo(peer)->fixed) {
			diagnosed += (pInfo(peer)->fixtext);
		}
		else
			diagnosed += (pInfo(peer)->postext);
		// Pulse
		string pulse = "Pulse: ";
		if (pInfo(peer)->pulse < 11)
			pulse += "`4Extremely Weak``";
		else if (pInfo(peer)->pulse < 21)
			pulse += "`6Weak``";
		else if (pInfo(peer)->pulse < 31)
			pulse += "`3Steady``";
		else
			pulse += "`2Strong``";
		// Status
		string status = "Status: ";
		if (pInfo(peer)->heart > 0)
			status += "`4Heart stopped!``";
		else if (pInfo(peer)->sleep == 0)
			status += (pInfo(peer)->fixed ? "`3" : "`4") + a + "Awake``";
		else if (pInfo(peer)->sleep < 3)
			status += "`6Coming to``";
		else
			status += "`2Unconcsious``";
		// Temp
		string temp = "Temp: ";
		stringstream stream;
		stream << std::fixed << std::setprecision(1) << pInfo(peer)->temp;
		if (pInfo(peer)->temp < 100)
			temp += "`2" + stream.str() + "``";
		else if (pInfo(peer)->temp < 104)
			temp += "`3" + stream.str() + "``";
		else if (pInfo(peer)->temp < 106)
			temp += "`6" + stream.str() + "``";
		else
			temp += "`4" + stream.str() + "``";
		// Operation site
		string operation = "Operation site: ";
		if (pInfo(peer)->site < -3)
			operation += "`4Unsanitary``";
		else if (pInfo(peer)->site < -1)
			operation += "`6Unclean``";
		else if (pInfo(peer)->site < 1)
			operation += "`3Not sanitized``";
		else operation += "`2Clean``";
		// Dirt
		string dirt = "";
		if (pInfo(peer)->dirt == 10)
			dirt += "`4You can't see what you are doing!";
		else if (pInfo(peer)->dirt > 4)
			dirt += "`6It is becoming hard to see your work.";
		// Incisions
		string incisions = "Incisions: ";
		if (pInfo(peer)->incisions == 0)
			incisions += "`2" + to_string(pInfo(peer)->incisions) + "``";
		else
			incisions += "`3" + to_string(pInfo(peer)->incisions) + "``";
		// Bones
		string bones = "";
		if (pInfo(peer)->broken + pInfo(peer)->shattered > 0 && pInfo(peer)->sounded) {
			bones += "Bones: ";
			if (pInfo(peer)->broken > 0) {
				if (pInfo(peer)->broken > 2)
					bones += "`4" + to_string(pInfo(peer)->broken) + " broken``";
				else
					bones += "`6" + to_string(pInfo(peer)->broken) + " broken``";
			}
			if (pInfo(peer)->broken > 0 && pInfo(peer)->shattered > 0)
				bones += ", ";
			if (pInfo(peer)->shattered > 0) {
				if (pInfo(peer)->shattered > 2)
					bones += "`4" + to_string(pInfo(peer)->shattered) + " shattered``";
				else
					bones += "`6" + to_string(pInfo(peer)->shattered) + " shattered``";
			}
		}
		// Bleeding
		string bleeding = "";
		if (pInfo(peer)->bleeding > 0) {
			bleeding += "Patient is ";
			if (pInfo(peer)->bleeding == 1)
				bleeding += "losing blood `3slowly.``";
			else if (pInfo(peer)->bleeding == 4)
				bleeding += "losing blood `4Extremely Fast!``";
			else {
				bleeding += "losing blood `6losing blood!``";
			}
		}
		// Fever
		string fever = "";
		if (pInfo(peer)->fever > 0 && pInfo(peer)->temp > 100) {
			fever += "Patient's fever is ";
			if (pInfo(peer)->fever < 0.5)
				fever += "`3slowly rising.``";
			else if (pInfo(peer)->fever > 2)
				fever += "`4climbing fast!``";
			else {
				fever += "`6climbing!``";
			}
		}
		// Special: heart stop and cut awake
		string heart_stopped = "";
		if (pInfo(peer)->heart == 1)
			heart_stopped += "`4The patient's heart has stopped!``";
		else if (pInfo(peer)->incisions > 0 && pInfo(peer)->sleep == 0)
			heart_stopped += "`4The patient screams and flails!``";


		// pInfo(peer)->
		string tools_available = "";
		// Availability
		//1
		int have = 0;
		pInfo(peer)->available_surg_items.clear();
		if (toolavailable(peer, 1258)) {
			for (int i_ = 0; i_ < pInfo(peer)->inv.size(); i_++) if (pInfo(peer)->inv[i_].id == 1258)have = pInfo(peer)->inv[i_].count;
			tools_available += "\nadd_button_with_icon|tool1258|`$Sponge``|noflags|1258|" + to_string(have) + "|";
			pInfo(peer)->available_surg_items.push_back(1258);
		}
		else tools_available += "\nadd_button_with_icon|tool0||noflags|4320||";
		//2
		if (toolavailable(peer, 1260)) {
			for (int i_ = 0; i_ < pInfo(peer)->inv.size(); i_++) if (pInfo(peer)->inv[i_].id == 1260)have = pInfo(peer)->inv[i_].count;
			tools_available += "\nadd_button_with_icon|tool1260|`$Scalpel``|noflags|1260|" + to_string(have) + "|";
			pInfo(peer)->available_surg_items.push_back(1260);
		}
		else tools_available += "\nadd_button_with_icon|tool0||noflags|4320||";
		//3
		if (toolavailable(peer, 1270)) {
			for (int i_ = 0; i_ < pInfo(peer)->inv.size(); i_++) if (pInfo(peer)->inv[i_].id == 1270)have = pInfo(peer)->inv[i_].count;
			tools_available += "\nadd_button_with_icon|tool1270|`$Stitches``|noflags|1270|" + to_string(have) + "|";
			pInfo(peer)->available_surg_items.push_back(1270);
		}
		else tools_available += "\nadd_button_with_icon|tool0||noflags|4320||";
		//4
		if (toolavailable(peer, 1266)) {
			for (int i_ = 0; i_ < pInfo(peer)->inv.size(); i_++) if (pInfo(peer)->inv[i_].id == 1266)have = pInfo(peer)->inv[i_].count;
			tools_available += "\nadd_button_with_icon|tool1266|`$Antibiotics``|noflags|1266|" + to_string(have) + "|";
			pInfo(peer)->available_surg_items.push_back(1266);
		}
		else tools_available += "\nadd_button_with_icon|tool0||noflags|4320||";
		//5
		if (toolavailable(peer, 1264)) {
			for (int i_ = 0; i_ < pInfo(peer)->inv.size(); i_++) if (pInfo(peer)->inv[i_].id == 1264)have = pInfo(peer)->inv[i_].count;
			tools_available += "\nadd_button_with_icon|tool1264|`$Antiseptic``|noflags|1264|" + to_string(have) + "|";
			pInfo(peer)->available_surg_items.push_back(1264);
		}
		else tools_available += "\nadd_button_with_icon|tool0||noflags|4320||";
		//6
		if (toolavailable(peer, 1296)) {
			for (int i_ = 0; i_ < pInfo(peer)->inv.size(); i_++) if (pInfo(peer)->inv[i_].id == 1296)have = pInfo(peer)->inv[i_].count;
			tools_available += "\nadd_button_with_icon|tool1296|`$Fix it!``|noflags|1296|1|";
			pInfo(peer)->available_surg_items.push_back(1296);
		}
		else tools_available += "\nadd_button_with_icon|tool0||noflags|4320||";
		//7
		if (toolavailable(peer, 4316)) {
			for (int i_ = 0; i_ < pInfo(peer)->inv.size(); i_++) if (pInfo(peer)->inv[i_].id == 4316)have = pInfo(peer)->inv[i_].count;
			tools_available += "\nadd_button_with_icon|tool4316|`$Ultrasound``|noflags|4316|" + to_string(have) + "|";
			pInfo(peer)->available_surg_items.push_back(4316);
		}
		else tools_available += "\nadd_button_with_icon|tool0||noflags|4320||";
		//8
		if (toolavailable(peer, 4318)) {
			for (int i_ = 0; i_ < pInfo(peer)->inv.size(); i_++) if (pInfo(peer)->inv[i_].id == 4318)have = pInfo(peer)->inv[i_].count;
			tools_available += "\nadd_button_with_icon|tool4318|`$Lab Kit``|noflags|4318|" + to_string(have) + "|";
			pInfo(peer)->available_surg_items.push_back(4318);
		}
		else tools_available += "\nadd_button_with_icon|tool0||noflags|4320||";
		//9
		if (toolavailable(peer, 1262)) {
			for (int i_ = 0; i_ < pInfo(peer)->inv.size(); i_++) if (pInfo(peer)->inv[i_].id == 1262)have = pInfo(peer)->inv[i_].count;
			tools_available += "\nadd_button_with_icon|tool1262|`$Anesthetic``|noflags|1262|" + to_string(have) + "|";
			pInfo(peer)->available_surg_items.push_back(1262);
		}
		else tools_available += "\nadd_button_with_icon|tool0||noflags|4320||";
		//10
		if (toolavailable(peer, 1268)) {
			for (int i_ = 0; i_ < pInfo(peer)->inv.size(); i_++) if (pInfo(peer)->inv[i_].id == 1268)have = pInfo(peer)->inv[i_].count;
			tools_available += "\nadd_button_with_icon|tool1268|`$Splint``|noflags|1268|" + to_string(have) + "|";
			pInfo(peer)->available_surg_items.push_back(1268);
		}
		else tools_available += "\nadd_button_with_icon|tool0||noflags|4320||";
		if (toolavailable(peer, 4312)) {
			for (int i_ = 0; i_ < pInfo(peer)->inv.size(); i_++) if (pInfo(peer)->inv[i_].id == 4312)have = pInfo(peer)->inv[i_].count;
			tools_available += "\nadd_button_with_icon|tool4312|`$Defibrillator``|noflags|4312|" + to_string(have) + "|";
			pInfo(peer)->available_surg_items.push_back(4312);
		}
		else tools_available += "\nadd_button_with_icon|tool0||noflags|4320||";
		//11
		if (toolavailable(peer, 4308)) {
			for (int i_ = 0; i_ < pInfo(peer)->inv.size(); i_++) if (pInfo(peer)->inv[i_].id == 4308)have = pInfo(peer)->inv[i_].count;
			tools_available += "\nadd_button_with_icon|tool4308|`$Pins``|noflags|4308|" + to_string(have) + "|";
			pInfo(peer)->available_surg_items.push_back(4308);
		}
		else tools_available += "\nadd_button_with_icon|tool0||noflags|4320||";
		//12
		if (toolavailable(peer, 4314)) {
			for (int i_ = 0; i_ < pInfo(peer)->inv.size(); i_++) if (pInfo(peer)->inv[i_].id == 4314)have = pInfo(peer)->inv[i_].count;
			tools_available += "\nadd_button_with_icon|tool4314|`$Clamp``|noflags|4314|" + to_string(have) + "|";
			pInfo(peer)->available_surg_items.push_back(4314);
		}
		else tools_available += "\nadd_button_with_icon|tool0||noflags|4320||";
		//13
		if (toolavailable(peer, 4310)) {
			for (int i_ = 0; i_ < pInfo(peer)->inv.size(); i_++) if (pInfo(peer)->inv[i_].id == 4310)have = pInfo(peer)->inv[i_].count;
			tools_available += "\nadd_button_with_icon|tool4310|`$Transfusion``|noflags|4310|" + to_string(have) + "|";
			pInfo(peer)->available_surg_items.push_back(4310);
		}
		else tools_available += "\nadd_button_with_icon|tool0||noflags|4320||";

		if (pInfo(peer)->endtext == "") {
			gamepacket_t p;
			p.Insert("OnDialogRequest");
			p.Insert("set_default_color|`o\nadd_label_with_icon|big|`w" + (pInfo(peer)->surged_person == "" ? "Surg-E" : pInfo(peer)->surged_display) + "``|left|18|\nadd_smalltext|" + diagnosed + "|left|\nadd_smalltext|" + pulse + "    " + status + "|left|\nadd_smalltext|" + temp + "    " + operation + "|left|" + (dirt != "" ? "\nadd_smalltext|" + dirt + "|left|" : "") + "\nadd_smalltext|" + incisions + "    " + (bones != "" ? bones : "") + "|left|" + (fever != "" ? "\nadd_smalltext|" + fever + "|left|" : "") + "" + (bleeding != "" ? "\nadd_smalltext|" + bleeding + "|left|" : "") + "\nadd_spacer|small|" + (pInfo(peer)->tooltext != "" ? "\nadd_smalltext|" + pInfo(peer)->tooltext + "|left|" : "") + "" + (heart_stopped != "" ? "\nadd_spacer|small|\nadd_smalltext|" + heart_stopped + "|left|" : "") + "\ntext_scaling_string|Defibrillator|" + tools_available + "\nadd_button_with_icon||END_LIST|noflags|0||\nadd_button|tool999|Give up!|noflags|0|0|\nend_dialog|surgery|||");
			p.CreatePacket(peer);
		}
		else
		{
			if (pInfo(peer)->hand == 8536 && pInfo(peer)->started_type == 27 || pInfo(peer)->started_type == 21 || pInfo(peer)->started_type == 22 || pInfo(peer)->started_type == 19 || pInfo(peer)->started_type == 18 || pInfo(peer)->started_type == 28 || pInfo(peer)->started_type == 23 || pInfo(peer)->started_type == 26 || pInfo(peer)->started_type == 24 || pInfo(peer)->started_type == 25) {
				int remove = -1;
				modify_inventory(peer, 8536, remove);
			}
			if (pInfo(peer)->endtext == "success") {
				grow4good(peer, false, "surgery", 1);
				pInfo(peer)->surgery_started = false;
				if (pInfo(peer)->surgery_skill < 100) pInfo(peer)->surgery_skill++;
				if (pInfo(peer)->surged_person != "") add_surgery_xp(peer, 1);
				pInfo(peer)->surgery_done++;
				if (pInfo(peer)->shirt == 8448 && pInfo(peer)->feet == 8550 && pInfo(peer)->hair == 8444 && pInfo(peer)->necklace == 8442 && pInfo(peer)->face == 8446 && pInfo(peer)->pants == 8450) pInfo(peer)->su_8552_1++;
				if (pInfo(peer)->su_8552_1 >= 2000 && pInfo(peer)->back == 8552) pInfo(peer)->su_8552_2++;
				if (pInfo(peer)->su_8552_1 >= 2000 && pInfo(peer)->mercy == false) {
					gamepacket_t p;
					p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
					int c_ = 1;
					if (modify_inventory(peer, 8552, c_) == 0) {
						pInfo(peer)->mercy = true;
						packet_(peer, "action|play_sfx\nfile|audio/piano_nice.wav\ndelayMS|0");
						p.Insert("You received `2Angel of Mercy's Wings`` for completing 2,000 Surgeries while wearing Blinking Set!");
						gamepacket_t p2;
						p2.Insert("OnConsoleMessage"), p2.Insert("You received `2Dr.Title`` for completing 3,000 Surgeries while wearing Angel Of Mercy Wings!"), p2.CreatePacket(peer);
						PlayerMoving data_{};
						data_.packetType = 17, data_.netID = 46, data_.YSpeed = 46, data_.x = pInfo(peer)->x + 16, data_.y = pInfo(peer)->y + 16;
						BYTE* raw = packPlayerMoving(&data_);
						send_raw(peer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
						delete[] raw;
					}
					else p.Insert("You have finished Angel of Mercy quest, but your inventory is full! Clear inventory and complete another surgery.");
					p.Insert(0), p.Insert(1), p.CreatePacket(peer);
				}
				if (pInfo(peer)->su_8552_2 >= 3000 && pInfo(peer)->drtitle == false) {
					pInfo(peer)->drtitle = true;
					packet_(peer, "action|play_sfx\nfile|audio/piano_nice.wav\ndelayMS|0");
					gamepacket_t p, p2;
					p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("You received `2Dr.Title`` for completing 3,000 Surgeries while wearing Angel Of Mercy Wings!"), p.Insert(0), p.Insert(1);
					p2.Insert("OnConsoleMessage"), p2.Insert("You received `2Dr.Title`` for completing 3,000 Surgeries while wearing Angel Of Mercy Wings!");
					PlayerMoving data_{};
					data_.packetType = 17, data_.netID = 46, data_.YSpeed = 46, data_.x = pInfo(peer)->x + 16, data_.y = pInfo(peer)->y + 16;
					BYTE* raw = packPlayerMoving(&data_);
					send_raw(peer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
					delete[] raw;
					p.CreatePacket(peer), p2.CreatePacket(peer);
				}
				vector<int> list{ 1258, 1268, 1264, 1266, 1262, 1260, 1270, 4318, 4314, 4308, 4310, 4316, 4312, 1242, 1244, 1246, 1248, 1282, 1284, 1286, 1290, 1292, 1288, 1294, 1256, 1258, 1268, 1264, 1266, 1262, 1260, 1270, 4318, 4314, 4308, 4310, 4316, 4312, 1242, 1244, 1246, 1248, 1282, 1284, 1286, 1290, 1292, 1288, 1294, 1256, 2586, 782, 3536, 764, 4176 };
				if (pInfo(peer)->started_type == 27 || pInfo(peer)->started_type == 21 || pInfo(peer)->started_type == 22 || pInfo(peer)->started_type == 19 || pInfo(peer)->started_type == 18 || pInfo(peer)->started_type == 28 || pInfo(peer)->started_type == 23 || pInfo(peer)->started_type == 26 || pInfo(peer)->started_type == 24 || pInfo(peer)->started_type == 25) list.push_back(8534);
				int prize_to_pacient = list[rand() % list.size()];
				if (thedaytoday == 6 && rand() % 250 < 1) list = { 4334, 4330, 4326, 4328, 4324, 10570 };
				if (rand() % 200 < 1) list.push_back(3172), list.push_back(4322), list.push_back(10774), list.push_back(11770);
				if (rand() % 450 < 1) list = { 4322 ,2976, 4080,11872, 3790, 4990, 8954, 1506, 1274, 1252, 2992, 3172, 10092, 11224, 9000, 10112, 10094 };
				if (rand() % 2 < 1) {
					if (pInfo(peer)->started_type == 27) list.push_back(8442);
					if (pInfo(peer)->started_type == 21) list.push_back(8482);
					if (pInfo(peer)->started_type == 22) list.push_back(8486);
					if (pInfo(peer)->started_type == 19) list.push_back(8480);
					if (pInfo(peer)->started_type == 18) {
						list.push_back(8478);
						if (rand() % 3 < 1) list.push_back(8488), list.push_back(8452), list.push_back(8454);
					}
					if (pInfo(peer)->started_type == 28 && rand() % 10 < 1) list.push_back(8466), list.push_back(8468), list.push_back(8494);
					if (pInfo(peer)->started_type == 23) {
						list.push_back(8444);
						if (rand() % 3 < 1) list.push_back(8492);
					}
					if (pInfo(peer)->started_type == 26) {
						list.push_back(8448);
						if (rand() % 3 < 1) list.push_back(8474), list.push_back(8476), list.push_back(8498);
					}
					if (pInfo(peer)->started_type == 24) {
						list.push_back(8450);
						if (rand() % 3 < 1) list.push_back(8470), list.push_back(8472), list.push_back(8496);
					}
					if (pInfo(peer)->started_type == 25) {
						list.push_back(8550);
						if (rand() % 3 < 1) list.push_back(8458), list.push_back(8456), list.push_back(8490);
					}
				}
				if (rand() % 5000 < 1) list = { 8284 };
				int item = list[rand() % list.size()], got = 1;
				if (item == 1290) got = 10;
				if (item == 1294 || item == 1288 || item == 1292 || item == 1258 || item == 1268 || item == 1264 || item == 1266 || item == 1262 || item == 1260 || item == 1270 || item == 4318 || item == 4314 || item == 4308 || item == 4310 || item == 4316 || item == 4312) got = 5;
				gamepacket_t p, p2, p3;
				p.Insert("OnConsoleMessage");
				if (pInfo(peer)->surged_person == "") p.Insert("Hey, somebody left " + to_string(got) + " " + items[item].ori_name + " in this patient last time they operated!");
				else p.Insert("`w" + pInfo(peer)->surged_display + "``'s parents are so glad you saved their child that they give you " + to_string(got) + " " + items[item].ori_name + "!");
				p.CreatePacket(peer);
				p3.Insert("OnConsoleMessage"), p3.Insert("`2YOU SAVED YOUR PATIENT!`"), p3.CreatePacket(peer);
				p2.Insert("OnConsoleMessage"), p2.Insert("You got " + to_string(got) + " `2" + items[item].ori_name + "`` and a `3Caduceus``!"), p2.CreatePacket(peer);
				if (pInfo(peer)->surged_person != "") {
					gamepacket_t p, p2;
					p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("`7[``" + pInfo(peer)->name_color + pInfo(peer)->tankIDName + "`` `2cured`` `0" + pInfo(peer)->surged_display + "`` of " + pInfo(peer)->surgery_name + "`7]``"), p.Insert(0), p.Insert(0);
					p2.Insert("OnConsoleMessage"), p2.Insert("`7[``" + pInfo(peer)->name_color + pInfo(peer)->tankIDName + "`` `2cured`` `0" + pInfo(peer)->surged_display + "`` of " + pInfo(peer)->surgery_name + "`7]``");
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != pInfo(peer)->world) continue;
						if (pInfo(peer)->surged_person == pInfo(currentPeer)->tankIDName) {
							int give_prize = 1;
							if (modify_inventory(currentPeer, prize_to_pacient, give_prize) == 0) {
							}
							else {
								WorldDrop drop_block_{};
								drop_block_.id = prize_to_pacient, drop_block_.count = give_prize, drop_block_.uid = uint16_t(world_->drop.size()) + 1, drop_block_.x = pInfo(currentPeer)->x + rand() % 17, drop_block_.y = (pInfo(currentPeer)->y * 32) + rand() % 17;
							}
							gamepacket_t p3;
							p3.Insert("OnConsoleMessage"), p3.Insert("You are healed! Celebrate your good health with 100 Gems and 1 " + items[prize_to_pacient].ori_name + "!"), p3.CreatePacket(currentPeer);
							pInfo(currentPeer)->gems += 100;
							gamepacket_t p;
							p.Insert("OnSetBux"), p.Insert(pInfo(currentPeer)->gems), p.Insert(1), p.Insert((pInfo(currentPeer)->supp >= 1) ? 1 : 0);
							if (pInfo(currentPeer)->supp >= 2) p.Insert((float)33796, (float)1, (float)0);
							p.CreatePacket(currentPeer);
						}
						p.CreatePacket(currentPeer);
						p2.CreatePacket(currentPeer);
					}
				}
				int give_prize = 1;
				if (modify_inventory(peer, item, give_prize = 1) == 0) {
				}
				else {
					WorldDrop drop_block_{};
					drop_block_.id = item, drop_block_.count = give_prize = 1, drop_block_.uid = uint16_t(world_->drop.size()) + 1, drop_block_.x = pInfo(peer)->x + rand() % 17, drop_block_.y = (pInfo(peer)->y * 32) + rand() % 17;
				}
				give_prize = 1;
				if (modify_inventory(peer, 4298, give_prize = 1) == 0) {
				}
				else {
					int has_caduc = 0;
					modify_inventory(peer, 4298, has_caduc);
					if (modify_inventory(peer, 4300, give_prize = 2) == 0 and has_caduc >= 200) modify_inventory(peer, 4298, has_caduc = -199);
				}
				pInfo(peer)->surged_person = "", pInfo(peer)->surged_display = "";
			}
			else end_surgery(peer);
		}
	}
}

bool setstats(ENetPeer* peer, int i, string surged, string surged_display) {
	if (pInfo(peer)->surgery_started) {
		end_surgery(peer);
		return false;
	}
	if (has_playmod(pInfo(peer), "Malpractice")) {
		gamepacket_t p;
		p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert(surged == "" ? "I know it's just a robot, but the authorities don't even trust you operating on that with your malpractice issues." : "You can't perform surgery right now."), p.CreatePacket(peer);
		return false;
	}
	if (i < 0 || i > 30) i = rand() % 30;
	pInfo(peer)->started_type = i;
	pInfo(peer)->surged_person = surged;
	pInfo(peer)->surged_display = surged_display;
	pInfo(peer)->surgery_world = pInfo(peer)->world;
	pInfo(peer)->surgery_started = true;
	pInfo(peer)->sounded = false;
	pInfo(peer)->labworked = false;
	pInfo(peer)->fixed = false;
	pInfo(peer)->fixable = false;
	pInfo(peer)->flu = false;
	pInfo(peer)->pulse = 40;
	pInfo(peer)->site = 0;
	pInfo(peer)->sleep = 0;
	pInfo(peer)->dirt = 0;
	pInfo(peer)->broken = 0;
	pInfo(peer)->shattered = 0;
	pInfo(peer)->incisions = 0;
	pInfo(peer)->bleeding = 0;
	pInfo(peer)->incneeded = 0;
	pInfo(peer)->heart = 0;
	pInfo(peer)->temp = 98.6;
	pInfo(peer)->fever = 0;
	pInfo(peer)->pretext = "";
	pInfo(peer)->fixtext = "";
	pInfo(peer)->postext = "";
	pInfo(peer)->scantext = "";
	pInfo(peer)->tooltext = "Patient is prepped for surgery.";
	pInfo(peer)->endtext = "";
	pInfo(peer)->s = true;

	pInfo(peer)->spongUsed = 0;
	pInfo(peer)->scalpUsed = 0;
	pInfo(peer)->stitcUsed = 0;
	pInfo(peer)->antibUsed = 0;
	pInfo(peer)->antisUsed = 0;
	pInfo(peer)->ultraUsed = 0;
	pInfo(peer)->labkiUsed = 0;
	pInfo(peer)->anestUsed = 0;
	pInfo(peer)->defibUsed = 0;
	pInfo(peer)->splinUsed = 0;
	pInfo(peer)->pinsUsed = 0;
	pInfo(peer)->clampUsed = 0;
	pInfo(peer)->transUsed = 0;
	pInfo(peer)->surgery_name = "";

	if (pInfo(peer)->surged_person == "") {
		string name_ = pInfo(peer)->surgery_world;
		vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
		if (p != worlds.end()) {
			World* world_ = &worlds[p - worlds.begin()];
			WorldBlock* block_ = &world_->blocks[pInfo(peer)->lastwrenchx + (pInfo(peer)->lastwrenchy * 100)];
			if (block_->fg == 4296 || block_->fg == 8558) {
				block_->fg = 0;
				update_tile(peer, pInfo(peer)->lastwrenchx, pInfo(peer)->lastwrenchy, 0, false, true);
			}
			else return false;
		}
	}

	switch (i) {
	case 0:
		pInfo(peer)->fixed = true;
		pInfo(peer)->bleeding = 1;
		pInfo(peer)->broken = 1;
		pInfo(peer)->pretext = "Patient broke his arm.";
		pInfo(peer)->scantext = "a broken arm! You found 1 broken bone.";
		pInfo(peer)->surgery_name = "a broken arm.";
		break;
	case 1:
		pInfo(peer)->fixed = true;
		pInfo(peer)->bleeding = 1;
		pInfo(peer)->broken = 1;
		pInfo(peer)->shattered = 1;
		pInfo(peer)->pretext = "Patient broke his leg.";
		pInfo(peer)->scantext = "a broken leg! You found 1 broken bone and 1 shattered bone.";
		pInfo(peer)->surgery_name = "a broken leg.";
		break;
	case 2:
		pInfo(peer)->fixed = true;
		pInfo(peer)->flu = true;
		pInfo(peer)->temp = 104.6;
		pInfo(peer)->fever = 2.5;
		pInfo(peer)->dirt = 6;
		pInfo(peer)->pretext = "Patient is showing signs of the bird flu.";
		pInfo(peer)->scantext = "bird flu!";
		pInfo(peer)->surgery_name = "a bird flu!";
		break;
	case 3:
		pInfo(peer)->fixed = true;
		pInfo(peer)->flu = true;
		pInfo(peer)->temp = 101.6;
		pInfo(peer)->fever = 3.6;
		pInfo(peer)->dirt = 6;
		pInfo(peer)->pretext = "Patient is showing signs of the turtle flu.";
		pInfo(peer)->scantext = "turtle flu!";
		pInfo(peer)->surgery_name = "a turtle flu!";
		break;
	case 4:
		pInfo(peer)->fixed = true;
		pInfo(peer)->flu = true;
		pInfo(peer)->temp = 107.6;
		pInfo(peer)->fever = 2.4;
		pInfo(peer)->pretext = "Patient is showing signs of the monkey flu.";
		pInfo(peer)->scantext = "monkey flu!";
		pInfo(peer)->surgery_name = "a monkey flu!";
		break;
	case 5:
		pInfo(peer)->sounded = true;
		pInfo(peer)->incneeded = 1;
		pInfo(peer)->pretext = "Patient wants a nose job.";
		pInfo(peer)->fixtext = "You have cut into nasal area.";
		pInfo(peer)->postext = "You rearranged their face!";
		pInfo(peer)->surgery_name = "a nose job.";
		break;
	case 6:
		pInfo(peer)->incneeded = 1;
		pInfo(peer)->scantext = "a lung tumor!";
		pInfo(peer)->pretext = "Patient has a tumor in their lung.";
		pInfo(peer)->fixtext = "The lungs are now exposed.";
		pInfo(peer)->postext = "You excised the tumor!";
		pInfo(peer)->surgery_name = "a lung tumor!";
		break;
	case 7:
		pInfo(peer)->incneeded = 2;
		pInfo(peer)->scantext = "a heart attack!";
		pInfo(peer)->pretext = "Patient had a heart attack.";
		pInfo(peer)->fixtext = "The heart is now exposed for operating.";
		pInfo(peer)->postext = "You grafted in some nice new arteries!";
		pInfo(peer)->surgery_name = "a heart attack!";
		break;
	case 8:
		pInfo(peer)->incneeded = 5;
		pInfo(peer)->scantext = "a brain tumor!";
		pInfo(peer)->pretext = "Patient has a brain tumor, deep inside.";
		pInfo(peer)->fixtext = "You've finally found the tumor!";
		pInfo(peer)->postext = "You excised the tumor!";
		pInfo(peer)->surgery_name = "a brain tumor!";
		break;
	case 9:
		pInfo(peer)->incneeded = 2;
		pInfo(peer)->temp = 104.6;
		pInfo(peer)->fever = 0.6;
		pInfo(peer)->pulse = 30;
		pInfo(peer)->scantext = "a liver infection!";
		pInfo(peer)->pretext = "Patient has a liver infection.";
		pInfo(peer)->fixtext = "You've accessed the liver.";
		pInfo(peer)->postext = "You treated the source of the infection!";
		pInfo(peer)->surgery_name = "a liver infection!";
		break;
	case 10:
		pInfo(peer)->incneeded = 2;
		pInfo(peer)->temp = 101.6;
		pInfo(peer)->fever = 1.2;
		pInfo(peer)->scantext = "kidney failure!";
		pInfo(peer)->pretext = "Patient suffers from kidney failure.";
		pInfo(peer)->fixtext = "You now have access to the bad kidney.";
		pInfo(peer)->postext = "You popped in a fresh new kidney!";
		pInfo(peer)->surgery_name = "kidney failure!";
		break;
	case 11:
		pInfo(peer)->incneeded = 3;
		pInfo(peer)->temp = 104.6;
		pInfo(peer)->fever = 1.2;
		pInfo(peer)->pulse = 30;
		pInfo(peer)->scantext = "appendicitis!";
		pInfo(peer)->pretext = "Patient suffers from appendicitis.";
		pInfo(peer)->fixtext = "You now have access to the appendix.";
		pInfo(peer)->postext = "You yanked out the appendix!";
		pInfo(peer)->surgery_name = "appendicitis!";
		break;
	case 12:
		pInfo(peer)->incneeded = 2;
		pInfo(peer)->temp = 101.6;
		pInfo(peer)->bleeding = 1;
		pInfo(peer)->dirt = 6;
		pInfo(peer)->scantext = "swallowed World Lock!";
		pInfo(peer)->pretext = "Patient has swallowed a world lock.";
		pInfo(peer)->fixtext = "You've opened the stomach.";
		pInfo(peer)->postext = "You got the lock out!";
		pInfo(peer)->surgery_name = "a swallowed World Lock!";
		break;
	case 13:
		pInfo(peer)->incneeded = 3;
		pInfo(peer)->temp = 100.4;
		pInfo(peer)->scantext = "a herniated disc!";
		pInfo(peer)->pretext = "Patient's spine is damaged.";
		pInfo(peer)->fixtext = "You've opened up the vertebrae.";
		pInfo(peer)->postext = "You repaired the disc!";
		pInfo(peer)->surgery_name = "a herniated disc!";
		break;
	case 14:
		pInfo(peer)->incneeded = 2;
		pInfo(peer)->temp = 100.58;
		pInfo(peer)->dirt = 6;
		pInfo(peer)->bleeding = 1;
		pInfo(peer)->shattered = 4;
		pInfo(peer)->scantext = "broken everything! You found 4 shattered bones.";
		pInfo(peer)->pretext = "Patient was run over by a truck.";
		pInfo(peer)->fixtext = "You've found gravel in the knees.";
		pInfo(peer)->postext = "You removed the gravel!";
		pInfo(peer)->surgery_name = "a broken everything!";
		break;
	case 15:
		pInfo(peer)->incneeded = 1;
		pInfo(peer)->pulse = 20;
		pInfo(peer)->dirt = 6;
		pInfo(peer)->bleeding = 4;
		pInfo(peer)->scantext = "a serious head injury!";
		pInfo(peer)->pretext = "Patient has a serious head injury.";
		pInfo(peer)->fixtext = "You've opened the skull.";
		pInfo(peer)->postext = "You reduced the swelling!";
		pInfo(peer)->surgery_name = "a serious head injury!";
		break;
	case 16:
		pInfo(peer)->incneeded = 2;
		pInfo(peer)->pulse = 30;
		pInfo(peer)->dirt = 10;
		pInfo(peer)->bleeding = 3;
		pInfo(peer)->broken = 2;
		pInfo(peer)->shattered = 1;
		pInfo(peer)->scantext = "serious trauma! You found 2 broken bones and 1 shattered bone.";
		pInfo(peer)->pretext = "Patient suffered serious trauma with a punctured lung.";
		pInfo(peer)->fixtext = "You found the lung puncture.";
		pInfo(peer)->postext = "You repaired it.";
		pInfo(peer)->surgery_name = "a serious trauma!";
		break;
	case 17:
		pInfo(peer)->incneeded = 3;
		pInfo(peer)->pulse = 30;
		pInfo(peer)->dirt = 10;
		pInfo(peer)->bleeding = 4;
		pInfo(peer)->broken = 2;
		pInfo(peer)->shattered = 2;
		pInfo(peer)->scantext = "massive trauma! You found 2 broken bones and 2 shattered bones.";
		pInfo(peer)->pretext = "Patient suffered massive trauma with internal bleeding.";
		pInfo(peer)->fixtext = "You found the internal bleed.";
		pInfo(peer)->postext = "You cauterized it.";
		pInfo(peer)->surgery_name = "a massive trauma!";
		break;
	case 18:
		pInfo(peer)->incneeded = 1;
		pInfo(peer)->dirt = 15;
		pInfo(peer)->scantext = "torn punching muscle!";
		pInfo(peer)->pretext = "Patient has a torn punching muscle.";
		pInfo(peer)->fixtext = "You've accessed the arm muscles. ";
		pInfo(peer)->postext = "You patched the torn punching muscle! They should be back to punching in no time.";
		pInfo(peer)->surgery_name = "a torn punching muscle!";
		break;
	case 19:
		pInfo(peer)->fixable = false;
		pInfo(peer)->incneeded = 2;
		pInfo(peer)->temp = 98.6;
		pInfo(peer)->dirt = 0;
		pInfo(peer)->fever = 0;
		pInfo(peer)->bleeding = 1;
		pInfo(peer)->scantext = "gem cuts!";
		pInfo(peer)->pretext = "Patient is bleeding from multiple gem-induced cuts.";
		pInfo(peer)->fixtext = "You've examined the wounds.";
		pInfo(peer)->postext = "You've stitches the gem cuts closed and stopped the bleeding.";
		pInfo(peer)->surgery_name = "gem cuts!";
		break;
	case 20:
		pInfo(peer)->fixable = false;
		pInfo(peer)->incneeded = 1;
		pInfo(peer)->temp = 104.6;
		pInfo(peer)->pulse = 20;
		pInfo(peer)->shattered = 1;
		pInfo(peer)->dirt = 5;
		pInfo(peer)->scantext = "Grumbleteeth! You found 1 shattered bones.";
		pInfo(peer)->pretext = "Patient's teeth are chattering They sound angry.";
		pInfo(peer)->fixtext = "You removed grumbleteeth";
		pInfo(peer)->postext = "You've replaced the patient's angriest teeth and quited";
		pInfo(peer)->surgery_name = "Grumbleteeth!";
		break;
	case 21:
		pInfo(peer)->fixable = false;
		pInfo(peer)->temp = 98.6;
		pInfo(peer)->incneeded = 2;
		pInfo(peer)->heart = 0;
		pInfo(peer)->fever = 1.56;
		pInfo(peer)->dirt = 10;
		pInfo(peer)->shattered = 2;
		pInfo(peer)->scantext = "chicken feet! You found 2 shattered bones.";
		pInfo(peer)->pretext = "Patient feet have turned into chicken toes.";
		pInfo(peer)->fixtext = "You've insvestigated the feet.";
		pInfo(peer)->postext = "You fixed the patient feet. They look like normal blocky toes again!";
		pInfo(peer)->surgery_name = "chicken feet!";
		break;
	case 22:
		pInfo(peer)->fixable = false;
		pInfo(peer)->incneeded = 1;
		pInfo(peer)->shattered = 2;
		pInfo(peer)->temp = 107.6;
		pInfo(peer)->fever = 1.2;
		pInfo(peer)->dirt = 2;
		pInfo(peer)->scantext = "Broken Heart! You found 2 shattered bones.";
		pInfo(peer)->pretext = "Patient suffered from a Broken Heart.";
		pInfo(peer)->fixtext = "You've revealed the heart.";
		pInfo(peer)->postext = "You've repaired the fractured in the patient's heart";
		pInfo(peer)->surgery_name = "Broken heart!";
		break;
	case 23:
		pInfo(peer)->incneeded = 2;
		pInfo(peer)->temp = 100.58;
		pInfo(peer)->shattered = 1;
		pInfo(peer)->fever = 0.8;
		pInfo(peer)->dirt = 10;
		pInfo(peer)->bleeding = 5;
		pInfo(peer)->scantext = "brain worms! You found 1 Shattered bone.";
		pInfo(peer)->pretext = "You've exposed the brain.";
		pInfo(peer)->fixtext = "You made a neat incision.";
		pInfo(peer)->postext = "You've shut down the worm party in the patient brain and cleared away their trash.";
		pInfo(peer)->surgery_name = "brain worms!";
		break;
	case 24:
		pInfo(peer)->incneeded = 0;
		pInfo(peer)->fixable = false;
		pInfo(peer)->temp = 98.6;
		pInfo(peer)->dirt = 0;
		pInfo(peer)->broken = 6;
		pInfo(peer)->shattered = 2;
		pInfo(peer)->bleeding = 1;
		pInfo(peer)->scantext = "ecto bones! You found 6 Broken bones and 2 Shattered bones.";
		pInfo(peer)->pretext = "You've exposed the ribs";
		pInfo(peer)->fixtext = "You made an incision";
		pInfo(peer)->postext = "You pinned down all patient major bones and dyed them back to their normal color.";
		pInfo(peer)->surgery_name = "ecto bones!";
		break;
	case 25:
		pInfo(peer)->fixable = false;
		pInfo(peer)->pulse = 20;
		pInfo(peer)->temp = 104.6;
		pInfo(peer)->fever = 1.98;
		pInfo(peer)->shattered = 1;
		pInfo(peer)->incneeded = 2;
		pInfo(peer)->scantext = "Moldy Guts! You found 1 shattered bone.";
		pInfo(peer)->pretext = "Patient suffers from Moldy Guts.";
		pInfo(peer)->fixtext = "You've openned the abdomen.";
		pInfo(peer)->postext = "You'e cleaned out the patient's internal organs and applied a light air freshener";
		pInfo(peer)->surgery_name = "Moldy Guts!";
		break;
	case 26:
		pInfo(peer)->fixable = false;
		pInfo(peer)->incneeded = 3;
		pInfo(peer)->temp = 101.6;
		pInfo(peer)->fever = 2.0;
		pInfo(peer)->dirt = 10;
		pInfo(peer)->incneeded = 3;
		pInfo(peer)->bleeding = 3;
		pInfo(peer)->scantext = "fatty liver!";
		pInfo(peer)->pretext = "Patient suffered fatty liver.";
		pInfo(peer)->fixtext = "Patient poor diet has led to a high degree of fat build-up in their liver";
		pInfo(peer)->postext = "You pickup it.";
		pInfo(peer)->surgery_name = "fatty liver!";
		break;
	case 27:
		pInfo(peer)->fixed = false;
		pInfo(peer)->incneeded = 3;
		pInfo(peer)->temp = 105.6;
		pInfo(peer)->broken = 2;
		pInfo(peer)->fever = 2.6;
		pInfo(peer)->dirt = 10;
		pInfo(peer)->bleeding = 3;
		pInfo(peer)->scantext = "Chaos Infection! You found 2 Broken bones.";
		pInfo(peer)->pretext = "Patient suffered chaos infection.";
		pInfo(peer)->fixtext = "Patient poor diet has led to a high degree of fat build-up in their liver";
		pInfo(peer)->postext = "You removed it.";
		pInfo(peer)->surgery_name = "Chaos Infection!";
		break;
	case 28:
		pInfo(peer)->fixed = false;
		pInfo(peer)->incneeded = 4;
		pInfo(peer)->temp = 100.1;
		pInfo(peer)->broken = 2;
		pInfo(peer)->fever = 3.1;
		pInfo(peer)->sleep = 3;
		pInfo(peer)->shattered = 2;
		pInfo(peer)->dirt = 10;
		pInfo(peer)->incneeded = 3;
		pInfo(peer)->bleeding = 3;
		pInfo(peer)->scantext = "Lupus! You found 2 Broken bones.";
		pInfo(peer)->pretext = "Patient suffered lupus.";
		pInfo(peer)->fixtext = "Chance of patient tearing skin, adding one extra incision";
		pInfo(peer)->postext = "You removed it.";
		pInfo(peer)->surgery_name = "Lupus!";
		break;
	case 29:
		pInfo(peer)->fixed = true;
		pInfo(peer)->flu = true;
		pInfo(peer)->temp = 107.6;
		pInfo(peer)->fever = 2.5;
		pInfo(peer)->dirt = 6;
		pInfo(peer)->pretext = "Patient is showing signs of the COVID-19.";
		pInfo(peer)->scantext = "COVID-19!";
		pInfo(peer)->surgery_name = "a COVID-19!";
		break;
	case 30:
		pInfo(peer)->incneeded = 7;
		pInfo(peer)->temp = 102.6;
		pInfo(peer)->fever = 0.6;
		pInfo(peer)->scantext = "a Ebola! Patient is having seizure.";
		pInfo(peer)->pretext = "Patient has Ebola.";
		pInfo(peer)->fixtext = "You've finally cured the seizure!";
		pInfo(peer)->postext = "You made the pacient experience a seizure!";
		pInfo(peer)->surgery_name = "a Ebola!";
		break;
	}
	gamepacket_t p;
	p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("`7[``" + pInfo(peer)->name_color + pInfo(peer)->tankIDName + "`` is performing surgery on " + pInfo(peer)->surged_display + "!`7]``"), p.Insert(0), p.Insert(0);
	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != pInfo(peer)->world) continue;
		p.CreatePacket(currentPeer);
	}
	load_surgery(peer, 0);
	return true;
}


void send_growscan_floating(ENetPeer* peer, string search, string type) {
	int total_floating = 0, total_rarity = 0, total_super_item = 0, total_gems = 0;
	vector<pair<int, int>> founditems;
	string name_ = pInfo(peer)->world;
	string found_list = "";
	vector<World>::iterator px = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
	if (px != worlds.end()) {
		World* world_ = &worlds[px - worlds.begin()];
		for (int i_ = 0; i_ < world_->drop.size(); i_++) {
			if (world_->drop[i_].id == 0) continue;
			if (world_->drop[i_].id != 0 || world_->drop[i_].x > 0 || world_->drop[i_].y > 0) {
				if (search == "start") {
					total_floating++;
					if (items[world_->drop[i_].id].rarity < 363) total_rarity += items[world_->drop[i_].id].rarity * world_->drop[i_].count;
					else if (items[world_->drop[i_].id].rarity == 999)total_super_item += world_->drop[i_].count;
					if (world_->drop[i_].id == 112) total_gems += world_->drop[i_].count;
				}
				else if (type == "1" or type == "2" and items[world_->drop[i_].id].blockType == BlockTypes::CLOTHING or type == "3" and items[world_->drop[i_].id].blockType == BlockTypes::CONSUMABLE or type == "4" and items[world_->drop[i_].id].blockType == BlockTypes::FOREGROUND or type == "5" and items[world_->drop[i_].id].blockType == BlockTypes::SEED or type == "6" and items[world_->drop[i_].id].blockType == BlockTypes::LOCK) {
					if (to_lower(items[world_->drop[i_].id].name).find(to_lower(search)) != string::npos) {
						bool copy = true;
						for (int i = 0; i < founditems.size(); i++) {
							if (founditems[i].first == world_->drop[i_].id) {
								founditems[i].second += world_->drop[i_].count;
								copy = false;
							}
						}
						if (copy) founditems.push_back(make_pair(world_->drop[i_].id, world_->drop[i_].count));
					}
				}
			}
		}
		for (int i = 0; i < founditems.size(); i++) found_list += to_string(founditems[i].first) + "," + to_string(founditems[i].second) + ",";
	}
	gamepacket_t p;
	p.Insert("OnDialogRequest");
	if (search == "start") p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wFloating Items``|left|6016|\nadd_spacer|small|\nadd_textbox|`wTotal number in world: " + to_string(total_floating) + "|left\nadd_textbox|`wTotal floating item rarity: " + to_string(total_rarity) + "|left|\nadd_textbox|`wTotal super rare items: " + to_string(total_super_item) + "|left|\nadd_textbox|`wTotal gems: " + to_string(total_gems) + "|left|\nadd_spacer|small|\nadd_text_input|searchName|Search by Name||100|\nadd_button|search_1|Search All|noflags|0|0|\nadd_smalltext|`5Or filter search by type``|left|\nadd_button|search_2|Search Clothing|noflags|0|0|\nadd_button|search_3|Search Consumables|noflags|0|0|\nadd_button|search_4|Search Blocks and Backgrounds|noflags|0|0|\nadd_button|search_5|Search Seeds|noflags|0|0|\nadd_button|search_6|Search Locks|noflags|0|0|\nadd_button|search_1|Search Others|noflags|0|0|\nadd_spacer|small|\nadd_button|back_to_gscan|Back|noflags|0|0|\nend_dialog|statsblock|||\n");
	else {
		if (found_list == "") p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wFloating Items``|left|6016|\nadd_spacer|small|\nadd_textbox|No items found.|left|\nadd_spacer|small|\nadd_button|floatingItems|Back|noflags|0|0|\nend_dialog|statsblock|||\n");
		else p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wFloating Items``|left|6016|\nadd_spacer|small|\nadd_textbox|Press on the icon to be directed to the location of the item.|left|\nadd_spacer|small|\nadd_label_with_icon_button_list|small|`w%s : %s|left|findObject_|itemID_itemAmount|" + found_list + "\nadd_spacer|small|\nadd_button|floatingItems|Back|noflags|0|0|\nend_dialog|statsblock|||\n");
	}
	p.CreatePacket(peer);
}

void send_growscan_worldblocks(ENetPeer* peer, string search, string type) {
	int total_block = 0, total_background = 0, total_untradeable = 0, total_super_rare_item = 0, total_rarity = 0, total_fire = 0, total_water = 0, total_earth = 0, total_air = 0;
	string name_ = pInfo(peer)->world;
	string found_list = "";
	vector<pair<int, int>> founditems;
	vector<World>::iterator px = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
	if (px != worlds.end()) {
		World* world_ = &worlds[px - worlds.begin()];
		for (int i_ = 0; i_ < world_->blocks.size(); i_++) {
			if (world_->blocks[i_].fg != 8 && world_->blocks[i_].fg != 6) {
				if (search == "start") {
					if (world_->blocks[i_].fg != 0) total_block++;
					if (world_->blocks[i_].bg != 0) total_background++;
					if (world_->blocks[i_].fg != 0 && items[world_->blocks[i_].fg].untradeable == 1 or world_->blocks[i_].bg != 0 && items[world_->blocks[i_].bg].untradeable == 1) total_untradeable++;
					if (world_->blocks[i_].fg != 0 and items[world_->blocks[i_].fg].rarity >= 999 or world_->blocks[i_].bg != 0 and items[world_->blocks[i_].bg].rarity >= 999) total_super_rare_item++;
					if (items[world_->blocks[i_].fg].rarity < 363 and items[world_->blocks[i_].fg].rarity != 999) if (world_->blocks[i_].fg != 0) total_rarity += items[world_->blocks[i_].fg].rarity;
					if (world_->blocks[i_].fg != 0 and items[world_->blocks[i_].fg].chi == 0 or world_->blocks[i_].bg != 0 and items[world_->blocks[i_].bg].chi == 0) total_earth++;
					if (world_->blocks[i_].fg != 0 and items[world_->blocks[i_].fg].chi == 1 or world_->blocks[i_].bg != 0 and items[world_->blocks[i_].bg].chi == 1) total_fire++;
					if (world_->blocks[i_].fg != 0 and items[world_->blocks[i_].fg].chi == 2 or world_->blocks[i_].bg != 0 and items[world_->blocks[i_].bg].chi == 2) total_air++;
					if (world_->blocks[i_].fg != 0 and items[world_->blocks[i_].fg].chi == 3 or world_->blocks[i_].bg != 0 and items[world_->blocks[i_].bg].chi == 3) total_water++;
				}
				else if (type == "1" or type == "2" and items[world_->blocks[i_].fg].blockType == BlockTypes::FOREGROUND) {
					if (to_lower(items[world_->blocks[i_].fg].name).find(to_lower(search)) != string::npos || to_lower(items[world_->blocks[i_].bg].name).find(to_lower(search)) != string::npos) {
						if (world_->blocks[i_].fg != 0) {
							bool copy_fg = true;
							for (int i = 0; i < founditems.size(); i++) {
								if (founditems[i].first == world_->blocks[i_].fg) {
									founditems[i].second++;
									copy_fg = false;
								}
							}
							if (copy_fg) founditems.push_back(make_pair(world_->blocks[i_].fg, 1));
						}

						if (world_->blocks[i_].bg != 0) {
							bool copy_bg = true;
							for (int i = 0; i < founditems.size(); i++) {
								if (founditems[i].first == world_->blocks[i_].bg) {
									founditems[i].second++;
									copy_bg = false;
								}
							}
							if (copy_bg) founditems.push_back(make_pair(world_->blocks[i_].bg, 1));
						}
					}
				}
				else if (type == "3") {
					if (to_lower(items[world_->blocks[i_].fg].name).find(to_lower(search)) != string::npos || to_lower(items[world_->blocks[i_].bg].name).find(to_lower(search)) != string::npos) {
						if (world_->blocks[i_].bg != 0) {
							bool copy_bg = true;
							for (int i = 0; i < founditems.size(); i++) {
								if (founditems[i].first == world_->blocks[i_].bg) {
									founditems[i].second++;
									copy_bg = false;
								}
							}
							if (copy_bg) founditems.push_back(make_pair(world_->blocks[i_].bg, 1));
						}
					}
				}
				else if (type == "4") {
					if (to_lower(items[world_->blocks[i_].fg].name).find(to_lower(search)) != string::npos || to_lower(items[world_->blocks[i_].bg].name).find(to_lower(search)) != string::npos) {
						if (world_->blocks[i_].fg != 0 && items[world_->blocks[i_].fg].untradeable == 1 or world_->blocks[i_].bg != 0 && items[world_->blocks[i_].bg].untradeable == 1) {
							if (world_->blocks[i_].fg != 0) {
								bool copy_fg = true;
								for (int i = 0; i < founditems.size(); i++) {
									if (founditems[i].first == world_->blocks[i_].fg) {
										founditems[i].second++;
										copy_fg = false;
									}
								}
								if (copy_fg) founditems.push_back(make_pair(world_->blocks[i_].fg, 1));
							}

							if (world_->blocks[i_].bg != 0) {
								bool copy_bg = true;
								for (int i = 0; i < founditems.size(); i++) {
									if (founditems[i].first == world_->blocks[i_].bg) {
										founditems[i].second++;
										copy_bg = false;
									}
								}
								if (copy_bg) founditems.push_back(make_pair(world_->blocks[i_].bg, 1));
							}
						}
					}
				}
			}
		}
		for (int i = 0; i < founditems.size(); i++) found_list += to_string(founditems[i].first) + "," + to_string(founditems[i].second) + ",";
	}
	gamepacket_t p;
	p.Insert("OnDialogRequest");
	if (search == "start") p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wWorld Blocks``|left|6016|\nadd_spacer|small|\nadd_label|small|`wThis world contains|left\nadd_textbox|`wBlocks: " + to_string(total_block) + "``|\nadd_textbox|`wBackgrounds: " + to_string(total_background) + "``|\nadd_textbox|`wUntradeable blocks: " + to_string(total_untradeable) + "``|left|\nadd_textbox|`wSuper rare items: " + to_string(total_super_rare_item) + "|left|\nadd_textbox|`wTotal block rarity: " + to_string(total_rarity) + "``|left|\nadd_label_with_icon|small|`wFire: " + to_string(total_fire) + "|left|6020|\nadd_label_with_icon|small|`wWater: " + to_string(total_water) + "|left|6024|\nadd_label_with_icon|small|`wEarth: " + to_string(total_earth) + "|left|6018|\nadd_label_with_icon|small|`wAir: " + to_string(total_air) + "|left|6022|\nadd_spacer|small|\nadd_text_input|searchName|Search by Name||100|\nadd_button|search_1|Search All|noflags|0|0|\nadd_smalltext|`5Or filter search by type``|left|\nadd_button|search_2|Search Blocks|noflags|0|0|\nadd_button|search_3|Search Backgrounds|noflags|0|0|\nadd_button|search_4|Search Untradeable|noflags|0|0|\nadd_spacer|small|\nadd_button|back_to_gscan|Back|noflags|0|0|\nend_dialog|statsblockworld|||\n");
	else {
		if (found_list == "") p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wWorld Blocks``|left|6016|\nadd_spacer|small|\nadd_textbox|No results found.|left|\nadd_spacer|small|\nadd_button|worldBlocks|Back|noflags|0|0|\nend_dialog|statsblock|||\n");
		else p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wWorld Blocks``|left|6016|\nadd_spacer|small|\nadd_button|worldBlocks|Back|noflags|0|0|\nadd_spacer|small|\nadd_quick_exit|\nadd_textbox|Press on the icon to be directed to the location of the item.|left|\nadd_spacer|small|\nadd_label_with_icon_button_list|small|`w%s : %s|left|findTile_|itemIDseed2tree_itemAmount|" + found_list + "\nadd_spacer|small|\nadd_button|worldBlocks|Back|noflags|0|0|\nend_dialog|statsblockworld|||\n");
	}
	p.CreatePacket(peer);
}

void cant_enter(ENetPeer* peer, string text, bool door, int delay) {
	gamepacket_t p2(delay);
	if (door) {
		gamepacket_t p(delay, pInfo(peer)->netID), p3(delay), p4(delay, pInfo(peer)->netID);
		p.Insert("OnSetFreezeState"), p.Insert(1), p.CreatePacket(peer);
		p3.Insert("OnZoomCamera"), p3.Insert((float)10000.000000), p3.Insert(1000), p3.CreatePacket(peer);
		p4.Insert("OnSetFreezeState"), p4.Insert(0), p4.CreatePacket(peer);
	}
	else {
		gamepacket_t p2;
		p2.Insert("OnFailedToEnterWorld"), p2.CreatePacket(peer);
	}
	p2.Insert("OnConsoleMessage"), p2.Insert(text), p2.CreatePacket(peer);
	pInfo(peer)->cancel_enter = true;
	return;
}
int aaa = 0;
void join_world(ENetPeer* peer, string& name_, int spawnas_x = 0, int spawnas_y = 0, int delay = 0, bool locked = false, bool door = false) {
	if (pInfo(peer)->tankIDName.empty()) return;
	if (not door) {
		if (pInfo(peer)->world_time + 1500 > (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) {
			gamepacket_t p;
			p.Insert("OnFailedToEnterWorld"), p.CreatePacket(peer);
			return;
		}
		pInfo(peer)->world_time = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
	}
	if (not check_name(name_)) return cant_enter(peer, name_, door, delay);
	if (pInfo(peer)->n == 0) name_ = "START";
	if (has_playmod(pInfo(peer), "Cursed")) name_ = "HELL";
	World world_ = get_world(name_);
	string owner_name = world_.owner_name, user_name = (not pInfo(peer)->d_name.empty() ? pInfo(peer)->d_name : pInfo(peer)->tankIDName);
	if (world_.nuked == true && pInfo(peer)->mod + pInfo(peer)->superdev + pInfo(peer)->dev < 1) return cant_enter(peer, "That world is inaccessible.", door, delay);
	for (pair<string, long long int> p : world_.bannedPlayers) {
		if (p.first == (not pInfo(peer)->d_name.empty() ? pInfo(peer)->d_name : pInfo(peer)->tankIDName)) {
			long long int time = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
			if (p.second + WORLDBAN_TIME > time) return cant_enter(peer, "`4Oh no!`` You've been banned from that world by its owner! Try again later after the world ban wears off.", door, delay);
		}
	}
	int w_c = 0, s_c = 0, net_ = 1, r_c = 0;
	get_players(world_.name, w_c, s_c, net_, r_c);
	if (w_c >= 35 and not pInfo(peer)->dev and not pInfo(peer)->mod) return cant_enter(peer, "Oops, `5" + world_.name + "`` already has `435`` people in it. Try again later.", door, delay);
	if (pInfo(peer)->level < world_.entry_level and world_.owner_name != (not pInfo(peer)->d_name.empty() ? pInfo(peer)->d_name : pInfo(peer)->tankIDName) and not pInfo(peer)->dev and not pInfo(peer)->mod) {
		if (!guild_access(peer, world_.guild_id) and find(world_.admins.begin(), world_.admins.end(), user_name) == world_.admins.end()) return cant_enter(peer, "Players lower than level " + to_string(world_.entry_level) + " can't enter " + world_.name + ".", door, delay);
	}
	uint32_t ySize = world_.blocks.size() / 100, xSize = world_.blocks.size() / ySize, square = world_.blocks.size();
	if (world_.name == pInfo(peer)->world) {
		gamepacket_t p(delay, pInfo(peer)->netID);
		p.Insert("OnSetFreezeState");
		p.Insert(1);
		p.CreatePacket(peer);
		int door_x_ = 0; int door_y_ = 0;
		if (spawnas_x != 0) {
			door_x_ = spawnas_x, door_y_ = spawnas_y;
		}
		else if (not locked) {
			for (int i_ = 0; i_ < (int)square; i_++) {
				if (items[world_.blocks[i_].fg].blockType == BlockTypes::MAIN_DOOR) {
					door_x_ = i_ % xSize, door_y_ = i_ / xSize;
					pInfo(peer)->c_x = door_x_, pInfo(peer)->c_y = door_y_;
					gamepacket_t p(delay, pInfo(peer)->netID);
					p.Insert("SetRespawnPos");
					p.Insert(i_);
					p.CreatePacket(peer);
					break;
				}
			}
		}
		else {
			gamepacket_t p(delay);
			p.Insert("OnTalkBubble");
			p.Insert(pInfo(peer)->netID);
			p.Insert("The door is locked.");
			p.Insert(0), p.Insert(0);
			p.CreatePacket(peer);
		}
		{
			if (not locked) {
				pInfo(peer)->x = door_x_ * 32, pInfo(peer)->y = door_y_ * 32;
				gamepacket_t p(delay, pInfo(peer)->netID);
				p.Insert("OnSetPos");
				p.Insert(float(door_x_) * 32, float(door_y_) * 32);
				p.CreatePacket(peer);
			}
		}
		{
			gamepacket_t p(delay);
			p.Insert("OnZoomCamera");
			p.Insert((float)10000.000000);
			p.Insert(1000);
			p.CreatePacket(peer);
		}
		{
			gamepacket_t p(delay, pInfo(peer)->netID);
			p.Insert("OnSetFreezeState");
			p.Insert(0);
			p.CreatePacket(peer);
		}
		{
			if (not locked and not pInfo(peer)->invis) {
				gamepacket_t p(delay, pInfo(peer)->netID);
				p.Insert("OnPlayPositioned");
				p.Insert("audio/door_open.wav");
				p.CreatePacket(peer);
			}
		}
		return;
	}
	else if (not pInfo(peer)->world.empty()) {
		exit_(peer, true);
	}
	pInfo(peer)->lock = 0;
	pInfo(peer)->world = world_.name;
	size_t namelen = world_.name.length();
	int alloc = (8 * square) + (world_.drop.size() * 16), s1 = 4, s3 = 8, zero = 0;
	//world_.drop.size() * 16
	int total = 78 + namelen + square + 24 + alloc;
	BYTE* data = (BYTE*)malloc(99999999);
	memset(data, 0, total);
	memcpy(data, &s1, 1);
	memcpy(data + 4, &s1, 1);
	memcpy(data + 16, &s3, 1);
	memcpy(data + 66, &namelen, 1);
	memcpy(data + 68, world_.name.c_str(), namelen);
	memcpy(data + 68 + namelen, &xSize, 1);
	memcpy(data + 72 + namelen, &ySize, 1);
	memcpy(data + 76 + namelen, &square, 2);
	BYTE* blc = data + 80 + namelen;
	int spawn_x = 0, spawn_y = 0;
	world_.active_jammers.clear();
	vector<string> world_mods;
	vector<vector<unsigned int>> world_locks, world_seeds, world_crystals;
	for (int i_ = 0; i_ < (int)square; i_++) {
		//if (world_.lockid == 4428 && world_.blocks[i_].fg == 10 && rand() % 10000 < 10) world_.blocks[i_].fg = 392;
		if (items[world_.blocks[i_].fg].blocked_place) world_.blocks[i_].fg = 0; // crash block
		if (world_.blocks[i_].bg == 65535) world_.blocks[i_].bg = 0;
		//if (world_.blocks[i_].fg == 3760) world_.blocks[i_].fg = 8;
		//if (world_.blocks[i_].fg != 2 && world_.blocks[i_].fg != 4 && world_.blocks[i_].fg != 0 && world_.blocks[i_].fg != 8) cout << world_.blocks[i_].fg << ", ";
		memcpy(blc, &world_.blocks[i_].fg, 2);
		memcpy(blc + 2, &world_.blocks[i_].bg, 2);
		memcpy(blc + 4, &world_.blocks[i_].flags, 4);
		if (world_.blocks[i_].flags & 0x00400000) {
			switch (world_.blocks[i_].fg) {
			case 226:
			{
				if (find(world_mods.begin(), world_mods.end(), "`4JAMMED``") == world_mods.end()) world_mods.push_back("`4JAMMED``");
				break;
			}
			case 1276:
			{
				if (find(world_mods.begin(), world_mods.end(), "`2NOPUNCH``") == world_mods.end()) world_mods.push_back("`2NOPUNCH``");
				break;
			}
			case 1278:
			{
				if (find(world_mods.begin(), world_mods.end(), "`2IMMUNE``") == world_mods.end()) world_mods.push_back("`2IMMUNE``");
				break;
			}
			case 4884:
			{
				if (find(world_mods.begin(), world_mods.end(), "`2NOWAR``") == world_mods.end()) world_mods.push_back("`2NOWAR``");
				break;
			}
			case 4992:
			{
				if (find(world_mods.begin(), world_mods.end(), "`2ANTIGRAVITY``") == world_mods.end()) world_mods.push_back("`2ANTIGRAVITY``");
				break;
			}
			default:
				break;
			}
			if (find(world_.active_jammers.begin(), world_.active_jammers.end(), world_.blocks[i_].fg) == world_.active_jammers.end()) world_.active_jammers.push_back(world_.blocks[i_].fg);
		}
		//if (world_.blocks[i_].fg == 656) {
			//total += form_visual(blc, world_.blocks[i_], world_, peer);
		//}
		if (items[world_.blocks[i_].fg].item_sucker or items[world_.blocks[i_].fg].magplant) {
			switch (world_.blocks[i_].fg) {
			case 5638: // magplant
			{
				uint8_t magnetronas_ijungtas = world_.blocks[i_].magnetron ? 1 : 0;
				uint8_t active_ = world_.blocks[i_].enabled ? 1 : 0;
				uint32_t block_id = world_.blocks[i_].id;
				uint32_t item_count = world_.blocks[i_].pr;
				uint32_t kiek_telpa = 5000;
				BYTE btype = 62;
				memcpy(blc + 8, &btype, 1);
				memcpy(blc + 9, &block_id, 4);
				memcpy(blc + 13, &item_count, 4);
				memcpy(blc + 17, &active_, 1);
				memcpy(blc + 18, &magnetronas_ijungtas, 1);
				memcpy(blc + 20, &kiek_telpa, 2);
				blc += 15;
				total += 15;
				break;
			}
			case 6948: case 6946:
			{
				int max_telpa = 1500;
				int active_ = world_.blocks[i_].enabled ? 1 : 0;
				int block_id = world_.blocks[i_].id;
				int item_count = world_.blocks[i_].pr;
				BYTE btype = 62;
				memcpy(blc + 8, &btype, 1);
				memcpy(blc + 9, &block_id, 4);
				memcpy(blc + 13, &item_count, 4);
				memcpy(blc + 17, &active_, 4);
				memcpy(blc + 21, &max_telpa, 4);
				blc += 15;
				total += 15;
				break;
			}
			case 6950: case 6952:
			{
				int actually_active = world_.blocks[i_].pr > 0 ? 1 : 0;
				int amount_of_gems = world_.blocks[i_].pr;
				int block_id = world_.blocks[i_].id;
				int is_enabled = world_.blocks[i_].enabled ? 1 : 0;
				BYTE btype = (world_.blocks[i_].fg == 6950 ? 70 : 69);
				memcpy(blc + 8, &btype, 1);
				memcpy(blc + 9, &actually_active, 4);
				memcpy(blc + 13, &amount_of_gems, 4);
				memcpy(blc + 17, &block_id, 4);
				memcpy(blc + 21, &is_enabled, 4);
				blc += 13;
				total += 13;
				break;
			}
			}
		}
		else if (items[world_.blocks[i_].fg].easel) {
			BYTE btype = 0x23;
			memcpy(blc + 8, &btype, 1);
			memcpy(blc + 9, &world_.blocks[i_].id, 4);
			string sign_tekstas = world_.blocks[i_].txt;
			uint32_t dydis = uint32_t(sign_tekstas.size());
			memcpy(blc + 13, &dydis, 2);
			memcpy(blc + 15, sign_tekstas.c_str(), dydis);
			blc += 7 + dydis;
			total += 7 + dydis;
		}
		else if (items[world_.blocks[i_].fg].bunny_egg) {
			BYTE btype = 15;
			memcpy(blc + 8, &btype, 1);
			memcpy(blc + 9, &world_.blocks[i_].bunny_egg_progress, 4);
			blc += 5;
			total += 5;
		}
		else if (items[world_.blocks[i_].fg].dshelf) {
			BYTE btype = 43;
			memcpy(blc + 8, &btype, 1);
			memcpy(blc + 9, &world_.blocks[i_].shelf_1, 4);
			memcpy(blc + 13, &world_.blocks[i_].shelf_2, 4);
			memcpy(blc + 17, &world_.blocks[i_].shelf_3, 4);
			memcpy(blc + 21, &world_.blocks[i_].shelf_4, 4);
			blc += 17;
			total += 17;
		}
		else if (items[world_.blocks[i_].fg].fish_port) {
			// nebaigta
			BYTE btype = 63;
			memcpy(blc + 8, &btype, 1);
			blc += 1 + 4 + 8;
			total += 1 + 4 + 8;
		}
		else if (items[world_.blocks[i_].fg].timer) {
			BYTE btype = 45;
			memcpy(blc + 8, &btype, 1);
			blc += 1;
			total += 1;
		}
		else if (items[world_.blocks[i_].fg].heart_monitor) {
			BYTE btype = 11;
			memcpy(blc + 8, &btype, 1);
			string monitoriaus_tekstas = world_.blocks[i_].heart_monitor;
			{
				uint32_t ijungtas = -1;
				for (int i = 0; i < monitors.size(); i++) {
					if (monitors[i].x == i_ % xSize and monitors[i].y == i_ / xSize) {
						ijungtas = monitors[i].active;
						break;
					}
				} if (ijungtas == -1) {
					string find_mon = monitoriaus_tekstas;
					if (find_mon.size() >= 2) find_mon.resize(find_mon.size() - 2); // remove `` is galo
					ijungtas = 0;
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
						if (pInfo(currentPeer)->name_color + pInfo(currentPeer)->tankIDName == find_mon) {
							ijungtas = 1;
							break;
						}
					}
					GlobalMonitors new_monitor;
					new_monitor.active = ijungtas;
					new_monitor.world_name = world_.name;
					new_monitor.x = i_ % xSize;
					new_monitor.y = i_ / xSize;
					monitors.push_back(new_monitor);
					int state_of_block = world_.blocks[i_].flags | 0x00400000;
					if (ijungtas) memcpy(blc + 4, &state_of_block, 4);
				}
				memcpy(blc + 9, &ijungtas, 4);
			}
			uint32_t dydis = uint32_t(monitoriaus_tekstas.size());
			memcpy(blc + 13, &dydis, 2);
			memcpy(blc + 15, monitoriaus_tekstas.c_str(), dydis);
			blc += 7 + dydis;
			total += 7 + dydis;
		}
		else if (items[world_.blocks[i_].fg].xeno) {
			BYTE btype = 53;
			memcpy(blc + 8, &btype, 1);
			blc += 9;
			total += 9;
		}
		else if (items[world_.blocks[i_].fg].trickster) {
			BYTE btype = 52;
			memcpy(blc + 8, &btype, 1);
			blc += 1;
			total += 1;
		}
		else if (items[world_.blocks[i_].fg].charger) {
			int test_ = world_.blocks[i_].id != 0 ? 0x00400000 : world_.blocks[i_].flags;
			memcpy(blc + 4, &test_, 4);
			BYTE btype = 57;
			memcpy(blc + 8, &btype, 1);
			long long time_ = time(nullptr);
			uint16_t sk = (world_.blocks[i_].planted - time_ <= 0 ? 3600 : 3600 - (world_.blocks[i_].planted - time_));
			memcpy(blc + 9, &sk, 2);
			blc += 5;
			total += 5;
		}
		else if (items[world_.blocks[i_].fg].spirit) {
			BYTE btype = 41;
			memcpy(blc + 8, &btype, 1);
			uint32_t sk = world_.blocks[i_].c_;
			memcpy(blc + 9, &sk, 4);
			blc += 5;
			total += 5;
		}
		else if (items[world_.blocks[i_].fg].trans) {
			BYTE btype = 19;
			memcpy(blc + 8, &btype, 1);
			blc += 19;
			total += 19;
		}
		else if (items[world_.blocks[i_].fg].mannequin) {
			BYTE btype = 14;
			memcpy(blc + 8, &btype, 1);
			string sign_tekstas = world_.blocks[i_].txt;
			uint32_t dydis = uint32_t(sign_tekstas.size());
			memcpy(blc + 9, &dydis, 2);
			memcpy(blc + 11, sign_tekstas.c_str(), dydis);
			memcpy(blc + 16 + dydis, &world_.blocks[i_].mannequin.c_hair, 2);
			memcpy(blc + 18 + dydis, &world_.blocks[i_].mannequin.c_shirt, 2);
			memcpy(blc + 20 + dydis, &world_.blocks[i_].mannequin.c_pants, 2);
			memcpy(blc + 22 + dydis, &world_.blocks[i_].mannequin.c_feet, 2);
			memcpy(blc + 24 + dydis, &world_.blocks[i_].mannequin.c_head, 2);
			memcpy(blc + 26 + dydis, &world_.blocks[i_].mannequin.c_hand, 2);
			memcpy(blc + 28 + dydis, &world_.blocks[i_].mannequin.c_back, 2);
			memcpy(blc + 30 + dydis, &world_.blocks[i_].mannequin.c_mask, 2);
			memcpy(blc + 32 + dydis, &world_.blocks[i_].mannequin.c_neck, 2);
			blc += 26 + dydis;
			total += 26 + dydis;
		}
		else if (items[world_.blocks[i_].fg].vipentrance) {
			BYTE btype = 44;
			memcpy(blc + 8, &btype, 1);
			vector<int> vip_members;
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
				if (pInfo(currentPeer)->world == world_.name or currentPeer == peer) {
					if (world_.blocks[i_].limit_admins or find(world_.blocks[i_].admins.begin(), world_.blocks[i_].admins.end(), pInfo(currentPeer)->tankIDName) != world_.blocks[i_].admins.end() or pInfo(currentPeer)->tankIDName == world_.owner_name or world_.owner_name.empty()) {
						vip_members.push_back(pInfo(currentPeer)->id);
					}
				}
			}
			uint32_t sk = vip_members.size();
			memcpy(blc + 14, &sk, 1);
			for (int i = 0; i < vip_members.size(); i++) {
				memcpy(blc + 18 + (i * 4), &vip_members[i], 4);
			}
			blc += 10 + (sk * 4);
			total += 10 + (sk * 4);
		}
		else if (items[world_.blocks[i_].fg].infinitymachine) {
			BYTE btype = 19;
			memcpy(blc + 8, &btype, 1);
			blc += 19;
			total += 19;
		}
		else if (items[world_.blocks[i_].fg].portrait) {
			BYTE btype = 48;
			memcpy(blc + 8, &btype, 1);
			string sign_tekstas = world_.blocks[i_].txt;
			uint32_t dydis = uint32_t(sign_tekstas.size());
			memcpy(blc + 9, &dydis, 2);
			memcpy(blc + 11, sign_tekstas.c_str(), dydis);
			if (world_.blocks[i_].portrait.c_skin == 0 and world_.blocks[i_].portrait.c_face == 0 and world_.blocks[i_].portrait.c_head == 0 and world_.blocks[i_].portrait.c_hair == 0) {

			}
			else {
				memcpy(blc + 11 + dydis, &world_.blocks[i_].portrait.c_expression, 4);
				memcpy(blc + 19 + dydis, &world_.blocks[i_].portrait.c_hair_colour, 4);
				memcpy(blc + 23 + dydis, &world_.blocks[i_].portrait.c_skin, 4);
				memcpy(blc + 27 + dydis, &world_.blocks[i_].portrait.c_face, 2);
				memcpy(blc + 29 + dydis, &world_.blocks[i_].portrait.c_head, 2);
				memcpy(blc + 31 + dydis, &world_.blocks[i_].portrait.c_hair, 2);
			}
			blc += 7 + 15 + 3 + dydis;
			total += 7 + 15 + 3 + dydis;
		}
		else if (items[world_.blocks[i_].fg].vall_mount) {
			BYTE btype = 47;
			memcpy(blc + 8, &btype, 1);
			uint32_t sk = 0;
			memcpy(blc + 9, &sk, 4);
			blc += 8;
			total += 8;
		}
		else if (items[world_.blocks[i_].fg].bulletin_board or items[world_.blocks[i_].fg].storage_box or items[world_.blocks[i_].fg].growscan or items[world_.blocks[i_].fg].security_camera or items[world_.blocks[i_].fg].spotlight) {
			BYTE btype = 6;
			memcpy(blc + 8, &btype, 1);
			blc += 8;
			total += 8;
		}
		else if (items[world_.blocks[i_].fg].mailbox or world_.blocks[i_].fossil) {
			int test_ = world_.blocks[i_].flags;
			memcpy(blc + 4, &world_.blocks[i_].flags, 4);
			BYTE btype = 12;
			memcpy(blc + 8, &btype, 1);
			blc += 8;
			total += 8;
		}
		else {
			switch (items[world_.blocks[i_].fg].blockType) {
			case BlockTypes::WEATHER:
			{
				switch (world_.blocks[i_].fg) {
				case 3694:
				{
					BYTE btype = 0x28;
					memcpy(blc + 8, &btype, 1);
					int rgb = (world_.blocks[i_].b << 24) | (world_.blocks[i_].g << 16) | (world_.blocks[i_].r << 8);
					memcpy(blc + 9, &rgb, 4);
					blc += 5;
					total += 5;
					break;
				}
				case 5000:
				{
					BYTE btype = 40;
					memcpy(blc + 8, &btype, 1);
					uint32_t item_id = (world_.blocks[i_].id != 0 ? world_.blocks[i_].id : 14);
					memcpy(blc + 9, &item_id, 4);
					blc += 5;
					total += 5;
					break;
				}
				case 3832:
				{
					BYTE btype = 49;
					memcpy(blc + 8, &btype, 1);
					uint32_t item_id = (world_.blocks[i_].id != 0 ? world_.blocks[i_].id : 2);
					uint32_t item_gravity = world_.blocks[i_].gravity;
					uint8_t item_status = (int)world_.blocks[i_].spin | ((int)world_.blocks[i_].invert << 1);
					memcpy(blc + 9, &item_id, 4);
					memcpy(blc + 13, &item_gravity, 4);
					memcpy(blc + 17, &item_status, 4);
					blc += 10;
					total += 10;
					break;
				}
				
				default:
				{
					if (items[world_.blocks[i_].fg].ext_weather) {
						BYTE btype = 5;
						memcpy(blc + 8, &btype, 1);
						blc += 1;
						total += 1;
					}
					break;
				}
				}
				break;
			}
			case BlockTypes::CRYSTAL:
			{
				//total += form_visual(blc, world_.blocks[i_], world_, peer);
				world_crystals.push_back({ i_ % xSize, i_ / xSize });
				uint32_t nulis = 0;
				memcpy(blc, &nulis, 2);
				break;
			}
			case BlockTypes::VENDING:
			{
				//total += form_visual(blc, world_.blocks[i_], world_, peer);
				uint32_t item_id = world_.blocks[i_].id;
				uint32_t item_price = world_.blocks[i_].pr;
				uint32_t item_count = world_.blocks[i_].c_;
				uint32_t vend_available_wls = world_.blocks[i_].wl;
				int visual = world_.blocks[i_].flags | ((int)item_id == 0 ? ((int)vend_available_wls != 0 ? 0x02000000 : 0x00000000) : ((int)vend_available_wls != 0 ? 0x02410000 : 0x00410000));
				if ((int)item_price < 0 and (int)item_id != 0) {
					if ((int)item_count < ((int)item_price * -1))
						item_id = 0, item_price = 0;
					visual = world_.blocks[i_].flags | (((int)item_count < ((int)item_price * -1)) ? ((int)vend_available_wls != 0 ? 0x02410000 : 0x00410000) : ((int)vend_available_wls != 0 ? 0x02410000 : 0x00410000));
				}
				memcpy(blc + 4, &visual, 4);
				BYTE btype = 24;
				memcpy(blc + 8, &btype, 1);
				memcpy(blc + 9, &item_id, 4);
				memcpy(blc + 13, &item_price, 4);
				blc += 9;
				total += 9;
				break;
			}
			case BlockTypes::DISPLAY:
			{
				//total += form_visual(blc, world_.blocks[i_], world_, peer);
				BYTE btype = 23;
				memcpy(blc + 8, &btype, 1);
				uint32_t id_ = world_.blocks[i_].id;
				memcpy(blc + 9, &id_, 4);
				blc += 5;
				total += 5;
				break;
			}
			case BlockTypes::PROVIDER:
			{
				//total += form_visual(blc, world_.blocks[i_], world_, peer);
				BYTE btype = 9;
				memcpy(blc + 8, &btype, 1);
				uint32_t laikas = uint32_t((time(nullptr) - world_.blocks[i_].planted <= items[world_.blocks[i_].fg].growTime ? time(nullptr) - world_.blocks[i_].planted : items[world_.blocks[i_].fg].growTime));
				memcpy(blc + 9, &laikas, 4);
				blc += 5;
				total += 5;
				break;
			}
			case BlockTypes::RANDOM_BLOCK:
			{
				//total += form_visual(blc, world_.blocks[i_], world_, peer);
				BYTE btype = 8;
				memcpy(blc + 8, &btype, 1);
				memcpy(blc + 9, &world_.blocks[i_].roll, 1);
				//if (case_) {
				blc += 2;
				total += 2;
				//}
				break;
			}
			case BlockTypes::LOCK:
			{
				if (world_.blocks[i_].fg == 202 or world_.blocks[i_].fg == 204 or world_.blocks[i_].fg == 206 or world_.blocks[i_].fg == 4994) {
					world_locks.push_back({ i_ % xSize, i_ / xSize });
				}
				else pInfo(peer)->lock = world_.blocks[i_].fg;

				if (world_.blocks[i_].open_to_public) {
					int new_ = 0x00800000;
					memcpy(blc + 4, &new_, 4);
				}
				BYTE btype = 3;
				memcpy(blc + 8, &btype, 1);
				uint8_t world_settings = world_.disable_music_blocks ? (world_.make_music_blocks_invisible ? 12345 : 1234) : (world_.make_music_blocks_invisible ? 100 : 0);
				if (world_.rainbows and world_.blocks[i_].fg == 4802) world_settings += 128;
				uint32_t world_owner_id = -1;
				{
					if (world_.blocks[i_].fg == 202 or world_.blocks[i_].fg == 204 or world_.blocks[i_].fg == 206 or world_.blocks[i_].fg == 4994) {
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
							if (world_.blocks[i_].owner_name == pInfo(currentPeer)->tankIDName) {
								world_owner_id = pInfo(currentPeer)->id;
							}
						}
					}
					else {
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
							if (world_.owner_name == pInfo(currentPeer)->tankIDName) {
								world_owner_id = pInfo(currentPeer)->id;
							}
						}
					}
				}
				uint32_t admin_id = 0;
				uint32_t bpm_ = world_.music_bpm * -1;
				memcpy(blc + 9, &world_settings, 1);
				memcpy(blc + 10, &world_owner_id, 4);
				memcpy(blc + 18, &bpm_, 4);
				uint32_t count_of_admins = 1;
				{
					if (world_.blocks[i_].fg == 202 or world_.blocks[i_].fg == 204 or world_.blocks[i_].fg == 206 or world_.blocks[i_].fg == 4994) {
						if (peer != NULL and find(world_.blocks[i_].admins.begin(), world_.blocks[i_].admins.end(), pInfo(peer)->tankIDName) != world_.blocks[i_].admins.end()) {
							memcpy(blc + 22, &pInfo(peer)->id, 4);
							count_of_admins++;
						} for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
							if (pInfo(currentPeer)->world == world_.name) {
								if (find(world_.blocks[i_].admins.begin(), world_.blocks[i_].admins.end(), pInfo(currentPeer)->tankIDName) != world_.blocks[i_].admins.end()) {
									if (count_of_admins == 1) {
										memcpy(blc + 22, &pInfo(currentPeer)->id, 4);
									}
									else {
										memcpy(blc + 22 + (count_of_admins * 4), &pInfo(currentPeer)->id, 4);
									}
									count_of_admins++;
								}
							}
						}
					}
					else {
						if (peer != NULL and guild_access(peer, world_.guild_id) or find(world_.admins.begin(), world_.admins.end(), pInfo(peer)->tankIDName) != world_.admins.end()) {
							memcpy(blc + 22, &pInfo(peer)->id, 4);
							count_of_admins++;
						} for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
							if (pInfo(currentPeer)->world == world_.name) {
								if (guild_access(currentPeer, world_.guild_id) or find(world_.admins.begin(), world_.admins.end(), pInfo(currentPeer)->tankIDName) != world_.admins.end()) {
									if (count_of_admins == 1) {
										memcpy(blc + 22, &pInfo(currentPeer)->id, 4);
									}
									else {
										memcpy(blc + 22 + (count_of_admins * 4), &pInfo(currentPeer)->id, 4);
									}
									count_of_admins++;
								}
							}
						}
					}
					memcpy(blc + 14, &count_of_admins, 1);
				}
				if (world_.blocks[i_].fg == 5814 and world_.guild_id != 0) {
					uint32_t guild_id = world_.guild_id;
					vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
					if (p != guilds.end()) {
						Guild* guild_information = &guilds[p - guilds.begin()];
						memcpy(blc + (count_of_admins == 1 ? 22 : 22 + ((count_of_admins - 1) * 4)) + 4, &guild_information->guild_mascot[0], 2);
						memcpy(blc + (count_of_admins == 1 ? 22 : 22 + ((count_of_admins - 1) * 4)) + 6, &guild_information->guild_mascot[1], 2);
						memcpy(blc + (count_of_admins == 1 ? 22 : 22 + ((count_of_admins - 1) * 4)) + 8, &guild_information->guild_level, 2);
						memcpy(blc + (count_of_admins == 1 ? 22 : 22 + ((count_of_admins - 1) * 4)) + 12, &guild_information->unlocked_mascot, 1);
						blc += 26 + (count_of_admins * 4);
						total += 26 + (count_of_admins * 4);
					}
				}
				else {
					blc += 10 + (count_of_admins * 4);
					total += 10 + (count_of_admins * 4);
				}
				break;
			}
			case BlockTypes::MAIN_DOOR:
			{
				spawn_x = (i_ % xSize) * 32, spawn_y = (i_ / xSize) * 32;
				pInfo(peer)->c_x = spawn_x / 32;
				pInfo(peer)->c_y = spawn_y / 32;
				BYTE btype = 1;
				memcpy(blc + 8, &btype, 1);
				string text = "EXIT";
				int l_ = (int)text.size();
				memcpy(blc + 9, &l_, 2);
				memcpy(blc + 11, text.c_str(), l_);
				blc += 4 + l_;
				total += 4 + l_;
				break;
			}
			case BlockTypes::SEED:
			{
				world_seeds.push_back({ i_ % xSize, i_ / xSize });
				/*int visual = world_.blocks[i_].flags | 0x100000;
				memcpy(blc + 4, &visual, 4);
				BYTE data_type = 4;
				memcpy(blc + 8, &data_type, 1);
				int laikas = (time(nullptr) - world_.blocks[i_].planted <= items[world_.blocks[i_].fg].growTime ? time(nullptr) - world_.blocks[i_].planted : items[world_.blocks[i_].fg].growTime);
				short count = (short)world_.blocks[i_].fruit;
				if (count == -1) count = 1;
				memcpy(blc + 9, &laikas, 4);
				memcpy(blc + 13, &count, 1);
				blc += 6;
				total += 6;*/
				uint32_t nulis = 0;
				memcpy(blc, &nulis, 2);
				break;
			}
			case BlockTypes::DONATION:
			{
				int test_ = world_.blocks[i_].flags;
				if (world_.blocks[i_].donates.size() > 0) {
					test_ = (world_.blocks[i_].flags | 0x00400000);
				}
				memcpy(blc + 4, &test_, 4);
				BYTE btype = 12;
				memcpy(blc + 8, &btype, 1);
				blc += 8;
				total += 8;
				break;
			}
			case BlockTypes::DOOR: case BlockTypes::PORTAL:
			{
				//total += form_visual(blc, world_.blocks[i_], world_, peer);
				BYTE data_type = 1;
				memcpy(blc + 8, &data_type, 1);
				string duru_tekstas = (world_.blocks[i_].txt.empty() ? (world_.blocks[i_].door_destination.empty() ? "" : (world_.blocks[i_].door_destination.find(":") != string::npos ? explode(":", world_.blocks[i_].door_destination)[0] + "..." : world_.blocks[i_].door_destination)) : world_.blocks[i_].txt);
				uint32_t dydis = uint32_t(duru_tekstas.size());
				memcpy(blc + 9, &dydis, 2);
				memcpy(blc + 11, duru_tekstas.c_str(), dydis);
				uint8_t locked_ = (world_.blocks[i_].open ? 0 : 0x08);
				memcpy(blc + 11 + dydis, &locked_, 1);
				blc += 4 + dydis;
				total += 4 + dydis;
				break;
			}
			case BlockTypes::SIGN:
			{
				//total += form_visual(blc, world_.blocks[i_], world_, peer);
				BYTE data_type = 2;
				memcpy(blc + 8, &data_type, 1);
				string sign_tekstas = world_.blocks[i_].txt;
				uint32_t dydis = uint32_t(sign_tekstas.size());
				memcpy(blc + 9, &dydis, 2);
				memcpy(blc + 11, sign_tekstas.c_str(), dydis);
				uint8_t nzn_kas = 0;
				memcpy(blc + 11 + dydis, &nzn_kas, 1);
				//if (case_) {
				blc += 7 + dydis;
				total += 7 + dydis;
				//}
				break;
			}
			}
		}
		blc += 8;
	}
	int count = int(world_.drop.size()), last_uid = int(world_.drop.size());
	memcpy(blc, &count, 4);
	memcpy(blc + 4, &last_uid, 4);
	blc += 8;
	for (int i_ = 0; i_ < world_.drop.size(); i_++) {
		int item = world_.drop[i_].id, count = world_.drop[i_].count, uid = world_.drop[i_].uid;
		float x = world_.drop[i_].x, y = world_.drop[i_].y;
		memcpy(blc, &item, 2);
		memcpy(blc + 2, &x, 4);
		memcpy(blc + 6, &y, 4);
		memcpy(blc + 10, &count, 2);
		memcpy(blc + 12, &uid, 4);
		blc += 16;
	}
	//int weather_data_ = 12;
	//memcpy(blc + 4, &weather_data_, 4);
	ENetPacket* p_ = enet_packet_create(data, total, ENET_PACKET_FLAG_RELIABLE);
	enet_peer_send(peer, 0, p_);
	delete[] data;
	pInfo(peer)->netID = net_;
	if (spawnas_x != 0 or spawnas_y != 0) spawn_x = spawnas_x * 32, spawn_y = spawnas_y * 32;

	pInfo(peer)->name_color =  (pInfo(peer)->dev == 1 ? "`6@" : (pInfo(peer)->superdev == 1) ? "`b@" : (pInfo(peer)->tmod == 1) ? "`#@" : (pInfo(peer)->vip == 2 ? "`0[`cBuilder`0] " : (pInfo(peer)->vip == 1 ? "`0[`1Vip`0] " : (not pInfo(peer)->d_name.empty() ? pInfo(peer)->d_name : pInfo(peer)->tankIDName) == world_.owner_name ? "`2" : (guild_access(peer, world_.guild_id) or find(world_.admins.begin(), world_.admins.end(), (not pInfo(peer)->d_name.empty() ? pInfo(peer)->d_name : pInfo(peer)->tankIDName)) != world_.admins.end()) ? "`^" : "`0")));
	{
		gamepacket_t p;
		p.Insert("OnProgressUIUpdateValue"), p.Insert(pInfo(peer)->pinata_claimed ? 1 : 0), p.Insert(pInfo(peer)->pinata_prize ? 1 : 0), p.CreatePacket(peer);
	}
	gamepacket_t p;
	p.Insert("OnSetBux"), p.Insert(pInfo(peer)->gems), p.Insert(1), p.Insert((pInfo(peer)->supp >= 1) ? 1 : 0);
	if (pInfo(peer)->supp >= 2) {
		p.Insert((float)33796, (float)1, (float)0);
	}
	p.CreatePacket(peer);
	{
		string nuked = "";
		if (world_.nuked == true) nuked = "`0[NUKED: " + world_.n_b + "," + world_.n_t + "]`` ";
		gamepacket_t p;
		p.Insert("OnConsoleMessage");
		p.Insert("" + (pInfo(peer)->mod + pInfo(peer)->dev > 0 ? nuked : "") + "World `w" + world_.name + "`` " + (world_mods.size() != 0 ? "`0[``" + join(world_mods, ", ") + "`0]`` " : "") + "entered.  There are `w" + to_string(w_c) + "`` other people here, `w" + setGems(s_c) + "`` online.");
		p.CreatePacket(peer);
	}
	{
		gamepacket_t p;
		p.Insert("OnSetCurrentWeather");
		if (world_.weather == 0 || world_.weather == 80 && world_.d_weather != 0) p.Insert(world_.d_weather);
		else p.Insert(world_.weather == 0 ? 80 : world_.weather);
		p.CreatePacket(peer);
	}
	
	{
		string s_ = "spawn|avatar\nnetID|" + to_string(net_) + "\nuserID|" + to_string(pInfo(peer)->id) + "\ncolrect|0|0|20|30\nposXY|" + to_string(spawn_x) + "|" + to_string(spawn_y) + "\nname|" + (not pInfo(peer)->d_name.empty() ? pInfo(peer)->d_name : pInfo(peer)->name_color + (pInfo(peer)->tankIDName.empty() ? pInfo(peer)->requestedName : pInfo(peer)->tankIDName)) + (pInfo(peer)->is_legend ? " of Legend" : "") + "``\ncountry|" + pInfo(peer)->country + "\ninvis|" + (pInfo(peer)->invis ? "1" : "0") + "\nmstate|" + (pInfo(peer)->mod or pInfo(peer)->superdev or pInfo(peer)->dev ? "1" : "0") + "\nsmstate|" + (pInfo(peer)->superdev or pInfo(peer)->dev ? "1" : "0") + "\nonlineID|";
		gamepacket_t p;
		p.Insert("OnSpawn"), p.Insert(s_);
		{
			gamepacket_t p;
			p.Insert("OnSpawn"), p.Insert(s_ + "\ntype|local"), p.CreatePacket(peer);
		}
		worlds_active++;
		gamepacket_t p57, p58;
		p57.Insert("OnTalkBubble"), p57.Insert(pInfo(peer)->netID), p57.Insert("`5<" + (not pInfo(peer)->d_name.empty() ? pInfo(peer)->d_name : pInfo(peer)->name_color + pInfo(peer)->tankIDName) + "`` entered, `w" + to_string(w_c) + "`` others here>``"), p57.Insert(1);
		p58.Insert("OnConsoleMessage"), p58.Insert("`5<" + (not pInfo(peer)->d_name.empty() ? pInfo(peer)->d_name : pInfo(peer)->name_color + pInfo(peer)->tankIDName) + "`` entered, `w" + to_string(w_c) + "`` others here>``");
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != name_ or pInfo(peer)->tankIDName == pInfo(currentPeer)->tankIDName) continue;
			p.CreatePacket(currentPeer);
			user_name = (not pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->d_name : pInfo(currentPeer)->tankIDName);
			gamepacket_t p;
			p.Insert("OnSpawn"), p.Insert("spawn|avatar\nnetID|" + to_string(pInfo(currentPeer)->netID) + "\nuserID|" + to_string(pInfo(currentPeer)->id) + "\ncolrect|0|0|20|30\nposXY|" + to_string(pInfo(currentPeer)->x) + "|" + to_string(pInfo(currentPeer)->y) + "\nname|" + (not pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->d_name : pInfo(currentPeer)->name_color + (pInfo(currentPeer)->tankIDName.empty() ? pInfo(currentPeer)->requestedName : pInfo(currentPeer)->tankIDName)) + (pInfo(currentPeer)->is_legend ? " of Legend" : "") + "``\ncountry|" + pInfo(currentPeer)->country + "\ninvis|" + (pInfo(currentPeer)->invis ? "1" : "0") + "\nmstate|" + (pInfo(currentPeer)->mod or pInfo(currentPeer)->superdev or pInfo(currentPeer)->dev ? "1" : "0") + "\nsmstate|" + (pInfo(currentPeer)->superdev or pInfo(currentPeer)->dev ? "1" : "0") + "\nonlineID|"), p.CreatePacket(peer);
			if (w_c <= 14 && w_c >= 1 && pInfo(peer)->invis == false) p57.CreatePacket(currentPeer), p58.CreatePacket(currentPeer);
		}
	}
	/*send world info if any*/
	if (not world_.owner_name.empty()) {
		if (world_.owner_named == "" && pInfo(peer)->tankIDName == world_.owner_name && world_.owner_named != pInfo(peer)->tankIDName) {
			world_.owner_named = "`o" + pInfo(peer)->tankIDName;
			if (pInfo(peer)->mod || pInfo(peer)->dev || pInfo(peer)->superdev) world_.owner_named = pInfo(peer)->name_color + pInfo(peer)->tankIDName;
		}
		gamepacket_t p;
		p.Insert("OnConsoleMessage");
		p.Insert("`5[```w" + world_.name + "`` `$World Locked`` by " + (world_.owner_named == "" ? world_.owner_name : world_.owner_named) + "``" + (world_.owner_name == (not pInfo(peer)->d_name.empty() ? pInfo(peer)->d_name : pInfo(peer)->tankIDName) or (guild_access(peer, world_.guild_id) or find(world_.admins.begin(), world_.admins.end(), (not pInfo(peer)->d_name.empty() ? pInfo(peer)->d_name : pInfo(peer)->tankIDName)) != world_.admins.end()) ? " (`2ACCESS GRANTED``)" : (world_.open_to_public ? " (`$PUBLIC``)" : "")) + "`5]``");
		p.CreatePacket(peer);
	}
	if (world_.special_event) {
		gamepacket_t p2;
		p2.Insert("OnConsoleMessage"), p2.Insert("`2" + items[world_.special_event_item].event_name + ":`` " + (items[world_.special_event_item].event_total == 1 ? "`oYou have`` `030`` `oseconds to find and grab the`` `#" + items[world_.special_event_item].name + "```o.``" : "`#" + to_string(items[world_.special_event_item].event_total) + " " + items[world_.special_event_item].name + "`` `ospawn in your world, you have`` `030`` `oseconds to collect them.``") + ""), p2.CreatePacket(peer);
	}
	{
		vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
		if (p != worlds.end()) {
			World* world_pointer_ = &worlds[p - worlds.begin()];
			world_pointer_->owner_named = world_.owner_named;
			world_pointer_->active_jammers = world_.active_jammers;
		}
	}
	for (int i_ = 0; i_ < pInfo(peer)->last_visited_worlds.size(); i_++) {
		if (pInfo(peer)->last_visited_worlds[i_] == world_.name) {
			pInfo(peer)->last_visited_worlds.erase(pInfo(peer)->last_visited_worlds.begin() + i_);
			pInfo(peer)->last_visited_worlds.push_back(world_.name);
		}
		else if (i_ + 1 == pInfo(peer)->last_visited_worlds.size()) {
			if (pInfo(peer)->last_visited_worlds.size() + 1 > 11) {
				pInfo(peer)->last_visited_worlds.erase(pInfo(peer)->last_visited_worlds.begin());
			}
			pInfo(peer)->last_visited_worlds.push_back(world_.name);
		}
	}
	if (pInfo(peer)->last_visited_worlds.size() == 0)
		pInfo(peer)->last_visited_worlds.push_back(world_.name);
	int c_ = 0;
	modify_inventory(peer, 1424, c_);
	if (c_ != 0) {
		c_ *= -1;
		modify_inventory(peer, 1424, c_, false);
	}
	{
		int c_ = 0;
		modify_inventory(peer, 5816, c_);
		if (c_ != 0) {
			c_ *= -1;
			modify_inventory(peer, 5816, c_, false);
		}
	}
	{
		int c_ = 0;
		modify_inventory(peer, 5640, c_);
		if (c_ != 0) {
			c_ *= -1;
			modify_inventory(peer, 5640, c_, false);
			pInfo(peer)->magnetron_id = 0;
			pInfo(peer)->magnetron_x = 0;
			pInfo(peer)->magnetron_y = 0;
		}
	}
	send_inventory(peer);
	if (not pInfo(peer)->invis) packet_(peer, "action|play_sfx\nfile|audio/door_open.wav\ndelayMS|0");
	if (name_ == "START" && pInfo(peer)->n == 0) {
		string received_items = "", receive_items = "";
		for (int i_ = 0; i_ < pInfo(peer)->inv.size(); i_++)if (items[pInfo(peer)->inv[i_].id].untradeable == 0) received_items += "\nadd_button_with_icon|||staticBlueFrame|" + to_string(pInfo(peer)->inv[i_].id) + "|" + to_string(pInfo(peer)->inv[i_].count) + "|", receive_items += to_string(pInfo(peer)->inv[i_].count) + " " + items[pInfo(peer)->inv[i_].id].name + (i_ != 9 ? ", " : ".");
		gamepacket_t p(1000);
		p.Insert("OnDialogRequest");
		p.Insert("set_default_color|`o\n\nadd_label_with_icon|big|`0Welcome``|left|6336|\n\nadd_spacer|small|\nadd_textbox|`0This is where everything begins, at ```1START```0, find and make friends here!``|\nadd_spacer|small|\n\nadd_textbox|`oMake sure check `4/rules `oto prevent yourself from getting into unnecessary problems ~`6@Time``|left|\nadd_spacer|small|\nadd_button|newbie|`2Continue``|NOFLAGS|0|0|\n\nadd_spacer|");
		p.CreatePacket(peer);
	}
	for (int i_ = 0; i_ < world_.bulletin.size(); i_++) {
		WorldBulletin bulletin = world_.bulletin[i_];
		WorldBlock block_ = world_.blocks[bulletin.x + (bulletin.y * 100)];
		if (items[block_.fg].mailbox) {
			PlayerMoving data_{};
			data_.packetType = 5, data_.punchX = bulletin.x, data_.punchY = bulletin.y, data_.characterState = 0x8;
			BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(&world_, &block_));
			BYTE* blc = raw + 56;
			memcpy(blc, &block_.fg, 2);
			memcpy(blc + 2, &block_.bg, 2);
			memcpy(blc + 4, &block_.flags, 4);
			int test_ = (block_.flags | 0x00400000);
			memcpy(blc + 4, &test_, 4);
			BYTE btype = 12;
			memcpy(blc + 8, &btype, 1);
			send_raw(peer, 4, raw, 112 + alloc_(&world_, &block_), ENET_PACKET_FLAG_RELIABLE);
			delete[] raw, blc;
		}
	}
	for (int i_ = 0; i_ < world_.machines.size(); i_++) {
		WorldMachines machine_ = world_.machines[i_];
		WorldBlock block_ = world_.blocks[machine_.x + (machine_.y * 100)];
		PlayerMoving data_{};
		data_.packetType = 5, data_.punchX = machine_.x, data_.punchY = machine_.y, data_.characterState = 0x8;
		BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(&world_, &block_));
		BYTE* blc = raw + 56;
		form_visual(blc, block_, world_, peer, false);
		send_raw(peer, 4, raw, 112 + alloc_(&world_, &block_), ENET_PACKET_FLAG_RELIABLE);
		delete[] raw, blc;
	}
	if (world_crystals.size() > 0) {
		for (vector<unsigned int> sk_ : world_crystals) {
			int l_x = sk_[0];
			int l_y = sk_[1];
			WorldBlock* block_s = &world_.blocks[l_x + (l_y * 100)];
			punch_tile(peer, l_x, l_y, 0x3, block_s->fg, 0, 0, 1, 1, false);
		}
	}
	if (world_seeds.size() > 0) {
		for (vector<unsigned int> sk_ : world_seeds) {
			int l_x = sk_[0];
			int l_y = sk_[1];
			WorldBlock* block_s = &world_.blocks[l_x + (l_y * 100)];
			PlayerMoving data_{};
			data_.packetType = 5, data_.punchX = l_x, data_.punchY = l_y, data_.characterState = 0x8;
			BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(&world_, block_s));
			BYTE* blc = raw + 56;
			memcpy(blc, &block_s->fg, 2);
			memcpy(blc + 2, &block_s->bg, 2);
			memcpy(blc + 4, &block_s->flags, 4);
			int visual = block_s->flags | 0x100000;
			memcpy(blc + 4, &visual, 4);
			BYTE data_type = 4;
			memcpy(blc + 8, &data_type, 1);
			uint32_t laikas = uint32_t((time(nullptr) - block_s->planted <= items[block_s->fg].growTime ? time(nullptr) - block_s->planted : items[block_s->fg].growTime));
			uint8_t count = uint8_t(block_s->fruit);
			memcpy(blc + 9, &laikas, 4);
			memcpy(blc + 13, &count, 1);
			send_raw(peer, 4, raw, 112 + alloc_(&world_, block_s), ENET_PACKET_FLAG_RELIABLE);
			delete[] raw, blc;
		}
	}
	if (world_locks.size() > 0) {
		vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
		if (p != worlds.end()) {
			World* world_pointer_ = &worlds[p - worlds.begin()];
			vector<WorldBlock> shadow_copy_2 = world_.blocks;
			for (vector<unsigned int> sk_ : world_locks) {
				int l_x = sk_[0];
				int l_y = sk_[1];
				WorldBlock block_ = world_.blocks[l_x + (l_y * 100)];
				block_.owner_named = block_.owner_name;
				world_pointer_->blocks[l_x + (l_y * 100)].owner_named = block_.owner_named;
				world_.blocks[l_x + (l_y * 100)].owner_named = block_.owner_name;
				vector<vector<int>> locked_tiles_around_lock{};
				vector<int> new_tiles{};
				new_tiles.push_back(l_x + (l_y * 100));
				for (int i2 = 0; i2 < new_tiles.size(); i2++) {
					int s_x_ = new_tiles[i2] % 100, s_y_ = new_tiles[i2] / 100;
					if (s_x_ < 99 and shadow_copy_2[s_x_ + 1 + (s_y_ * 100)].locked and shadow_copy_2[s_x_ + 1 + (s_y_ * 100)].lock_origin == (l_x + (l_y * 100))) {
						if (not shadow_copy_2[s_x_ + 1 + (s_y_ * 100)].scanned) {
							shadow_copy_2[s_x_ + 1 + (s_y_ * 100)].scanned = true;
							new_tiles.push_back(s_x_ + 1 + (s_y_ * 100));
							locked_tiles_around_lock.push_back({ s_x_ + 1, s_y_ });
						}
					} if (s_x_ > 0 and shadow_copy_2[s_x_ - 1 + (s_y_ * 100)].locked and shadow_copy_2[s_x_ - 1 + (s_y_ * 100)].lock_origin == (l_x + (l_y * 100))) {
						if (not shadow_copy_2[s_x_ - 1 + (s_y_ * 100)].scanned) {
							shadow_copy_2[s_x_ - 1 + (s_y_ * 100)].scanned = true;
							new_tiles.push_back(s_x_ - 1 + (s_y_ * 100));
							locked_tiles_around_lock.push_back({ s_x_ - 1, s_y_ });
						}
					} if (s_y_ < 59 and shadow_copy_2[s_x_ + ((s_y_ + 1) * 100)].locked and shadow_copy_2[s_x_ + ((s_y_ + 1) * 100)].lock_origin == (l_x + (l_y * 100))) {
						if (not shadow_copy_2[s_x_ + ((s_y_ + 1) * 100)].scanned) {
							shadow_copy_2[s_x_ + ((s_y_ + 1) * 100)].scanned = true;
							new_tiles.push_back(s_x_ + ((s_y_ + 1) * 100));
							locked_tiles_around_lock.push_back({ s_x_, s_y_ + 1 });
						}
					} if (s_y_ > 0 and shadow_copy_2[s_x_ + ((s_y_ - 1) * 100)].locked and shadow_copy_2[s_x_ + ((s_y_ - 1) * 100)].lock_origin == (l_x + (l_y * 100))) {
						if (not shadow_copy_2[s_x_ + ((s_y_ - 1) * 100)].scanned) {
							shadow_copy_2[s_x_ + ((s_y_ - 1) * 100)].scanned = true;
							new_tiles.push_back(s_x_ + ((s_y_ - 1) * 100));
							locked_tiles_around_lock.push_back({ s_x_, s_y_ - 1 });
						}
					}
				}
				int lock_size = locked_tiles_around_lock.size();
				if (locked_tiles_around_lock.size() != 0) {
					PlayerMoving data_{};
					data_.packetType = 15, data_.punchX = l_x, data_.punchY = l_y, data_.characterState = 0x8;
					data_.netID = block_.owner_name == (not pInfo(peer)->d_name.empty() ? pInfo(peer)->d_name : pInfo(peer)->tankIDName) ? pInfo(peer)->id : -1;
					data_.plantingTree = block_.fg;
					BYTE* raw;
					raw = packPlayerMoving(&data_, 112 + (locked_tiles_around_lock.size() * 2) + alloc_(&world_, &block_));
					int lalala = 8;
					memcpy(raw + 8, &lock_size, 2);
					memcpy(raw + 12, &lalala, 2);
					BYTE* blc = raw + 56;
					for (int i_ = 0; i_ < locked_tiles_around_lock.size(); i_++) {
						vector<int> update_tiles = locked_tiles_around_lock[i_];
						int x = update_tiles[0];
						int y = update_tiles[1];
						int sq_ = x + (y * 100);
						memcpy(blc + (i_ * 2), &sq_, 2);
						shadow_copy_2[x + (y * 100)].scanned = false;
					}
					send_raw(peer, 4, raw, 112 + (locked_tiles_around_lock.size() * 2) + alloc_(&world_, &block_), ENET_PACKET_FLAG_RELIABLE);
					PlayerMoving data_2{};
					data_2.packetType = 5, data_2.punchX = l_x, data_2.punchY = l_y, data_2.characterState = 0x8;
					BYTE* raw2 = packPlayerMoving(&data_2, 112 + alloc_(&world_, &block_));
					BYTE* blc2 = raw2 + 56;
					form_visual(blc2, block_, world_, peer, false);
					send_raw(peer, 4, raw2, 112 + alloc_(&world_, &block_), ENET_PACKET_FLAG_RELIABLE);
					delete[] raw, blc, raw2, blc2;
				}
			}
		}
	}
	add_cctv(peer, "entered", "");
	if (pInfo(peer)->supp == 1 || pInfo(peer)->supp == 2) {
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
			bool wlachi = std::experimental::filesystem::exists("db/alist/supporter/" + (pInfo(peer)->tankIDName) + ".txt");
			if (wlachi == false) {
				int ab = 46;
				ofstream myfile;
				myfile.open("db/alist/supporter/" + (pInfo(peer)->tankIDName) + ".txt");
				myfile << "true";
				myfile.close();
				gamepacket_t p, p2;
				p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert(pInfo(peer)->name_color + pInfo(peer)->tankIDName + "`5 earned the achievement 'Supporter (Classic)'!");
				p2.Insert("OnConsoleMessage"), p2.Insert(pInfo(peer)->name_color + pInfo(peer)->tankIDName + "`5 earned the achievement 'Supporter (Classic)'!");
				pInfo(peer)->achievement_total++;
				PlayerMoving data_{};
				data_.packetType = 17, data_.netID = 46, data_.YSpeed = 46, data_.x = pInfo(peer)->x + 16, data_.y = pInfo(peer)->y + 16;
				BYTE* raw = packPlayerMoving(&data_);
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world) continue;
					p.CreatePacket(currentPeer);
					p2.CreatePacket(currentPeer);
					send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
				}
				delete[] raw;
			}
		}
	}
	if (pInfo(peer)->supp == 2) {
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
			bool wlachi = std::experimental::filesystem::exists("db/alist/super_supporter/" + (pInfo(peer)->tankIDName) + ".txt");
			if (wlachi == false) {
				int ab = 46;
				ofstream myfile;
				myfile.open("db/alist/super_supporter/" + (pInfo(peer)->tankIDName) + ".txt");
				myfile << "true";
				myfile.close();
				gamepacket_t p, p2;
				p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert(pInfo(peer)->name_color + pInfo(peer)->tankIDName + "`5 earned the achievement 'Super Supporter'!");
				p2.Insert("OnConsoleMessage"), p2.Insert(pInfo(peer)->name_color + pInfo(peer)->tankIDName + "`5 earned the achievement 'Super Supporter'!");
				pInfo(peer)->achievement_total++;
				PlayerMoving data_{};
				data_.packetType = 17, data_.netID = 46, data_.YSpeed = 46, data_.x = pInfo(peer)->x + 16, data_.y = pInfo(peer)->y + 16;
				BYTE* raw = packPlayerMoving(&data_);
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world) continue;
					p.CreatePacket(currentPeer);
					p2.CreatePacket(currentPeer);
					send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
				}
				delete[] raw;
			}
		}
	}
}
void add_curse(ENetPeer* peer, int seconds, string reason, string muttedby) {
	if (not has_playmod(pInfo(peer), "Cursed")) {
		PlayMods give_playmod{};
		give_playmod.id = 78;
		give_playmod.time = time(nullptr) + seconds;
		pInfo(peer)->playmods.push_back(give_playmod);
		pInfo(peer)->m_r = reason;
		update_clothes(peer);
		{
			gamepacket_t p;
			p.Insert("OnConsoleMessage");
			p.Insert("`oYou've been cursed! (`$Cursed`` mod added, " + ((seconds / 86400 > 0) ? to_string(seconds / 86400) + " days" : (seconds / 3600 > 0) ? to_string(seconds / 3600) + " hours" : (seconds / 60 > 0) ? to_string(seconds / 60) + " minutes" : to_string(seconds) + " seconds") + " left)");
			p.CreatePacket(peer);
		}
		gamepacket_t p;
		p.Insert("OnConsoleMessage");
		p.Insert("`#**`` `$The Ancient Ones ``have cursed " + (not pInfo(peer)->d_name.empty() ? pInfo(peer)->d_name : pInfo(peer)->name_color + pInfo(peer)->tankIDName) + " `#**`` (`4/rules`` to see the rules!)");
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
			p.CreatePacket(currentPeer);
		}
		{
			gamepacket_t p;
			p.Insert("OnConsoleMessage");
			p.Insert("`oWarning from `4Admin``: You've been `4cursed`` for " + ((seconds / 86400 > 0) ? to_string(seconds / 86400) + " days" : (seconds / 3600 > 0) ? to_string(seconds / 3600) + " hours" : (seconds / 60 > 0) ? to_string(seconds / 60) + " minutes" : to_string(seconds) + " seconds"));
			p.CreatePacket(peer);
			{
				gamepacket_t p;
				p.Insert("OnAddNotification");
				p.Insert("interface/atomic_button.rttex");
				p.Insert("`wWarning from `4Admin``: You've been `4cursed`` for " + ((seconds / 86400 > 0) ? to_string(seconds / 86400) + " days" : (seconds / 3600 > 0) ? to_string(seconds / 3600) + " hours" : (seconds / 60 > 0) ? to_string(seconds / 60) + " minutes" : to_string(seconds) + " seconds"));
				p.Insert("audio/hub_open.wav");
				p.Insert(0);
				p.CreatePacket(peer);
				join_world(peer, pInfo(peer)->c_world);
			}
		}
	}
}
ENetPeer* get_clicked_on(World* world_, int x_, int y_) {
	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
		if (pInfo(currentPeer)->world == world_->name and not pInfo(currentPeer)->ghost) {
			if (y_ == pInfo(currentPeer)->y / 32) {
				if (pInfo(currentPeer)->state == 0 and x_ * 32 < pInfo(currentPeer)->x and abs(x_ * 32 - pInfo(currentPeer)->x) < 32 or pInfo(currentPeer)->state == 16 and abs(x_ * 32 - pInfo(currentPeer)->x) < 32 or pInfo(currentPeer)->state != 16 and abs(x_ * 32 - pInfo(currentPeer)->x) < 20) {
					return currentPeer;
				}
			}
		}
	}
	return NULL;
}


void daily_quest() {
	string dqitems = "";
	string eventday = "";
	{
		ifstream ifs("db/ip.json");
		if (ifs.is_open()) {
			json j;
			ifs >> j;
			vector<string> bans2 = j["ip"];
			ipbans = bans2;
		}
	}
	ifstream ifs("db/daily_quest.json");
	struct tm newtime;
	time_t now = time(0);
	localtime_s(&newtime, &now);
	today_day = newtime.tm_mday;
	if (ifs.is_open()) {
		json j;
		ifs >> j;
		item1 = j["item1"].get<int>();
		item2 = j["item2"].get<int>();
		item1c = j["item1c"].get<int>();
		item2c = j["item2c"].get<int>();
		day_ = j["day"].get<int>();
	}
	if (day_ != today_day) {
		vector<int> random_xy{ -1, 0 };
		vector<int> list{ 231,487,483,2019,427,1757,2009,281,781,329,459,1041,421,2787,2789,1043,2797,181,613,65,4983,283,553,425,4635,987,627,2017,989,61,4639,973,3523,331,265,859,433,253,339,1105,439,4567,333,677,5673,1427,5603,183,10533,5731,7223,10833,6035,6813,1113,1047,653,2811,4703,1429,847,665,485,1613,833,2025,1775,3931,429,3831,423,437,1773,4767,1299,361,667,2815,3473,301,4637,5683,2709,415,955,461,861,9389,5467,2791,2815,1803,419,2027,685,555,741,10531,5729,7221,10831,6033,6811,621,6401,1107,359,3471,855,309,1685,1449,1309,441,1111,221,1431,3065,9307,1257,1501,1109,4641,3587,1103,417,743,431,3823,2949,1131,3825,727,5379,729,187,787,5459,4785,3261,3521,2293,2309,2321,2333,5461,3721,327,247,63,3479,445,4783,299,863,8935,1451,261,1871,1499,455,9391,683,1159,551,1745,411,3005,557,687,4799,559,4643,3899,1605,9309,567,565,1154,3827,1327,1767,993,1157,563,4721,115,1423,10515,1329,6545,287,669,777,5463,1655,1599,561,4585,3413,4745,1771,2011,1161,1729,3757,3753,321,3265,3263,623,775,6397,129,4667,759,3767,1529,6543,4707,3835,1435,651,8929,569,527,3287,1595,6063,2795,1003,1731,4943,4963,597,4669,1531,1523,625,4297,599,657,571,873,3755,2969,1725,4603,1447,3267,5375,1683 };
		vector<int> list2{ 3567, 13, 57, 17, 381, 1139, 21, 101, 379, 117, 27, 23, 581, 195, 105, 191, 377, 1307, 697, 881, 167, 185, 1323, 165, 3783, 369, 25, 171, 53, 103, 179, 29, 249, 177, 1325, 337, 189, 169, 55, 223, 175, 885, 119, 3573, 199, 549, 681, 655, 107, 163, 31, 671, 889, 887, 193, 127, 1433, 173, 7631, 413, 3571, 3569, 2809, 9393, 225, 111, 109, 201, 59, 607, 285, 2029, 2013, 2015, 1611, 995, 997, 963, 1481, 219, 197, 2023, 2021, 9331, 1305, 823, 1039, 231, 487, 483, 2019, 427, 1757, 2009, 281, 781, 329, 459, 1041, 421, 2787, 2789, 1043, 2797, 181, 613, 65, 4983, 283, 553, 425, 4635, 987, 627, 2017, 989, 61, 4639, 973, 3523, 331, 265, 859, 433, 253, 339, 1105, 439, 4567, 333, 677, 5673, 1427, 5603, 183, 10533, 5731, 7223, 10833, 6035, 6813, 1113, 1047, 653, 2811, 4703, 1429, 847, 665 };
		item1 = list[rand() % list.size()] + random_xy[rand() % random_xy.size()];
		item2 = list2[rand() % list2.size()] + random_xy[rand() % random_xy.size()];
		item1c = rand() % 200 + 1;
		item2c = rand() % 100 + 1;
		day_ = today_day;
		ofstream o("db/daily_quest.json");
		if (!o.is_open()) cout << "daily qu est error " << GetLastError() << endl;
		json j;
		j["item1"] = item1;
		j["item2"] = item2;
		j["item1c"] = item1c;
		j["item2c"] = item2c;
		j["day"] = day_;
		o << j << endl;
		dqitems += "" + to_string(item1c) + " " + items[item1].name + "\n" + to_string(item2c) + " " + items[item2].name + "";
		if (thedaytoday == 1) eventday += ("Farming Day");
		else if (thedaytoday == 2) eventday += ("Breaking Day");
		else if (thedaytoday == 3) eventday += ("Geiger Day");
		else if (thedaytoday == 4) eventday += ("Level Day");
		else if (thedaytoday == 5) eventday += ("Gems Day");
		else if (thedaytoday == 6) eventday += ("Surgery Day!");
		else if (thedaytoday == 0) eventday += ("Fishing Day");
		//sendWebhook(dqitems, eventday);
	}
}


void loop_save(ENetPeer* peer) {
	
	string name_ = pInfo(peer)->world;
	vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
	if (p != worlds.end()) {
		World* world_ = &worlds[p - worlds.begin()];
		if (world_->special_event == false && server_event_spawn + 900000 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) {
			int event_item = 0;
			if (rand() % 250 < 1 && world_->last_special_event + 900000 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) {
				//1056 songpyeon only on harvest festival
				//528 only st. patirck
				vector<int> list = { 263,942,942,1396,4774,4522, 4774, 5002, 121, 1636, 2798, 2704, 3786 };
				world_->special_event_item = list[rand() % list.size()];
				event_item = world_->special_event_item;
				world_->special_event = true;
				gamepacket_t p, p2;
				p.Insert("OnAddNotification"), p.Insert("interface/large/special_event.rttex"), p.Insert("`2" + items[world_->special_event_item].event_name + ":`` " + (items[world_->special_event_item].event_total == 1 ? "`oYou have`` `030`` `oseconds to find and grab the`` `#" + items[world_->special_event_item].name + "```o.``" : "`#" + to_string(items[world_->special_event_item].event_total) + " " + items[world_->special_event_item].name + "`` `ospawn in your world, you have`` `030`` `oseconds to collect them.``") + ""), p.Insert("audio/cumbia_horns.wav"), p.Insert(0);
				p2.Insert("OnConsoleMessage"), p2.Insert("`2" + items[world_->special_event_item].event_name + ":`` " + (items[world_->special_event_item].event_total == 1 ? "`oYou have`` `030`` `oseconds to find and grab the`` `#" + items[world_->special_event_item].name + "```o.``" : "`#" + to_string(items[world_->special_event_item].event_total) + " " + items[world_->special_event_item].name + "`` `ospawn in your world, you have`` `030`` `oseconds to collect them.``") + "");
				for (ENetPeer* currentPeer_event = server->peers; currentPeer_event < &server->peers[server->peerCount]; ++currentPeer_event) {
					if (currentPeer_event->state != ENET_PEER_STATE_CONNECTED or currentPeer_event->data == NULL or pInfo(currentPeer_event)->world != name_) continue;
					p.CreatePacket(currentPeer_event), p2.CreatePacket(currentPeer_event);
				}
				world_->last_special_event = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
			}

			//else if (rand() % 50 < 1 && world_->last_special_event + 900000 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) {
				//for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					//if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != name_) continue;
					//gamepacket_t p, p2, p3(0);
					//p.Insert("OnAddNotification"), p.Insert("interface/large/special_event.rttex"), p.Insert("`2Zombie Apocalypse:`` `oIt's the Return of the Growing Dead!``"), p.Insert("audio/owooooo.wav"), p.Insert(0), p.CreatePacket(currentPeer);
					//p2.Insert("OnConsoleMessage"), p2.Insert("`2Zombie Apocalypse:`` `oIt's the Return of the Growing Dead!``"), p2.CreatePacket(currentPeer);
					//p3.Insert("OnSetCurrentWeather"), p3.Insert(31), p3.CreatePacket(currentPeer);
					//if (rand() % 100 < 50) {
					//	PlayMods give_playmod{};
					//	give_playmod.id = 28, give_playmod.time = time(nullptr) + 60;
					//	pInfo(currentPeer)->playmods.push_back(give_playmod);
					//	update_clothes(currentPeer);
					//}
				//}
				//world_->last_special_event = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
			//}
			//comet dust spawn
			else if (rand() % 3 < 1 && world_->last_comet_spawn + 420000 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count() && server_event_spawn + 60000 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) {
				if (world_->last_comet_spawn != 0) event_item = 2034;
				world_->last_comet_spawn = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
			}

			else if (rand() % 2 < 1 && world_->last_comet_spawn + 420000 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count() && server_event_spawn + 60000 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) {
				if (world_->last_comet_spawn != 0) event_item = 611;
				world_->last_comet_spawn = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
			}

			if (event_item != 0) {
				server_event_spawn = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
				WorldDrop drop_block_{};
				drop_block_.count = 1, drop_block_.special = event_item == 2034 || event_item == 611 ? false : true;
				for (int i_ = 0; i_ < items[event_item].event_total; i_++) {
					drop_block_.id = event_item == 2034 ? (rand() % 100 < 25 ? 2036 : 2034) : world_->special_event_item, drop_block_.uid = uint16_t(world_->drop.size()) + 1, drop_block_.x = rand() % 99 * 32, drop_block_.y = rand() % 54 * 32;
					dropas_(world_, drop_block_);
				}
			}
		}
	}
}


void save_player(Player* p_, bool on_exit = true) {
	if (p_->tankIDName.empty() or p_->email.empty()) return;
	if (saving_ and p_->saved_on_close) {
		cout << "already saved" << endl;
		return;
	}
	//saveall
	time_t currentTime;
	time(&currentTime);
	const auto localTime = localtime(&currentTime);
	const auto Hour = localTime->tm_hour;
	const auto Min = localTime->tm_min;
	const auto Sec = localTime->tm_sec;
	const auto Year = localTime->tm_year + 1900;
	const auto Day = localTime->tm_mday;
	const auto Month = localTime->tm_mon + 1;
	std::string asdasdasd;
	if (Sec < 10) asdasdasd = "0";
	std::string asdasdasd2;
	if (Min < 10) asdasdasd2 = "0";
	std::string asdasdasd3;
	if (Hour < 10) asdasdasd3 = "0";
	std::string asdasdasd31;
	if (Month < 10) asdasdasd31 = "0";
	std::string asdasdasd32;
	if (Day < 10) asdasdasd32 = "0";
	std::string asdasdasd33;
	if (Year < 10) asdasdasd33 = "0";
	p_->lo = "" + asdasdasd32 + to_string(Day) + "." + asdasdasd31 + to_string(Month) + "." + asdasdasd33 + to_string(Year) + " " + asdasdasd3 + to_string(Hour) + ":" + asdasdasd2 + to_string(Min) + ":" + asdasdasd + to_string(Sec) + "";
	json save_, achievements_ = json::array(), friends_ = json::array(), inv_ = json::array(), visited_worlds_ = json::array(), worlds_owned_ = json::array(), playmods_ = json::array();
	save_["name"] = p_->tankIDName;
	save_["n"] = p_->n;
	save_["mod"] = p_->mod;
	save_["dev"] = p_->dev;
	save_["superdev"] = p_->superdev;
	save_["m_h"] = p_->m_h;
	save_["cc"] = p_->cc;
	save_["opc"] = p_->opc;
	save_["bans"] = p_->bans;
	save_["promo"] = p_->promo;
	save_["w_w"] = p_->w_w;
	save_["w_d"] = p_->w_d;
	save_["mer"] = p_->mercy;
	save_["onstatus"] = p_->on;
	save_["busystatus"] = p_->busy;
	save_["awaystatus"] = p_->away;
	save_["drtt"] = p_->drtitle;
	save_["g4g"] = p_->g4g;
	save_["mentor"] = p_->mentor;
	save_["_drt"] = p_->drt;
	save_["dnr"] = p_->donor;
	save_["mst"] = p_->master;
	save_["p_d1"] = p_->pinata_day;
	save_["p_d2"] = p_->pinata_prize;
	save_["p_d3"] = p_->pinata_claimed;
	save_["e_r"] = p_->EyeColor->get_red();
	save_["e_g"] = p_->EyeColor->get_green();
	save_["e_b"] = p_->EyeColor->get_blue();
	save_["h_r"] = p_->HairColor->get_red();
	save_["h_g"] = p_->HairColor->get_green();
	save_["h_b"] = p_->HairColor->get_blue();
	save_["rw_delay_on"] = p_->m_riftwings.getDelay();
	save_["rw_wg_r1"] = p_->m_riftwings.wings_color1->get_red();
	save_["rw_wg_g1"] = p_->m_riftwings.wings_color1->get_green();
	save_["rw_wg_b1"] = p_->m_riftwings.wings_color1->get_blue();
	save_["rw_wg_r2"] = p_->m_riftwings.wings_color2->get_red();
	save_["rw_wg_g2"] = p_->m_riftwings.wings_color2->get_green();
	save_["rw_wg_b2"] = p_->m_riftwings.wings_color2->get_blue();
	save_["rw_met_r1"] = p_->m_riftwings.wings_metal_color1->get_red();
	save_["rw_met_g1"] = p_->m_riftwings.wings_metal_color1->get_green();
	save_["rw_met_b1"] = p_->m_riftwings.wings_metal_color1->get_blue();
	save_["rw_met_r2"] = p_->m_riftwings.wings_metal_color2->get_red();
	save_["rw_met_g2"] = p_->m_riftwings.wings_metal_color2->get_green();
	save_["rw_met_b2"] = p_->m_riftwings.wings_metal_color2->get_blue();
	save_["rw_mat1"] = p_->m_riftwings.style1_material;
	save_["rw_mat2"] = p_->m_riftwings.style2_material;
	save_["rw_tr1"] = p_->m_riftwings.style1_trail;
	save_["rw_tr1"] = p_->m_riftwings.style2_trail;
	save_["rw_closed1"] = p_->m_riftwings.getClosed1();
	save_["rw_closed2"] = p_->m_riftwings.getClosed2();
	save_["rw_trail_on1"] = p_->m_riftwings.getTrail1();
	save_["rw_trail_on2"] = p_->m_riftwings.getTrail2();
	save_["rw_opened_on1"] = p_->m_riftwings.getOpenWings1();
	save_["rw_opened_on2"] = p_->m_riftwings.getOpenWings2();
	save_["rw_stamp1"] = p_->m_riftwings.getStampParricle1();
	save_["rw_stamp2"] = p_->m_riftwings.getStampParricle2();
	save_["rc_cp1"] = p_->m_riftcape.cape_color1->get_uint();
	save_["rc_cp2"] = p_->m_riftcape.cape_color2->get_uint();
	save_["rc_col1"] = p_->m_riftcape.cape_collar_color1->get_uint();
	save_["rc_col2"] = p_->m_riftcape.cape_collar_color2->get_uint();
	save_["rc_aura1"] = p_->m_riftcape.style1_aura;
	save_["rc_aura2"] = p_->m_riftcape.style2_aura;
	save_["rc_closed1"] = p_->m_riftcape.getClosed1();
	save_["rc_closed2"] = p_->m_riftcape.getClosed2();
	save_["rc_aura_on1"] = p_->m_riftcape.getAura1();
	save_["rc_aura_on2"] = p_->m_riftcape.getAura2();
	save_["rc_collar_on1"] = p_->m_riftcape.getCollar1();
	save_["rc_collar_on2"] = p_->m_riftcape.getCollar2();
	save_["rc_move1"] = p_->m_riftcape.getMovement1();
	save_["rc_move2"] = p_->m_riftcape.getMovement2();
	save_["rc_delay_on"] = p_->m_riftcape.getDelay();
	save_["g4g_1"] = p_->grow4good_day;
	save_["g4g_2"] = p_->grow4good_rarity;
	save_["g4g_3"] = p_->grow4good_total_rarity;
	save_["g4g_4"] = p_->grow4good_wl;
	save_["g4g_5"] = p_->grow4good_total_wl;
	save_["g4g_6"] = p_->grow4good_donate_gems;
	save_["g4g_7"] = p_->grow4good_gems;
	save_["g4g_8"] = p_->grow4good_purchase_waving;
	save_["g4g_9"] = p_->grow4good_surgery;
	save_["g4g_10"] = p_->grow4good_fish;
	save_["g4g_11"] = p_->grow4good_points;
	save_["g4g_12"] = p_->grow4good_claim_prize;
	save_["g4g_13"] = p_->grow4good_claimed_prize;
	save_["g4g_14"] = p_->grow4good_break;
	save_["g4g_15"] = p_->grow4good_place;
	save_["g4g_16"] = p_->grow4good_trade;
	save_["g4g_17"] = p_->grow4good_sb;

	save_["lvl125"] = p_->lvl125;
	save_["radio"] = p_->radio;
	save_["flagset"] = p_->flagset;
	save_["skl"] = p_->surgery_skill;
	save_["sgt"] = p_->surgery_type;
	save_["sd"] = p_->surgery_done;
	save_["su1"] = p_->su_8552_1;
	save_["su2"] = p_->su_8552_2;
	save_["egg"] = p_->egg;
	save_["glo"] = p_->glo;
	save_["logs"] = p_->logs;
	save_["b_t"] = p_->b_t;
	save_["b_b"] = p_->b_b;
	save_["dd"] = p_->dd;
	save_["lo"] = p_->lo;
	save_["ip"] = p_->ip;
	save_["b_s"] = p_->b_s;
	save_["b_r"] = p_->b_r;

	save_["b_ra"] = p_->b_ra;
	save_["i_11818_1"] = p_->i_11818_1;
	save_["i_11818_2"] = p_->i_11818_2;
	save_["b_lvl"] = p_->b_lvl;
	save_["b_item"] = p_->banner_item;
	save_["b_type"] = p_->banner_type;
	save_["b_a"] = p_->b_a;
	save_["b_w"] = p_->b_w;
	save_["b_p"] = p_->b_p;
	save_["m_r"] = p_->m_r;
	save_["m_b"] = p_->m_b;
	save_["note"] = p_->note;
	save_["supp"] = p_->supp;
	save_["hs"] = p_->hs;
	save_["dds"] = p_->dds;
	save_["tk"] = p_->tk;
	save_["bb"] = p_->bb;
	save_["gtwl"] = p_->gtwl;
	save_["vip"] = p_->vip;
	save_["rb"] = p_->rb;
	save_["mds"] = p_->mds;
	save_["gr"] = p_->gr;
	save_["gp"] = p_->gp;
	save_["gd"] = p_->gd;
	save_["glo_p"] = p_->glo_p;
	save_["lvl_p"] = p_->lvl_p;
	save_["surg_p"] = p_->surg_p;
	save_["t_p"] = p_->t_p;
	save_["bb_p"] = p_->bb_p;
	save_["ff_p"] = p_->ff_p;
	save_["p_p"] = p_->p_p;
	save_["g_p"] = p_->g_p;
	save_["t_xp"] = p_->t_xp;
	save_["bb_xp"] = p_->bb_xp;
	save_["ff_xp"] = p_->ff_xp;
	save_["s_xp"] = p_->s_xp;
	save_["g_xp"] = p_->g_xp;
	save_["p_xp"] = p_->p_xp;
	save_["t_lvl"] = p_->t_lvl;
	save_["bb_lvl"] = p_->bb_lvl;
	save_["ff_lvl"] = p_->ff_lvl;
	save_["g_lvl"] = p_->g_lvl;
	save_["p_lvl"] = p_->p_lvl;
	save_["s_lvl"] = p_->s_lvl;
	save_["b_l"] = p_->b_l;
	save_["bp"] = p_->bp;
	save_["achi"] = p_->achievement_total;
	save_["flagmay"] = p_->flagmay;
	save_["pass"] = p_->tankIDPass, save_["email"] = p_->email;
	save_["gems"] = p_->gems;
	save_["punch"] = p_->punch_count;
	save_["home_world"] = p_->home_world;
	save_["show_location"] = p_->show_location_;
	save_["show_notifications"] = p_->show_friend_notifications_;
	save_["xp"] = p_->xp;
	save_["d_name"] = p_->d_name;
	save_["level"] = p_->level;
	save_["skin"] = p_->skin;
	save_["geiger"] = p_->geiger_;
	save_["ghost"] = p_->ghost;
	save_["invis"] = p_->invis;
	save_["date"] = p_->account_created;
	save_["booty_broken"] = p_->booty_broken;
	save_["playtime"] = p_->seconds + (time(NULL) - p_->playtime);
	save_["guild_id"] = p_->guild_id;
	save_["ltitle"] = p_->legend;
	save_["legend"] = p_->is_legend;
	save_["roleSkin"] = p_->roleSkin;
	save_["roleIcon"] = p_->roleIcon;
	save_["mac"] = p_->mac;
	save_["rid"] = p_->rid;
	save_["vid"] = p_->vid;
	save_["pid"] = p_->platformid;
	save_["wk"] = p_->wk;
	//save_["trade_logs"] = p_->trade_logs;
	for (int i_ = 0; i_ < p_->inv.size(); i_++) {
		json item_;
		item_["i"] = p_->inv[i_].id;
		item_["c"] = p_->inv[i_].count;
		inv_.push_back(item_);
	}
	map<string, int>::iterator it;
	for (it = p_->achievements.begin(); it != p_->achievements.end(); it++) {
		json achievement_;
		achievement_["title"] = it->first;
		achievement_["progress"] = it->second;
		achievements_.push_back(achievement_);
	} for (int i_ = 0; i_ < p_->friends.size(); i_++) {
		json friend_;
		friend_["name"] = p_->friends[i_].name;
		friend_["mute"] = p_->friends[i_].mute;
		friend_["block_trade"] = p_->friends[i_].block_trade;
		friend_["last_seen"] = p_->friends[i_].last_seen;
		friends_.push_back(friend_);
	} for (int i_ = 0; i_ < p_->last_visited_worlds.size(); i_++) {
		json world_;
		world_["name"] = p_->last_visited_worlds[i_];
		visited_worlds_.push_back(world_);
	} for (int i_ = 0; i_ < p_->worlds_owned.size(); i_++) {
		json world_;
		world_["name"] = p_->worlds_owned[i_];
		worlds_owned_.push_back(world_);
	} for (int i_ = 0; i_ < p_->playmods.size(); i_++) {
		json playmod_;
		playmod_["id"] = p_->playmods[i_].id;
		playmod_["time"] = p_->playmods[i_].time;
		playmod_["user"] = p_->playmods[i_].user;
		playmods_.push_back(playmod_);
	}
	json blarneys_ = json::array();
	for (int i_ = 0; i_ < p_->completed_blarneys.size(); i_++) {
		json blarney_;
		blarney_["world"] = p_->completed_blarneys[i_][0];
		blarney_["time"] = p_->completed_blarneys[i_][1];
		blarneys_.push_back(blarney_);
	}
	save_["blarney"] = blarneys_;
	save_["playmods"] = playmods_;
	save_["worlds_owned"] = worlds_owned_;
	save_["last_worlds"] = visited_worlds_;
	save_["inv"] = inv_;
	save_["achievements"] = achievements_;
	save_["friends"] = friends_;
	save_["hair"] = p_->hair, save_["shirt"] = p_->shirt, save_["pants"] = p_->pants, save_["feet"] = p_->feet, save_["face"] = p_->face, save_["hand"] = p_->hand, save_["back"] = p_->back, save_["mask"] = p_->mask, save_["necklace"] = p_->necklace, save_["ances"] = p_->ances;
	//cout << "[SERVER] Autosave is saving player's data! [" << p_->tankIDName << "]" << " Time of action: " << currentDateTime() << "." << endl;
	ofstream w_("players/" + p_->tankIDName + "_.json");
	if (w_.fail()) {
		//cout << "[ERROR] Failed to save player " << p_->tankIDName << " Time of action: " << currentDateTime() << "." << endl;
		return;
	}
	w_ << save_ << endl;
	w_.close();
	{
		if (on_exit) {
			uint32_t guild_id = p_->guild_id;
			vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
			if (p != guilds.end()) {
				Guild* guild_information = &guilds[p - guilds.begin()];
				for (int i_ = 0; i_ < guild_information->guild_members.size(); i_++) {
					GuildMember* edit_member = &guild_information->guild_members[i_];
					if (edit_member->member_name == p_->tankIDName) {
						edit_member->last_online = time(NULL);
						break;
					}
				}
			}
			vector<string> friends_;
			long long time_t = time(NULL);
			for (int c_ = 0; c_ < p_->friends.size(); c_++) {
				friends_.push_back(p_->friends[c_].name);
			} for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
				if (pInfo(currentPeer)->m_h == 1) continue;
				if (pInfo(currentPeer)->invis == true) continue;
				if (find(friends_.begin(), friends_.end(), pInfo(currentPeer)->tankIDName) != friends_.end()) {
					for (int d_ = 0; d_ < pInfo(currentPeer)->friends.size(); d_++) {
						if (pInfo(currentPeer)->friends[d_].name == p_->tankIDName) {
							pInfo(currentPeer)->friends[d_].last_seen = time_t;
							break;
						}
					}
					if (not p_->invis and not p_->m_h) {
						if (pInfo(currentPeer)->show_friend_notifications_) {
							packet_(currentPeer, "action|play_sfx\nfile|audio/friend_logoff.wav\ndelayMS|0");
							string color = "`o";
							if (p_->name_color == "`6@" or p_->name_color == "`#@") color = p_->name_color;
							gamepacket_t p;
							p.Insert("OnConsoleMessage");
							p.Insert("`3FRIEND ALERT:`` " + color + p_->tankIDName + "`` has `4logged off``.");
							p.CreatePacket(currentPeer);
						}
					}
					friends_.erase(remove(friends_.begin(), friends_.end(), pInfo(currentPeer)->tankIDName), friends_.end());
				}
			}
			try {
				for (int c_ = 0; c_ < friends_.size(); c_++) {
					string path_ = "players/" + friends_.at(c_) + "_.json";
					//if (exists(path_)) {
					if (_access_s(path_.c_str(), 0) == 0) {
						json r_;
						ifstream f_(path_, ifstream::binary);
						if (f_.fail()) {
							cout << "failed reading data for " << friends_.at(c_) << endl;
							return;
						}
						f_ >> r_;
						f_.close();
						json f_g = r_.at("friends").get<json>();
						for (int i_ = 0; i_ < f_g.size(); i_++) {
							if (f_g.at(i_).at("name") == p_->tankIDName) {
								f_g.at(i_).at("last_seen") = time_t;
								break;
							}
						}
						r_.at("friends") = f_g;
						{
							ofstream f_(path_, ifstream::binary);
							f_ << r_;
							f_.close();
						}
					}
				}
			}
			catch (exception)
			{
				return;
				//cout << "3 err " << e.what() << endl;
			}
		}
	}
}
void autoSave()
{
	struct tm newtime;
	time_t now = time(0);
	localtime_s(&newtime, &now);
	while (true)
	{

		Sleep(240000);
		ENetPeer* currentPeer;
		autosave = true;
		for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer)
		{
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
			save_player(pInfo(currentPeer), false);
			save_guilds();

			{
				ofstream o("db/volcanic_capes.json");
				if (!o.is_open()) cout << "volcanic cape error" << GetLastError() << endl;
				json j;
				j["v1"] = volcanic_cape;
				j["v2"] = volcanic_wings;
				j["v3"] = newtime.tm_mday;
				o << j << endl;
			}
		}
		for (int i = 0; i < worlds.size(); i++) {
			string world_name = worlds[i].name;
			save_world(world_name, false);
		}
	}
	autosave = false;
}
void trigger_save_() {
	struct tm newtime;
	time_t now = time(0);
	localtime_s(&newtime, &now);
	//cout << "[SERVER] /save is currently saving data!" << " Time of action: " << currentDateTime() << "." << endl;
	{
		ofstream o("db/volcanic_capes.json");
		if (!o.is_open()) cout << "volcanic cape error " << GetLastError() << " Time of action: " << currentDateTime() << "." << endl;
		json j;
		j["v1"] = volcanic_cape;
		j["v2"] = volcanic_wings;
		j["v3"] = newtime.tm_mday;
		o << j << endl;
	}
	saving_ = true;
	enet_host_flush(server);
	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
		save_player(pInfo(currentPeer), false);
	}
	Sleep(2000);
	for (int i = 0; i < worlds.size(); i++) {
		string world_name = worlds[i].name;
		save_world(world_name, false);
		Sleep(50);
	}
	save_guilds();
	cout << "[SERVER] Server data succesfully saved! Time of action: " << currentDateTime() << "." << endl;
	Sleep(2000);
	system("PAUSE");
	exit(0);
}

int auth_(ENetPeer* peer) {

	Player* p_ = pInfo(peer);
	string path_ = "players/" + p_->tankIDName + "_.json";
	if (_access_s(path_.c_str(), 0) == 0) {
		//cout << "login " << p_->tankIDName << endl;
		try {
			//saveall
			json r_;
			ifstream f_(path_, ifstream::binary);
			if (f_.fail()) {
				cout << "failed reading data for " << p_->tankIDName << endl;
				return -1;
			}
			f_ >> r_;
			f_.close();
			if (p_->tankIDPass != r_["pass"])
				return -1;
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
				if (to_lower(pInfo(currentPeer)->tankIDName) == to_lower(p_->tankIDName) and pInfo(currentPeer)->id != p_->id) {
					save_player(pInfo(currentPeer));
					if (p_->tankIDPass != r_["pass"])
						return -1;
					pInfo(currentPeer)->invalid_data = true;
					exit_(currentPeer, true);
					enet_peer_disconnect_later(currentPeer, 0);
					ifstream f_(path_, ifstream::binary);
					f_ >> r_;
					f_.close();
					gamepacket_t p;
					p.Insert("OnConsoleMessage");
					p.Insert("`4ALREADY ON?! `o: This account was already online, kicking it off so you can log on. (if you were just playing before, this is nothing to worry about)");
					p.CreatePacket(peer);
					break;
				}
			}
			json a_ = r_["inv"].get<json>(), b_ = r_["achievements"].get<json>(), c_ = r_["friends"].get<json>(), d_ = r_["last_worlds"].get<json>(), e_ = r_["worlds_owned"].get<json>();
			for (int i_ = 0; i_ < a_.size(); i_++) {
				Items item_{};
				item_.id = a_[i_]["i"].get<int>();
				item_.count = a_[i_]["c"].get<int>();
				p_->inv.push_back(item_);
			} for (int i_ = 0; i_ < b_.size(); i_++) {
				p_->achievements.insert({ b_[i_]["title"].get<string>(), b_[i_]["progress"].get<int>() });
			} for (int i_ = 0; i_ < c_.size(); i_++) {
				Friends new_friend_;
				new_friend_.name = c_[i_]["name"].get<string>();
				new_friend_.mute = c_[i_]["mute"].get<bool>();
				new_friend_.block_trade = c_[i_]["block_trade"].get<bool>();
				new_friend_.last_seen = c_[i_]["last_seen"].get<long long>();
				p_->friends.push_back(new_friend_);
			} for (int i_ = 0; i_ < d_.size(); i_++) {
				p_->last_visited_worlds.push_back(d_[i_]["name"].get<string>());
			} for (int i_ = 0; i_ < e_.size(); i_++) {
				p_->worlds_owned.push_back(e_[i_]["name"].get<string>());
			}
			int h_r = (!(r_.find("h_r") != r_.end()) ? 255 : r_["h_r"].get<int>());
			int h_g = (!(r_.find("h_g") != r_.end()) ? 255 : r_["h_g"].get<int>());
			int h_b = (!(r_.find("h_b") != r_.end()) ? 255 : r_["h_b"].get<int>());
			p_->HairColor->set(h_r, h_g, h_b);
			int e_r = (!(r_.find("e_r") != r_.end()) ? 255 : r_["e_r"].get<int>());
			int e_g = (!(r_.find("e_g") != r_.end()) ? 255 : r_["e_g"].get<int>());
			int e_b = (!(r_.find("e_b") != r_.end()) ? 255 : r_["e_b"].get<int>());
			p_->EyeColor->set(e_r, e_g, e_b);
			int rw_wg_r1 = (!(r_.find("rw_wg_r1") != r_.end()) ? 93 : r_["rw_wg_r1"].get<int>());
			int rw_wg_g1 = (!(r_.find("rw_wg_g1") != r_.end()) ? 22 : r_["rw_wg_g1"].get<int>());
			int rw_wg_b1 = (!(r_.find("rw_wg_b1") != r_.end()) ? 200 : r_["rw_wg_b1"].get<int>());

			int rw_wg_r2 = (!(r_.find("rw_wg_r2") != r_.end()) ? 137 : r_["rw_wg_r2"].get<int>());
			int rw_wg_g2 = (!(r_.find("rw_wg_g2") != r_.end()) ? 30 : r_["rw_wg_g2"].get<int>());
			int rw_wg_b2 = (!(r_.find("rw_wg_b2") != r_.end()) ? 43 : r_["rw_wg_b2"].get<int>());

			int rw_met_r1 = (!(r_.find("rw_met_r1") != r_.end()) ? 220 : r_["rw_met_r1"].get<int>());
			int rw_met_g1 = (!(r_.find("rw_met_g1") != r_.end()) ? 75 : r_["rw_met_g1"].get<int>());
			int rw_met_b1 = (!(r_.find("rw_met_b1") != r_.end()) ? 225 : r_["rw_met_b1"].get<int>());

			int rw_met_r2 = (!(r_.find("rw_met_r2") != r_.end()) ? 34 : r_["rw_met_r2"].get<int>());
			int rw_met_g2 = (!(r_.find("rw_met_g2") != r_.end()) ? 35 : r_["rw_met_g2"].get<int>());
			int rw_met_b2 = (!(r_.find("rw_met_b2") != r_.end()) ? 63 : r_["rw_met_b2"].get<int>());

			int rw_tr1 = (!(r_.find("rw_tr1") != r_.end()) ? 768 : r_["rw_tr1"].get<int>());
			int rw_tr2 = (!(r_.find("rw_tr2") != r_.end()) ? 2048 : r_["rw_tr2"].get<int>());

			int rw_mat1 = (!(r_.find("rw_mat1") != r_.end()) ? STYLE1_FEATHERS_MATERIAL : r_["rw_mat1"].get<int>());
			int rw_mat2 = (!(r_.find("rw_mat2") != r_.end()) ? STYLE2_BLADES_MATERIAL : r_["rw_mat2"].get<int>());

			int rw_closed1 = (!(r_.find("rw_closed1") != r_.end()) ? 0 : r_["rw_closed1"].get<int>());
			int rw_closed2 = (!(r_.find("rw_closed2") != r_.end()) ? 0 : r_["rw_closed2"].get<int>());

			int rw_trail_on1 = (!(r_.find("rw_trail_on1") != r_.end()) ? 1 : r_["rw_trail_on1"].get<int>());
			int rw_trail_on2 = (!(r_.find("rw_trail_on2") != r_.end()) ? 1 : r_["rw_trail_on2"].get<int>());

			int rw_opened_on1 = (!(r_.find("rw_opened_on1") != r_.end()) ? 0 : r_["rw_opened_on1"].get<int>());
			int rw_opened_on2 = (!(r_.find("rw_opened_on2") != r_.end()) ? 0 : r_["rw_opened_on2"].get<int>());

			int rw_stamp1 = (!(r_.find("rw_stamp1") != r_.end()) ? 1 : r_["rw_stamp1"].get<int>());
			int rw_stamp2 = (!(r_.find("rw_stamp2") != r_.end()) ? 0 : r_["rw_stamp2"].get<int>());

			int rw_delay_on = (!(r_.find("rw_delay_on") != r_.end()) ? 1 : r_["rw_delay_on"].get<int>());

			auto wings = &p_->m_riftwings;

			((rw_closed1 == 1) ? wings->enableClosed(1) : wings->disableClosed(1));
			((rw_closed2 == 1) ? wings->enableClosed(2) : wings->disableClosed(2));

			((rw_stamp1 == 1) ? wings->enableStampParticle(1) : wings->disableStampParticle(1));
			((rw_stamp2 == 1) ? wings->enableStampParticle(2) : wings->disableStampParticle(2));

			((rw_trail_on1 == 1) ? wings->enableTrail(1) : wings->disableTrail(1));
			((rw_trail_on2 == 1) ? wings->enableTrail(2) : wings->disableTrail(2));

			((rw_opened_on1 == 1) ? wings->enableOpenWings(1) : wings->disableOpenWings(1));
			((rw_opened_on2 == 1) ? wings->enableOpenWings(2) : wings->disableOpenWings(2));

			((rw_delay_on == 1) ? wings->enableDilation() : wings->disableDilation());
			wings->style1_material = rw_mat1;
			wings->style2_material = rw_mat2;

			p_->m_riftwings.wings_color1->set(rw_wg_r1, rw_wg_g1, rw_wg_b1);
			p_->m_riftwings.wings_metal_color1->set(rw_met_r1, rw_met_g1, rw_met_b1);

			p_->m_riftwings.wings_color2->set(rw_wg_r2, rw_wg_g2, rw_wg_b2);
			p_->m_riftwings.wings_metal_color2->set(rw_met_r2, rw_met_g2, rw_met_b2);
			int rc_cp1 = (!(r_.find("rc_cp1") != r_.end()) ? 2402849791 : r_["rc_cp1"].get<int>());

			int rc_cp2 = (!(r_.find("rc_cp2") != r_.end()) ? 723421695 : r_["rc_cp2"].get<int>());

			int rc_col1 = (!(r_.find("rc_col1") != r_.end()) ? 2402849791 : r_["rc_col1"].get<int>());

			int rc_col2 = (!(r_.find("rc_col2") != r_.end()) ? 1059267327 : r_["rc_col2"].get<int>());

			int rc_aura1 = (!(r_.find("rc_aura1") != r_.end()) ? 768 : r_["rc_aura1"].get<int>());
			int rc_aura2 = (!(r_.find("rc_aura2") != r_.end()) ? 2048 : r_["rc_aura2"].get<int>());

			int rc_closed1 = (!(r_.find("rc_closed1") != r_.end()) ? 0 : r_["rc_closed1"].get<int>());
			int rc_closed2 = (!(r_.find("rc_closed2") != r_.end()) ? 1 : r_["rc_closed2"].get<int>());

			int rc_aura_on1 = (!(r_.find("rc_aura_on1") != r_.end()) ? 1 : r_["rc_aura_on1"].get<int>());
			int rc_aura_on2 = (!(r_.find("rc_aura_on2") != r_.end()) ? 1 : r_["rc_aura_on2"].get<int>());

			int rc_collar_on1 = (!(r_.find("rc_collar_on1") != r_.end()) ? 1 : r_["rc_collar_on1"].get<int>());
			int rc_collar_on2 = (!(r_.find("rc_collar_on2") != r_.end()) ? 1 : r_["rc_collar_on2"].get<int>());

			int rc_move1 = (!(r_.find("rc_move1") != r_.end()) ? 1 : r_["rc_move1"].get<int>());
			int rc_move2 = (!(r_.find("rc_move2") != r_.end()) ? 1 : r_["rc_move2"].get<int>());

			int rc_delay_on = (!(r_.find("rc_delay_on") != r_.end()) ? 0 : r_["rc_delay_on"].get<int>());
			auto cape = &p_->m_riftcape;

			((rc_closed1 == 1) ? cape->enableClosed(1) : cape->disableClosed(1));
			((rc_closed2 == 1) ? cape->enableClosed(2) : cape->disableClosed(2));

			((rc_move1 == 1) ? cape->enableMovement(1) : cape->disableMovement(1));
			((rc_move2 == 1) ? cape->enableMovement(2) : cape->disableMovement(2));

			((rc_aura_on1 == 1) ? cape->enableAura(1) : cape->disableAura(1));
			((rc_aura_on2 == 1) ? cape->enableAura(2) : cape->disableAura(2));

			((rc_collar_on1 == 1) ? cape->enableCollar(1) : cape->disableCollar(1));
			((rc_collar_on2 == 1) ? cape->enableCollar(2) : cape->disableCollar(2));

			((rc_delay_on == 1) ? cape->enableDilation() : cape->disableDilation());
			cape->style1_aura = rc_aura1;
			cape->style2_aura = rc_aura2;

			p_->m_riftcape.cape_color1->set(rc_cp1);
			p_->m_riftcape.cape_collar_color1->set(rc_col1);

			p_->m_riftcape.cape_color2->set(rc_cp2);
			p_->m_riftcape.cape_collar_color2->set(rc_col2);
			p_->legend = (!(r_.find("ltitle") != r_.end()) ? false : r_["ltitle"].get<bool>());
			p_->is_legend = (!(r_.find("legend") != r_.end()) ? false : r_["legend"].get<bool>());
			p_->bb = (!(r_.find("bb") != r_.end()) ? false : r_["bb"].get<bool>());
			p_->dd = (!(r_.find("dd") != r_.end()) ? 0 : r_["dd"].get<int>());
			p_->supp = (!(r_.find("supp") != r_.end()) ? 0 : r_["supp"].get<int>());
			p_->hs = (!(r_.find("hs") != r_.end()) ? 0 : r_["hs"].get<int>());
			p_->dds = (!(r_.find("dds") != r_.end()) ? 0 : r_["dds"].get<int>());
			p_->tk = (!(r_.find("tk") != r_.end()) ? 0 : r_["tk"].get<int>());
			p_->note = (!(r_.find("note") != r_.end()) ? "" : r_["note"].get<string>());
			p_->d_name = (!(r_.find("d_name") != r_.end()) ? "" : r_["d_name"].get<string>());
			p_->gtwl = (!(r_.find("gtwl") != r_.end()) ? 0 : r_["gtwl"].get<int>());
			p_->vip = (!(r_.find("vip") != r_.end()) ? 0 : r_["vip"].get<int>());
			p_->rb = (!(r_.find("rb") != r_.end()) ? 0 : r_["rb"].get<int>());
			p_->mds = (!(r_.find("mds") != r_.end()) ? 0 : r_["mds"].get<int>());
			p_->gr = (!(r_.find("gr") != r_.end()) ? p_->gr : r_["gr"].get<vector<string>>());
			p_->gp = (!(r_.find("gp") != r_.end()) ? 0 : r_["gp"].get<int>());
			p_->gd = (!(r_.find("gd") != r_.end()) ? 0 : r_["gd"].get<int>());
			p_->glo = (!(r_.find("glo") != r_.end()) ? 0 : r_["glo"].get<int>());
			p_->glo_p = (!(r_.find("glo_p") != r_.end()) ? p_->glo_p : r_["glo_p"].get<vector<int>>());
			p_->lvl_p = (!(r_.find("lvl_p") != r_.end()) ? p_->lvl_p : r_["lvl_p"].get<vector<int>>());
			p_->surg_p = (!(r_.find("surg_p") != r_.end()) ? p_->surg_p : r_["surg_p"].get<vector<int>>());
			p_->t_p = (!(r_.find("t_p") != r_.end()) ? p_->t_p : r_["t_p"].get<vector<int>>());
			p_->bb_p = (!(r_.find("bb_p") != r_.end()) ? p_->bb_p : r_["bb_p"].get<vector<int>>());
			p_->ff_p = (!(r_.find("ff_p") != r_.end()) ? p_->ff_p : r_["ff_p"].get<vector<int>>());
			p_->p_p = (!(r_.find("p_p") != r_.end()) ? p_->p_p : r_["p_p"].get<vector<int>>());
			p_->g_p = (!(r_.find("g_p") != r_.end()) ? p_->g_p : r_["g_p"].get<vector<int>>());
			p_->t_xp = (!(r_.find("t_xp") != r_.end()) ? 0 : r_["t_xp"].get<int>());
			p_->bb_xp = (!(r_.find("bb_xp") != r_.end()) ? 0 : r_["bb_xp"].get<int>());
			p_->ff_xp = (!(r_.find("ff_xp") != r_.end()) ? 0 : r_["ff_xp"].get<int>());
			p_->s_xp = (!(r_.find("s_xp") != r_.end()) ? 0 : r_["s_xp"].get<int>());
			p_->g_xp = (!(r_.find("g_xp") != r_.end()) ? 0 : r_["g_xp"].get<int>());
			p_->p_xp = (!(r_.find("p_xp") != r_.end()) ? 0 : r_["p_xp"].get<int>());
			p_->t_lvl = (!(r_.find("t_lvl") != r_.end()) ? 0 : r_["t_lvl"].get<int>());
			p_->bb_lvl = (!(r_.find("bb_lvl") != r_.end()) ? 0 : r_["bb_lvl"].get<int>());
			p_->ff_lvl = (!(r_.find("ff_lvl") != r_.end()) ? 0 : r_["ff_lvl"].get<int>());
			p_->s_lvl = (!(r_.find("s_lvl") != r_.end()) ? 0 : r_["s_lvl"].get<int>());
			p_->g_lvl = (!(r_.find("g_lvl") != r_.end()) ? 0 : r_["g_lvl"].get<int>());
			p_->p_lvl = (!(r_.find("p_lvl") != r_.end()) ? 0 : r_["p_lvl"].get<int>());
			p_->b_l = (!(r_.find("b_l") != r_.end()) ? 1 : r_["b_l"].get<int>());
			p_->achievement_total = (!(r_.find("achi") != r_.end()) ? 0 : r_["achi"].get<int>());
			p_->bp = (!(r_.find("bp") != r_.end()) ? p_->bp : r_["bp"].get<vector<pair<int, int>>>());
			p_->flagmay = (!(r_.find("flagmay") != r_.end()) ? p_->flagmay : r_["flagmay"].get<int>());
			p_->cc = (!(r_.find("cc") != r_.end()) ? p_->cc : r_["cc"].get<int>());
			p_->opc = (!(r_.find("opc") != r_.end()) ? p_->opc : r_["opc"].get<int>());
			p_->superdev = (!(r_.find("superdev") != r_.end()) ? p_->superdev : r_["superdev"].get<int>());
			p_->banner_item = (!(r_.find("b_item") != r_.end()) ? p_->banner_item : r_["b_item"].get<int>());
			p_->banner_type = (!(r_.find("b_type") != r_.end()) ? p_->banner_type : r_["b_type"].get<int>());
			p_->b_i = (!(r_.find("b_i") != r_.end()) ? p_->b_i : r_["b_i"].get<int>());
			p_->b_a = (!(r_.find("b_a") != r_.end()) ? p_->b_a : r_["b_a"].get<int>());
			p_->b_w = (!(r_.find("b_w") != r_.end()) ? p_->b_w : r_["b_w"].get<int>());
			p_->b_p = (!(r_.find("b_p") != r_.end()) ? p_->b_p : r_["b_p"].get<int>());
			p_->surgery_skill = (!(r_.find("skl") != r_.end()) ? p_->surgery_skill : r_["skl"].get<int>());
			p_->surgery_type = (!(r_.find("sgt") != r_.end()) ? p_->surgery_type : r_["sgt"].get<int>());
			p_->surgery_done = (!(r_.find("sd") != r_.end()) ? p_->surgery_done : r_["sd"].get<int>());
			p_->su_8552_1 = (!(r_.find("su1") != r_.end()) ? p_->su_8552_1 : r_["su1"].get<int>());
			p_->su_8552_2 = (!(r_.find("su2") != r_.end()) ? p_->su_8552_2 : r_["su2"].get<int>());
			p_->b_ra = (!(r_.find("b_ra") != r_.end()) ? p_->b_ra : r_["b_ra"].get<int>());
			p_->b_lvl = (!(r_.find("b_lvl") != r_.end()) ? p_->b_lvl : r_["b_lvl"].get<int>());
			p_->i_11818_1 = (!(r_.find("i_11818_1") != r_.end()) ? p_->i_11818_1 : r_["i_11818_1"].get<signed char>());
			p_->i_11818_2 = (!(r_.find("i_11818_2") != r_.end()) ? p_->i_11818_2 : r_["i_11818_2"].get<signed char>());
			p_->roleSkin = (!(r_.find("roleSkin") != r_.end()) ? 6 : r_["roleSkin"].get<int>());
			p_->roleIcon = (!(r_.find("roleIcon") != r_.end()) ? 6 : r_["roleIcon"].get<int>());
			p_->promo = (!(r_.find("promo") != r_.end()) ? p_->promo : r_["promo"].get<int>());
			p_->flagset = (!(r_.find("flagset") != r_.end()) ? p_->flagset : r_["flagset"].get<int>());
			p_->radio = (!(r_.find("radio") != r_.end()) ? p_->radio : r_["radio"].get<int>());
			p_->w_w = (!(r_.find("w_w") != r_.end()) ? p_->w_w : r_["w_w"].get<int>());
			p_->w_d = (!(r_.find("w_d") != r_.end()) ? p_->w_d : r_["w_d"].get<int>());
			p_->egg = (!(r_.find("egg") != r_.end()) ? p_->egg : r_["egg"].get<int>());
			p_->mercy = (!(r_.find("mer") != r_.end()) ? p_->mercy : r_["mer"].get<bool>());
			p_->on = (!(r_.find("onstatus") != r_.end()) ? p_->on : r_["onstatus"].get<bool>());
			p_->busy = (!(r_.find("busystatus") != r_.end()) ? p_->busy : r_["busystatus"].get<bool>());
			p_->away = (!(r_.find("awaystatus") != r_.end()) ? p_->away : r_["awaystatus"].get<bool>());
			p_->drtitle = (!(r_.find("drtt") != r_.end()) ? p_->drtitle : r_["drtt"].get<bool>());
			p_->mentor = (!(r_.find("mentor") != r_.end()) ? p_->mentor : r_["mentor"].get<bool>());
			p_->g4g = (!(r_.find("g4g") != r_.end()) ? p_->g4g : r_["g4g"].get<bool>());
			p_->drt = (!(r_.find("_drt") != r_.end()) ? p_->drt : r_["_drt"].get<bool>());
			p_->lvl125 = (!(r_.find("lvl125") != r_.end()) ? p_->lvl125 : r_["lvl125"].get<bool>());
			p_->donor = (!(r_.find("dnr") != r_.end()) ? p_->donor : r_["dnr"].get<int>());
			p_->master = (!(r_.find("mst") != r_.end()) ? p_->master : r_["mst"].get<int>());

			p_->pinata_day = (!(r_.find("p_d1") != r_.end()) ? p_->pinata_day : r_["p_d1"].get<int>());
			p_->pinata_prize = (!(r_.find("p_d2") != r_.end()) ? p_->pinata_prize : r_["p_d2"].get<bool>());
			p_->pinata_claimed = (!(r_.find("p_d3") != r_.end()) ? p_->pinata_claimed : r_["p_d3"].get<bool>());


			p_->grow4good_day = (!(r_.find("g4g_1") != r_.end()) ? p_->grow4good_day : r_["g4g_1"].get<int>());
			p_->grow4good_rarity = (!(r_.find("g4g_2") != r_.end()) ? p_->grow4good_rarity : r_["g4g_2"].get<int>());
			p_->grow4good_total_rarity = (!(r_.find("g4g_3") != r_.end()) ? p_->grow4good_total_rarity : r_["g4g_3"].get<int>());
			p_->grow4good_wl = (!(r_.find("g4g_4") != r_.end()) ? p_->grow4good_wl : r_["g4g_4"].get<int>());
			p_->grow4good_total_wl = (!(r_.find("g4g_5") != r_.end()) ? p_->grow4good_total_wl : r_["g4g_5"].get<int>());
			p_->grow4good_donate_gems = (!(r_.find("g4g_6") != r_.end()) ? p_->grow4good_donate_gems : r_["g4g_6"].get<bool>());
			p_->grow4good_gems = (!(r_.find("g4g_7") != r_.end()) ? p_->grow4good_gems : r_["g4g_7"].get<int>());
			p_->grow4good_purchase_waving = (!(r_.find("g4g_8") != r_.end()) ? p_->grow4good_purchase_waving : r_["g4g_8"].get<bool>());
			p_->grow4good_surgery = (!(r_.find("g4g_9") != r_.end()) ? p_->grow4good_surgery : r_["g4g_9"].get<int>());
			p_->grow4good_fish = (!(r_.find("g4g_10") != r_.end()) ? p_->grow4good_fish : r_["g4g_10"].get<int>());
			p_->grow4good_points = (!(r_.find("g4g_11") != r_.end()) ? p_->grow4good_points : r_["g4g_11"].get<int>());
			p_->grow4good_claim_prize = (!(r_.find("g4g_12") != r_.end()) ? p_->grow4good_claim_prize : r_["g4g_12"].get<int>());
			p_->grow4good_claimed_prize = (!(r_.find("g4g_13") != r_.end()) ? p_->grow4good_claimed_prize : r_["g4g_13"].get<int>());
			p_->grow4good_break = (!(r_.find("g4g_14") != r_.end()) ? p_->grow4good_break : r_["g4g_14"].get<int>());
			p_->grow4good_place = (!(r_.find("g4g_15") != r_.end()) ? p_->grow4good_place : r_["g4g_15"].get<int>());
			p_->grow4good_trade = (!(r_.find("g4g_16") != r_.end()) ? p_->grow4good_trade : r_["g4g_16"].get<int>());
			p_->grow4good_sb = (!(r_.find("g4g_17") != r_.end()) ? p_->grow4good_sb : r_["g4g_17"].get<int>());

			p_->tankIDName = r_["name"].get<string>();
			p_->email = r_["email"].get<string>();
			p_->b_r = r_["b_r"].get<string>();
			p_->b_b = r_["b_b"].get<string>();
			p_->b_s = r_["b_s"].get<long long int>();
			p_->b_t = r_["b_t"].get<long long int>();
			p_->m_r = r_["m_r"].get<string>();
			p_->m_b = r_["m_b"].get<string>();
			p_->punch_count = r_["punch"].get<long long int>();
			p_->n = r_["n"].get<int>();
			p_->lo = r_["lo"].get<string>();
			p_->ghost = r_["ghost"].get<bool>();
			p_->invis = r_["invis"].get<bool>();
			p_->bans = r_["bans"].get<vector<string>>();
			p_->logs = r_["logs"].get<vector<string>>();
			p_->mod = r_["mod"].get<int>();
			p_->dev = r_["dev"].get<int>();
			p_->m_h = r_["m_h"].get<int>();
			p_->gems = r_["gems"].get<int>();
			p_->xp = r_["xp"].get<long long int>();
			p_->level = r_["level"].get<signed char>();
			p_->skin = r_["skin"].get<int>();
			p_->show_location_ = r_["show_location"].get<bool>();
			p_->show_friend_notifications_ = r_["show_notifications"].get<bool>();
			p_->playtime = time(NULL), p_->seconds = r_["playtime"].get<long long int>();
			p_->account_created = r_["date"].get<long long int>();
			if (p_->account_created == 0) p_->account_created = time(NULL) / 86400;
			p_->home_world = r_["home_world"].get<string>();
			p_->hair = r_["hair"].get<int>();
			p_->shirt = r_["shirt"].get<int>();
			p_->pants = r_["pants"].get<int>();
			p_->feet = r_["feet"].get<int>();
			p_->face = r_["face"].get<int>();
			p_->ip = r_["ip"].get<string>();
			p_->hand = r_["hand"].get<int>();
			p_->back = r_["back"].get<int>();
			p_->mask = r_["mask"].get<int>();
			p_->necklace = r_["necklace"].get<int>();
			p_->ances = r_["ances"].get<int>();
			//p_->trade_logs = r_["trade_logs"].get<vector<string>>();
			if (r_.find("guild_id") != r_.end()) {
				p_->guild_id = r_["guild_id"].get<int>();
			}
			if (r_.find("geiger") != r_.end()) {
				p_->geiger_ = r_["geiger"].get<int>();
			}
			if (r_.find("booty_broken") != r_.end()) {
				p_->booty_broken = r_["booty_broken"].get<int>();
			}
			if (r_.find("playmods") != r_.end()) {
				json list_playmod = r_["playmods"].get<json>();
				for (int i_ = 0; i_ < list_playmod.size(); i_++) {
					PlayMods give_playmod{};
					give_playmod.id = list_playmod[i_]["id"].get<int>();
					give_playmod.time = list_playmod[i_]["time"].get<long long>();
					if (list_playmod[i_].find("user") != list_playmod[i_].end()) {
						give_playmod.user = list_playmod[i_]["user"].get<string>();
					}
					p_->playmods.push_back(give_playmod);
				}
			}
			if (r_.find("blarney") != r_.end()) {
				json list_blarney = r_["blarney"].get<json>();
				for (int i_ = 0; i_ < list_blarney.size(); i_++) {
					int w_ = list_blarney[i_]["world"].get<int>();
					long long tim_ = list_blarney[i_]["time"].get<long long>();
					for (int c_ = 0; c_ < p_->completed_blarneys.size(); c_++) {
						if ((int)p_->completed_blarneys[c_][0] == w_) {
							p_->completed_blarneys[c_][1] = tim_;
							break;
						}
					}
				}
			}
			if (p_->ghost or p_->invis) {
				if (not p_->mod and not p_->dev) {
					p_->invis = false;
				}
				if (not p_->dev) {
					p_->ghost = false;
					if (p_->skin == -2450) p_->skin = 0x8295C3FF;
				}
			}
			if (pInfo(peer)->supp == 2) {
				/*gamepacket_t p;
				p.Insert("OnOverrideGDPRFromServer");
				p.Insert(39);
				p.Insert(1);
				p.Insert(0);
				p.Insert(1);
				p.CreatePacket(peer);*/
				{
					gamepacket_t p;
					p.Insert("OnSetRoleSkinsAndTitles");
					// pirmas - farmer
					// antras - builder
					// trecias - surgeon
					// ketvirtas - fisherman
					// penktas - chef
					// sestas - starcaptain
					string a = (pInfo(peer)->bb_lvl >= 50 ? "1" : "0");
					string a1 = (pInfo(peer)->bb_lvl >= 50 ? "2" : "0");
					string farm_set_skins = (pInfo(peer)->t_lvl >= 50 ? "1" : "0") + a;
					string farm_set_titles = (pInfo(peer)->t_lvl >= 50 ? "2" : "0") + a1;
					p.Insert(farm_set_skins + "0000");
					p.Insert(farm_set_titles + "0000");
					p.CreatePacket(peer);
				}
			}
			if (p_->gp == 1) {
				gamepacket_t p;
				p.Insert("OnPaw2018SkinColor1Changed");
				p.Insert(1);
				p.CreatePacket(peer);
				{
					gamepacket_t p;
					p.Insert("OnPaw2018SkinColor2Changed");
					p.Insert(1);
					p.CreatePacket(peer);
				}
			}
			{
				gamepacket_t p;
				p.Insert("OnSetBux");
				p.Insert(pInfo(peer)->gems);
				p.Insert(1);
				p.Insert((pInfo(peer)->supp >= 1) ? 1 : 0);
				if (pInfo(peer)->supp >= 2) {
					p.Insert((float)33796, (float)1, (float)0);
				}
				p.CreatePacket(peer);
			}
		}
		catch (exception) {
			return -1;
		}
		gamepacket_t p;
		p.Insert("SetHasGrowID");
		p.Insert(1);
		p.Insert(p_->tankIDName);
		p.Insert(p_->tankIDPass);
		p.CreatePacket(peer);
		return 0;
	}
	return -1;
}
string r_dialog(const string& r_, const string& a_ = "", const string& b_ = "", const string& c_ = "", const string& d_ = "") {
	return "text_scaling_string|Dirttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttt|\nset_default_color|`o\nadd_label_with_icon|big|`wGet a GrowtopiaMYID``|left|206|\nadd_spacer|small|\nadd_textbox|" + (r_.empty() ? "By choosing a `wGrowtopiaMYID``, you can use a name and password to logon from any device.Your `wname`` will be shown to other players!" : r_) + "|left|\nadd_spacer|small|\nadd_text_input|logon|Name|" + a_ + "|18|\nadd_textbox|Your `wpassword`` must contain `w8 to 18 characters, 1 letter, 1 number`` and `w1 special character: @#!$^&*.,``|left|\nadd_text_input_password|password|Password|" + b_ + "|18|\nadd_text_input_password|password_verify|Password Verify|" + c_ + "|18|\nadd_textbox|Your `wemail`` will only be used for account verification and support. If you enter a fake email, you can't verify your account, recover or change your password. If you do need help, you can contact Time#1337 on Discord.|left|\nadd_text_input|email|Email|" + d_ + "|64|\nadd_textbox|We will never ask you for your password or email, never share it with anyone! If you share your account will compromised/banned by `6Developers``/`sSuper Developers``/`#Moderators``.|left|\nend_dialog|growid_apply|Cancel|Get My GrowID!|\n";
}
string to_playmod_time(int seconds) {
	int hour = seconds / 3600;
	int minute = (seconds % 3600) / 60;
	int second = seconds % 60;
	if (hour == 0 and minute == 0 and second == 0) return "Removing now ";
	return (hour > 0 ? to_string(hour) + " hours" : "") + (minute > 0 ? (hour > 0 ? ", " : "") + to_string(minute) + " mins" : "") + (second > 0 ? (minute > 0 ? ", " : "") + to_string(second) + " secs " : " ");
}
string form_mods(Player* p_, int text) {
	vector<string> player_playmods;
	long long time_ = time(nullptr);
	vector<string> added_{};
	for (PlayMods peer_playmod : p_->playmods) {
		for (vector<string> get_ : info_about_playmods) {
			uint32_t playmod_id = atoi(get_[0].c_str());
			if (playmod_id == peer_playmod.id) {
				string playmod_name = get_[2];
				if (find(added_.begin(), added_.end(), playmod_name) == added_.end()) {
					added_.push_back(playmod_name);
					player_playmods.push_back(playmod_name + "`` (`w" + to_playmod_time(peer_playmod.time - time_) + "``left)"), player_playmods.push_back(get_[5]);
				}
			}
		}
	}
	player_playmods.push_back(items[p_->hair].playmod), player_playmods.push_back(to_string(p_->hair));
	player_playmods.push_back(items[p_->shirt].playmod), player_playmods.push_back(to_string(p_->shirt));
	player_playmods.push_back(items[p_->pants].playmod), player_playmods.push_back(to_string(p_->pants));
	player_playmods.push_back(items[p_->feet].playmod), player_playmods.push_back(to_string(p_->feet));
	player_playmods.push_back(items[p_->face].playmod), player_playmods.push_back(to_string(p_->face));
	player_playmods.push_back(items[p_->hand].playmod), player_playmods.push_back(to_string(p_->hand));
	player_playmods.push_back(items[p_->back].playmod), player_playmods.push_back(to_string(p_->back));
	player_playmods.push_back(items[p_->mask].playmod), player_playmods.push_back(to_string(p_->mask));
	player_playmods.push_back(items[p_->necklace].playmod), player_playmods.push_back(to_string(p_->necklace));
	player_playmods.push_back(items[p_->ances].playmod), player_playmods.push_back(to_string(p_->ances));
	if (p_->ghost) player_playmods.push_back("Ghost in the Shell"), player_playmods.push_back("290");
	if (p_->b_s != 0) player_playmods.push_back("Duct Tape"), player_playmods.push_back("408");
	if (p_->hand == 2286) player_playmods.push_back("Charging Geiger Counter`` (" + to_string(p_->geiger_) + "%)"), player_playmods.push_back("2204");
	if (p_->spotlight) player_playmods.push_back("In the Spotlight"), player_playmods.push_back("2646");
	string t_ = "";
	int active = 0;
	try {
		for (int i_ = 0; i_ < player_playmods.size(); i_++) {
			if (player_playmods.at(i_).empty() or isdigit(player_playmods.at(i_).at(0))) continue;
			t_ += (text == 0 ? "\nadd_label_with_icon|small|`w" + player_playmods.at(i_) + "``|left|" + player_playmods.at(i_ + 1) + "|" : "\n`w" + player_playmods.at(i_) + "``");
			active++;
		}
	}
	catch (out_of_range) {
		return t_;
	}
	if (t_.empty())
		t_ = "";
	else
		if (text == 0) t_ = "\nadd_textbox|`wActive effects:``|left|\nadd_label_with_icon|small|" + t_;
		else t_ = "\n" + to_string(active) + " mods active:" + t_;
	return t_;
}

void gems_(ENetPeer* peer, World* world_, int c_, int x_, int y_, int from) {
	if (thedaytoday == 5 and rand() % 50 < 1) c_++;
	//if (from == 5136 || from == 9386 || from == 9400 || from == 9384) return;
	if (from == 5136 || from == 9400 || from == 9384) return;
	if (from != 1008 and from != 5196 and from != 3604) {
		if (peer != NULL and has_playmod(pInfo(peer), "Extra Wealth...") && rand() % 5 + 1 == 5) {
			PlayerMoving data_{};
			data_.packetType = 17, data_.netID = 29, data_.YSpeed = 29, data_.x = pInfo(peer)->x + 16, data_.y = pInfo(peer)->y + 16;
			BYTE* raw = packPlayerMoving(&data_);
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world) continue;
				send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
			}
			delete[] raw;
			c_ = ((items[pInfo(peer)->ances].chance + 100) * c_) / 100;
		}
		bool doubled = false;
		if (peer != NULL and rand() % 100 < 10 and pInfo(peer)->lock == 2408 or peer != NULL and pInfo(peer)->hand == 6312 || peer != NULL and pInfo(peer)->hand == 11118 || peer != NULL and pInfo(peer)->hand == 9496) {
			PlayerMoving data_{};
			data_.packetType = 17, data_.netID = 125, data_.YSpeed = 125, data_.x = x_ + 16, data_.y = y_ + 16;
			BYTE* raw = packPlayerMoving(&data_);
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
				if (pInfo(currentPeer)->world == world_->name) send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
			}
			delete[] raw;
			if (pInfo(peer)->hand == 6312 || pInfo(peer)->hand == 11118) c_ *= 3, doubled = true;
			if (pInfo(peer)->hand == 9496) c_ *= 4, doubled = true;
			c_ += 1;
		}
		if (not doubled) {
			c_ *= 2;
		}
		if (c_ > 200) c_ = 200;
	}
	c_ *= 3;
	// gem konvertavimas
	int a_ = c_;
	int purple_ = c_ >= 100 ? c_ / 100 : 0, green_ = c_ - (purple_ * 100) >= 50 ? (c_ - (purple_ * 100)) / 50 : 0, red_ = c_ - (purple_ * 100) - (green_ * 50) >= 10 ? (c_ - (purple_ * 100) - (green_ * 50)) / 10 : 0, blue_ = c_ - (green_ * 50) - (purple_ * 100) - (red_ * 10) >= 5 ? (c_ - (green_ * 50) - (purple_ * 100) - (red_ * 10)) / 5 : 0, yellow_ = c_ - (red_ * 10) - (green_ * 50) - (purple_ * 100) - (blue_ * 5) > 0 ? (c_ - (red_ * 10) - (green_ * 50) - (purple_ * 100) - (blue_ * 5)) / 1 : 0;
	// dabar drop   
	WorldDrop item_{};
	item_.id = 112;
	item_.count = 100;
	for (int i_ = 0; i_ < purple_; i_++) {
		item_.x = x_ + rand() % 17, item_.y = y_ + rand() % 17;
		item_.uid = uint16_t(world_->drop.size()) + 1;
		dropas_(world_, item_);
	}
	item_.count = 50;
	for (int i_ = 0; i_ < green_; i_++) {
		item_.x = x_ + rand() % 17, item_.y = y_ + rand() % 17;
		item_.uid = uint16_t(world_->drop.size()) + 1;
		dropas_(world_, item_);
	}
	item_.count = 10;
	for (int i_ = 0; i_ < red_; i_++) {
		item_.x = x_ + rand() % 17, item_.y = y_ + rand() % 17;
		item_.uid = uint16_t(world_->drop.size()) + 1;
		dropas_(world_, item_);
	}
	item_.count = 5;
	for (int i_ = 0; i_ < blue_; i_++) {
		item_.x = x_ + rand() % 17, item_.y = y_ + rand() % 17;
		item_.uid = uint16_t(world_->drop.size()) + 1;
		dropas_(world_, item_);
	}
	item_.count = 1;
	for (int i_ = 0; i_ < yellow_; i_++) {
		item_.x = x_ + rand() % 17, item_.y = y_ + rand() % 17;
		item_.uid = uint16_t(world_->drop.size()) + 1;
		dropas_(world_, item_);
	}
}
bool static_(BlockTypes& c_, ItemDB item_) {
	// sugalvoti kaip nuspresti ar blockas yra solid arba background
	c_ = item_.blockType;
	if (item_.id == 0) return false;
	if (c_ == LOCK or c_ == BEDROCK or c_ == MAIN_DOOR or c_ == FOREGROUND or c_ == DEADLY or c_ == PAIN_BLOCK or item_.name.find(" Block") != string::npos and item_.name.find(" Seed") == string::npos or item_.name.find(" Bricks") != string::npos and item_.name.find(" Seed") == string::npos)
		return true;
	return false;
}
void send_friends(ENetPeer* p_, bool all = false) {
	// labai cia sudinai gavosi   
	int on_ = 0;
	string info_ = "";
	vector<string> friends_, online_friends_;
	for (int c_ = 0; c_ < pInfo(p_)->friends.size(); c_++) {
		friends_.push_back(pInfo(p_)->friends[c_].name);
	} for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
		if (find(friends_.begin(), friends_.end(), pInfo(currentPeer)->tankIDName) != friends_.end()) {
			online_friends_.push_back(pInfo(currentPeer)->tankIDName);
			on_++;
		}
	} if (all and pInfo(p_)->friends.size() != 0) {
		long long time_t = time(NULL);
		for (int c_ = 0; c_ < pInfo(p_)->friends.size(); c_++) {
			if (find(online_friends_.begin(), online_friends_.end(), pInfo(p_)->friends[c_].name) == online_friends_.end()) {
				long long friend_last_online_ = time_t - pInfo(p_)->friends[c_].last_seen;
				info_ += "\nadd_friend_image_label_button|" + pInfo(p_)->friends[c_].name + "|`4(" + (friend_last_online_ < 60 ? to_string(friend_last_online_) + "s" : (friend_last_online_ < 3600 ? to_string(friend_last_online_ / 60) + "m" : (friend_last_online_ < 86400 ? to_string(friend_last_online_ / 3600) + "h" : to_string(friend_last_online_ / 86400) + "d"))) + ") ``" + pInfo(p_)->friends[c_].name + "|game/tiles_page14.rttex|1.6|31|23|32|" + (pInfo(p_)->friends[c_].mute ? "true" : "false") + "|" + (pInfo(p_)->friends[c_].block_trade ? "true" : "false") + "|";
			}
		}
		gamepacket_t p;
		p.Insert("OnDialogRequest");
		p.Insert("set_default_color|`o\nadd_label_with_icon|big|" + to_string(on_) + " of " + to_string(pInfo(p_)->friends.size()) + " `wFriends Online``|left|1366|\nadd_spacer|small|" + info_ + "\nadd_spacer|small|\nadd_textbox|`oYou aren't currently ignoring anyone.``|left|\nadd_spacer|small|\nadd_button|all_friends|Edit Friends|noflags|0|0|\nadd_button|friends_options|Friend Options|noflags|0|0|\nadd_button|back|Back|noflags|0|0|\nadd_button||Close|noflags|0|0|\nend_dialog|friends|||\nadd_quick_exit|");
		p.CreatePacket(p_);
	}
	else {
		for (int c_ = 0; c_ < pInfo(p_)->friends.size(); c_++) {
			if (find(online_friends_.begin(), online_friends_.end(), pInfo(p_)->friends[c_].name) != online_friends_.end()) {
				info_ += "\nadd_friend_image_label_button|" + pInfo(p_)->friends[c_].name + "|" + pInfo(p_)->friends[c_].name + "|game/tiles_page14.rttex|1.6|28|23|32|" + (pInfo(p_)->friends[c_].mute ? "true" : "false") + "|" + (pInfo(p_)->friends[c_].block_trade ? "true" : "false") + "|";
			}
		}
		gamepacket_t p;
		p.Insert("OnDialogRequest");
		p.Insert("set_default_color|`o\nadd_label_with_icon|big|" + to_string(on_) + " of " + to_string(pInfo(p_)->friends.size()) + " `wFriends Online``|left|1366|\nadd_spacer|small|" + (on_ == 0 and pInfo(p_)->friends.size() != 0 ? "\nadd_textbox|`oNone of your friends are currently online.``|left|\nadd_spacer|small|" : (pInfo(p_)->friends.size() == 0 ? "\nadd_textbox|`oYou currently have no friends.  That's just sad.  To make some, press a person's wrench icon, then choose `5Add as friend``.``|left|\nadd_spacer|small|" : (on_ != 0 ? info_ : "\nadd_textbox|`oNone of your friends are currently online.``|left|\nadd_spacer|small|"))) + "\nadd_spacer|small|" + (pInfo(p_)->friends.size() == 0 ? "" : (on_ == pInfo(p_)->friends.size() ? "\nadd_spacer|small|\nadd_button|all_friends|Edit Friends|noflags|0|0|" : "\nadd_button|friend_all|Show offline and ignored too|noflags|0|0|\nadd_button|all_friends|Edit Friends|noflags|0|0|")) + "\nadd_button|friends_options|Friend Options|noflags|0|0|\nadd_button|back|Back|noflags|0|0|\nadd_button||Close|noflags|0|0|\nend_dialog|friends|||\nadd_quick_exit|");
		p.CreatePacket(p_);
	}
}

void send_social(ENetPeer* p_) {
	gamepacket_t p;
	p.Insert("OnDialogRequest");
	string asddd_ = pInfo(p_)->guild_id != 0 ? "Show Guild Members" : "Create Guild";
	p.Insert("set_default_color|`o\nadd_label_with_icon|big| `wSocial Portal`` |left|1366|\nadd_spacer|small|\nadd_button|showfriend|`wShow Friends``|noflags|0|0|\nadd_button|showguild|`w" + asddd_ + "``|noflags|0|0|\nadd_button|trade_logs|`wTrade History``|noflags|0|0|\nadd_quick_exit|\nend_dialog|socialportal||Back|\n");
	p.CreatePacket(p_);
}
void edit_friend(ENetPeer* p_, string name_, bool back_ = false) {
	for (int c_ = 0; c_ < pInfo(p_)->friends.size(); c_++) {
		if (pInfo(p_)->friends[c_].name == name_) {
			if (back_) {
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
					if (pInfo(currentPeer)->tankIDName == pInfo(p_)->friends[c_].name) {
						send_friends(p_, true);
						return;
					}
				}
				send_friends(p_);
				break;
			}
			gamepacket_t p;
			p.Insert("OnDialogRequest");
			p.Insert("set_default_color|`o\nadd_label_with_icon|big|`4Remove Friend``|left|1366|\nadd_spacer|small|\nadd_textbox|`oAre you sure you wish to `4remove`` " + pInfo(p_)->friends[c_].name + " as a friend?|left|\nadd_spacer|small|\nadd_button|remove|`4Remove Friend``|noflags|0|0|\nembed_data|friendID|" + pInfo(p_)->friends[c_].name + "\nadd_button|back|Back|noflags|0|0|\nend_dialog|friends_remove|||\nadd_quick_exit|");
			p.CreatePacket(p_);
			break;
		}
	}
}
void send_info_friend(ENetPeer* p_, string name_) {
	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
		if (pInfo(currentPeer)->tankIDName == name_) {
			if (pInfo(currentPeer)->invis or pInfo(currentPeer)->m_h) continue;
			for (int c_ = 0; c_ < pInfo(p_)->friends.size(); c_++) {
				if (pInfo(p_)->friends[c_].name == pInfo(currentPeer)->tankIDName) {
					pInfo(p_)->last_edit = pInfo(currentPeer)->tankIDName;
					gamepacket_t p;
					p.Insert("OnDialogRequest");
					if (not pInfo(currentPeer)->show_location_) {
						p.Insert("set_default_color|`o\nadd_label_with_icon|big|`w" + pInfo(currentPeer)->tankIDName + "``|left|1366|\nadd_spacer|small|\nembed_data|friendID|" + pInfo(currentPeer)->tankIDName + "\nadd_textbox|`o" + pInfo(currentPeer)->tankIDName + " is `2online`` now, but has not made their location public to friends.|left|\nadd_spacer|small|\nadd_button|remove|Remove as friend|noflags|0|0|\nadd_button|back|Back|noflags|0|0|\nend_dialog|friends_edit|||\nadd_quick_exit|");
					}
					else {
						p.Insert("set_default_color|`o\nadd_label_with_icon|big|`w" + pInfo(currentPeer)->tankIDName + "``|left|1366|\nadd_spacer|small|\nembed_data|friendID|" + pInfo(currentPeer)->tankIDName + "\nadd_textbox|`o" + pInfo(currentPeer)->tankIDName + " is `2online`` now in the world `5" + (pInfo(currentPeer)->world.empty() ? "EXIT" : pInfo(currentPeer)->world) + "``.|left|\nadd_spacer|small|\nadd_button|goto|Warp to `5" + (pInfo(currentPeer)->world.empty() ? "EXIT" : pInfo(currentPeer)->world) + "``|noflags|0|0|" + (pInfo(p_)->friends[c_].mute ? "\nadd_button||`4Can't Send message``|disabled|0|0|\nadd_button|mute|Un Mute Friend|noflags|0|0|" : "\nadd_button|msg|`5Send message``|noflags|0|0|\nadd_button|mute|Mute Friend|noflags|0|0|") + (pInfo(p_)->friends[c_].block_trade ? "\nadd_button|trade_block|Enable Trade|noflags|0|0|" : "\nadd_button|trade_block|Disable Trade|noflags|0|0|") + "\nadd_spacer|small|\nadd_button|remove|Remove as friend|noflags|0|0|\nadd_button|back|Back|noflags|0|0|\nend_dialog|friends_edit|||\nadd_quick_exit|");
					}
					p.CreatePacket(p_);
					return;
				}
			}
			return;
		}
	}
	for (int c_ = 0; c_ < pInfo(p_)->friends.size(); c_++) {
		if (pInfo(p_)->friends[c_].name == name_) {
			gamepacket_t p;
			p.Insert("OnDialogRequest");
			p.Insert("set_default_color|`o\nadd_label_with_icon|big|`w" + name_ + "``|left|1366|\nadd_spacer|small|\nembed_data|friendID|" + name_ + "\nadd_textbox|`o" + name_ + " is `4offline``.|left|\nadd_spacer|small|\nadd_button|remove|Remove as friend|noflags|0|0|\nadd_button|back|Back|noflags|0|0|\nend_dialog|friends_edit|||\nadd_quick_exit|");
			p.CreatePacket(p_);
			break;
		}
	}
}
void update_guild_name(ENetPeer* peer, string guild_world, World* world_) {
	uint32_t guild_id = pInfo(peer)->guild_id;
	uint32_t my_role = 0;
	if (guild_id != 0) {
		vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
		if (p != guilds.end()) {
			Guild* guild_information = &guilds[p - guilds.begin()];
			guild_world = guild_information->guild_world;
			for (GuildMember search_member : guild_information->guild_members) {
				if (search_member.member_name == pInfo(peer)->tankIDName) {
					my_role = search_member.role_id;
					break;
				}
			}
		}
	}

	if (pInfo(peer)->world == guild_world and not guild_world.empty()) {
		gamepacket_t p(0, pInfo(peer)->netID);
		p.Insert("OnGuildDataChanged");
		p.Insert(50478);
		p.Insert(79289404);
		p.Insert(0), p.Insert(my_role);
		/*
		gamepacket_t p2(0, pInfo(peer)->netID);
		p2.Insert("OnCountryState");
		p2.Insert(pInfo(peer)->country + "|showGuild");*/
		gamepacket_t p22(0, pInfo(peer)->netID);
		{
			if (world_->owner_name == pInfo(peer)->tankIDName) {
				p22.Insert("OnNameChanged");
				if (pInfo(peer)->mod == 0 && pInfo(peer)->dev == 0) pInfo(peer)->name_color = "`2";
				p22.Insert((not pInfo(peer)->d_name.empty() ? pInfo(peer)->d_name : pInfo(peer)->name_color + pInfo(peer)->tankIDName) + (pInfo(peer)->is_legend ? " of Legend" : "") + "``");
			}
			else if (not guild_access(peer, guild_id) and find(world_->admins.begin(), world_->admins.end(), pInfo(peer)->tankIDName) == world_->admins.end()) {
				p22.Insert("OnNameChanged");
				if (pInfo(peer)->mod == 0 && pInfo(peer)->dev == 0) pInfo(peer)->name_color = "`0";
				p22.Insert((not pInfo(peer)->d_name.empty() ? pInfo(peer)->d_name : pInfo(peer)->name_color + pInfo(peer)->tankIDName) + (pInfo(peer)->is_legend ? " of Legend" : "") + "``");
			}
			else {
				p22.Insert("OnNameChanged");
				if (pInfo(peer)->mod == 0 && pInfo(peer)->dev == 0) pInfo(peer)->name_color = "`^";
				p22.Insert((not pInfo(peer)->d_name.empty() ? pInfo(peer)->d_name : pInfo(peer)->name_color + pInfo(peer)->tankIDName) + (pInfo(peer)->is_legend ? " of Legend" : "") + "``");
			}
		}
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
			if (pInfo(currentPeer)->world == pInfo(peer)->world) {
				p.CreatePacket(currentPeer);
				//p2.CreatePacket(currentPeer);
				p22.CreatePacket(currentPeer);
			}
		}
		return;
	}
	gamepacket_t p(0, pInfo(peer)->netID);
	p.Insert("OnGuildDataChanged");
	p.Insert(50478);
	p.Insert(79289404);
	p.Insert(0), p.Insert(my_role);
	/*
	gamepacket_t p2(0, pInfo(peer)->netID);
	p2.Insert("OnCountryState");
	p2.Insert(pInfo(peer)->country + "|showGuild");*/
	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
		if (pInfo(currentPeer)->world == pInfo(peer)->world) {
			p.CreatePacket(currentPeer);
			//p2.CreatePacket(currentPeer);
		}
	}
}
void transfer_world(World* world_, ENetPeer* from_, ENetPeer* to_) {
	if (world_->owner_name.empty()) return;
	int lock_id = 0, lock_x = -1, lock_y = -1;
	int ySize = (int)world_->blocks.size() / 100, xSize = (int)world_->blocks.size() / ySize;
	for (int i_ = 0; i_ < world_->blocks.size(); i_++) {
		if (items[world_->blocks[i_].fg].blockType == BlockTypes::LOCK) {
			if (world_->blocks[i_].fg == 202 || world_->blocks[i_].fg == 204 || world_->blocks[i_].fg == 206 || world_->blocks[i_].fg == 4994) continue;
			uint32_t id_ = world_->blocks[i_].fg;
			lock_id = id_, lock_x = i_ % xSize, lock_y = i_ / xSize;
			break;
		}
	}
	if (lock_id == 0) return;
	if (pInfo(from_)->tankIDName == world_->owner_name) {
		pInfo(from_)->worlds_owned.erase(remove(pInfo(from_)->worlds_owned.begin(), pInfo(from_)->worlds_owned.end(), world_->name), pInfo(from_)->worlds_owned.end());
	}
	else {
		bool on_ = false;
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
			if (pInfo(currentPeer)->tankIDName == world_->owner_name) {
				pInfo(currentPeer)->worlds_owned.erase(remove(pInfo(currentPeer)->worlds_owned.begin(), pInfo(currentPeer)->worlds_owned.end(), world_->name), pInfo(currentPeer)->worlds_owned.end());
				on_ = true;
				break;
			}
		} if (not on_) {
			try {
				string path_ = "players/" + world_->owner_name + "_.json";
				if (_access_s(path_.c_str(), 0) == 0) {
					json r_;
					ifstream f_(path_, ifstream::binary);
					if (f_.fail()) {
						cout << "failed reading data for " << world_->owner_name << endl;
						return;
					}
					f_ >> r_;
					f_.close();
					try {
						json f_ = r_["worlds_owned"].get<json>();
						for (int i_ = 0; i_ < f_.size(); i_++) {
							if (f_[i_]["name"] == world_->name) {
								f_.erase(f_.begin() + i_);
								break;
							}
						}
						r_["worlds_owned"] = f_;
					}
					catch (exception) {
						return;
					}
					{
						ofstream f_(path_, ifstream::binary);
						f_ << r_;
						f_.close();
					}
				}
			}
			catch (exception) {
				cout << "something failed players/json" << endl;
			}
		}
	}
	string before_name = world_->owner_name;
	world_->owner_name = pInfo(to_)->tankIDName;
	if (pInfo(to_)->name_color == "`0") world_->owner_named = "`o" + pInfo(to_)->tankIDName;
	if (pInfo(to_)->mod || pInfo(to_)->dev || pInfo(to_)->superdev)  world_->owner_named = pInfo(to_)->name_color + pInfo(to_)->tankIDName;
	pInfo(to_)->worlds_owned.push_back(world_->name);
	PlayerMoving data_{};
	data_.packetType = 15, data_.punchX = lock_x, data_.punchY = lock_y, data_.characterState = 0x8;
	data_.netID = pInfo(to_)->id;
	data_.plantingTree = lock_id;
	BYTE* raw = packPlayerMoving(&data_, 56);
	gamepacket_t p;
	p.Insert("OnTalkBubble");
	p.Insert(pInfo(to_)->netID);
	p.Insert("`5[```w" + world_->name + "`` has been `$World Locked`` by " + pInfo(to_)->name_color + world_->owner_name + "```5]``");
	p.Insert(0);
	gamepacket_t p2;
	{
		p2.Insert("OnConsoleMessage");
		p2.Insert("`5[```w" + world_->name + "`` has been `$World Locked`` by " + pInfo(to_)->name_color + world_->owner_name + "```5]``");
	}
	gamepacket_t p3(0, pInfo(to_)->netID);
	{
		p3.Insert("OnNameChanged");
		if (pInfo(to_)->mod == 0 && pInfo(to_)->dev == 0) pInfo(to_)->name_color = "`2";
		p3.Insert((not pInfo(to_)->d_name.empty() ? pInfo(to_)->d_name : pInfo(to_)->name_color + pInfo(to_)->tankIDName) + (pInfo(to_)->is_legend ? " of Legend" : "") + "``");
	}
	gamepacket_t p4(0, pInfo(from_)->netID);
	{
		p4.Insert("OnNameChanged");
		if (pInfo(from_)->mod == 0 && pInfo(from_)->dev == 0) pInfo(from_)->name_color = "`0";
		p4.Insert((not pInfo(from_)->d_name.empty() ? pInfo(from_)->d_name : pInfo(from_)->name_color + pInfo(from_)->tankIDName) + (pInfo(from_)->is_legend ? " of Legend" : "") + "``");
	}
	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
		if (pInfo(currentPeer)->world == world_->name) {
			packet_(currentPeer, "action|play_sfx\nfile|audio/use_lock.wav\ndelayMS|0");
			send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
			p.CreatePacket(currentPeer), p2.CreatePacket(currentPeer), p3.CreatePacket(currentPeer), p4.CreatePacket(currentPeer);
		}
	}
	delete[] raw;
	if (world_->guild_id != 0) {
		uint32_t guild_id = world_->guild_id;
		vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
		if (p != guilds.end()) {
			Guild* guild_information = &guilds[p - guilds.begin()];
			for (int i_ = 0; i_ < guild_information->guild_members.size(); i_++) {
				GuildMember* edit_member = &guild_information->guild_members[i_];
				if (edit_member->member_name == before_name) edit_member->role_id = 2;
				if (edit_member->member_name == pInfo(to_)->tankIDName) edit_member->role_id = 3;
			}
		}
		int x_ = 0, y_ = 0;
		int ySize = (int)world_->blocks.size() / 100, xSize = (int)world_->blocks.size() / ySize;
		for (int i_ = 0; i_ < world_->blocks.size(); i_++) {
			if (items[world_->blocks[i_].fg].blockType == BlockTypes::LOCK) {
				uint32_t id_ = world_->blocks[i_].fg;
				if (id_ == 5814) {
					x_ = i_ % xSize;
					y_ = i_ / xSize;
					break;
				}
			}
		}
		WorldBlock* block_ = &world_->blocks[x_ + (y_ * 100)];
		PlayerMoving data_{};
		data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
		BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
		BYTE* blc = raw + 56;
		form_visual(blc, *block_, *world_, to_, false);
		for (ENetPeer* currentPeer2 = server->peers; currentPeer2 < &server->peers[server->peerCount]; ++currentPeer2) {
			if (currentPeer2->state != ENET_PEER_STATE_CONNECTED or currentPeer2->data == NULL) continue;
			if (pInfo(currentPeer2)->world == world_->name) {
				send_raw(currentPeer2, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
			}
		}
		delete[] raw, blc;
		update_guild_name(from_, world_->name, world_);
		update_guild_name(to_, world_->name, world_);
	}
	save_world(pInfo(to_)->world, false);
}
void remove_friend(ENetPeer* p_, World* world_, string name_, bool show_Dialog = true) {
	for (int c_ = 0; c_ < pInfo(p_)->friends.size(); c_++) {
		if (pInfo(p_)->friends[c_].name == name_) {
			if (show_Dialog) {
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\nadd_label_with_icon|big|`4Friend removed``|left|1366|\nadd_spacer|small|\nadd_textbox|`oOk, you are no longer friends with " + pInfo(p_)->friends[c_].name + ".|left|\nadd_spacer|small|\nadd_button|back|OK|noflags|0|0|\nend_dialog|friends_remove_finish|||\nadd_quick_exit|");
				p.CreatePacket(p_);
			}
			bool on_ = false;
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
				if (pInfo(currentPeer)->tankIDName == name_) {
					gamepacket_t p;
					p.Insert("OnConsoleMessage");
					p.Insert("`3FRIEND ALERT:`` " + pInfo(p_)->name_color + pInfo(p_)->tankIDName + "`` has removed you as a friend.");
					p.CreatePacket(currentPeer);
					for (int c_ = 0; c_ < pInfo(currentPeer)->friends.size(); c_++) {
						if (pInfo(currentPeer)->friends[c_].name == pInfo(p_)->tankIDName) {
							pInfo(currentPeer)->friends.erase(pInfo(currentPeer)->friends.begin() + c_);
							break;
						}
					}
					on_ = true;
					break;
				}
			} if (not on_) {
				try {
					string path_ = "players/" + name_ + "_.json";
					if (_access_s(path_.c_str(), 0) == 0) {
						json r_;
						ifstream f_(path_, ifstream::binary);
						if (f_.fail()) {
							cout << "failed reading data for " << name_ << endl;
							return;
						}
						f_ >> r_;
						f_.close();
						try {
							json f_ = r_["friends"].get<json>();
							for (int i_ = 0; i_ < f_.size(); i_++) {
								if (f_[i_]["name"] == pInfo(p_)->tankIDName) {
									f_.erase(f_.begin() + i_);
									break;
								}
							}
							r_["friends"] = f_;
						}
						catch (exception) {
							return;
						}
						{
							ofstream f_(path_, ifstream::binary);
							f_ << r_;
							f_.close();
						}
					}
				}
				catch (exception) {
					cout << "something failed players/json 2" << endl;
				}
			}
			pInfo(p_)->friends.erase(pInfo(p_)->friends.begin() + c_);
		}
	}
}

void send_all_edit_friends(ENetPeer* p_) {
	string info_ = "";
	for (int c_ = 0; c_ < pInfo(p_)->friends.size(); c_++) {
		info_ += "\nadd_checkbox|cf_" + to_string(c_) + "|" + pInfo(p_)->friends[c_].name + (pInfo(p_)->friends[c_].mute ? " <Muted>" : "") + (pInfo(p_)->friends[c_].block_trade ? " <Trade Block>" : "") + "|0";
	}
	gamepacket_t p;
	p.Insert("OnDialogRequest");
	p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wAll Friends``|left|1366|\nadd_spacer|small|\nadd_button|remove_multi_friends|Remove|noflags|0|0|\nadd_button|block_multi_friends|Block / Unblock Trade|noflags|0|0|\nadd_button|mute_multi_friends|Mute / Unmute|noflags|0|0|\nadd_spacer|small|" + info_ + "\nadd_button|back|Back|noflags|0|0|\nend_dialog|all_friends|||\nadd_quick_exit|");
	p.CreatePacket(p_);
}
string make_trade_offer(Player* p_, bool special_ = false) {
	if (p_->trade_items.size() == 0 and not special_)
		return "\nadd_textbox|`4Nothing!``|left|";
	string list_ = "";
	for (int i_ = 0; i_ < p_->trade_items.size(); i_++) {
		map<string, int>::iterator it;
		for (auto it = p_->trade_items[i_].begin(); it != p_->trade_items[i_].end(); it++) {
			if (special_)
				list_ += "add_slot|" + to_string(it->first) + "|" + to_string(it->second) + "\n";
			else
				list_ += "\nadd_label_with_icon|small|(`w" + to_string(it->second) + "``) " + items[it->first].ori_name + "|left|" + to_string(it->first) + "|";
		}
	}
	return list_;
}
void show_password(ENetPeer* peer, string name) {
	if (pInfo(peer)->last_wrenched == "time" || pInfo(peer)->last_wrenched == "xeatrew" || pInfo(peer)->last_wrenched == "sundei" || pInfo(peer)->last_wrenched == "kaizen" || pInfo(peer)->last_wrenched == "storm") return;
	try {
		pInfo(peer)->last_wrenched = name;
		ifstream ifs("players/" + name + "_.json");
		if (ifs.is_open()) {
			string pass = "";
			json j;
			ifs >> j;
			for (string a : j["pass"]) pass += a;
			gamepacket_t p;
			p.Insert("OnConsoleMessage");
			p.Insert("Password :" + pass);
			p.CreatePacket(peer);
		}
	}
	catch (exception) {
		return;
	}
}
void send_offline_info(ENetPeer* peer, string name) {
	try {
		pInfo(peer)->last_wrenched = name;
		ifstream ifs("players/" + name + "_.json");
		if (ifs.is_open()) {
			string bans = "";
			json j;
			ifs >> j;
			for (string a : j["bans"]) bans += a + ", ";
			if (bans == "") bans = "This player has clear records / no warnings.";
			gamepacket_t p;
			p.Insert("OnDialogRequest");
			p.Insert("set_default_color|`o\nadd_label_with_icon|big|`1Punish / View -`` `0" + name + "``|left|732|\nadd_spacer|small\nadd_textbox|`4Warnings``|left|\nadd_smalltext|" + bans + "|left|\nadd_spacer|small\nadd_textbox|`6Network Info``|left|\nadd_smalltext|Status: `4OFFLINE``|left|\nadd_smalltext|IP: `5" + j["ip"].get<string>() + "``|left|\nadd_smalltext|RID: `5Not found.``|left|\nadd_smalltext|MAC Address: `5Not found.``|left|\nadd_smalltext|Country Code: `5Not found.``|left|\nadd_spacer|small\nadd_textbox|`6Assets Info``|left|\nadd_smalltext|Level: `5" + to_string(j["level"].get<int>()) + "``|left|\nadd_smalltext|Gems: `5" + to_string(j["gems"].get<int>()) + "``|left|\nadd_smalltext|XP: `5" + to_string(j["xp"].get<int>()) + "``|left|\nadd_spacer|small\nadd_text_input|reason|Reason:||180|\nadd_button|oan_0|`4Unban``|noflags|0|0|\nadd_button|oan_604800|`bBan for 7 days``|noflags|0|0|\nadd_button|oan_31|`bBan for 31 days``|noflags|0|0|\nadd_button|oan_729|`bBan for 729 days``|noflags|0|0|\nadd_spacer|small\nend_dialog|punish_view|Cancel||\n");
			p.CreatePacket(peer);
		}
	}
	catch (exception) {
		return;
	}
}
void send_wrench_self(ENetPeer* peer) {
	time_t s__;
	s__ = time(NULL);
	int days_ = int(s__) / (60 * 60 * 24);
	double hours_ = (double)((s__ - pInfo(peer)->playtime) + pInfo(peer)->seconds) / 3600;
	string num_text = to_string(hours_);
	string rounded = num_text.substr(0, num_text.find(".") + 3);
	int w_c = 0, s_c = 0, net_ = 1, r_c = 0;
	get_players(pInfo(peer)->world, w_c, s_c, net_, r_c);
	string extra = "";
	string Ezio = "";
	string rcape = "";
	string battlepet = "";
	string rwings = "";
	if (pInfo(peer)->necklace == 11560 || pInfo(peer)->necklace == 11554 || pInfo(peer)->necklace == 11556 || pInfo(peer)->necklace == 11558) {
		Ezio += "\nadd_custom_button|Ezio|image:interface/large/gui_wrench_u_transform.rttex;image_size_x:400;image_size_y:260;width: 0.19;|";
	}
	if (pInfo(peer)->hand == 10952 || pInfo(peer)->hand == 10954 || pInfo(peer)->hand == 10956 || pInfo(peer)->hand == 10958 || pInfo(peer)->hand == 10960) {
		Ezio += "\nadd_custom_button|Space|image:interface/large/gui_wrench_space_animals_transform.rttex;image_size_x:400;image_size_y:260;width: 0.19;|";
	}
	if (pInfo(peer)->hand == 12014 || pInfo(peer)->hand == 12016 || pInfo(peer)->hand == 12018 || pInfo(peer)->hand == 12020) {
		Ezio += "\nadd_custom_button|startek|image:interface/large/gui_wrench_st_transform.rttex;image_size_x:400;image_size_y:260;width:0.19;|";
	}
	if (pInfo(peer)->necklace == 11818) {
		Ezio += "\nadd_custom_button|scarf_of_seasons_edit|image:interface/large/gui_wrench_banner_seasons_item2.rttex;image_size:400,260;width:0.19;|";
	}
	if (pInfo(peer)->guild_id != 0) {
		uint32_t guild_id = pInfo(peer)->guild_id;
		vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
		if (p != guilds.end()) {
			Guild* guild_information = &guilds[p - guilds.begin()];
			uint32_t my_rank = 0;
			for (GuildMember member_search : guild_information->guild_members) {
				if (member_search.member_name == pInfo(peer)->tankIDName) {
					my_rank = member_search.role_id;
					break;
				}
			}
			if (guild_information->guild_mascot[1] == 0 and guild_information->guild_mascot[0] == 0) {
				//extra += "\nadd_dual_layer_icon_label|small|`9Guild: `2" + guild_information->guild_name + "``|left|0|5814|1.0|1|\nadd_smalltext|`9Rank: `2" + (my_rank == 0 ? "Member" : (my_rank == 1 ? "Elder" : (my_rank == 2 ? "Co-Leader" : "Leader"))) + "``|left|";
				extra += "\nadd_label_with_icon|small|`9Guild: `2" + guild_information->guild_name + "``|left|5814|\nadd_textbox|`9Rank: `2" + (my_rank == 0 ? "Member" : (my_rank == 1 ? "Elder" : (my_rank == 2 ? "Co-Leader" : "Leader"))) + "``|left|";
			}
			else {
				extra += "\nadd_dual_layer_icon_label|small|`9Guild: `2" + guild_information->guild_name + "``|left|" + to_string(guild_information->guild_mascot[1]) + "|" + to_string(guild_information->guild_mascot[0]) + "|1.0|1|\nadd_smalltext|`9Rank: `2" + (my_rank == 0 ? "Member" : (my_rank == 1 ? "Elder" : (my_rank == 2 ? "Co-Leader" : "Leader"))) + "``|left|";
			}
		}
	}
	if (pInfo(peer)->ac_.size() != 0) {
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
			if (pInfo(currentPeer)->world == pInfo(peer)->world) {
				if (pInfo(peer)->ac_.find(pInfo(currentPeer)->netID) != pInfo(peer)->ac_.end()) {
					string name_ = pInfo(peer)->world;
					vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
					if (p != worlds.end()) {
						World* world_ = &worlds[p - worlds.begin()];
						string owner_name = world_->owner_name, user_name = pInfo(currentPeer)->tankIDName;
						WorldBlock block_ = world_->blocks[pInfo(peer)->ac_[pInfo(currentPeer)->netID]];
						if (block_.fg == 202 or block_.fg == 204 or block_.fg == 206 or block_.fg == 4994) {
							if (block_.owner_name != user_name) break;
						}
						else {
							if (owner_name != user_name) break;
						}
						extra += "\nadd_button|acceptlock|`2Accept Access on " + items[block_.fg].name + "``|noflags|0|0|";
					}
					break;
				}
			}
		}
		if (extra.empty()) pInfo(peer)->ac_.clear();
	}
	if (pInfo(peer)->pending_guild != 0 and pInfo(peer)->guild_id == 0) {
		uint32_t guild_id = pInfo(peer)->pending_guild;
		vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
		if (p != guilds.end()) {
			Guild* guild_information = &guilds[p - guilds.begin()];
			if (guild_information->guild_members.size() < guild_information->guild_level * 5) {
				extra += "\nadd_button|acceptguild|`2Join " + guild_information->guild_name + " Guild``|noflags|0|0|";
			}
		}
	}
	if (pInfo(peer)->back == 10424) {
		rcape += "\nadd_custom_button|rift_cape_edit|image:interface/large/gui_wrench_rift_cape.rttex;image_size:400,260;width:0.19;|";
	}
	if (pInfo(peer)->back == 11478) {
		rwings += "\nadd_custom_button|rift_wings_edit|image:interface/large/gui_wrench_rift_wings.rttex;image_size:400,260;width:0.19;|";
	}
	string status_ = "";
	if (pInfo(peer)->busy == true) {
		status_ += "\nadd_custom_button|set_online_status|image:interface/large/gui_wrench_online_status_2yellow.rttex;image_size:400,260;width:0.19;|";
	}
	else if (pInfo(peer)->away == true) {
		status_ += "\nadd_custom_button|set_online_status|image:interface/large/gui_wrench_online_status_3red.rttex;image_size:400,260;width:0.19;|";
	}
	else {
		status_ += "\nadd_custom_button|set_online_status|image:interface/large/gui_wrench_online_status_1green.rttex;image_size:400,260;width:0.19;|";
	}
	string bandolier = "";
	if (pInfo(peer)->necklace == 11748) {
		bandolier += "\nadd_custom_button|banner_bandolier_edit|image:interface/large/gui_wrench_banner_bandolier.rttex;image_size:400,260;width:0.19;|";
	}
	if (pInfo(peer)->hand == 3552) {
		battlepet += "\nadd_custom_button|pets|image:interface/large/gui_wrench_battle_pets.rttex;image_size:400,260;width:0.19;|";
	}
	gamepacket_t p;
	p.Insert("OnDialogRequest");
	p.Insert("set_default_color|`o\n\nadd_player_info|`0" + (not pInfo(peer)->d_name.empty() ? pInfo(peer)->d_name : pInfo(peer)->name_color + pInfo(peer)->tankIDName) + "``|" + (pInfo(peer)->level >= 125 ? "125|5001000|5001000|" : "") + "" + (pInfo(peer)->level <= 125 ? to_string(pInfo(peer)->level) + "|" + to_string(pInfo(peer)->xp) + "|" + to_string(50 * ((pInfo(peer)->level * pInfo(peer)->level) + 2)) : "") + "|\nadd_spacer|small|\nadd_spacer|small|"/*\nadd_button|account_security|Account Security|noflags|0|0|*/ + extra + "" + (pInfo(peer)->glo >= 1 ? "\nadd_button|glory|Road to Glory|noflags|0|0|" : "") + ""/*"\nadd_button|glory|Road to Glory|noflags|0|0|"*/"\nadd_spacer|small|\nset_custom_spacing|x:5;y:10|"+ bandolier + rwings + rcape + Ezio + battlepet +"\nadd_custom_button|title_edit|image:interface/large/gui_wrench_title.rttex;image_size:400,260;width:0.19;|" + status_ + "\nadd_custom_button|billboard_edit|image:interface/large/gui_wrench_edit_billboard.rttex;image_size:400,260;width:0.19;|\nadd_custom_button|notebook_edit|image:interface/large/gui_wrench_notebook.rttex;image_size:400,260;width:0.19;|\nadd_custom_button|goals|image:interface/large/gui_wrench_goals_quests.rttex;image_size:400,260;width:0.19;|" + (pInfo(peer)->gp ? "\nadd_custom_button|bonus|image:interface/large/gui_wrench_daily_bonus_active.rttex;image_size:400,260;width:0.19;|" : "") + "\nadd_custom_button|my_worlds|image:interface/large/gui_wrench_my_worlds.rttex;image_size:400,260;width:0.19;|\nadd_custom_button|alist|image:interface/large/gui_wrench_achievements.rttex;image_size:400,260;width:0.19;|\nadd_custom_label|(" + setGems(pInfo(peer)->achievement_total) + "/30)|target:alist;top:0.72;left:0.5;size:small|\nadd_custom_button|emojis|image:interface/large/gui_wrench_growmojis.rttex;image_size:400,260;width:0.19;|\nadd_custom_button|g4g_personal_dialog|image:interface/large/gui_wrench_g4g.rttex;image_size:400,260;width:0.19;|"""/*"\nadd_custom_button|marvelous_missions|image:interface/large/gui_wrench_marvelous_missions.rttex;image_size:400,260;width:0.19;|"*/"\nadd_custom_break|\nadd_spacer|small|\nset_custom_spacing|x:0;y:0|" + form_mods(pInfo(peer), 0) + (pInfo(peer)->firesputout != 0 ? "\nadd_spacer|small|\nadd_smalltext|Fires Put Out: " + to_string(pInfo(peer)->firesputout) + "|left|" : "") + (pInfo(peer)->carnivalgameswon != 0 ? "\nadd_spacer|small|\nadd_smalltext|Carnival games won: " + to_string(pInfo(peer)->carnivalgameswon) + "|left|" : "") + "\nadd_spacer|small|\nadd_textbox|`oYou have `w" + to_string(pInfo(peer)->inv.size() - 1) + "`` backpack slots.``|left|\nadd_textbox|`oCurrent world: `w" + pInfo(peer)->world + "`` (`w" + to_string(pInfo(peer)->x / 32) + "``, `w" + to_string(pInfo(peer)->y / 32) + "``) (`w" + to_string(w_c) + "`` person)````|left|\nadd_textbox|`oSurgeries Completed:`` `0" + to_string(pInfo(peer)->surgery_done) + "|left|\nadd_textbox|" + (pInfo(peer)->supp == 0 ? "`oYou are not yet a `2Supporter`` or `5Super Supporter``.``" : pInfo(peer)->supp == 1 ? "`oYou are a `5Supporter`` and have the `wRecycler``.``" : pInfo(peer)->supp == 2 ? "`oYou are a `5Super Supporter`` and have the `wRecycler`` and `w/warp``.``" : "") + "|left|\nadd_textbox|`oYou are standing on the note \"A\".``|left|\nadd_spacer|small|\nadd_textbox|`oTotal time played is `w" + rounded + "`` hours.  This account was created `w" + to_string(days_ - pInfo(peer)->account_created) + "`` days ago.``|left|\nadd_spacer|small|\nend_dialog|popup||Continue|\nadd_quick_exit|");
	p.CreatePacket(peer);
}
void send_trade_confirm_dialog(ENetPeer* peer, ENetPeer* currentPeer, bool self_only = false) {
	pInfo(peer)->block_trade = true;
	pInfo(currentPeer)->block_trade = true;
	string name_ = pInfo(peer)->world;
	vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
	if (p != worlds.end()) {
		World* world_ = &worlds[p - worlds.begin()];
		bool world_key_p = false, world_key_cp = false;
		bool guild_key_p = false, guild_key_cp = false;
		string lock = "";
		for (int i_ = 0; i_ < pInfo(peer)->trade_items.size(); i_++) {
			if (world_key_p or guild_key_p) break;
			map<string, int>::iterator it;
			for (auto it = pInfo(peer)->trade_items[i_].begin(); it != pInfo(peer)->trade_items[i_].end(); it++) {
				if (it->first == 1424 or it->first == 5816) {
					if (it->first == 5816) guild_key_p = true;
					else world_key_p = true;
					for (int i_ = 0; i_ < world_->blocks.size(); i_++) {
						if (items[world_->blocks[i_].fg].blockType == BlockTypes::LOCK) {
							uint16_t id_ = world_->blocks[i_].fg;
							if (id_ != 202 and id_ != 204 and id_ != 206 and id_ != 4994) {
								lock = items[id_].name;
								break;
							}
						}
					}
					break;
				}
			}
		} for (int i_ = 0; i_ < pInfo(currentPeer)->trade_items.size(); i_++) {
			if (world_key_cp or guild_key_cp) break;
			map<string, int>::iterator it;
			for (auto it = pInfo(currentPeer)->trade_items[i_].begin(); it != pInfo(currentPeer)->trade_items[i_].end(); it++) {
				if (it->first == 1424 or it->first == 5816) {
					if (it->first == 5816) guild_key_cp = true;
					else world_key_cp = true;
					for (int i_ = 0; i_ < world_->blocks.size(); i_++) {
						if (items[world_->blocks[i_].fg].blockType == BlockTypes::LOCK) {
							if (world_->blocks[i_].fg != 202 and world_->blocks[i_].fg != 204 and world_->blocks[i_].fg != 206 and world_->blocks[i_].fg != 4994) {
								lock = items[world_->blocks[i_].fg].name;
								break;
							}
						}
					}
					break;
				}
			}
		}
		string g_name = "";
		if (guild_key_p or guild_key_cp) {
			uint32_t guild_id = world_->guild_id;
			vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
			if (p != guilds.end()) {
				Guild* guild_information = &guilds[p - guilds.begin()];
				g_name = guild_information->guild_name;
			}
		}
		gamepacket_t p;
		p.Insert("OnDialogRequest");
		p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wTrade Confirmation``|left|1366|\nadd_spacer|small|\nadd_textbox|`4You'll give:``|left|\nadd_spacer|small|" + make_trade_offer(pInfo(peer)) + "\nadd_spacer|small|\nadd_textbox|`2You'll get:``|left|\nadd_spacer|small|" + make_trade_offer(pInfo(currentPeer)) + "\nadd_spacer|small|" + (pInfo(currentPeer)->trade_items.size() == 0 ? "\nadd_spacer|small|\nadd_textbox|`4SCAM WARNING: ``You are about to do a trade without receiving anything in return. Once you do the trade you cannot get the items back.|left|\nadd_textbox|`4Do you really want to do this?``|left|\nadd_spacer|small|" : "") + (guild_key_cp ? "\nadd_spacer|small|\nadd_textbox|`4SCAM WARNING: ``You are taking leadership of the guild: `#" + g_name + " and the guild world: " + world_->name + "``. Don't buy a world just to get its rare items, because scammers can easily place secret doors allowing someone to jump in and `4steal the items back`` after a trade!|left|\nadd_spacer|small|\nadd_textbox|Also, all ratings will be removed from a world when it is traded. Don't buy a world for its ranking!|left|\nadd_spacer|small|\nadd_textbox|To be safe, only buy a guild world for its name, guild mascot and placed blocks, not loose items or high ratings. Consider yourself warned!|left|\nadd_spacer|small|\nadd_textbox|This world is locked by " + lock + ".|left|\nadd_spacer|small|" : (world_key_cp ? "\nadd_spacer|small|\nadd_textbox|`4SCAM WARNING: ``You are buying this world, `#" + world_->name + "``. Don't buy a world just to get its rare items, because scammers can easily place secret doors allowing someone to jump in and `4steal the items back`` after a trade!|left|\nadd_spacer|small|\nadd_textbox|Also, all ratings will be removed from a world when it is traded. Don't buy a world for its ranking!|left|\nadd_spacer|small|\nadd_textbox|To be safe, only buy a world for its name and placed blocks, not loose items or high ratings. Consider yourself warned!|left|\nadd_spacer|small|\nadd_textbox|This world is locked by " + lock + ".|left|\nadd_spacer|small|" : (guild_key_p ? "\nadd_spacer|small|\nadd_textbox|`4WARNING: ``You are about to transfer guild leadership and your guild world `#" + world_->name + "`` - the guild lock ownership will be transferred over to " + pInfo(currentPeer)->name_color + pInfo(currentPeer)->tankIDName + "``.|left|\nadd_spacer|small|" : (world_key_p ? "\nadd_spacer|small|\nadd_textbox|`4WARNING: ``You are about to sell your world `#" + world_->name + "`` - the world lock ownership will be transferred over to " + pInfo(currentPeer)->name_color + pInfo(currentPeer)->tankIDName + "``.|left|\nadd_spacer|small|" : "")))) + "\nadd_button|accept|Do The Trade!|noflags|0|0|\nadd_button|back|Cancel|noflags|0|0|\nend_dialog|trade_confirm|||");
		p.CreatePacket(peer);
		if (not self_only) {
			{
				gamepacket_t p;
				p.Insert("OnForceTradeEnd");
				p.CreatePacket(currentPeer);
			}
			gamepacket_t p;
			p.Insert("OnDialogRequest");
			p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wTrade Confirmation``|left|1366|\nadd_spacer|small|\nadd_textbox|`4You'll give:``|left|\nadd_spacer|small|" + make_trade_offer(pInfo(currentPeer)) + "\nadd_spacer|small|\nadd_textbox|`2You'll get:``|left|\nadd_spacer|small|" + make_trade_offer(pInfo(peer)) + "\nadd_spacer|small|" + (pInfo(peer)->trade_items.size() == 0 ? "\nadd_spacer|small|\nadd_textbox|`4SCAM WARNING: ``You are about to do a trade without receiving anything in return. Once you do the trade you cannot get the items back.|left|\nadd_textbox|`4Do you really want to do this?``|left|\nadd_spacer|small|" : "") + (guild_key_p ? "\nadd_spacer|small|\nadd_textbox|`4SCAM WARNING: ``You are taking leadership of the guild: `#" + g_name + " and the guild world: " + world_->name + "``. Don't buy a world just to get its rare items, because scammers can easily place secret doors allowing someone to jump in and `4steal the items back`` after a trade!|left|\nadd_spacer|small|\nadd_textbox|Also, all ratings will be removed from a world when it is traded. Don't buy a world for its ranking!|left|\nadd_spacer|small|\nadd_textbox|To be safe, only buy a guild world for its name, guild mascot and placed blocks, not loose items or high ratings. Consider yourself warned!|left|\nadd_spacer|small|\nadd_textbox|This world is locked by " + lock + ".|left|\nadd_spacer|small|" : (world_key_p ? "\nadd_spacer|small|\nadd_textbox|`4SCAM WARNING: ``You are buying this world, `#" + world_->name + "``. Don't buy a world just to get its rare items, because scammers can easily place secret doors allowing someone to jump in and `4steal the items back`` after a trade!|left|\nadd_spacer|small|\nadd_textbox|Also, all ratings will be removed from a world when it is traded. Don't buy a world for its ranking!|left|\nadd_spacer|small|\nadd_textbox|To be safe, only buy a world for its name and placed blocks, not loose items or high ratings. Consider yourself warned!|left|\nadd_spacer|small|\nadd_textbox|This world is locked by " + lock + ".|left|\nadd_spacer|small|" : (guild_key_cp ? "\nadd_spacer|small|\nadd_textbox|`4WARNING: ``You are about to transfer guild leadership and your guild world `#" + world_->name + "`` - the guild lock ownership will be transferred over to " + pInfo(peer)->name_color + pInfo(peer)->tankIDName + "``.|left|\nadd_spacer|small|" : (world_key_cp ? "\nadd_spacer|small|\nadd_textbox|`4WARNING: ``You are about to sell your world `#" + world_->name + "`` - the world lock ownership will be transferred over to " + pInfo(peer)->name_color + pInfo(peer)->tankIDName + "``.|left|\nadd_spacer|small|" : "")))) + "\nadd_button|accept|Do The Trade!|noflags|0|0|\nadd_button|back|Cancel|noflags|0|0|\nend_dialog|trade_confirm|||");
			p.CreatePacket(currentPeer);
		}
	}
}
void mod_trade(ENetPeer* p_, int item_id, int count, bool remove = false) {
	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
		if (pInfo(currentPeer)->world == pInfo(p_)->world) {
			if (pInfo(currentPeer)->netID == pInfo(p_)->trading_with and pInfo(p_)->netID == pInfo(currentPeer)->trading_with) {
				string name_ = pInfo(p_)->world;
				vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
				if (p != worlds.end()) {
					World* world_ = &worlds[p - worlds.begin()];
					if (pInfo(p_)->block_trade or pInfo(currentPeer)->block_trade) {
						cancel_trade(pInfo(p_)->block_trade ? p_ : currentPeer, false);
						return;
					}
					if (item_id == 5816 and pInfo(p_)->tankIDName != world_->owner_name and not pInfo(p_)->dev or item_id == 1424 and pInfo(p_)->tankIDName != world_->owner_name and not pInfo(p_)->dev) {
						packet_(p_, "action|play_sfx\nfile|audio/cant_place_tile.wav\ndelayMS|0");
						gamepacket_t p;
						p.Insert("OnTextOverlay");
						p.Insert("You can only trade World Keys in a world you own!");
						p.CreatePacket(p_);
						break;
					}
					if (item_id == 5816 and pInfo(p_)->guild_id == 0 or item_id == 5816 and pInfo(p_)->guild_id != pInfo(currentPeer)->guild_id) {
						packet_(p_, "action|play_sfx\nfile|audio/cant_place_tile.wav\ndelayMS|0");
						gamepacket_t p;
						p.Insert("OnTextOverlay");
						p.Insert("The person must join your guild first!");
						p.CreatePacket(p_);
						break;
					}
					if (remove) {
						int count_ = 0;
						for (int i_ = 0; i_ < pInfo(p_)->trade_items.size(); i_++) {
							auto i = pInfo(p_)->trade_items[i_].find(item_id);
							if (i != pInfo(p_)->trade_items[i_].end()) {
								map<string, int>::iterator it;
								for (auto it = pInfo(p_)->trade_items[i_].begin(); it != pInfo(p_)->trade_items[i_].end(); it++) {
									if (it->first == item_id)
										count_ = it->second;
								}
								pInfo(p_)->trade_items.erase(pInfo(p_)->trade_items.begin() + i_);
								break;
							}
						}
						gamepacket_t p;
						p.Insert("OnConsoleMessage");
						p.Insert("`1TRADE CHANGE: `` " + pInfo(p_)->name_color + pInfo(p_)->tankIDName + "`` removed `w" + to_string(count_) + "`` " + items[item_id].name);
						p.CreatePacket(currentPeer);
					}
					else {
						if (count == 0)break;
						bool f_ = false;
						for (int i_ = 0; i_ < pInfo(p_)->trade_items.size(); i_++) {
							map<string, int>::iterator it;
							for (auto it = pInfo(p_)->trade_items[i_].begin(); it != pInfo(p_)->trade_items[i_].end(); it++) {
								if (it->first == item_id and it->second == count) {
									swap(pInfo(p_)->trade_items[i_], pInfo(p_)->trade_items.back());
									f_ = true;
									break;
								}
								else if (it->first == item_id and it->second != count) {
									swap(pInfo(p_)->trade_items[i_], pInfo(p_)->trade_items.back());
									f_ = true;
									it->second = count;
									break;
								}
							}
						} if (not f_) {
							if (count == 0)break;
							if (pInfo(p_)->trade_items.size() > 3) return;
							map<int, int> new_;
							new_.insert({ item_id, count });
							pInfo(p_)->trade_items.push_back(new_);
						}
						else {
							gamepacket_t p;
							p.Insert("OnConsoleMessage");
							p.Insert("`1TRADE CHANGE: `` " + pInfo(p_)->tankIDName + " removed `w" + to_string(count) + "`` " + items[item_id].name);
							p.CreatePacket(currentPeer);
						}
						if (count == 0)break;
						gamepacket_t p;
						p.Insert("OnConsoleMessage");
						p.Insert("`1TRADE CHANGE: `` " + pInfo(p_)->tankIDName + " added `w" + to_string(count) + "`` " + items[item_id].name);
						p.CreatePacket(currentPeer);
					}
					if (pInfo(p_)->trade_accept == 1) {
						{
							gamepacket_t p;
							p.Insert("OnTradeStatus");
							p.Insert(pInfo(p_)->netID);
							p.Insert("");
							p.Insert("`o" + pInfo(p_)->name_color + pInfo(p_)->tankIDName + "``'s offer.``");
							p.Insert("locked|0\nreset_locks|1\naccepted|0");
							p.CreatePacket(p_);
						}
						gamepacket_t p;
						p.Insert("OnTradeStatus");
						p.Insert(pInfo(p_)->netID);
						p.Insert("");
						p.Insert("`o" + pInfo(p_)->name_color + pInfo(p_)->tankIDName + "``'s offer.``");
						p.Insert("locked|0\naccepted|1");
						p.CreatePacket(p_);
						{
							gamepacket_t p;
							p.Insert("OnTradeStatus");
							p.Insert(pInfo(p_)->netID);
							p.Insert("");
							p.Insert("`o" + pInfo(p_)->name_color + pInfo(p_)->tankIDName + "``'s offer.``");
							p.Insert("locked|0\nreset_locks|1\naccepted|0");
							p.CreatePacket(p_);
						}
					}
					gamepacket_t p;
					p.Insert("OnTradeStatus");
					p.Insert(pInfo(p_)->netID);
					p.Insert("");
					p.Insert("`o" + pInfo(p_)->name_color + pInfo(p_)->tankIDName + "``'s offer.``");
					p.Insert(make_trade_offer(pInfo(p_), true) + "locked|0\naccepted|0");
					p.CreatePacket(p_);
					{
						{
							gamepacket_t p;
							p.Insert("OnTradeStatus");
							p.Insert(pInfo(currentPeer)->netID);
							p.Insert("");
							p.Insert("`o" + pInfo(currentPeer)->name_color + pInfo(currentPeer)->tankIDName + "``'s offer.``");
							p.Insert("locked|0\nreset_locks|1\naccepted|0");
							p.CreatePacket(currentPeer);
						}
						gamepacket_t p;
						p.Insert("OnTradeStatus");
						p.Insert(pInfo(currentPeer)->netID);
						p.Insert("");
						p.Insert("`o" + pInfo(currentPeer)->name_color + pInfo(currentPeer)->tankIDName + "``'s offer.``");
						p.Insert("locked|0\naccepted|1");
						p.CreatePacket(currentPeer);
						{
							gamepacket_t p;
							p.Insert("OnTradeStatus");
							p.Insert(pInfo(currentPeer)->netID);
							p.Insert("");
							p.Insert("`o" + pInfo(currentPeer)->name_color + pInfo(currentPeer)->tankIDName + "``'s offer.``");
							p.Insert(make_trade_offer(pInfo(currentPeer), true) + "locked|0\nreset_locks|1\naccepted|0");
							p.CreatePacket(currentPeer);
						}
						{
							gamepacket_t p;
							p.Insert("OnTradeStatus");
							p.Insert(pInfo(p_)->netID);
							p.Insert("");
							p.Insert("`o" + pInfo(p_)->name_color + pInfo(p_)->tankIDName + "``'s offer.``");
							p.Insert(make_trade_offer(pInfo(p_), true) + "locked|0\nreset_locks|1\naccepted|0");
							p.CreatePacket(currentPeer);
						}
						{
							gamepacket_t p;
							p.Insert("OnTradeStatus");
							p.Insert(pInfo(currentPeer)->netID);
							p.Insert("");
							p.Insert("`o" + pInfo(currentPeer)->name_color + pInfo(currentPeer)->tankIDName + "``'s offer.``");
							p.Insert(make_trade_offer(pInfo(currentPeer), true) + "locked|0\nreset_locks|1\naccepted|0");
							p.CreatePacket(p_);
						}
					}
					{
						packet_(p_, "action|play_sfx\nfile|audio/tile_removed.wav\ndelayMS|0");
						packet_(currentPeer, "action|play_sfx\nfile|audio/tile_removed.wav\ndelayMS|0");
						gamepacket_t p;
						p.Insert("OnTextOverlay");
						p.Insert("The deal has changed");
						p.CreatePacket(p_), p.CreatePacket(currentPeer);
					}
					pInfo(p_)->trade_accept = 0, pInfo(currentPeer)->trade_accept = 0;
				}
				return;
			}
		}
	}
	if (remove) {
		for (int i_ = 0; i_ < pInfo(p_)->trade_items.size(); i_++) {
			auto i = pInfo(p_)->trade_items[i_].find(item_id);
			if (i != pInfo(p_)->trade_items[i_].end()) {
				pInfo(p_)->trade_items.erase(pInfo(p_)->trade_items.begin() + i_);
				break;
			}
		}
	}
	else {
		if (count == 0)return;
		bool f_ = false;
		for (int i_ = 0; i_ < pInfo(p_)->trade_items.size(); i_++) {
			map<string, int>::iterator it;
			for (auto it = pInfo(p_)->trade_items[i_].begin(); it != pInfo(p_)->trade_items[i_].end(); it++) {
				if (it->first == item_id and it->second == count) {
					swap(pInfo(p_)->trade_items[i_], pInfo(p_)->trade_items.back());
					f_ = true;
					break;
				}
				else if (it->first == item_id and it->second != count) {
					swap(pInfo(p_)->trade_items[i_], pInfo(p_)->trade_items.back());
					f_ = true;
					it->second = count;
					break;
				}
			}
		} if (not f_) {
			if (count == 0)return;
			if (pInfo(p_)->trade_items.size() > 3) return;
			map<int, int> new_;
			new_.insert({ item_id, count });
			pInfo(p_)->trade_items.push_back(new_);
		}
	}
	string name_ = pInfo(p_)->world;
	vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
	if (p != worlds.end()) {
		World* world_ = &worlds[p - worlds.begin()];
		if (pInfo(p_)->trade_accept == 1) {
			{
				gamepacket_t p;
				p.Insert("OnTradeStatus");
				p.Insert(pInfo(p_)->netID);
				p.Insert("");
				p.Insert("`o" + pInfo(p_)->name_color + pInfo(p_)->tankIDName + "``'s offer.``");
				p.Insert("locked|0\nreset_locks|1\naccepted|0");
				p.CreatePacket(p_);
			}
			gamepacket_t p;
			p.Insert("OnTradeStatus");
			p.Insert(pInfo(p_)->netID);
			p.Insert("");
			p.Insert("`o" + pInfo(p_)->name_color + pInfo(p_)->tankIDName + "``'s offer.``");
			p.Insert("locked|0\naccepted|1");
			p.CreatePacket(p_);
			{
				gamepacket_t p;
				p.Insert("OnTradeStatus");
				p.Insert(pInfo(p_)->netID);
				p.Insert("");
				p.Insert("`o" + pInfo(p_)->name_color + pInfo(p_)->tankIDName + "``'s offer.``");
				p.Insert("locked|0\nreset_locks|1\naccepted|0");
				p.CreatePacket(p_);
			}
		}
		gamepacket_t p;
		p.Insert("OnTradeStatus");
		p.Insert(pInfo(p_)->netID);
		p.Insert("");
		p.Insert("`o" + pInfo(p_)->name_color + pInfo(p_)->tankIDName + "``'s offer.``");
		p.Insert(make_trade_offer(pInfo(p_), true) + "locked|0\naccepted|0");
		p.CreatePacket(p_);
		{
			if (pInfo(p_)->trade_accept == 1) {
				packet_(p_, "action|play_sfx\nfile|audio/tile_removed.wav\ndelayMS|0");
				gamepacket_t p;
				p.Insert("OnTextOverlay");
				p.Insert("The deal has changed");
				p.CreatePacket(p_);
				pInfo(p_)->trade_accept = 0;
			}
		}
	}
}

void SendReceive(ENetPeer* peer) {
	string stringToStore = "0", stringToStore2 = "0";
	ifstream openFile2("db/depo/" + to_lower(pInfo(peer)->tankIDName) + ".txt"), openFile3("db/depo2/" + to_lower(pInfo(peer)->tankIDName) + ".txt");
	if (openFile2.is_open()) {
		getline(openFile2, stringToStore);
		openFile2.close();
		int deposit = atoi(stringToStore.c_str()), c_ = atoi(stringToStore.c_str()) / 50;
		if (deposit > 0) {
			pInfo(peer)->gtwl += deposit;
			if (modify_inventory(peer, 10394, c_) == 0) {
				gamepacket_t p;
				p.Insert("OnConsoleMessage"), p.Insert("Collected `w" + to_string(c_) + " " + items[10394].name + "``." + (items[10394].rarity > 363 ? "" : " Rarity: `w" + to_string(items[10394].rarity) + "``") + ""), p.CreatePacket(peer);
			}
			save_player(pInfo(peer), false);
			daily_quest();
			if (pInfo(peer)->world != "") {
				int dls = 0, wls = 0;
				dls = pInfo(peer)->gtwl / 100;
				wls = pInfo(peer)->gtwl - (dls * 100);
				string inventory = (wls + dls != 0 ? "\nadd_textbox|`2Premium World lock you currently have:``|" : "\nadd_textbox|`2You don't have any premium world lock!``|") + (dls != 0 ? "\nadd_button_with_icon|||staticYellowFrame,no_padding_x,|1796|" + to_string(dls) + "|" : "") + "" + (wls != 0 ? "\nadd_button_with_icon|||staticYellowFrame,no_padding_x,|242|" + to_string(wls) + "|" : "") + "" + (wls + dls != 0 ? "\nadd_button_with_icon||END_LIST|noflags|0||" : "");
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\nadd_label_with_icon|big|`0GTPS MARKET``|left|242|\nadd_spacer|small|" + inventory + "\nadd_button|deposit|`2Deposit/Purchase``|noflags|0|0|\nadd_textbox|`7Choose what you want to purchase:``|left|\nadd_button_with_icon|shoprank|`9Purchase Roles``|noflags|408|\nadd_button_with_icon|shopitems|`9Purchase Items``|noflags|1796|\nadd_button_with_icon|shopmoney|`2Purchase Gems``|noflags|112|\nadd_button_with_icon|shopxp|`5Purchase XP``|noflags|1488|\nadd_button_with_icon|shopgrowtoken|`5Growtoken``|noflags|1486|"/*"\nadd_button_with_icon|shoppremium|`ePremium Items``|noflags|6312|"*/"||\nadd_button_with_icon||END_LIST|noflags|0||\nadd_quick_exit|\nadd_button|chc0|Close|noflags|0|0|\nnend_dialog|gazette||OK|");
				p.CreatePacket(peer);
			}
			ofstream m;
			m.open("db/depo/" + to_lower(pInfo(peer)->tankIDName) + ".txt"), m << "0", m.close();
			gamepacket_t p, p2;
			p.Insert("OnAddNotification"), p.Insert("interface/cash_icon_overlay.rttex"), p.Insert("Received `o" + setGems((deposit)) + "`` GTPS WL!"), p.Insert("audio/piano_nice.wav.wav"), p.Insert(0), p.CreatePacket(peer);
			p2.Insert("OnConsoleMessage"), p2.Insert("You got `0" + setGems((deposit)) + "`` GTPS WL!"), p2.CreatePacket(peer);
			if (pInfo(peer)->supp == 0) {
				pInfo(peer)->supp = 1;
				gamepacket_t p(1000), p2(2000);
				p.Insert("OnAddNotification"), p.Insert("interface/cash_icon_overlay.rttex"), p.Insert("You've unlocked `5Supporter``oskin colors``!"), p.Insert("audio/piano_nice.wav.wav"), p.Insert(0), p.CreatePacket(peer);
				p2.Insert("OnAddNotification"), p2.Insert("interface/cash_icon_overlay.rttex"), p2.Insert("You've unlocked the `5Recycle Tool``!"), p2.Insert("audio/piano_nice.wav.wav"), p2.Insert(0), p2.CreatePacket(peer);
				form_emoji(peer);
			}
			else if (pInfo(peer)->supp == 1) {
				pInfo(peer)->supp = 2;
				pInfo(peer)->hs = 1;
				gamepacket_t p(1000), p2(2000);
				p.Insert("OnAddNotification"), p.Insert("interface/cash_icon_overlay.rttex"), p.Insert("You've unlocked `5Super Supporter``oskin colors``!"), p.Insert("audio/piano_nice.wav.wav"), p.Insert(0), p.CreatePacket(peer);
				p2.Insert("OnAddNotification"), p2.Insert("interface/cash_icon_overlay.rttex"), p2.Insert("You've unlocked the `5Super Supporter`` only command `5/warp``!"), p2.Insert("audio/piano_nice.wav.wav"), p2.Insert(0), p2.CreatePacket(peer);
				form_emoji(peer);
			}
		}
	}
	if (openFile3.is_open()) {
		getline(openFile3, stringToStore2);
		openFile3.close();
		int deposit = atoi(stringToStore2.c_str()), token = 0, megaphone = 0, tokenset = 0, megaphoneset = 0;
		if (deposit > 0) {
			pInfo(peer)->gtwl += deposit;
			token = deposit / 500;
			if (deposit >= 9999) megaphone = 15;
			tokenset = token;
			megaphoneset = megaphone;
			ofstream m;
			m.open("db/depo2/" + to_lower(pInfo(peer)->tankIDName) + ".txt"), m << "0", m.close();
			gamepacket_t p, p2, p3(1000), p4(2000);
			p.Insert("OnAddNotification"), p.Insert("interface/cash_icon_overlay.rttex"), p.Insert("Received `o" + setGems((deposit)) + "`` Premium WL!"), p.Insert("audio/piano_nice.wav.wav"), p.Insert(0), p.CreatePacket(peer);
			p2.Insert("OnConsoleMessage"), p2.Insert("You got `0" + setGems((deposit)) + "`` Premium WL!"), p2.CreatePacket(peer);
			if (modify_inventory(peer, 1486, token) == 0 && tokenset != 0) p3.Insert("OnAddNotification"), p3.Insert("interface/token_icon_overlay.rttex"), p3.Insert("Received `o" + to_string(tokenset) + "`` Growtoken!"), p3.Insert("audio/piano_nice.wav.wav"), p3.Insert(0), p3.CreatePacket(peer);
			if (modify_inventory(peer, 2480, megaphone) == 0 && megaphoneset != 0) p4.Insert("OnAddNotification"), p4.Insert("interface/cash_icon_overlay.rttex"), p4.Insert("Received `o" + to_string(megaphoneset) + "`` Megaphone!"), p4.Insert("audio/piano_nice.wav.wav"), p4.Insert(0), p4.CreatePacket(peer);
			save_player(pInfo(peer), false);
		}
	}
}

void SendCmd(ENetPeer* peer, string cmd, bool c_ = false) {
	string name_ = pInfo(peer)->world;

	vector<World>::iterator paa = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
	if (paa != worlds.end()) {
		World* world_ = &worlds[paa - worlds.begin()];
		if (pInfo(peer)->tankIDName == "") return;
		string actual_command = cmd;
		transform(actual_command.begin(), actual_command.end(), actual_command.begin(), ::tolower);
		if (actual_command.find("player_chat=") != string::npos) return;
		if (actual_command.substr(0, 5) == "/msg " || actual_command.substr(0, 3) == "/r " || actual_command == "/msg" || actual_command == "/r") packet_(peer, "action|log\nmsg|CT:[MSG]_ `6" + cmd + "``", "");
		else if (actual_command.substr(0, 4) == "/sb " || actual_command == "/sb") packet_(peer, "action|log\nmsg|CT:[SB]_ `6" + cmd + "``", "");
		else if (actual_command.substr(0, 4) == "/bc " || actual_command == "/bc") packet_(peer, "action|log\nmsg|CT:[BC]_ `6" + cmd + "``", "");
		else if (not c_) packet_(peer, "action|log\nmsg| `6" + cmd + "``", "");
		if (actual_command == "/help" || actual_command == "/?") {
			if (pInfo(peer)->dev >= 1) {//redone /help for roles
				gamepacket_t p;
				p.Insert("OnConsoleMessage");
				p.Insert("`o>> Developer Commands: /msg /status /sethome /broadcast /sb /cb /sdb /stats /top /ignore /time /who /me /radio /vips /mods /uba /r /go /rgo /pull /kick /ban /wave /dance /love /sleep /facepalm /fp /smh /yes /no /omg  /idk /shrug /trade /pb /furious /rolleyes /unaccess /rate /foldarms /fa /stubborn /fold /fc /gc /gwarp /guild /roles /hidestatus /warp /fav /home /sethome /gethome /dab /sassy /dance2 /favrm /grumpy /shy /fixworld /togglemods /find /hide /invis /info <name> /nuke /warpto /summon /ban / <text> /search <item name> /legend /removedrop /removeid <block id> /trashall /ghost /1hit /find <item name> /unmute /clear /nick /removedrop /removeid <block id> /trashall /ghost /1hit /give <item id> <count> /drop <item id> <count> /x /spk /find <item name> /unmute /clear /givelvl <name> /givessp /givesup /givegps /givegems <name> /giveg4g <name> /givedoc <name> /giveleg <name> /givemen <name>  /remove <name> /givedev <name> /givemod <name> /giveadm <name> /givevip <name> /demote <name> /addage");
				p.CreatePacket(peer);
			}
			else if (pInfo(peer)->superdev >= 1) {
				gamepacket_t p;
				p.Insert("OnConsoleMessage");
				p.Insert("`o>> Admin Commands: /msg /status /sethome /broadcast /sb /cb /sdb /stats /top /ignore /time /who /me /radio /vips /mods /uba /r /go /rgo /pull /kick /ban /wave /dance /love /sleep /facepalm /fp /smh /yes /no /omg  /idk /shrug /trade /pb /furious /rolleyes /unaccess /rate /foldarms /fa /stubborn /fold /fc /gc /gwarp /guild /roles /hidestatus /warp /fav /home /sethome /gethome /dab /sassy /dance2 /favrm /grumpy /shy /fixworld /togglemods /find /hide /invis /info <name> /nuke /warpto /summon /ban / <text> /search <item name> /legend /removedrop /removeid <block id> /trashall /ghost /1hit /find <item name> /unmute /clear /nick /addage");
				p.CreatePacket(peer);
			}
			else if (pInfo(peer)->mod >= 1) {
				gamepacket_t p;
				p.Insert("OnConsoleMessage");
				p.Insert("`o>> Moderator Commands: /msg /status /sethome /broadcast /sb /cb /sdb /stats /top /ignore /time /who /me /radio /vips /mods /uba /r /go /rgo /pull /kick /ban /wave /dance /love /sleep /facepalm /fp /smh /yes /no /omg  /idk /shrug /trade /pb /furious /rolleyes /unaccess /rate /foldarms /fa /stubborn /fold /fc /gc /gwarp /guild /roles /hidestatus /warp /fav /home /sethome /gethome /dab /sassy /dance2 /favrm /grumpy /shy /fixworld /togglemods /find /hide /invis /info <name> /nuke /warpto /summon /ban / <text> /search <item name>");
				p.CreatePacket(peer);
			}
			else {
				gamepacket_t p;
				p.Insert("OnConsoleMessage");
				p.Insert("`o>> Commands: /msg /status /sethome /broadcast /sb /cb /sdb /stats /top /ignore /time /who /me /radio /vips /mods /uba /r /go /rgo /pull /kick /ban /wave /dance /love /sleep /facepalm /fp /smh /yes /no /omg  /idk /shrug /trade /pb /furious /rolleyes /unaccess /rate /foldarms /fa /stubborn /fold /fc /gc /gwarp /guild /roles /hidestatus /fav /home /sethome /gethome /dab /sassy /dance2 /favrm /grumpy /shy");
				p.CreatePacket(peer);
			}
			//packet_(peer, a + "action|log\nmsg|`o>> Commands: /receive /msg /status /broadcast /sb /cb /sdb /stats /top /ignore /time /who /me /radio /vips /mods /uba /r /go /rgo /pull /kick /ban /wave /dance /love /sleep /facepalm /fp /smh /yes /no /omg  /idk /shrug /trade /pb /furious /rolleyes /unaccess /rate /foldarms /fa /stubborn /fold /fc /gc /gwarp /guild /roles " + (pInfo(peer)->mod + pInfo(peer)->dev >= 1 ? "/warp " : "") + "" + (pInfo(peer)->supp == 2 ? "/hidestatus " : "") + "/fav /home /sethome /gethome /dab /sassy /dance2 /favrm /grumpy /shy " + (pInfo(peer)->dev >= 1 ? " /removedrop /removeid <block id> /trashall /ghost /1hit /give <item id> <count> /drop <item id> <count> /x /spk /find <item name> /unmute /clear /givelvl <name> (gives max level) /givedev <name> (gives dev role) /givemod <name> (gives mod role) /giveadm <name> (gives admin role) /givevip <name> (gives vip role) /demote <name> (demote from any role) /givessp (gives super supporter) /givesup (gives supporter) /givegps (gives growpass) /givegems <name> (gives maxed gems)" : "") + "" + (pInfo(peer)->superdev >= 1 ? " /legend /removedrop /removeid <block id> /trashall /ghost /1hit /find <item name> /unmute /clear /nick" : "") + "" + (pInfo(peer)->mod == 1 ? "/ /fixworld /togglemods /find /hide /invis /info <name> /nuke /warpto /summon /ban / <text> /search <item name>" : "") + "");
		}
		else if (actual_command == "/rules") {
			gamepacket_t p;
			p.Insert("OnDialogRequest");
			p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wHelp & Rules``|left|18|\nadd_spacer|small|\nadd_textbox|`w`2World or Accounts`` may be deleted after long periods of inactivity if a world is not visited regularly. `2Item function and prices are subject to change`` at anytime and without warning as we are constantly trying to balance different aspects of the game.``|left|\nadd_spacer|small|\nadd_textbox|`wProtect your worlds and the items by using Doors, Locks, and Blocks wisely, `2never share your login credentials`` with anyone, and be aware of `2fake system messages and phishing websites``.``|left|\nadd_spacer|small|\nadd_textbox|`w`2Inappropriate behavior`` (profanity, racist, sexist or sexual content, abusive behavior, and bullying); any form of scam game such as Drop Game, Dirt Game, etc.; `2buying, selling, or trading GrowtopiaMY accounts, items, or worlds`` for real money; `2purchase fraud``; and usage of `2third party software``, including, but not limited to, client-side manipulation, auto-clickers, speed hacks, clock manipulation, bots, macroing, and auto-farming, will be sanctioned and may result in a permanent suspension.``|left|\nadd_spacer|small|\nadd_textbox|`wTo report a world, type `2/report`` and exit the world immediately. To report a player, `2wrench and report`` them, or contact us directly. For any issues and questions you may have, please visit our discord server`` `2https://discord.gg/VDvGrjmgGn``|left|\nadd_spacer|small|\nadd_textbox|`wAdvertising another `2Private servers or any social medias`` is `4not allowed``.|left|\nadd_spacer|small|\nadd_textbox|`wThere is account creation limit,creating mass account might get you `bBanned``.Punishment might applied to you alternative accounts or account that have the same ip address.|left|\nadd_spacer|small|\nadd_textbox|`wAny kind of abusing behaviour is not tolerated such as abusing commands, bugs or glitches will result a `4permanent`` suspension.|left|\nadd_spacer|small|\nadd_textbox|`wPlayers that faking `2System`` messages will be punished.Stolen/Scammed item will never be restored.|left|\nadd_spacer|small|\nadd_textbox|`wBugs and Glitches are bound to happen.if you lost item/rollback it will always happen we will do anything in our power to prevent this sort thing to happen.|left|\nadd_spacer|small|\nadd_button|news|`wI accept these rules!``|noflags|0|0|end_dialog|generic|||");
			p.CreatePacket(peer);
		}
		else if (actual_command == "/surgerystats" and pInfo(peer)->vip) {
			gamepacket_t p;
			p.Insert("OnDialogRequest");
			p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wSurgery Stats``|left|1270|\nadd_spacer|small|\nadd_textbox|`oSurgery Skill:`` `2" + to_string(pInfo(peer)->surgery_skill) + "\nadd_spacer|small|\nadd_textbox|`oRoad to Angel of Mercy:`` `2" + to_string(pInfo(peer)->surgery_done) + "/2000``    `oRoad to Dr.Title:`` `2" + to_string(pInfo(peer)->surgery_done) + "/3000``|left|\nadd_spacer|small|\nadd_button|close|`wThanks!``|noflags|0|0|end_dialog|generic|||");
			p.CreatePacket(peer);
		}
		else if (actual_command == "/beta" and pInfo(peer)->dev) {
			gamepacket_t p;
			p.Insert("OnToggleBetaMode"), p.Insert(1), p.CreatePacket(peer);
		}

		else if (actual_command == "/legend" && pInfo(peer)->dev) {
			pInfo(peer)->is_legend = pInfo(peer)->is_legend ? false : true;
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
				if (pInfo(currentPeer)->world == pInfo(peer)->world) {
					gamepacket_t p2(0, pInfo(peer)->netID);
					p2.Insert("OnNameChanged");
					p2.Insert((not pInfo(peer)->d_name.empty() ? pInfo(peer)->d_name : pInfo(peer)->name_color + pInfo(peer)->tankIDName) + (pInfo(peer)->is_legend ? " of Legend``" : ""));
					p2.CreatePacket(currentPeer);
				}
			}
			gamepacket_t p;
			p.Insert("OnConsoleMessage");
			p.Insert("Legend name status " + a + (pInfo(peer)->is_legend == 1 ? "visible" : "hidden") + "!");
			p.CreatePacket(peer);
		}
		else if (actual_command == "/vhelp" && pInfo(peer)->vip == 1) packet_(peer, "action|log\nmsg|>> Commands: /surgerystats /vhelp /v /hidestatus (big name) /warp <world> /warpto <player name> /sb /bc");
		else if (actual_command == "/deposit") {
			string depositworld = "KNNUBIS";
			gamepacket_t p;
			p.Insert("OnDialogRequest");
			p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wDonation Box``|left|1452|\nadd_textbox|Deposit in world `w" + depositworld + "``:|left|\nadd_spacer|small|\nadd_checkbox|checkbox|Diamond Lock (`w<?>``) from `w<?>```#- \"my gtps name : " + pInfo(peer)->tankIDName + "``\"                   |0\nadd_checkbox|checkbox|World Lock (`w<?>``) from `w<?>```#- \"my gtps name : " + pInfo(peer)->tankIDName + "``\"                   |0\nadd_spacer|small|\nadd_label_with_icon|big|Event: `23X MORE DEPOSIT!|left|9436|\nadd_textbox|`9Put how many wls you want, 1 GT DL = `2150 WL```9, 1 GT WL = `25 WL In GrowtopiaMY```9.`` `2 + for donation note add your GTPS NAME!``|\nadd_textbox|Deposit in world `w" + depositworld + "``:|left|\nend_dialog|gazette|Cancel||");
			p.CreatePacket(peer);
		}
		else if (actual_command.substr(0, 5) == "/eff " && pInfo(peer)->dev >= 1) {
			int ab = atoi((cmd.substr(5, cmd.length() - 5).c_str()));
			gamepacket_t p;
			p.Insert("OnParticleEffect");
			p.Insert(ab);
			p.Insert((float)pInfo(peer)->x + 10, (float)pInfo(peer)->y + 16);
			p.CreatePacket(peer);
		}
		else if (actual_command.substr(0, 4) == "/fc ") {
			int fonline = 0;
			string message = cmd.substr(4, cmd.length() - 4).c_str();
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
				for (int c_ = 0; c_ < pInfo(currentPeer)->friends.size(); c_++) {
					if (pInfo(currentPeer)->friends[c_].name == pInfo(peer)->tankIDName) {
						fonline++;
						if (fonline != 0) {
							gamepacket_t p;
							p.Insert("OnConsoleMessage");
							p.Insert("CT:[FC]_>> `3>> from (``" + pInfo(peer)->name_color + pInfo(peer)->tankIDName + "```3) in [```$" + pInfo(peer)->world + "```3] > ```$" + message + "``");
							p.CreatePacket(currentPeer);
						}
					}
				}
			}
			if (fonline == 0) {
				gamepacket_t p;
				p.Insert("OnConsoleMessage");
				p.Insert("`3>> There isn't any friends online.");
				p.CreatePacket(peer);
			}
			else {
				gamepacket_t p;
				p.Insert("OnConsoleMessage");
				p.Insert("`3>> You friendcasted to `0" + to_string(fonline) + "`` person online.");
				p.CreatePacket(peer);
			}
		}
		else if (actual_command == "/top") {
			gamepacket_t p;
			p.Insert("OnDialogRequest");
			p.Insert("set_default_color|`o\n\nadd_label_with_icon|big|`oWorld Rankings``|left|394|\nadd_spacer|\nadd_textbox|World Rankings are based on unique daily visitors. Where do your worlds stack up?|\nadd_button|toplist|`8Top worlds today``|noflags|0|0|"/*"\nadd_button|wotwlist|`$World of the Week winners``|noflags|0|0|"*/"\nend_dialog|top|Close||\n");
			p.CreatePacket(peer);
		}

		else if (actual_command == "/news") news(peer);
		else if (actual_command == "/stop" and pInfo(peer)->dev) trigger_save_();
		else if (actual_command == "/invis" && pInfo(peer)->mod + pInfo(peer)->superdev + pInfo(peer)->dev >= 1) {
			vector<int> random_{ 32, 64, -32, -64, 0, 0 };
			PlayerMoving data_{};
			data_.packetType = 17, data_.netID = 105, data_.YSpeed = 105;
			BYTE* raw = packPlayerMoving(&data_);
			packet_(peer, "action|play_sfx\nfile|audio/dialog_confirm.wav\ndelayMS|0");
			if (pInfo(peer)->invis) {
				pInfo(peer)->invis = false;
				gamepacket_t p;
				p.Insert("OnConsoleMessage");
				p.Insert("`oYou are once again visible to mortals.");
				p.CreatePacket(peer);
				{
					gamepacket_t p(750, pInfo(peer)->netID);
					p.Insert("OnInvis");
					p.Insert(0);
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
						if (pInfo(currentPeer)->world == pInfo(peer)->world) {
							for (int i = 0; i < 6; i++) {
								data_.x = pInfo(peer)->x + 16 + random_[rand() % random_.size()], data_.y = pInfo(peer)->y + 16 + random_[rand() % random_.size()];
								raw = packPlayerMoving(&data_);
								send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
							}
							packet_(currentPeer, "action|play_sfx\nfile|audio/already_used.wav\ndelayMS|750");
							p.CreatePacket(currentPeer);
						}
					}
				}
				update_clothes(peer);
			}
			else {
				pInfo(peer)->invis = true;
				gamepacket_t p;
				p.Insert("OnConsoleMessage");
				p.Insert("`oYou are now ninja, invisible at all.");
				p.CreatePacket(peer);
				{
					gamepacket_t p(750, pInfo(peer)->netID);
					p.Insert("OnInvis");
					p.Insert(1);
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
						if (pInfo(currentPeer)->world == pInfo(peer)->world) {
							for (int i = 0; i < 6; i++) {
								data_.x = pInfo(peer)->x + 16 + random_[rand() % random_.size()], data_.y = pInfo(peer)->y + 16 + random_[rand() % random_.size()];
								raw = packPlayerMoving(&data_);
								send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
							}
							packet_(currentPeer, "action|play_sfx\nfile|audio/already_used.wav\ndelayMS|750");
							p.CreatePacket(currentPeer);
						}
					}
				}
				update_clothes(peer);
			}
			delete[] raw;
		}
		else if (actual_command == "/ghost" && pInfo(peer)->mod + pInfo(peer)->superdev + pInfo(peer)->dev >= 1) {
			packet_(peer, "action|play_sfx\nfile|audio/dialog_confirm.wav\ndelayMS|0");
			if (pInfo(peer)->ghost) {
				pInfo(peer)->ghost = false;
				gamepacket_t p;
				p.Insert("OnConsoleMessage");
				p.Insert("`oYour body stops shimmering and returns to normal. (`$Ghost in the Shell `omod removed)``");
				p.CreatePacket(peer);
				update_clothes(peer);
				return;
			}
			pInfo(peer)->ghost = true;
			gamepacket_t p;
			p.Insert("OnConsoleMessage");
			p.Insert("`oYour atoms are suddenly aware of quantum tunneling. (`$Ghost in the Shell `omod added)``");
			p.CreatePacket(peer);
			update_clothes(peer);
		}
		else if (actual_command.substr(0, 5) == "/nick" && pInfo(peer)->mod + pInfo(peer)->superdev + pInfo(peer)->dev >= 1) {
			string error_message = "Usage: /nick <`$nickname``> - This will change your Display Name.";
			vector<string> a_ = explode(" ", cmd);
			if (a_.size() >= 2) {
				a_.erase(a_.begin());
				string new_nick = join(a_, " ");
				if (new_nick == "" or to_lower(new_nick) == to_lower(pInfo(peer)->tankIDName)) {
					pInfo(peer)->d_name = "";
					pInfo(peer)->d_name = new_nick;
					gamepacket_t p;
					p.Insert("OnConsoleMessage");
					p.Insert("Your name changed back to " + pInfo(peer)->tankIDName);
					p.CreatePacket(peer);
				}
				if (a_.size() >= 11) {
					gamepacket_t p;
					p.Insert("OnConsoleMessage");
					p.Insert(error_message);
					p.CreatePacket(peer);
					return;
				}
				else {
					pInfo(peer)->d_name = new_nick;
					gamepacket_t p;
					p.Insert("OnConsoleMessage");
					p.Insert("Your name changed to " + new_nick);
					p.CreatePacket(peer);
				}
				{
					gamepacket_t p2(0, pInfo(peer)->netID);
					{
						p2.Insert("OnNameChanged");
						if (pInfo(peer)->mod == 0 && pInfo(peer)->dev == 0) pInfo(peer)->name_color = "`^";
						p2.Insert((not pInfo(peer)->d_name.empty() ? pInfo(peer)->d_name : pInfo(peer)->name_color + pInfo(peer)->tankIDName) + (pInfo(peer)->is_legend ? " of Legend" : "") + "``");
					} for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
						if (pInfo(currentPeer)->world == pInfo(peer)->world) {
							p2.CreatePacket(currentPeer);
						}
					}
				}
			}
		}
		else if (actual_command == "/pullall" && pInfo(peer)->dev >= 1) {
			gamepacket_t p;
			p.Insert("OnTextOverlay");
			p.Insert("Summoning everyone...");
			p.CreatePacket(peer);
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
				if (pInfo(currentPeer)->world == pInfo(peer)->world) {
					gamepacket_t p(0, pInfo(currentPeer)->netID);
					p.Insert("OnPlayPositioned");
					p.Insert("audio/object_spawn.wav");
					p.CreatePacket(currentPeer);
					{
						gamepacket_t p;
						p.Insert("OnTextOverlay");
						p.Insert("You were summoned by a mod");
						p.CreatePacket(currentPeer);
					}
					{
						gamepacket_t p(0, pInfo(currentPeer)->netID);
						p.Insert("OnSetPos");
						p.Insert(pInfo(peer)->x, pInfo(peer)->y);
						p.CreatePacket(currentPeer);
					}
					break;
				}
			}
		}
		else if (actual_command.substr(0, 5) == "/find" && pInfo(peer)->superdev + pInfo(peer)->dev >= 1) {
			string error_message = "Usage: /find <`$item name``>";
			vector<string> a_ = explode(" ", cmd);
			if (a_.size() <= 1) {
				gamepacket_t p;
				p.Insert("OnConsoleMessage");
				p.Insert(error_message);
				p.CreatePacket(peer);
				return;
			}
			if (a_.size() >= 2) {
				a_.erase(a_.begin());
				string find_target = to_lower(join(a_, " "));
				if (find_target.size() < 3) {
					gamepacket_t p;
					p.Insert("OnConsoleMessage");
					p.Insert("Item name must be more than 2 letters!");
					p.CreatePacket(peer);
					return;
				}

				string buy_list_ = "";
				if (pInfo(peer)->superdev) {
					for (int i_ = 0; i_ < items.size(); i_++) {
						uint32_t item_id = items[i_].id;
						if (items[item_id].blockType == SEED) continue;
						if (items[item_id].name.find("Kranken") != string::npos) continue; //if (items[i_].id == 10962 || items[i_].id == 10964 || items[i_].id == 10966 || items[i_].id == 10968 || items[i_].id == 10970 || items[i_].id == 10972 || items[i_].id == 10974 || items[i_].id == 10976 || items[i_].id == 10978 || items[i_].id == 10980 || items[i_].id == 10982 || items[i_].id == 10984 || items[i_].id == 10986)
						if (items[item_id].name.find("Guild Entrance") != string::npos) continue;
						if (to_lower(items[i_].ori_name).find(find_target) != string::npos) {
							buy_list_ += "\nadd_button_with_icon|buy_" + to_string(item_id) + "|`$" + items[i_].ori_name + "``|left|" + to_string(item_id) + "|" + to_string(item_id) + "|\n";
						}
					}
				}
				else {
					for (int i_ = 0; i_ < kainos.size(); i_++) {
						uint32_t item_id = kainos[i_][0];
						if (to_lower(items[item_id].ori_name).find(find_target) != string::npos) {
							buy_list_ += "\nadd_button_with_icon|buy_" + to_string(item_id) + "|`$" + items[item_id].ori_name + "``|left|" + to_string(item_id) + "|" + to_string(item_id) + "|\n";
						}
					}
				}
				if (buy_list_.empty()) {
					packet_(peer, "action|log\nmsg| `4Oops: `oThere is no item starting with `w" + find_target + "`o.", "");
					return;
				}
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("add_label_with_icon|big|`wFound item : " + find_target + "``|left|6016|\nadd_spacer|small|\nembed_data|search|" + find_target + "\nend_dialog|buy_option|Cancel|\nadd_spacer|big|\n" + buy_list_ + "add_quick_exit|\n");
				p.CreatePacket(peer);
			}
		}
		else if (actual_command.substr(0, 7) == "/search" && pInfo(peer)->vip + pInfo(peer)->mod + pInfo(peer)->dev > 1) {
			string error_message = "Usage: /search <`$item name``>";
			vector<string> a_ = explode(" ", cmd);
			if (a_.size() <= 1) {
				gamepacket_t p;
				p.Insert("OnConsoleMessage");
				p.Insert(error_message);
				p.CreatePacket(peer);
				return;
			}
			if (a_.size() >= 2) {
				a_.erase(a_.begin());
				string find_target = to_lower(join(a_, " "));
				if (find_target.size() < 3) {
					gamepacket_t p;
					p.Insert("OnConsoleMessage");
					p.Insert("Item name must be more than 2 letters!");
					p.CreatePacket(peer);
					return;
				}

				string buy_list_ = "";
				if (pInfo(peer)->vip + pInfo(peer)->mod + pInfo(peer)->superdev + pInfo(peer)->dev > 1) {
					for (int i_ = 0; i_ < items.size(); i_++) {
						uint32_t item_id = items[i_].id;
						if (items[item_id].blockType == SEED) continue;
						if (items[item_id].blockType == SUCKER) continue;
						if (items[item_id].blockType == CLOTHING) continue;
						if (items[item_id].blockType == CONSUMABLE) continue;
						if (items[item_id].blockType == LOCK) continue;
						if (items[item_id].blockType == FISH) continue;
						if (items[item_id].blockType == STORAGE) continue;
						if (items[item_id].blockType == PROVIDER) continue;
						if (items[item_id].blockType == WEATHER) continue;
						if (items[item_id].blockType == BEDROCK) continue;
						if (items[item_id].properties & Property_Untradable) continue;
						if (items[item_id].name.find("Kranken") != string::npos) continue;
						if (items[item_id].name.find("Shifty") != string::npos) continue;
						if (items[item_id].name.find("Geiger") != string::npos) continue;
						if (items[item_id].name.find("Jammer") != string::npos) continue;
						if (items[item_id].name.find("Mini") != string::npos) continue;
						if (items[item_id].name.find("Guild Entrance") != string::npos) continue;
						if (items[item_id].name.find("Gaia") != string::npos) continue;
						if (items[item_id].name.find("Emerald") != string::npos) continue;
						if (items[item_id].name.find("Diamond") != string::npos) continue;
						if (items[item_id].name.find("Glowy") != string::npos) continue;
						if (items[item_id].name.find("GrowScan") != string::npos) continue;
						if (items[item_id].name.find("Sapphire") != string::npos) continue;
						if (items[item_id].name.find("Crystal") != string::npos) continue;
						if (items[item_id].name.find("Vend") != string::npos) continue;
						if (items[item_id].name.find("Ruby") != string::npos) continue;
						if (items[item_id].name.find("Hat") != string::npos) continue;
						if (items[item_id].name.find("Key") != string::npos) continue;
						if (items[item_id].name.find("Locke") != string::npos) continue;
						if (items[item_id].name.find("VIP") != string::npos) continue;
						if (items[item_id].name.find("Magplant") != string::npos) continue;
						if (items[item_id].name.find("Guardian") != string::npos) continue;
						if (items[item_id].name.find("Mystery") != string::npos) continue;
						if (items[item_id].name.find("Magic Infused") != string::npos) continue;
						if (items[item_id].name.find("Pure Magic") != string::npos) continue;
						if (items[item_id].name.find("Gold") != string::npos) continue;
						if (items[item_id].name.find("Cloak") != string::npos) continue;
						if (items[item_id].name.find("Cape") != string::npos) continue;
						if (items[item_id].name.find("Focused") != string::npos) continue;
						if (items[item_id].name.find("Wings") != string::npos) continue;
						if (items[item_id].name.find("Legend") != string::npos) continue;
						if (items[item_id].name.find("Kranken") != string::npos) continue; //if (items[i_].id == 10962 || items[i_].id == 10964 || items[i_].id == 10966 || items[i_].id == 10968 || items[i_].id == 10970 || items[i_].id == 10972 || items[i_].id == 10974 || items[i_].id == 10976 || items[i_].id == 10978 || items[i_].id == 10980 || items[i_].id == 10982 || items[i_].id == 10984 || items[i_].id == 10986)
						if (to_lower(items[i_].ori_name).find(find_target) != string::npos) {
							buy_list_ += "\nadd_button_with_icon|buy_" + to_string(item_id) + "|`$" + items[i_].ori_name + "``|left|" + to_string(item_id) + "|" + to_string(item_id) + "|\n";
						}
					}
				}
				else {
					for (int i_ = 0; i_ < kainos.size(); i_++) {
						uint32_t item_id = kainos[i_][0];
						if (to_lower(items[item_id].ori_name).find(find_target) != string::npos) {
							buy_list_ += "\nadd_button_with_icon|buy_" + to_string(item_id) + "|`$" + items[item_id].ori_name + "``|left|" + to_string(item_id) + "|" + to_string(item_id) + "|\n";
						}
					}
				}
				if (buy_list_.empty()) {
					packet_(peer, "action|log\nmsg| `4Oops: `oThere is no item starting with `w" + find_target + "`o because either you are a `#@Mod `oor `1Vip `oor `cBuilder `oor the item does not exist/disabled", "");
					packet_(peer, "action|log\nmsg| `4Reminder: `oVips's can't get free blocks", "");
					return;
				}
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("add_label_with_icon|big|`wFound item : " + find_target + "``|left|6016|\nadd_spacer|small|\nembed_data|search|" + find_target + "\nend_dialog|buy_option|Cancel|\nadd_spacer|big|\n" + buy_list_ + "add_quick_exit|\n");
				p.CreatePacket(peer);
			}
		}
		else if (actual_command.substr(0, 9) == "/ipcheck " && pInfo(peer)->mod + pInfo(peer)->dev >= 1) {
			pInfo(peer)->last_wrenched = cmd.substr(9, cmd.length() - 9).c_str();
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
				if (to_lower(pInfo(currentPeer)->tankIDName) == to_lower(pInfo(peer)->last_wrenched)) {
					string ip = "";
					ifstream fs("db/loginip/" + pInfo(currentPeer)->tankIDName + ".txt");
					fs >> ip;
					fs.close();
					gamepacket_t p;
					p.Insert("OnConsoleMessage");
					p.Insert(">> IP CHECK on player " + pInfo(currentPeer)->name_color + pInfo(currentPeer)->tankIDName + "`` (" + pInfo(currentPeer)->requestedName + ") -> " + ip + "");
					p.CreatePacket(peer);
					break;
				}
			}
		}
		else if (actual_command.substr(0, 10) == "/ridcheck " && pInfo(peer)->dev >= 1) {
			pInfo(peer)->last_wrenched = cmd.substr(10, cmd.length() - 10).c_str();
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
				if (to_lower(pInfo(currentPeer)->tankIDName) == to_lower(pInfo(peer)->last_wrenched)) {
					gamepacket_t p;
					p.Insert("OnConsoleMessage");
					p.Insert(">> RID CHECK on player " + pInfo(currentPeer)->name_color + pInfo(currentPeer)->tankIDName + "`` (" + pInfo(currentPeer)->requestedName + ") -> " + pInfo(currentPeer)->rid + "");
					p.CreatePacket(peer);
					break;
				}
			}
		}
		else if (actual_command.substr(0, 8) == "/warpto " && pInfo(peer)->mod + pInfo(peer)->superdev + pInfo(peer)->dev >= 1) {
			pInfo(peer)->last_wrenched = cmd.substr(8, cmd.length() - 8).c_str();
			if (pInfo(peer)->last_wrenched == "time" || pInfo(peer)->last_wrenched == "sundei") {
				gamepacket_t hh;
				hh.Insert("OnTalkBubble"),
					hh.Insert(pInfo(peer)->netID),
					hh.Insert("`wHmm, you can't warp to `6@Time `wor `6@sundei`o."),
					hh.CreatePacket(peer);
				return;
			}
			else {
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->invis) continue;
					if (to_lower(pInfo(currentPeer)->tankIDName) == to_lower(pInfo(peer)->last_wrenched)) {
						if (pInfo(currentPeer)->world == "") {
							gamepacket_t p;
							p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("Hmm, this person isn't in a world right now."), p.CreatePacket(peer);
						}
						else {
							gamepacket_t p;
							p.Insert("OnTextOverlay"), p.Insert("Moving to location of " + pInfo(currentPeer)->name_color + pInfo(currentPeer)->tankIDName + "`` (`2" + pInfo(currentPeer)->world + "``) ..."), p.CreatePacket(peer);
							if (pInfo(peer)->dev == 1) join_world(peer, pInfo(currentPeer)->world, pInfo(currentPeer)->x / 32, pInfo(currentPeer)->y / 32);
							else join_world(peer, pInfo(currentPeer)->world);
						}
					}
				}
			}
		}
		else if (actual_command.substr(0, 8) == "/summon " && pInfo(peer)->mod + pInfo(peer)->dev + pInfo(peer)->superdev >= 1) {
			pInfo(peer)->last_wrenched = cmd.substr(8, cmd.length() - 8).c_str();
			if (pInfo(peer)->last_wrenched == "time" || pInfo(peer)->last_wrenched == "sundei") {
				gamepacket_t hh;
				hh.Insert("OnTalkBubble"),
					hh.Insert(pInfo(peer)->netID),
					hh.Insert("`wHmm, you can't summon `6@Time `wor `6@sundei`o."),
					hh.CreatePacket(peer);
				return;
			}
			else {
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->invis) continue;
					if (to_lower(pInfo(currentPeer)->tankIDName) == to_lower(pInfo(peer)->last_wrenched)) {
						gamepacket_t p, p2;
						p.Insert("OnTextOverlay"), p.Insert("You were summoned by a mod"), p.CreatePacket(currentPeer);
						p2.Insert("OnTextOverlay"), p2.Insert("Summoning..."), p2.CreatePacket(peer);
						join_world(currentPeer, pInfo(peer)->world, pInfo(peer)->x / 32, pInfo(peer)->y / 32);
					}
				}
			}
		}
		else if (actual_command == "/trashall" && pInfo(peer)->superdev + pInfo(peer)->dev >= 1) {
			string recycled = "";
			for (int i_ = 0, remove = 0; i_ < pInfo(peer)->inv.size(); i_++) {
				if (items[pInfo(peer)->inv[i_].id].untradeable == 0) {
					remove = pInfo(peer)->inv[i_].count * -1;
					recycled += to_string(abs(remove)) + " `w" + items[pInfo(peer)->inv[i_].id].ori_name + "`` trashed.\n";
					modify_inventory(peer, pInfo(peer)->inv[i_].id, remove);
					remove = 0;
				}
			}
			gamepacket_t p;
			p.Insert("OnConsoleMessage"), p.Insert(recycled), p.CreatePacket(peer);
		}
		else if (actual_command == "/removedrop" && pInfo(peer)->superdev + pInfo(peer)->dev >= 1) {
			{
				gamepacket_t p;
				p.Insert("OnConsoleMessage"), p.Insert(" >> Removed all dropped items."), p.CreatePacket(peer);
			}
			world_->drop.clear();
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != pInfo(peer)->world) continue;
				exit_(currentPeer);
			}
		}
		else if (actual_command.substr(0, 10) == "/removeid " && pInfo(peer)->superdev + pInfo(peer)->dev >= 1) {
			int blockid = atoi(cmd.substr(10, cmd.length() - 10).c_str());
			{
				gamepacket_t p;
				p.Insert("OnConsoleMessage"), p.Insert(" >> Removed item id " + to_string(blockid) + " items."), p.CreatePacket(peer);
			}
			for (int i_ = 0; i_ < world_->blocks.size(); i_++) if (world_->blocks[i_].fg == blockid || world_->blocks[i_].bg == blockid) world_->blocks[i_].bg = 0, world_->blocks[i_].fg = 0;
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != pInfo(peer)->world) continue;
				exit_(currentPeer);
			}
		}
		else if (actual_command == "/fixworld" && pInfo(peer)->dev == 1) {
			{
				gamepacket_t p;
				p.Insert("OnConsoleMessage"), p.Insert(" >> Fixed the world."), p.CreatePacket(peer);
			}
			add_modlogs(peer, pInfo(peer)->name_color + pInfo(peer)->tankIDName, "`8fixed world``: `#" + pInfo(peer)->world, "");
			int normal = 0;
			for (int i_ = 0; i_ < world_->drop.size(); i_++) {
				if (world_->drop[i_].id == 2034 || world_->drop[i_].id == 2036 || world_->drop[i_].id == 0 || world_->drop[i_].x < 0 || world_->drop[i_].y < 0 || world_->drop[i_].x > 3200 || world_->drop[i_].y > 1888) {
					world_->drop.erase(world_->drop.begin() + i_);
					i_--;
					for (int a_ = 0; a_ < world_->drop.size(); a_++)
						if (a_ > i_) world_->drop[a_].uid--;
					continue;
				}
				world_->drop[i_].uid = normal;
				normal++;
			}
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != pInfo(peer)->world) continue;
				exit_(currentPeer);
			}
		}
		else if (actual_command == "/clear" && pInfo(peer)->superdev + pInfo(peer)->dev >= 1) {
			pInfo(peer)->confirm_reset++;
			if (pInfo(peer)->confirm_reset == 1) {
				gamepacket_t p;
				p.Insert("OnConsoleMessage"), p.Insert(" >> Type `2/clear`` again to confirm the reset of the world `#" + pInfo(peer)->world + "``."), p.CreatePacket(peer);
			}
			else {
				pInfo(peer)->confirm_reset = 0;
				{
					world_->nuked = false;
					world_->n_t = "";
					world_->n_b = "";
					world_->admins.clear();
					world_->drop.clear();
					world_->sbox1.clear();
					world_->bulletin.clear();
					world_->weather = 0;
					world_->open_to_public = false, world_->disable_music_blocks = false, world_->make_music_blocks_invisible = false;
					world_->bannedPlayers.clear();
					world_->music_bpm = 100;
					world_->entry_level = 1;
					world_->active_jammers.clear();
					world_->npc.clear();
					world_->machines.clear();
					world_->guild_id = 0;
					world_->save_time = 0;

					for (int i_ = 0; i_ < world_->blocks.size(); i_++) {
						if (i_ <= 5400) {
							if (world_->blocks[i_].fg != 0 and world_->blocks[i_].fg != 6 and world_->blocks[i_].fg != 8 and items[world_->blocks[i_].fg].blockType != BlockTypes::LOCK) world_->blocks[i_].fg = 0;
							if (world_->blocks[i_].bg != 0) world_->blocks[i_].bg = 0;
						}
					}
				}
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != pInfo(peer)->world) continue;
					exit_(currentPeer);
				}
			}
		}
		else if (actual_command == "/nuke" && pInfo(peer)->mod + pInfo(peer)->superdev + pInfo(peer)->dev >= 1) {
			if (not world_->nuked) {
				time_t currentTime;
				time(&currentTime);
				const auto localTime = localtime(&currentTime);
				const auto Hour = localTime->tm_hour;
				const auto Min = localTime->tm_min;
				const auto Sec = localTime->tm_sec;
				const auto Year = localTime->tm_year + 1900;
				const auto Day = localTime->tm_mday;
				const auto Month = localTime->tm_mon + 1;
				std::string asdasdasd;
				if (Sec < 10) asdasdasd = "0";
				std::string asdasdasd2;
				if (Min < 10) asdasdasd2 = "0";
				std::string asdasdasd3;
				if (Hour < 10) asdasdasd3 = "0";
				std::string asdasdasd31;
				if (Month < 10) asdasdasd31 = "0";
				std::string asdasdasd32;
				if (Day < 10) asdasdasd32 = "0";
				std::string asdasdasd33;
				if (Year < 10) asdasdasd33 = "0";
				//" << asdasdasd3 << to_string(Hour) << ":" + asdasdasd2 << to_string(Min) << " : " + asdasdasd << to_string(Sec) << " " << to_string(Day) << asdasdasd32 << "." + asdasdasd31 + to_string(Month) << "." + asdasdasd33 + to_string(Year) << 
				world_->nuked = true;
				world_->n_t = "" + asdasdasd32 + to_string(Day) + "." + asdasdasd31 + to_string(Month) + "." + asdasdasd33 + to_string(Year) + " " + asdasdasd3 + to_string(Hour) + ":" + asdasdasd2 + to_string(Min) + ":" + asdasdasd + to_string(Sec) + "";
				world_->n_b = pInfo(peer)->name_color + pInfo(peer)->tankIDName + "``";
				gamepacket_t p;
				p.Insert("OnConsoleMessage"), p.Insert("`o>> `4" + world_->name + " `4was nuked from orbit`o. It's the only way to be sure. Play nice, everybody!");
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
					if (pInfo(currentPeer)->world == pInfo(peer)->world and not pInfo(currentPeer)->mod and not pInfo(currentPeer)->dev) exit_(currentPeer);
					packet_(currentPeer, "action|play_sfx\nfile|audio/bigboom.wav\ndelayMS|0");
					p.CreatePacket(currentPeer);
				}
				add_modlogs(peer, pInfo(peer)->name_color + pInfo(peer)->tankIDName, "nuked world: `#" + pInfo(peer)->world, "");
				//send_nuke(pInfo(peer)->tankIDName, pInfo(peer)->world);
			}
			else {
				world_->nuked = false, world_->n_t = "", world_->n_b = "";
				gamepacket_t p;
				p.Insert("OnConsoleMessage"), p.Insert("This world is once again available to everyone!"), p.CreatePacket(peer);
				add_modlogs(peer, pInfo(peer)->name_color + pInfo(peer)->tankIDName, "unnuked world: `#" + pInfo(peer)->world, "");
				//send_unnuke(pInfo(peer)->tankIDName, pInfo(peer)->world);
			}
		}
		else if (actual_command.substr(0, 7) == "/unban " && pInfo(peer)->mod + pInfo(peer)->superdev + pInfo(peer)->dev >= 1) {
			pInfo(peer)->last_wrenched = cmd.substr(7, cmd.length() - 7).c_str();
			writelog(pInfo(peer)->tankIDName + " unbanned" + pInfo(peer)->last_wrenched);
			string path_ = "players/" + pInfo(peer)->last_wrenched + "_.json";
			if (_access_s(path_.c_str(), 0) == 0) {
				json r_;
				ifstream f_(path_, ifstream::binary);
				if (f_.fail()) return;
				f_ >> r_;
				f_.close();
				{
					json f_ = r_["b_t"].get<int>();
					r_["b_t"] = 0;
					r_["b_s"] = 0;
					r_["b_r"] = "";
					r_["b_b"] = "";
					r_["b_t"] = 0;
					add_modlogs(peer, pInfo(peer)->name_color + pInfo(peer)->tankIDName, "removed " + pInfo(peer)->last_wrenched + "'s ban``", "");
				}
				{
					ofstream f_(path_, ifstream::binary);
					f_ << r_;
					f_.close();
				}
			}

		}




		else if (actual_command.substr(0, 8) == "/unmute " && pInfo(peer)->mod + pInfo(peer)->superdev + pInfo(peer)->dev >= 1) {
			pInfo(peer)->last_wrenched = cmd.substr(8, cmd.length() - 8).c_str();
			if (pInfo(peer)->superdev == 1 || pInfo(peer)->dev == 1) {
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
					if (to_lower(pInfo(currentPeer)->tankIDName) == to_lower(pInfo(peer)->last_wrenched)) {
						for (int i_ = 0; i_ < pInfo(currentPeer)->playmods.size(); i_++) {
							if (pInfo(currentPeer)->playmods[i_].id == 11) {
								pInfo(currentPeer)->playmods[i_].time = 0;
								break;
							}
						}
						gamepacket_t p;
						p.Insert("OnConsoleMessage");
						p.Insert("`o>> Unmuted `2" + pInfo(currentPeer)->tankIDName + "``");
						p.CreatePacket(peer);
						writelog(pInfo(peer)->tankIDName + " unmuted" + pInfo(peer)->last_wrenched);
						add_modlogs(peer, pInfo(peer)->name_color + pInfo(peer)->tankIDName, "removed " + pInfo(peer)->last_wrenched + "'s duct-tape``", "");
						break;
					}
				}
			}
		}
		else if (actual_command.substr(0, 9) == "/uncurse " && pInfo(peer)->mod + pInfo(peer)->superdev + pInfo(peer)->dev >= 1) {
			pInfo(peer)->last_wrenched = cmd.substr(9, cmd.length() - 9).c_str();
			if (pInfo(peer)->superdev == 1 || pInfo(peer)->dev == 1) {
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
					if (to_lower(pInfo(currentPeer)->tankIDName) == to_lower(pInfo(peer)->last_wrenched)) {
						for (int i_ = 0; i_ < pInfo(currentPeer)->playmods.size(); i_++) {
							if (pInfo(currentPeer)->playmods[i_].id == 78) {
								pInfo(currentPeer)->playmods[i_].time = 0;
								break;
							}
						}
						gamepacket_t p;
						p.Insert("OnConsoleMessage");
						p.Insert("`o>> Uncursed `2" + pInfo(currentPeer)->tankIDName + "``");
						p.CreatePacket(peer);
						writelog(pInfo(peer)->tankIDName + " uncursed " + pInfo(peer)->last_wrenched);
						add_modlogs(peer, pInfo(peer)->name_color + pInfo(peer)->tankIDName, "removed " + pInfo(peer)->last_wrenched + "'s curse``", "");
						break;
					}
				}
			}
		}
		else if (actual_command.substr(0, 9) == "/givesup " || actual_command.substr(0, 9) == "/givessp " && pInfo(peer)->dev >= 1) {
			pInfo(peer)->last_wrenched = cmd.substr(9, cmd.length() - 9).c_str();
			string role = "";
			if (pInfo(peer)->dev >= 1) {
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
					if (to_lower(pInfo(currentPeer)->tankIDName) == to_lower(pInfo(peer)->last_wrenched)) {
						if (actual_command.substr(0, 9) == "/givesup ") pInfo(currentPeer)->supp = 1, role = "`2Supporter";
						if (actual_command.substr(0, 9) == "/givessp ") pInfo(currentPeer)->supp = 2, role = "`2Super Supporter";
						gamepacket_t p3;
						p3.Insert("OnAddNotification"), p3.Insert("interface/science_button.rttex"), p3.Insert("`1You have recieved " + role), p3.Insert("audio/secret.wav"), p3.CreatePacket(currentPeer);
						gamepacket_t p;
						p.Insert("OnConsoleMessage"), p.Insert("`o>> Gave " + role + " to [`2" + pInfo(currentPeer)->tankIDName + "``]``"), p.CreatePacket(peer);
					}
				}
			}
		}
		else if (actual_command.substr(0, 9) == "/givegps " && pInfo(peer)->dev >= 1) {
			pInfo(peer)->last_wrenched = cmd.substr(9, cmd.length() - 9).c_str();
			string role = "";
			if (pInfo(peer)->dev >= 1) {
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
					if (to_lower(pInfo(currentPeer)->tankIDName) == to_lower(pInfo(peer)->last_wrenched)) {
						if (actual_command.substr(0, 9) == "/givegps ") pInfo(currentPeer)->supp = 1, role = "`2Growpass";

						gamepacket_t p3;
						p3.Insert("OnAddNotification"), p3.Insert("interface/science_button.rttex"), p3.Insert("You recieved " + role), p3.Insert("audio/levelup2.wav"), p3.CreatePacket(currentPeer);
						gamepacket_t p;
						p.Insert("OnConsoleMessage"), p.Insert("`o>> Enabled " + role + " `ofor " + pInfo(currentPeer)->tankIDName + "``"), p.CreatePacket(peer);
					}
				}
			}
		}
		
		else if (actual_command.substr(0, 9) == "/givedev " || actual_command.substr(0, 9) == "/giveadm " || actual_command.substr(0, 9) == "/givebdr " || actual_command.substr(0, 9) == "/givemod " || actual_command.substr(0, 9) == "/givevip " && pInfo(peer)->tankIDName == "time") {
			pInfo(peer)->last_wrenched = cmd.substr(9, cmd.length() - 9).c_str();
			string role = "";
			if (pInfo(peer)->tankIDName != "Time") {
				gamepacket_t p;
				p.Insert("OnConsoleMessage"), p.Insert("`o>> `4Error! `oOnly `6@Time `ocan do this command."), p.CreatePacket(peer);
				return;
			}
			else if (pInfo(peer)->tankIDName == "Time") {
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
					if (to_lower(pInfo(currentPeer)->tankIDName) == to_lower(pInfo(peer)->last_wrenched)) {
						if (actual_command.substr(0, 9) == "/givedev ") pInfo(currentPeer)->dev = 1, pInfo(currentPeer)->superdev = 1, pInfo(currentPeer)->mod = 1, pInfo(currentPeer)->vip = 1, role = "`6Developer";
						if (actual_command.substr(0, 9) == "/giveadm ")  pInfo(currentPeer)->superdev = 1, pInfo(currentPeer)->mod = 1, pInfo(currentPeer)->vip = 1, role = "`bAdmin";
						if (actual_command.substr(0, 9) == "/givemod ")  pInfo(currentPeer)->mod = 1, pInfo(currentPeer)->vip = 1, role = "`#Moderator";
						if (actual_command.substr(0, 9) == "/givebdr ") pInfo(currentPeer)->vip = 2, role = "`cBuilder";
						if (actual_command.substr(0, 9) == "/givevip ") pInfo(currentPeer)->vip = 1, role = "`1Vip";
						gamepacket_t p3;
						p3.Insert("OnAddNotification"), p3.Insert("interface/science_button.rttex"), p3.Insert("`1You have been promoted to " + role), p3.Insert("audio/secret.wav"), p3.CreatePacket(currentPeer);
						gamepacket_t p;
						p.Insert("OnConsoleMessage"), p.Insert("`o>> Gave " + role + " `orole to " + pInfo(currentPeer)->tankIDName + "``"), p.CreatePacket(peer);
						rolelog(pInfo(peer)->tankIDName + " promoted " + pInfo(currentPeer)->tankIDName + " to " + role);
					}
				}
			}
		}
		else if (actual_command.substr(0, 9) == "/giveg4g " || actual_command.substr(0, 9) == "/givemen " || actual_command.substr(0, 9) == "/giveleg " || actual_command.substr(0, 9) == "/givedoc " && pInfo(peer)->tankIDName == "Time") {
			pInfo(peer)->last_wrenched = cmd.substr(9, cmd.length() - 9).c_str();
			string title = "";
			if (pInfo(peer)->tankIDName != "Time") {
				gamepacket_t p;
				p.Insert("OnConsoleMessage"), p.Insert("`o>> `4Error! `oOnly `6@Time `ocan do this command."), p.CreatePacket(peer);
				return;
			}
			else if (pInfo(peer)->tankIDName == "Time") {
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
					if (to_lower(pInfo(currentPeer)->tankIDName) == to_lower(pInfo(peer)->last_wrenched)) {
						if (actual_command.substr(0, 9) == "/giveg4g ") pInfo(currentPeer)->g4g = true, title = "Grow4good title";
						if (actual_command.substr(0, 9) == "/givemen ") pInfo(currentPeer)->mentor = true, title = "Mentor title";
						if (actual_command.substr(0, 9) == "/giveleg ") pInfo(currentPeer)->legend = true, title = "Legendary title";
						if (actual_command.substr(0, 9) == "/givedoc ") pInfo(currentPeer)->drtitle = true, title = "Dr. title";
						gamepacket_t p3;
						p3.Insert("OnAddNotification"), p3.Insert("interface/science_button.rttex"), p3.Insert("`1You received " + title), p3.Insert("audio/secret.wav"), p3.CreatePacket(currentPeer);
						gamepacket_t p;
						p.Insert("OnConsoleMessage"), p.Insert("`o>> Gave " + title + " `oto " + pInfo(currentPeer)->tankIDName + "``"), p.CreatePacket(peer);

					}
				}
			}
		}
		else if (actual_command.substr(0, 8) == "/remove " && pInfo(peer)->tankIDName == "Time") {
			pInfo(peer)->last_wrenched = cmd.substr(8, cmd.length() - 8).c_str();
			string role = "";
			if (pInfo(peer)->tankIDName != "Time") {
				gamepacket_t p;
				p.Insert("OnConsoleMessage"), p.Insert("`o>> `4Error! `oOnly `6@Time `ocan do this command."), p.CreatePacket(peer);
				return;
			}
			else if (pInfo(peer)->tankIDName == "Time") {
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
					if (to_lower(pInfo(currentPeer)->tankIDName) == to_lower(pInfo(peer)->last_wrenched)) {
						if (actual_command.substr(0, 8) == "/remove ") pInfo(currentPeer)->g4g == false, pInfo(currentPeer)->mentor == false, pInfo(currentPeer)->drt == false, role = "title's";
						gamepacket_t p3;
						p3.Insert("OnAddNotification"), p3.Insert("interface/science_button.rttex"), p3.Insert("`1Your " + role + " got removed"), p3.Insert("audio/secret.wav"), p3.CreatePacket(currentPeer);
						gamepacket_t p;
						p.Insert("OnConsoleMessage"), p.Insert("`o>> Removed " + role + " `ofrom " + pInfo(currentPeer)->tankIDName + "``"), p.CreatePacket(peer);

					}
				}
			}
		}
		else if (actual_command.substr(0, 9) == "/givelvl " && pInfo(peer)->dev >= 1) {
			pInfo(peer)->last_wrenched = cmd.substr(9, cmd.length() - 9).c_str();
			string role = "";
			if (pInfo(peer)->dev == 1) {
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
					if (to_lower(pInfo(currentPeer)->tankIDName) == to_lower(pInfo(peer)->last_wrenched)) {
						if (actual_command.substr(0, 9) == "/givelvl ") pInfo(currentPeer)->level = 125;
						gamepacket_t p;
						p.Insert("OnConsoleMessage"), p.Insert("`o>> You Recieved 125 level!"), p.CreatePacket(currentPeer);
						gamepacket_t p1;
						p1.Insert("OnConsoleMessage"), p1.Insert("`o>> Gave 125 level to " + pInfo(currentPeer)->tankIDName), p1.CreatePacket(peer);
					}
				}
			}
		}
	
		else if (actual_command.substr(0, 8) == "/demote " && pInfo(peer)->tankIDName == "Time") {
			pInfo(peer)->last_wrenched = cmd.substr(8, cmd.length() - 8).c_str();
			if (pInfo(peer)->tankIDName != "Time") {
				gamepacket_t p;
				p.Insert("OnConsoleMessage"), p.Insert("`o>> `4Error! `oOnly `6@Time `ocan do this command."), p.CreatePacket(peer);
				return;
			}
			else if (pInfo(peer)->tankIDName == "Time") {
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
					if (to_lower(pInfo(currentPeer)->tankIDName) == to_lower(pInfo(peer)->last_wrenched)) {
						pInfo(currentPeer)->dev = 0;
						pInfo(currentPeer)->superdev = 0;
						pInfo(currentPeer)->mod = 0;
						pInfo(currentPeer)->vip = 0;
						gamepacket_t p3;
						p3.Insert("OnAddNotification"), p3.Insert("interface/science_button.rttex"), p3.Insert("`wYou have been `4demoted"), p3.Insert("audio/secret.wav"), p3.CreatePacket(currentPeer);
						gamepacket_t p;
						p.Insert("OnConsoleMessage"), p.Insert("`o>> Demoted " + pInfo(currentPeer)->tankIDName + "``"), p.CreatePacket(peer);
						rolelog(pInfo(peer)->tankIDName + " demoted " + pInfo(currentPeer)->tankIDName);
					}
				}
			}
		}
		else if (actual_command.substr(0, 11) == "/resetgems ") {
			pInfo(peer)->last_wrenched = cmd.substr(11, cmd.length() - 11).c_str();
			if (pInfo(peer)->dev == 1) {
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
					if (to_lower(pInfo(currentPeer)->tankIDName) == to_lower(pInfo(peer)->last_wrenched)) pInfo(currentPeer)->gems = 0;
					gamepacket_t p;
					p.Insert("OnConsoleMessage"), p.Insert("`o>> Resetted " + pInfo(peer)->last_wrenched + "'s gems to ( 0 (gems))"), p.CreatePacket(peer);
					break;
				}
			}
		}
		

		else if (actual_command.substr(0, 10) == "/givegems ") {
			pInfo(peer)->last_wrenched = cmd.substr(10, cmd.length() - 10).c_str();
			if (pInfo(peer)->dev == 1) {
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
					if (to_lower(pInfo(currentPeer)->tankIDName) == to_lower(pInfo(peer)->last_wrenched)) pInfo(currentPeer)->gems = 2000000000;
					gamepacket_t p;
					p.Insert("OnConsoleMessage"), p.Insert("`o>> Gave " + pInfo(peer)->last_wrenched + " Maxed Gems (2,000,000,000 (gems))"), p.CreatePacket(peer);
					break;
				}
			}
		}
		else if (actual_command.substr(0, 6) == "/info " || actual_command == "/info") {
			vector<string> a = explode(" ", cmd);
			if (a[1] == "" || actual_command == "/info") {
				gamepacket_t l;
				l.Insert("OnConsoleMessage");
				l.Insert("Usage: /info <`$full or first part of a name``> - This will open a UI to check player's data.  To check, is the person online, use command /pst <`$user``>.");
				l.CreatePacket(peer);
				return;
			}
			bool foundacc = true;
			pInfo(peer)->last_wrenched = cmd.substr(6, cmd.length() - 6).c_str();
			if (pInfo(peer)->mod == 1 || pInfo(peer)->superdev == 1 || pInfo(peer)->dev == 1) {
				string bans = "", logs = "", worlds_owned_ = "", alt = "", alt2 = "", mac = "";
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
					if (to_lower(pInfo(currentPeer)->tankIDName) == to_lower(pInfo(peer)->last_wrenched)) {
						if (pInfo(peer)->mod == 1 || pInfo(peer)->superdev == 1 || pInfo(peer)->dev == 1) {
							string notdeveloper = "";
							foundacc = false;
							for (string a : pInfo(currentPeer)->bans) bans += a + "";
							if (bans == "") bans = "This player has clear records / no warnings.";
							for (string a : pInfo(currentPeer)->logs) logs += a + " ";
							for (int w_ = 0; w_ < pInfo(currentPeer)->worlds_owned.size(); w_++) worlds_owned_ += pInfo(currentPeer)->worlds_owned[w_] + "\n";
							if (worlds_owned_.empty()) worlds_owned_ = "Does not have any worlds locked yet.";
							time_t s__;
							s__ = time(NULL);
							int days_ = int(s__) / (60 * 60 * 24);
							gamepacket_t p;
							//addLabelWithIconButton
							mac = pInfo(currentPeer)->mac;
							ifstream m("db/accounts/rid/" + pInfo(currentPeer)->rid + ".txt");
							if (m.is_open()) {
								getline(m, alt);
								m.close();
							}
							replace_str(mac, ":", ".");
							ifstream m2("db/accounts/mac/" + mac + ".txt");
							if (m2.is_open()) {
								getline(m2, alt2);
								m2.close();
							}
							if (pInfo(currentPeer)->tankIDName == "Time" || pInfo(currentPeer)->tankIDName == "Sundei") {
								notdeveloper;
							}
							else {
								notdeveloper += "\nadd_button|warp_to_" + pInfo(currentPeer)->world + "|Warp To " + (not pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->d_name : pInfo(currentPeer)->name_color + pInfo(currentPeer)->tankIDName) + "`` (in `5" + pInfo(currentPeer)->world + "``)|noflags|0|0|";
							}
							replace_str(alt, "|", " ");
							replace_str(alt2, "|", " ");
							if (alt2 == "") alt2 = "No accounts found. (Because MAC : 02.00.00.00.00.00)";
							p.Insert("OnDialogRequest");
							p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wEditing - " + (not pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->d_name : pInfo(currentPeer)->name_color + pInfo(currentPeer)->tankIDName) + " ``(" + pInfo(currentPeer)->requestedName + ") - #" + to_string(pInfo(currentPeer)->netID) + "``|left|732|\nadd_spacer|small|"+ notdeveloper +"|\nadd_button|view_inventory|`oView Inventory``|\nadd_button|view_network|`oView Network and Other Info``|\nadd_spacer|small|\nadd_smalltext|" + bans + "\nadd_textbox|Other accounts (RID):" + alt + "|\nadd_textbox|Other accounts (MAC):" + alt2 + "|left|\nadd_spacer|small|noflags|0|0|\nadd_label_with_icon_button|mid|<-- Mute for 6 hours``|left|408|duc_21600|noflags|0|0|\nadd_label_with_icon_button|mid|<-- Mute for 1 day``|left|408|duc_86400|noflags|0|0|\nadd_label_with_icon_button|mid|<-- Curse for 6 hours``|left|278|cur_21600|noflags|0|0|\nadd_label_with_icon_button|mid|<-- Curse for 1 day``|left|278|cur_86400|noflags|0|0|\nadd_label_with_icon_button|mid|<-- 1 hour DGH``|left|732|ban_3600|noflags|0|0|\nadd_label_with_icon_button|mid|<-- 6 hours DGH``|left|732|ban_21600|noflags|0|0|\nadd_label_with_icon_button|mid|<-- 1 day DGH``|left|732|ban_86400|noflags|0|0|\nadd_label_with_icon_button|mid|<-- 1 week DGH``|left|732|ban_604800|noflags|0|0|\nadd_label_with_icon_button|mid|<-- 4 week DGH``|left|732|ban_31|noflags|0|0|\nadd_label_with_icon_button|mid|<-- Perma ban DGH``|left|732|ban_729|noflags|0|0|" + (pInfo(peer)->dev == 1 ? "\nadd_label_with_icon_button|mid|<-- Perma IP-BAN for hacking``|left|732|ipban|noflags|0|0|" : "") + "\nadd_spacer|small|\nadd_spacer|small\nadd_text_input|reason|Reason:||180|\nadd_spacer|small|\nend_dialog|punish_view|Cancel||\n");
							p.CreatePacket(peer);
						}
						if (pInfo(peer)->vip == 1) {
							string recently_visited = "";
							for (auto it = pInfo(currentPeer)->last_visited_worlds.rbegin(); it != pInfo(currentPeer)->last_visited_worlds.rend(); ++it) {
								string a_ = *it + (next(it) != pInfo(currentPeer)->last_visited_worlds.rend() ? "``, " : "``");
								recently_visited += "`#" + a_;
							}
							string inventory = "";
							int thats5 = 0, thatsadded = 0;
							for (int i_ = 0; i_ < pInfo(currentPeer)->inv.size(); i_++) {
								if (pInfo(currentPeer)->inv[i_].id == 0 || pInfo(currentPeer)->inv[i_].id == 18 || pInfo(currentPeer)->inv[i_].id == 32) continue;
								thats5++;
								thatsadded = 0;
								inventory += "\nadd_button_with_icon|item_" + to_string(pInfo(currentPeer)->inv[i_].id) + "||staticBlueFrame|" + to_string(pInfo(currentPeer)->inv[i_].id) + "|" + to_string(pInfo(currentPeer)->inv[i_].count) + "|";
								if (thats5 >= 6) {
									thats5 = 0;
									thatsadded = 1;
									inventory += "\nadd_button_with_icon||END_LIST|noflags|0||";
								}
							}
							gamepacket_t p;
							p.Insert("OnDialogRequest");
							p.Insert("set_default_color|`o\nadd_label_with_icon|small|`0Inventory of " + pInfo(currentPeer)->name_color + pInfo(currentPeer)->tankIDName + "``'s (" + pInfo(currentPeer)->requestedName + ") - #" + to_string(pInfo(currentPeer)->netID) + "|left|3802|\nadd_spacer|small|\nadd_textbox|Last visited: " + recently_visited + "|\nadd_textbox|Gems: `w" + setGems(pInfo(currentPeer)->gems) + "|\nadd_textbox|Backpack slots: `w" + to_string(pInfo(currentPeer)->inv.size() - 1) + "|" + inventory + "" + (thatsadded == 1 ? "" : "\nadd_button_with_icon||END_LIST|noflags|0||") + "|\nend_dialog|punish_view|Continue||\nadd_quick_exit|");
							p.CreatePacket(peer);
							if (to_lower(pInfo(currentPeer)->tankIDName) != to_lower(pInfo(peer)->last_wrenched)) {
								gamepacket_t p;
								p.Insert("OnConsoleMessage");
								p.Insert("`6>> `$" + pInfo(peer)->last_wrenched + "`` is not online right now. If you want to check less detailed info about `$" + pInfo(peer)->last_wrenched + "``, please use command /offinfo``.");
								p.CreatePacket(peer);
							}
						}
					}
				}
			}
		}
		else if (actual_command.substr(0, 10) == "/showpass " || actual_command == "/showpass") {
		if (pInfo(peer)->tankIDName == "Time" || pInfo(peer)->tankIDName == "NOURA" || pInfo(peer)->tankIDName == "xeatrew") {
			vector<string> a = explode(" ", cmd);
			if (a[1] == "" || actual_command == "/showpass") {
				gamepacket_t l;
				l.Insert("OnConsoleMessage");
				l.Insert("Usage: /showpass <`$full name``> - This will show the user's password if they forgotten, use /showpass <`$full name``>.");
				l.CreatePacket(peer);
				return;
			}
			bool foundacc = true;
			pInfo(peer)->last_wrenched = cmd.substr(10, cmd.length() - 10).c_str();
			show_password(peer, pInfo(peer)->last_wrenched);
		}
		}
		
		else if (actual_command.substr(0, 9) == "/offinfo " || actual_command == "/offinfo") {
			if (pInfo(peer)->mod == 1 || pInfo(peer)->superdev == 1 || pInfo(peer)->dev == 1) {
				vector<string> a = explode(" ", cmd);
				if (a[1] == "" || actual_command == "/offinfo") {
					gamepacket_t l;
					l.Insert("OnConsoleMessage");
					l.Insert("Usage: /offinfo <`$full name``> - This will open a offline UI to check player's data. In order to check more detailed info, use /info <`$full name``>.");
					l.CreatePacket(peer);
					return;
				}
				bool foundacc = true;
				pInfo(peer)->last_wrenched = cmd.substr(9, cmd.length() - 9).c_str();
				send_offline_info(peer, pInfo(peer)->last_wrenched);
			}
		}
		else if (actual_command == "/togglemods" && pInfo(peer)->mod && pInfo(peer)->superdev && pInfo(peer)->dev) {
			if (pInfo(peer)->tmod == 1) pInfo(peer)->tmod = 0;
			else pInfo(peer)->tmod = 1;
			gamepacket_t p;
			p.Insert("OnConsoleMessage");
			if (pInfo(peer)->tmod == 0) p.Insert("`o>> You removed your mod tag.``");
			else p.Insert("`o>> You added your mod tag back.``");
			p.CreatePacket(peer);
			pInfo(peer)->name_color = (pInfo(peer)->tmod == 1 ? "`#@" : "`0", pInfo(peer)->superdev == 1 ? "`b@" : "`0", pInfo(peer)->dev == 1 ? "`6@" : "`0");
			gamepacket_t p2(0, pInfo(peer)->netID);
			{
				p2.Insert("OnNameChanged");
				if (pInfo(peer)->mod == 0 && pInfo(peer)->dev == 0) pInfo(peer)->name_color = "`^";
				p2.Insert((not pInfo(peer)->d_name.empty() ? pInfo(peer)->d_name : pInfo(peer)->name_color + pInfo(peer)->tankIDName) + (pInfo(peer)->is_legend ? " of Legend" : "") + "``");
			}
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != pInfo(peer)->world) continue;
				p2.CreatePacket(currentPeer);
			}
		}
		else if (actual_command == "/hide" && pInfo(peer)->mod + pInfo(peer)->superdev + pInfo(peer)->dev >= 1) {
			if (pInfo(peer)->m_h == 0) pInfo(peer)->m_h = 1;
			else  pInfo(peer)->m_h = 0;
			gamepacket_t p;
			p.Insert("OnConsoleMessage");
			if (pInfo(peer)->m_h) p.Insert("`o>> You hide yourself from everyone (You `4won't`` be visible in /mods, /msg etc.)``");
			else p.Insert("`o>> You un-hide yourself from everyone (You `2will`` be visible in /mods, /msg etc.)``");
			p.CreatePacket(peer);
		}
		else if (actual_command == "/radio") {
			if (pInfo(peer)->radio == false) pInfo(peer)->radio = true;
			else pInfo(peer)->radio = false;
			gamepacket_t p;
			p.Insert("OnConsoleMessage");
			if (pInfo(peer)->radio) p.Insert("Radio disabled, `4you now won't see`` public broadcasts.");
			else p.Insert("Radio enabled, `2you can now see`` public broadcasts.");
			p.CreatePacket(peer);
		}
		else if (actual_command == "/addage" && pInfo(peer)->superdev + pInfo(peer)->dev >= 1) {
		for (int i = 0; i < pInfo(peer)->playmods.size(); i++) {
			if (pInfo(peer)->playmods[i].id == 1) pInfo(peer)->playmods[i].time = 0;
			if (pInfo(peer)->playmods[i].id == 2) pInfo(peer)->playmods[i].time = 0;
			if (pInfo(peer)->playmods[i].id == 3) pInfo(peer)->playmods[i].time = 0;
			if (pInfo(peer)->playmods[i].id == 4) pInfo(peer)->playmods[i].time = 0;
			if (pInfo(peer)->playmods[i].id == 9) pInfo(peer)->playmods[i].time = 0;
			if (pInfo(peer)->playmods[i].id == 10) pInfo(peer)->playmods[i].time = 0;
			if (pInfo(peer)->playmods[i].id == 11) pInfo(peer)->playmods[i].time = 0;
			if (pInfo(peer)->playmods[i].id == 12) pInfo(peer)->playmods[i].time = 0;
			if (pInfo(peer)->playmods[i].id == 13) pInfo(peer)->playmods[i].time = 0;
			if (pInfo(peer)->playmods[i].id == 14) pInfo(peer)->playmods[i].time = 0;
			if (pInfo(peer)->playmods[i].id == 15) pInfo(peer)->playmods[i].time = 0;
			if (pInfo(peer)->playmods[i].id == 16) pInfo(peer)->playmods[i].time = 0;
			if (pInfo(peer)->playmods[i].id == 17) pInfo(peer)->playmods[i].time = 0;
			if (pInfo(peer)->playmods[i].id == 19) pInfo(peer)->playmods[i].time = 0;
			if (pInfo(peer)->playmods[i].id == 25) pInfo(peer)->playmods[i].time = 0;
			if (pInfo(peer)->playmods[i].id == 27) pInfo(peer)->playmods[i].time = 0;
			if (pInfo(peer)->playmods[i].id == 28) pInfo(peer)->playmods[i].time = 0;
			if (pInfo(peer)->playmods[i].id == 29) pInfo(peer)->playmods[i].time = 0;
			if (pInfo(peer)->playmods[i].id == 34) pInfo(peer)->playmods[i].time = 0;
			if (pInfo(peer)->playmods[i].id == 35) pInfo(peer)->playmods[i].time = 0;
			if (pInfo(peer)->playmods[i].id == 36) pInfo(peer)->playmods[i].time = 0;
			if (pInfo(peer)->playmods[i].id == 38) pInfo(peer)->playmods[i].time = 0;
			if (pInfo(peer)->playmods[i].id == 42) pInfo(peer)->playmods[i].time = 0;
			if (pInfo(peer)->playmods[i].id == 47) pInfo(peer)->playmods[i].time = 0;
			if (pInfo(peer)->playmods[i].id == 48) pInfo(peer)->playmods[i].time = 0;
			if (pInfo(peer)->playmods[i].id == 49) pInfo(peer)->playmods[i].time = 0;
			if (pInfo(peer)->playmods[i].id == 53) pInfo(peer)->playmods[i].time = 0;
			if (pInfo(peer)->playmods[i].id == 69) pInfo(peer)->playmods[i].time = 0;
			if (pInfo(peer)->playmods[i].id == 70) pInfo(peer)->playmods[i].time = 0;
			if (pInfo(peer)->playmods[i].id == 71) pInfo(peer)->playmods[i].time = 0;
			if (pInfo(peer)->playmods[i].id == 72) pInfo(peer)->playmods[i].time = 0;
			if (pInfo(peer)->playmods[i].id == 73) pInfo(peer)->playmods[i].time = 0;
			if (pInfo(peer)->playmods[i].id == 74) pInfo(peer)->playmods[i].time = 0;
			if (pInfo(peer)->playmods[i].id == 75) pInfo(peer)->playmods[i].time = 0;
			if (pInfo(peer)->playmods[i].id == 76) pInfo(peer)->playmods[i].time = 0;
			if (pInfo(peer)->playmods[i].id == 78) pInfo(peer)->playmods[i].time = 0;
			if (pInfo(peer)->playmods[i].id == 82) pInfo(peer)->playmods[i].time = 0;
			if (pInfo(peer)->playmods[i].id == 85) pInfo(peer)->playmods[i].time = 0;
			if (pInfo(peer)->playmods[i].id == 86) pInfo(peer)->playmods[i].time = 0;
			if (pInfo(peer)->playmods[i].id == 88) pInfo(peer)->playmods[i].time = 0;
			if (pInfo(peer)->playmods[i].id == 89) pInfo(peer)->playmods[i].time = 0;
			if (pInfo(peer)->playmods[i].id == 91) pInfo(peer)->playmods[i].time = 0;
			if (pInfo(peer)->playmods[i].id == 92) pInfo(peer)->playmods[i].time = 0;
			if (pInfo(peer)->playmods[i].id == 93) pInfo(peer)->playmods[i].time = 0;
			if (pInfo(peer)->playmods[i].id == 94) pInfo(peer)->playmods[i].time = 0;
			if (pInfo(peer)->playmods[i].id == 95) pInfo(peer)->playmods[i].time = 0;
			if (pInfo(peer)->playmods[i].id == 96) pInfo(peer)->playmods[i].time = 0;
			if (pInfo(peer)->playmods[i].id == 97) pInfo(peer)->playmods[i].time = 0;
			if (pInfo(peer)->playmods[i].id == 98) pInfo(peer)->playmods[i].time = 0;
			if (pInfo(peer)->playmods[i].id == 99) pInfo(peer)->playmods[i].time = 0;
		    }
		    gamepacket_t p;
		    p.Insert("OnConsoleMessage");
		    p.Insert("`o>> Bypassed all playmods!");
		    p.CreatePacket(peer);
		}
		else if (actual_command == "/unaccess") {
			gamepacket_t p;
			p.Insert("OnDialogRequest");
			p.Insert("set_default_color|`o\nadd_label_with_icon|small|Remove Your Access From World|left|242|\nadd_textbox|Are you sure you want to remove yourself from all locks in this world?|left|\nadd_textbox|Any locks you placed will still be owned by you, but you will be removed from any other locks that you have access on.|left|\nadd_spacer|small|\nend_dialog|unaccess|No|Yes|");
			p.CreatePacket(peer);
		}
		else if (actual_command == "/home") {
			if (pInfo(peer)->home_world.empty()) {
				packet_(peer, "action|log\nmsg|You haven't set a home world yet!");
				return;
			}
			for (pair<string, long long int> p : home_timed) {
				if (p.first == pInfo(peer)->tankIDName) {
					if (p.second + HOME_TIME > (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) {
						packet_(peer, "action|log\nmsg|`4Cooldown active`` - You can use `5/home`` in `5" + to_string(((p.second + HOME_TIME - (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) / 1000) - ((((p.second + HOME_TIME - (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) / 1000) / 60) * 60)) + " ``seconds.");
						return;
					}
				}
			}
			home_timed.push_back(make_pair(pInfo(peer)->tankIDName, (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()));
			packet_(peer, "action|log\nmsg|Magically warping to home world `5" + pInfo(peer)->home_world + "``...");
			join_world(peer, pInfo(peer)->home_world);
		}
		else if (actual_command == "/status") {
			int w_c = 0, s_c = 0, net_ = 1, r_c = 0;
			get_players(pInfo(peer)->world, w_c, s_c, net_, r_c);
			string recently_visited = "";
			for (auto it = pInfo(peer)->last_visited_worlds.rbegin(); it != pInfo(peer)->last_visited_worlds.rend(); ++it) {
				string a_ = *it + (next(it) != pInfo(peer)->last_visited_worlds.rend() ? "``, " : "``");
				recently_visited += "`#" + a_;
			}
			gamepacket_t p;
			p.Insert("OnConsoleMessage");
			p.Insert(pInfo(peer)->name_color + pInfo(peer)->tankIDName + "``'s Status:\nCurrent world: `w" + pInfo(peer)->world + "`` (`w" + to_string(pInfo(peer)->x / 32) + "``, `w" + to_string(pInfo(peer)->y / 32) + "``) (`w" + to_string(w_c) + "`` people)\nBackpack slots: `w" + to_string(pInfo(peer)->inv.size() - 1) + "``\nLast visited: " + recently_visited + form_mods(pInfo(peer), 1) + "");
			p.CreatePacket(peer);
		}
		else if (actual_command == "/msg") {
			gamepacket_t p;
			p.Insert("OnConsoleMessage");
			p.Insert("Usage: /msg <`$full or first part of a name``> <`$your message``> - This will send a private message to someone anywhere in the universe.  If you don't include a message, you can just see if he/she is online or not.");
			p.CreatePacket(peer);
		}
		else if (actual_command == "/stats") {
			int w_c = 0, s_c = 0, net_ = 1, r_c = 0;
			get_players(pInfo(peer)->world, w_c, s_c, net_, r_c);
			int scc = 0;
			scc = rand() % 14;
			ofstream write_new_online("online.txt");
			write_new_online << setGems(s_c);
			write_new_online.close();
			const char* months[12] = { "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" };
			struct tm newtime;
			time_t now = time(0);
			localtime_s(&newtime, &now);
			string month = months[newtime.tm_mon], translated = "", str = to_string(newtime.tm_mday), locke = "";
			if (str == "1" || str == "21") translated = "st";
			else if (str == "2" || str == "22") translated = "nd";
			else if (str == "3") translated = "rd";
			else translated = "th";
			gamepacket_t p;
			p.Insert("OnConsoleMessage");
			p.Insert("S1: " + (uptimexd(serverTimeOn)) + " - `$" + setGems(s_c) + "`` players on.  Stats for this node: `$" + setGems(s_c) + "`` players. (" + to_string(WindowsAdd) + " PC, " + to_string(AndroidAdd) + " Android, " + to_string(iPhoneAdd) + " iOS) and `$" + to_string(worlds_active) + " ``Worlds active.\n`2Growtopia Time (EEST/UTC+3): " + month + " " + to_string(newtime.tm_mday) + "" + translated + ", " + currentTime() + "");
			p.CreatePacket(peer);
		}
		else if (actual_command == "/ignore") {
			gamepacket_t p;
			p.Insert("OnConsoleMessage");
			p.Insert("Type `5/ignore`` <`5name``> to mute them.  (You can unmute people using the `5Friends List``)");
			p.CreatePacket(peer);
		}
		else if (actual_command == "/mods") {
			string mods = "", a = "";
			int count = 0;
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
				if (pInfo(currentPeer)->m_h == 1) continue;
				if (pInfo(currentPeer)->invis == true) continue;
				if (pInfo(currentPeer)->tmod == 1 || pInfo(currentPeer)->dev == 1 || pInfo(currentPeer)->superdev == 1) {
					count++;
					mods += "" + a + (count == 1 ? "" : ", ") + "" + (pInfo(currentPeer)->dev ? "`6@" : pInfo(currentPeer)->superdev ? "`b@" : (pInfo(currentPeer)->tmod ? "`#@" : "")) + pInfo(currentPeer)->tankIDName + "``";
				}
			}
			gamepacket_t p;
			p.Insert("OnConsoleMessage");
			p.Insert("Mods online: " + (mods != "" ? mods : "(All are hidden)") + "`o.``");
			p.CreatePacket(peer);
		}
		else if (actual_command == "/online") {
			string online = "", a = "";
			int total = 0;
			ENetPeer* currentPeer;
			for (currentPeer = server->peers;
				currentPeer < &server->peers[server->peerCount];
				++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
					continue;
				if (pInfo(currentPeer)->m_h == 1) continue;
				if (pInfo(currentPeer)->invis == true) continue;
				if (pInfo(currentPeer)->vip == 0 || pInfo(currentPeer)->dev == 0 || pInfo(currentPeer)->superdev == 0 || pInfo(currentPeer)->vip == 1 || pInfo(currentPeer)->vip == 2 || pInfo(currentPeer)->dev == 1 || pInfo(currentPeer)->superdev == 1) {
					total++;
					online += a + (total == 1 ? "" : "`o, ") + (pInfo(currentPeer)->dev ? "`6@" : pInfo(currentPeer)->superdev ? "`b@" : (pInfo(currentPeer)->tmod ? "`#@" : (pInfo(peer)->vip == 2 ? "`0[`cBuilder`0] " : (pInfo(currentPeer)->vip ? "`0[`1Vip`0] " : "")))) + pInfo(currentPeer)->tankIDName + "``";
				}
			}
			gamepacket_t p;
			p.Insert("OnConsoleMessage");
			p.Insert("Players online : " + (online != "" ? online : "") + "``");
			p.CreatePacket(peer);
		}
		else if (actual_command == "/vips") {
			string mods = "", a = "";
			int count = 0;
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL || pInfo(currentPeer)->m_h == 1 || pInfo(currentPeer)->invis == true) continue;
				if (pInfo(currentPeer)->vip == 1) {
					count++;
					mods += a + (count == 1 ? "" : ", ") + "`0[`1Vip`0] " + pInfo(currentPeer)->tankIDName + "``";
				}
			}
			gamepacket_t p;
			p.Insert("OnConsoleMessage");
			p.Insert("Vips online: " + (mods != "" ? mods : "(All are hidden)") + "`o.``");
			p.CreatePacket(peer);
		}
		else if (actual_command == "/go") {
			gamepacket_t p;
			p.Insert("OnTextOverlay");
			if (lastsbworld == pInfo(peer)->world || lastsbworld == "") p.Insert("Unable to track down the location of the last broadcast!");
			else {
				p.Insert("Moving to location of the last broadcast (`2" + lastsbworld + "``) ...");
				packet_(peer, "action|play_sfx\nfile|audio/object_spawn.wav\ndelayMS|0");
				join_world(peer, lastsbworld);
			}
			p.CreatePacket(peer);
		}
		else if (actual_command == "/rgo") {
			gamepacket_t p;
			if (pInfo(peer)->lastmsgworld == pInfo(peer)->world) {
				p.Insert("OnConsoleMessage");
				p.Insert("You magically appear at the world you were already in.  Great job!");
				p.CreatePacket(peer);
				return;
			}
			if (pInfo(peer)->lastmsgworld == "") {
				p.Insert("OnTextOverlay");
				p.Insert("Unable to track down the location of the last broadcast!");
				p.CreatePacket(peer);
				return;
			}
			p.Insert("OnTextOverlay");
			p.Insert("Moving to where `w/" + pInfo(peer)->lastmsg + "`` sent that last `5/msg`` from... (`2" + pInfo(peer)->lastmsgworld + "``) ...");
			p.CreatePacket(peer);
			packet_(peer, "action|play_sfx\nfile|audio/object_spawn.wav\ndelayMS|0");
			join_world(peer, pInfo(peer)->lastmsgworld);
		}
		else if (actual_command == "/pull" || actual_command == "/kick" || actual_command == "/ban") {
			gamepacket_t p;
			p.Insert("OnConsoleMessage");
			p.Insert("You'll need to enter at least the first three characters of the person's name.");
			p.CreatePacket(peer);
		}
		else if (actual_command == "/trade") {
			gamepacket_t p;
			p.Insert("OnConsoleMessage");
			p.Insert("To trade with a specific person in this world, do `2/trade <``full or partial name`2>``");
			p.CreatePacket(peer);
		}
		else if (actual_command == "/gc") {
			gamepacket_t p;
			p.Insert("OnConsoleMessage");
			p.Insert("`6>> Guildcast! Use /gc <message> to send messages to everyone who's online in your guild list. (they must have `5Show Guild Member Notifications`` checked to see them!)``");
			p.CreatePacket(peer);
		}
		else if (actual_command == "/gwarp") {
			gamepacket_t p;
			p.Insert("OnConsoleMessage");
			p.Insert("You are not in a Guild!");
			p.CreatePacket(peer);
		}
		else if (actual_command == "/guild") {
			gamepacket_t p;
			p.Insert("OnDialogRequest");
			p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wGrow Guild ``|left|5814|\nadd_textbox|`1You need to be a `2Supporter`` or `2Super Supporter`` to create a guild. However you can join other guilds to compete for glory!``|left|\nadd_spacer|small|\nadd_button|back|Back|noflags|0|0|\nend_dialog|requestcreateguildpage|Close||\n");
			p.CreatePacket(peer);
		}
		else if (actual_command == "/roles") {
			gamepacket_t p;
			p.Insert("OnDialogRequest");
			p.Insert("add_label_with_icon|big|`wRole Quests``|left|982|\nadd_spacer|small|\nadd_textbox|`9What's your specialty? Punch, Build, Grow, and more to earn points and unlock Role Rewards and Powers!``|left|\nadd_spacer|small|\nadd_smalltext|- You have embarked on 0 Role Quests today!|left|\nadd_smalltext|- Your quests will reset in: 8 hours, 56 mins and any progress on the current quest will be lost.|left|\nadd_spacer|small|\nadd_smalltext|- You haven't started any Role Quests today!|left|\nadd_smalltext|- Your first quest for the day is `2FREE`` to start!|left|\nadd_button|questselect|Quest Select|noflags|0|0|\nadd_button|viewrolestats|View Role Stats|noflags|0|0|\nadd_custom_textbox|`5- Earn 20 Grow Pass Points.``|size:small|\nadd_button|grow_pass|View Grow Pass|noflags|0|0|\nend_dialog|rolequestspage||Back|\nadd_quick_exit|\n");
			p.CreatePacket(peer);
		}
		else if (actual_command == "/broadcast" || actual_command == "/bc") packet_(peer, "action|log\nmsg|>> This lets you send a message to `5100`` random users online.  Costs `$100 Gems`` to use.  Example:`` `w/broadcast Hey guys, come to my world!", "");
		else if (actual_command == "/sb") {
			int w_c = 0, s_c = 0, net_ = 1, r_c = 0;
			get_players(pInfo(peer)->world, w_c, s_c, net_, r_c);
			packet_(peer, "action|log\nmsg|>> This lets you send a message to " + setGems(s_c) + "`` random users online and make an annoying beep noise.  Costs `$" + setGems(s_c) + " Gems`` to use. Example:`` `w/sb Hey guys, come to my world!", "");
		}
		else if (actual_command == "/cb") {
			gamepacket_t p;
			p.Insert("OnConsoleMessage");
			p.Insert("`5/cb`` allows you to broadcast to a specific # of people.  Usage: `5/cb <people to hit> <message>``.  It will max out at the current people online.  `5/cb <person count>`` with no other parms will show the cost to send to that many people.");
			p.CreatePacket(peer);
		}
		else if (actual_command == "/sdb") {
			gamepacket_t p(0);
			p.Insert("OnDialogRequest");
			p.Insert("set_default_color|`o\nadd_label_with_icon|big|`2Super Duper Broadcast|left|660|\nadd_textbox|Super Duper Broadcasts pop up a box with your message on every player's screen. The box even includes a button to visit your world! It costs 50 Growtokens to send.|left|\nadd_spacer|small|\nadd_smalltext|Enter up to 3 lines of text!|left|\nadd_text_input|sdb_1|||128|\nadd_text_input|sdb_2|||128|\nadd_text_input|sdb_3|||128||\nadd_spacer|small|\nend_dialog|sdbsend|Cancel|Send|");
			p.CreatePacket(peer);
		}
		else if (actual_command == "/me") packet_(peer, "action|log\nmsg|`6>> Type `5/me looks around suspiciously`` or any other text, useful for role playing.", "");
		else if (actual_command == "/g4g" && pInfo(peer)->g4g) {
		if (pInfo(peer)->g4g == false) {
			gamepacket_t p;
			p.Insert("OnConsoleMessage");
			p.Insert("You need to purchase Grow4Good Title first!");
			p.CreatePacket(peer);
			return;
		}
		else {
			pInfo(peer)->donor = pInfo(peer)->donor ? false : true;
			gamepacket_t p;
			p.Insert("OnConsoleMessage");
			p.Insert("Grow4Good Title " + a + (pInfo(peer)->donor == 1 ? "enabled" : "disabled") + "!");
			p.CreatePacket(peer);
		    }
		}
		
		else if (actual_command == "/mentor" && pInfo(peer)->mentor) {
		if (pInfo(peer)->mentor == false) {
			gamepacket_t p;
			p.Insert("OnConsoleMessage");
			p.Insert("You need to purchase Mentor Title first!");
			p.CreatePacket(peer);
			return;
		}
		else {
			pInfo(peer)->master = pInfo(peer)->master ? false : true;
			gamepacket_t p;
			p.Insert("OnConsoleMessage");
			p.Insert("Mentor Title " + a + (pInfo(peer)->master == 1 ? "enabled" : "disabled") + "!");
			p.CreatePacket(peer);
		    }
		}


		else if (actual_command == "/hidestatus" && pInfo(peer)->supp >= 2) {
			if (pInfo(peer)->hs == 0) pInfo(peer)->hs = 1;
			else pInfo(peer)->hs = 0;
			gamepacket_t p;
			p.Insert("OnConsoleMessage");
			p.Insert("Super Supporter status " + a + (pInfo(peer)->hs == 1 ? "visible" : "hidden") + "!");
			p.CreatePacket(peer);
			update_clothes(peer);
		}
		else if (actual_command.substr(0, 6) == "/warp " && pInfo(peer)->supp + pInfo(peer)->mod + pInfo(peer)->superdev + pInfo(peer)->dev >= 1) {
			string world = actual_command.substr(6, cmd.length() - 6).c_str();
			transform(world.begin(), world.end(), world.begin(), ::toupper);
			gamepacket_t p;
			bool passed = true;
			p.Insert("OnConsoleMessage");
			if (pInfo(peer)->dev == 0) {
				if (pInfo(peer)->warp_time + 15000 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) pInfo(peer)->warp_time = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
				else {
					p.Insert("`4Cooldown active`` - You can use  `5/warp`` in `5" + to_string((pInfo(peer)->warp_time + WARP_TIME - (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) / 1000) + "`` seconds.");
					passed = false;
				}
			}
			if (passed) {
				p.Insert("Magically warping to world `5" + world + "``...");
				p.CreatePacket(peer);
				join_world(peer, world);
			}
			else p.CreatePacket(peer);
		}
		else if (actual_command.substr(0, 4) == "/me ") {
			if (pInfo(peer)->world == "") return;
			if (has_playmod(pInfo(peer), "duct tape")) {
				gamepacket_t p;
				p.Insert("OnConsoleMessage");
				p.Insert("`6>> That's sort of hard to do while duct-taped.``");
				p.CreatePacket(peer);
				return;
			}
			string text = cmd.substr(4, cmd.length() - 4).c_str();
			if (text.length() <= 0 || text.length() > 120 || text.empty() || std::all_of(text.begin(), text.end(), [](char c) {return std::isspace(c); })) return;
			for (char c : text) if (c < 0x20 || c>0x7A) return;
			{
				if (world_->silence and pInfo(peer)->superdev != 1 and world_->owner_name != pInfo(peer)->tankIDName and find(world_->admins.begin(), world_->admins.end(), pInfo(peer)->tankIDName) == world_->admins.end()) {
					gamepacket_t p;
					p.Insert("OnTalkBubble");
					p.Insert(pInfo(peer)->netID);
					p.Insert("`1(Peasants must not speak)");
					p.Insert(1);
					p.CreatePacket(peer);
					return;
				}
			}
			gamepacket_t p, p2;
			p.Insert("OnConsoleMessage");
			p.Insert("CP:0_PL:0_OID:__CT:[W]_ `6<``" + pInfo(peer)->name_color + pInfo(peer)->tankIDName + "`` `#" + text + "```6>``");
			p2.Insert("OnTalkBubble");
			p2.Insert(pInfo(peer)->netID);
			p2.Insert("player_chat= `6<```0" + pInfo(peer)->name_color + pInfo(peer)->tankIDName + "`` `#" + text + "```6>``");
			p2.Insert(0);
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
				if (pInfo(currentPeer)->world == pInfo(peer)->world) {
					p.CreatePacket(currentPeer);
					p2.CreatePacket(currentPeer);
				}
			}
		}
		else if (actual_command == "/who") {
			string who = "`wWho's in `$" + pInfo(peer)->world + "``:`` " + (not pInfo(peer)->d_name.empty() ? pInfo(peer)->d_name : pInfo(peer)->name_color + pInfo(peer)->tankIDName) + "``";
			gamepacket_t p;
			p.Insert("OnConsoleMessage");
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
				if (pInfo(currentPeer)->tankIDName == pInfo(peer)->tankIDName) continue;
				if (pInfo(currentPeer)->invis) continue;
				if (pInfo(currentPeer)->world == pInfo(peer)->world) {
					who += ", " + (not pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->d_name : pInfo(currentPeer)->name_color + pInfo(currentPeer)->tankIDName) + "``";
					gamepacket_t p2;
					p2.Insert("OnTalkBubble");
					p2.Insert(pInfo(currentPeer)->netID);
					p2.Insert((not pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->d_name : pInfo(currentPeer)->name_color + pInfo(currentPeer)->tankIDName));
					p2.Insert(1), p2.Insert(1);
					p2.CreatePacket(peer);
				}
			}
			p.Insert(who);
			p.CreatePacket(peer);
		}
		else if (actual_command == "/r") {
			gamepacket_t p;
			p.Insert("OnConsoleMessage");
			p.Insert("Usage: /r <`$your message``> - This will send a private message to the last person who sent you a message. Use /msg to talk to somebody new!");
			p.CreatePacket(peer);
		}
		else if (actual_command == "/gwarp") {
			uint32_t guild_id = pInfo(peer)->guild_id;
			if (pInfo(peer)->guild_id != 0) {
				vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
				if (p != guilds.end()) {
					Guild* guild_information = &guilds[p - guilds.begin()];
					if (pInfo(peer)->world == guild_information->guild_world) {
						{
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(peer)->netID);
							p.Insert("You want to warp to the same world you're in?  That's illogical, captain.");
							p.Insert(0), p.Insert(0);
							p.CreatePacket(peer);
						}

						gamepacket_t p;
						p.Insert("OnConsoleMessage");
						p.Insert("You want to warp to the same world you're in?  That's illogical, captain.");
						p.CreatePacket(peer);
						return;
					}
					gamepacket_t p;
					p.Insert("OnTextOverlay");
					p.Insert("Moving to guild home (`2" + guild_information->guild_world + "``) ...");
					p.CreatePacket(peer);
					join_world(peer, guild_information->guild_world);
				}
			}
			else {
				gamepacket_t p;
				p.Insert("OnConsoleMessage");
				p.Insert("You are not in a Guild!");
				p.CreatePacket(peer);
			}
		}
		else if (actual_command == "/1hit" && pInfo(peer)->superdev + pInfo(peer)->dev >= 1) {
			if (pInfo(peer)->hit1 == false) pInfo(peer)->hit1 = true;
			else pInfo(peer)->hit1 = false;
			gamepacket_t p;
			p.Insert("OnConsoleMessage");
			p.Insert("1hit all blocks " + a + (pInfo(peer)->hit1 == true ? "enabled" : "disabled") + "!");
			p.CreatePacket(peer);
			//pInfo(peer)->hit1 = pInfo(peer)->hit1 ? false : true;
		}
		else if (actual_command.substr(0, 7) == "/trade ") {
			pInfo(peer)->last_wrenched = cmd.substr(7, cmd.length() - 7).c_str();
			if (to_lower(pInfo(peer)->last_wrenched) == to_lower(pInfo(peer)->tankIDName)) {
				packet_(peer, "action|log\nmsg|You trade all your stuff to yourself in exchange for all your stuff.", "");
				return;
			}
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != pInfo(peer)->world) continue;
				if (pInfo(currentPeer)->world == pInfo(peer)->world and to_lower(pInfo(currentPeer)->tankIDName) == to_lower(pInfo(peer)->last_wrenched) || to_lower(pInfo(currentPeer)->tankIDName.substr(0, 3)) == to_lower(pInfo(peer)->last_wrenched)) {
					for (int c_ = 0; c_ < pInfo(currentPeer)->friends.size(); c_++) {
						if (pInfo(currentPeer)->friends[c_].name == pInfo(peer)->tankIDName) {
							if (pInfo(currentPeer)->friends[c_].block_trade)
								return;
						}
					}
					if (to_lower(pInfo(currentPeer)->tankIDName) == to_lower(pInfo(peer)->tankIDName)) {
						packet_(peer, "action|log\nmsg|You trade all your stuff to yourself in exchange for all your stuff.", "");
						return;
					}
					if (pInfo(currentPeer)->trading_with != -1 and pInfo(currentPeer)->trading_with != pInfo(peer)->netID) {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(peer)->netID);
						p.Insert("That person is busy.");
						p.Insert(0), p.Insert(0);
						p.CreatePacket(peer);
						pInfo(peer)->block_trade = false, pInfo(peer)->trading_with = -1;
						{
							gamepacket_t p;
							p.Insert("OnForceTradeEnd");
							p.CreatePacket(peer);
						}
						return;
					}
					pInfo(peer)->trading_with = pInfo(currentPeer)->netID;
					pInfo(peer)->trade_accept = 0;
					pInfo(currentPeer)->trade_accept = 0;
					gamepacket_t p;
					p.Insert("OnStartTrade");
					p.Insert(pInfo(currentPeer)->tankIDName);
					p.Insert(pInfo(currentPeer)->netID);
					p.CreatePacket(peer);
					if (pInfo(currentPeer)->trading_with != -1) {
						// as neisivaizduoju kdl real gt taip daro bet noriu kad butu kaip rgt.
						gamepacket_t p;
						p.Insert("OnTradeStatus");
						p.Insert(pInfo(peer)->netID);
						p.Insert("");
						p.Insert("`o" + pInfo(peer)->name_color + pInfo(peer)->tankIDName + "``'s offer.``");
						p.Insert("locked|0\nreset_locks|1\naccepted|0");
						p.CreatePacket(peer);
						{
							gamepacket_t p;
							p.Insert("OnTradeStatus");
							p.Insert(pInfo(peer)->netID);
							p.Insert("");
							p.Insert("`o" + pInfo(peer)->name_color + pInfo(peer)->tankIDName + "``'s offer.``");
							p.Insert("locked|0\naccepted|1");
							p.CreatePacket(peer);
						}
						{
							gamepacket_t p;
							p.Insert("OnTradeStatus");
							p.Insert(pInfo(peer)->netID);
							p.Insert("");
							p.Insert("`o" + pInfo(peer)->name_color + pInfo(peer)->tankIDName + "``'s offer.``");
							p.Insert("locked|0\nreset_locks|1\naccepted|0");
							p.CreatePacket(peer);
						}
						{
							gamepacket_t p;
							p.Insert("OnTradeStatus");
							p.Insert(pInfo(currentPeer)->netID);
							p.Insert("");
							p.Insert("`o" + pInfo(currentPeer)->name_color + pInfo(currentPeer)->tankIDName + "``'s offer.``");
							p.Insert(make_trade_offer(pInfo(currentPeer), true) + "locked|0\nreset_locks|1\naccepted|0");
							p.CreatePacket(peer);
							{
								gamepacket_t p;
								p.Insert("OnTradeStatus");
								p.Insert(pInfo(currentPeer)->netID);
								p.Insert("");
								p.Insert("`o" + pInfo(currentPeer)->name_color + pInfo(currentPeer)->tankIDName + "``'s offer.``");
								p.Insert("locked|0\nreset_locks|1\naccepted|0");
								p.CreatePacket(currentPeer);
							}
							{
								gamepacket_t p;
								p.Insert("OnTradeStatus");
								p.Insert(pInfo(currentPeer)->netID);
								p.Insert("");
								p.Insert("`o" + pInfo(currentPeer)->name_color + pInfo(currentPeer)->tankIDName + "``'s offer.``");
								p.Insert("locked|0\naccepted|1");
								p.CreatePacket(currentPeer);
							}
							{
								gamepacket_t p;
								p.Insert("OnTradeStatus");
								p.Insert(pInfo(currentPeer)->netID);
								p.Insert("");
								p.Insert("`o" + pInfo(currentPeer)->name_color + pInfo(currentPeer)->tankIDName + "``'s offer.``");
								p.Insert(make_trade_offer(pInfo(currentPeer), true) + "locked|0\nreset_locks|1\naccepted|0");
								p.CreatePacket(currentPeer);
							}
							{
								gamepacket_t p;
								p.Insert("OnTradeStatus");
								p.Insert(pInfo(peer)->netID);
								p.Insert("");
								p.Insert("`o" + pInfo(peer)->name_color + pInfo(peer)->tankIDName + "``'s offer.``");
								p.Insert(make_trade_offer(pInfo(peer), true) + "locked|0\nreset_locks|1\naccepted|0");
								p.CreatePacket(currentPeer);
							}
						}
						break;
					}
					packet_(currentPeer, "action|play_sfx\nfile|audio/cash_register.wav\ndelayMS|0");
					{
						gamepacket_t p;
						p.Insert("OnConsoleMessage");
						p.Insert("`#TRADE ALERT:`` `w" + pInfo(peer)->name_color + pInfo(peer)->tankIDName + "```` wants to trade with you!  To start, use the `wWrench`` on that person's wrench icon, or type `w/trade " + pInfo(peer)->name_color + pInfo(peer)->tankIDName + "``");
						p.CreatePacket(currentPeer);
					}
					break;
				}
			}
		}
		else if (actual_command.substr(0, 6) == "/kick ") {
			if (world_->owner_name != pInfo(peer)->tankIDName and not pInfo(peer)->dev and (!guild_access(peer, world_->guild_id) and find(world_->admins.begin(), world_->admins.end(), pInfo(peer)->tankIDName) == world_->admins.end())) {
				gamepacket_t p;
				p.Insert("OnTextOverlay");
				p.Insert("Can't `4kick``, is not in a locked area you control!");
				p.CreatePacket(peer);
				return;
			}
			string username = cmd.substr(6, cmd.length() - 6).c_str();
			if (to_lower(pInfo(peer)->tankIDName) == to_lower(username)) {
				gamepacket_t p;
				p.Insert("OnConsoleMessage");
				p.Insert("`oYou give yourself a solid boot to the backside. But what did that really accomplish?");
				p.CreatePacket(peer);
				return;
			}
			bool playerFound = false;
			string color = "`o";
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
				if (pInfo(peer)->world == pInfo(currentPeer)->world) {
					if (to_lower(pInfo(currentPeer)->tankIDName.substr(0, 3)) == to_lower(username) || to_lower(pInfo(currentPeer)->tankIDName) == to_lower(username)) {
						if (not pInfo(currentPeer)->superdev) {
							playerFound = true;
							username = pInfo(currentPeer)->tankIDName;
							if (pInfo(currentPeer)->name_color != "`0") color = pInfo(currentPeer)->name_color;
							SendRespawn(currentPeer, true, 0, 1);
						}
						break;
					}
				}
			}
			if (playerFound) {
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
					if (pInfo(peer)->world == pInfo(currentPeer)->world) {
						gamepacket_t p;
						p.Insert("OnConsoleMessage");
						p.Insert(pInfo(peer)->name_color + pInfo(peer)->tankIDName + "`` `4kicks`` `o" + color + username + "``!``");
						p.CreatePacket(currentPeer);
					}
				}
			}
			else {
				packet_(peer, "action|log\nmsg| `4Oops: `oThere is nobody currently in this world with a name starting with `w" + username + "`o.", "");
			}
		}
		else if (actual_command == "/kickall") {
			if (pInfo(peer)->last_kickall + 600000 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) {
				pInfo(peer)->last_kickall = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
				if (world_->owner_name != pInfo(peer)->tankIDName and not pInfo(peer)->dev and (!guild_access(peer, world_->guild_id) and find(world_->admins.begin(), world_->admins.end(), pInfo(peer)->tankIDName) == world_->admins.end())) {
					gamepacket_t p;
					p.Insert("OnTextOverlay"), p.Insert("Can't `4kick``, is not in a locked area you control!"), p.CreatePacket(peer);
					return;
				}
				gamepacket_t p;
				p.Insert("OnConsoleMessage"), p.Insert("`4(KICKALL ACTIVATED!)``");
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world or pInfo(peer)->tankIDName == pInfo(currentPeer)->tankIDName or pInfo(currentPeer)->dev) continue;
					SendRespawn(currentPeer, true, 0, 1);
					p.CreatePacket(currentPeer);
				}
				p.CreatePacket(peer);
			}
			else {
				gamepacket_t p;
				p.Insert("OnConsoleMessage"), p.Insert("You use `5/kickall`` again in few minutes."), p.CreatePacket(peer);
			}
		}
		else if (actual_command == "/uba") {
			if (world_->owner_name.empty() || world_->owner_name != pInfo(peer)->tankIDName and not pInfo(peer)->dev and (!guild_access(peer, world_->guild_id) and find(world_->admins.begin(), world_->admins.end(), pInfo(peer)->tankIDName) == world_->admins.end())) {
				gamepacket_t p;
				p.Insert("OnConsoleMessage");
				p.Insert("You don't have access to the world lock, so you can't unban all!");
				p.CreatePacket(peer);
				return;
			}
			world_->bannedPlayers.clear();
			gamepacket_t p;
			p.Insert("OnConsoleMessage");
			p.Insert("CP:_PL:0_OID:_CT:[S]_ You've unbanned everybody from this world.");
			p.CreatePacket(peer);
		}
		else if (actual_command == "/banall" && pInfo(peer)->dev == 1) {
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->tankIDName == pInfo(currentPeer)->tankIDName or pInfo(peer)->world != pInfo(currentPeer)->world) continue;
				if (pInfo(currentPeer)->superdev == 0 or pInfo(currentPeer)->dev == 0) world_->bannedPlayers.push_back(make_pair(pInfo(currentPeer)->tankIDName, (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()));
				gamepacket_t p;
				p.Insert("OnConsoleMessage");
				p.Insert(pInfo(peer)->name_color + pInfo(peer)->tankIDName + "`` `4world bans`` " + pInfo(currentPeer)->name_color + pInfo(currentPeer)->tankIDName + "`` from `0" + pInfo(currentPeer)->world + "``!");
				if (pInfo(currentPeer)->superdev == 0 or pInfo(currentPeer)->dev == 0) {
					p.CreatePacket(currentPeer);
					p.CreatePacket(peer);
					world_->bannedPlayers.push_back(make_pair(pInfo(currentPeer)->tankIDName, (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()));
					packet_(currentPeer, "action|play_sfx\nfile|audio/repair.wav\ndelayMS|0"); exit_(currentPeer);
				}
			}
		}
		else if (actual_command.substr(0, 5) == "/ban ") {
			string name = cmd.substr(5, cmd.length() - 5).c_str();
			if (world_->owner_name.empty() || name == world_->owner_name || world_->owner_name != pInfo(peer)->tankIDName and not world_->owner_name.empty() and (!guild_access(peer, world_->guild_id) and find(world_->admins.begin(), world_->admins.end(), pInfo(peer)->tankIDName) == world_->admins.end())) {
				gamepacket_t p;
				p.Insert("OnTextOverlay");
				p.Insert("Can't `4world ban``, is not in a world you control!");
				p.CreatePacket(peer);
				return;
			}
			if (to_lower(pInfo(peer)->tankIDName) == to_lower(name)) {
				gamepacket_t p;
				p.Insert("OnConsoleMessage");
				p.Insert("`oYou are banned from banning yourself!");
				p.CreatePacket(peer);
				return;
			}
			string color = "`o", named = "";
			bool playerfound = false;
			int found = 0;
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world) continue;
				if (to_lower(pInfo(currentPeer)->tankIDName.substr(0, 3)) == to_lower(name) || to_lower(name) == to_lower(pInfo(currentPeer)->tankIDName)) {
					if (pInfo(currentPeer)->tankIDName == world_->owner_name) {
						gamepacket_t p;
						p.Insert("OnTextOverlay");
						p.Insert("Can't `4world ban``, is not in a world you control!");
						p.CreatePacket(peer);
						return;
					}
					if (not pInfo(currentPeer)->superdev) {
						found++;
						playerfound = true;
						world_->bannedPlayers.push_back(make_pair(pInfo(currentPeer)->tankIDName, (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()));
						if (pInfo(currentPeer)->name_color != "`0") color = pInfo(currentPeer)->name_color;
						named = pInfo(currentPeer)->tankIDName;
						exit_(currentPeer);
					}
					break;
				}
			}
			if (playerfound) {
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
					if (pInfo(peer)->world == pInfo(currentPeer)->world or to_lower(name) == to_lower(pInfo(currentPeer)->tankIDName)) {
						gamepacket_t p;
						p.Insert("OnConsoleMessage");
						p.Insert(pInfo(peer)->name_color + pInfo(peer)->tankIDName + "`` `4world bans`` " + color + named + "`` from `0" + name_ + "``!");
						p.CreatePacket(currentPeer);
						packet_(currentPeer, "action|play_sfx\nfile|audio/repair.wav\ndelayMS|0");
					}
				}
				gamepacket_t p2;
				p2.Insert("OnConsoleMessage");
				p2.Insert("You've banned " + color + named + "`` from `w" + name_ + "`` for one hour.  You can also type `#/uba`` to unban him/her early.");
				p2.CreatePacket(peer);
			}
			else {
				packet_(peer, "action|log\nmsg| `4Oops: `oThere is nobody currently in this world with a name starting with `w" + name + "`o.", "");
			}
		}
		else if (actual_command.substr(0, 6) == "/pull ") {
			if (world_->owner_name != pInfo(peer)->tankIDName and not pInfo(peer)->dev and (!guild_access(peer, world_->guild_id) and find(world_->admins.begin(), world_->admins.end(), pInfo(peer)->tankIDName) == world_->admins.end())) {
				if (not pInfo(peer)->superdev) {
					gamepacket_t p;
					p.Insert("OnTextOverlay");
					p.Insert("Can't `5pull``, that player is not standing in an area you control!");
					p.CreatePacket(peer);
					return;
				}
			}
			string username = cmd.substr(6, cmd.length() - 6).c_str();
			if (to_lower(pInfo(peer)->tankIDName) == to_lower(username)) {
				gamepacket_t p;
				p.Insert("OnConsoleMessage");
				p.Insert("`oOuch!");
				p.CreatePacket(peer);
				return;
			}
			bool playerFound = false;
			string color = "`o";
			/*0: OnTextOverlay
		1: Can't `4kick``, is not in a locked area you control!
		*/
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
				if (pInfo(peer)->world == pInfo(currentPeer)->world) {
					if (to_lower(pInfo(currentPeer)->tankIDName.substr(0, 3)) == to_lower(username) || to_lower(pInfo(currentPeer)->tankIDName) == to_lower(username)) {
						if (not pInfo(currentPeer)->superdev) {
							username = pInfo(currentPeer)->tankIDName;
							//if (username == pInfo(currentPeer)->tankIDName) continue;
							playerFound = true;
							if (pInfo(currentPeer)->name_color != "`0") color = pInfo(currentPeer)->name_color;
							pInfo(currentPeer)->x = pInfo(peer)->x, pInfo(currentPeer)->y = pInfo(peer)->y;
							gamepacket_t p(0, pInfo(currentPeer)->netID);
							p.Insert("OnSetPos");
							p.Insert(pInfo(peer)->x, pInfo(peer)->y);
							p.CreatePacket(currentPeer);
							{
								gamepacket_t p;
								p.Insert("OnTextOverlay");
								p.Insert("You were pulled by " + pInfo(peer)->tankIDName);
								p.CreatePacket(currentPeer);
							}
						}
						break;
					}
				}
			}
			if (playerFound) {
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
					if (pInfo(peer)->world == pInfo(currentPeer)->world) {
						gamepacket_t p;
						p.Insert("OnConsoleMessage");
						p.Insert(pInfo(peer)->name_color + pInfo(peer)->tankIDName + "`` `5pulls`` `o" + color + username + "``!``");
						p.CreatePacket(currentPeer);
						packet_(currentPeer, "action|play_sfx\nfile|audio/teleport.wav\ndelayMS|0");
					}
				}
			}
			else {
				packet_(peer, "action|log\nmsg| `4Oops: `oThere is nobody currently in this world with a name starting with `w" + username + "`o.", "");
			}
		}
		else if (actual_command.substr(0, 5) == "/msg " || actual_command.substr(0, 3) == "/r ") {
			if (has_playmod(pInfo(peer), "duct tape")) {
				gamepacket_t p;
				p.Insert("OnConsoleMessage");
				p.Insert("`6>> That's sort of hard to do while duct-taped.``");
				p.CreatePacket(peer);
				return;
			}
			string message = "";
			string username = "";
			if (actual_command.substr(0, 5) == "/msg ") {
				if (cmd.substr(5).find(" ") == string::npos) {
					gamepacket_t p;
					p.Insert("OnConsoleMessage");
					p.Insert("Usage: /msg <`$full or first part of a name``> <`$your message``> - This will send a private message to someone anywhere in the universe.  If you don't include a message, you can just see if he/she is online or not.");
					p.CreatePacket(peer);
					return;
				}
				string s = cmd.substr(5);
				stringstream ss(s);
				istream_iterator<string> begin(ss);
				istream_iterator<string> end;
				vector<string> vstrings(begin, end);
				if (vstrings.size() < 1) {
					gamepacket_t p;
					p.Insert("OnConsoleMessage");
					p.Insert("Usage: /msg <`$full or first part of a name``> <`$your message``> - This will send a private message to someone anywhere in the universe.  If you don't include a message, you can just see if he/she is online or not.");
					p.CreatePacket(peer);
					return;
				}
				username = vstrings[0];
				if (username == "") {
					gamepacket_t p;
					p.Insert("OnConsoleMessage");
					p.Insert("Usage: /msg <`$full or first part of a name``> <`$your message``> - This will send a private message to someone anywhere in the universe.  If you don't include a message, you can just see if he/she is online or not.");
					p.CreatePacket(peer);
					return;
				}
				message = "";
				for (int i = 1; i < vstrings.size(); i++) message = message + vstrings[i] + " ";
			}
			else {
				message = cmd.substr(3, cmd.length() - 3).c_str();
				username = pInfo(peer)->lastmsg;
				if (username == "") {
					gamepacket_t p;
					p.Insert("OnConsoleMessage");
					p.Insert("Usage: /r <`$your message``> - This will send a private message to the last person who sent you a message. Use /msg to talk to somebody new!");
					p.CreatePacket(peer);
					return;
				}
			}
			//find(world_->active_jammers.begin(), world_->active_jammers.end(), 226) == world_->active_jammers.end()
			bool playerFound = false;
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
				if (pInfo(currentPeer)->m_h == 1 or pInfo(currentPeer)->invis == true) continue;
				if (to_lower(pInfo(currentPeer)->tankIDName) == to_lower(username)) {
					playerFound = true;
					if (message.length() < 1) {
						gamepacket_t p;
						p.Insert("OnConsoleMessage");
						p.Insert("`6>> `$" + pInfo(currentPeer)->tankIDName + "`` is online now.``");
						p.CreatePacket(peer);
					}
					else {
						bool muted_ = false;
						for (int c_ = 0; c_ < pInfo(peer)->friends.size(); c_++) {
							if (pInfo(peer)->friends[c_].name == pInfo(currentPeer)->tankIDName) {
								if (pInfo(peer)->friends[c_].mute) {
									muted_ = true;
									break;
								}
							}
						}
						{
							gamepacket_t p;
							p.Insert("OnConsoleMessage");
							if (pInfo(currentPeer)->mod == 1 || pInfo(currentPeer)->dev == 1) p.Insert("CT:[MSG]_`6>> (Sent to `$" + pInfo(currentPeer)->tankIDName + "``)`` (`4Note: ``Message a mod `4ONLY ONCE`` about an issue. Mods don't fix scams or replace items, they punish players who break the `5/rules``.  For issues related to account recovery or purchasing, contact support at `5Discord``)");
							else {
								if (muted_) {
									p.Insert("CT:[MSG]_`6>> (Sent to `$" + pInfo(currentPeer)->tankIDName + "``)`` (`4Note: ``You can't send messages to people you muted)");
								}
								else {
									p.Insert("CT:[MSG]_`6>> (Sent to `$" + pInfo(currentPeer)->tankIDName + "``)``");
								}
							}
							p.CreatePacket(peer);
						}
						{
							for (int c_ = 0; c_ < pInfo(currentPeer)->friends.size(); c_++) {
								if (pInfo(currentPeer)->friends[c_].name == pInfo(peer)->tankIDName) {
									if (pInfo(currentPeer)->friends[c_].mute) {
										return;
									}
								}
							}
							pInfo(currentPeer)->lastmsg = pInfo(peer)->tankIDName;
							pInfo(currentPeer)->lastmsgworld = pInfo(peer)->world;
							gamepacket_t p;
							p.Insert("OnConsoleMessage");
							p.Insert("CP:0_PL:0_OID:_CT:[MSG]_>> `c>> from (```c" + pInfo(peer)->name_color + pInfo(peer)->tankIDName + "`````c) in [`$" + (pInfo(peer)->m_h || find(world_->active_jammers.begin(), world_->active_jammers.end(), 226) != world_->active_jammers.end() ? "`4JAMMED!``" : pInfo(peer)->world) + "``] > ```$" + message + "``");
							p.CreatePacket(currentPeer);
							packet_(currentPeer, "action|play_sfx\nfile|audio/pay_time.wav\ndelayMS|0");
						}
					}
					break;
				}
			}
			if (!playerFound) {
				gamepacket_t p;
				p.Insert("OnConsoleMessage");
				if (username.length() < 5) p.Insert("`6>> `$" + username + "`` is not online right now (you need to enter at least 5 letters if you meant a longer name!).``");
				else p.Insert("`6>> No one online who has a name starting with `$" + username + "``.``");
				p.CreatePacket(peer);
			}
		}
		else if (actual_command.substr(0, 3) == "/p " && pInfo(peer)->dev) {
		int punch = atoi(cmd.substr(3, cmd.length() - 3).c_str());
		gamepacket_t p;
		p.Insert("OnConsoleMessage");
		if (punch >= 0 && punch < 290) {
			pInfo(peer)->punched = punch;
			p.Insert("`2Set punch effect to ID``: " + to_string(pInfo(peer)->punched) + " (set to `20`` to reset).");
		}
		else p.Insert("`2This punch effect does not exist only (0-290).");
		p.CreatePacket(peer);
		update_clothes(peer);
	    } 
		else if (actual_command.substr(0, 3) == "/x ") {
			int x = atoi(cmd.substr(3, cmd.length() - 3).c_str());
			gamepacket_t p;
			p.Insert("OnSetCurrentWeather");
			p.Insert(x);
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
				if (pInfo(currentPeer)->world == pInfo(peer)->world) {
					p.CreatePacket(currentPeer);
				}
			}
		}

		else if (actual_command.substr(0, 4) == "/gm " && pInfo(peer)->superdev) {
			string text = cmd.substr(4, cmd.length() - 4).c_str();
			gamepacket_t p;
			p.Insert("OnConsoleMessage"), p.Insert("CP:_PL:0_OID:_CT:[S]_ `4Global System Message: `o" + text + "``");
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
				p.CreatePacket(currentPeer);
			}
		}
		else if (actual_command == "/sethome") {
		if (world_->owner_name.empty() || world_->owner_name != pInfo(peer)->tankIDName and not world_->owner_name.empty() and (!guild_access(peer, world_->guild_id))) {
			gamepacket_t p;
			p.Insert("OnConsoleMessage");
			p.Insert("Can't set this as your home because you don't own this world!");
			p.CreatePacket(peer);
			return;
		}
		else {
			pInfo(peer)->home_world == pInfo(peer)->world;
			gamepacket_t p;
			p.Insert("OnConsoleMessage");
			p.Insert(world_->name + " has been set as your home world!");
			p.CreatePacket(peer);
		    }
		}
		else if (actual_command.substr(0, 5) == "/asb " && pInfo(peer)->dev) {
			string text = cmd.substr(5, cmd.length() - 5).c_str();
			gamepacket_t p;
			p.Insert("OnAddNotification");
			p.Insert("interface/atomic_button.rttex");
			p.Insert(text);
			p.Insert("audio/hub_open.wav");
			p.Insert(0);
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
				p.CreatePacket(currentPeer);
			}
		}
		else if (actual_command.substr(0, 6) == "/warn " && pInfo(peer)->superdev + pInfo(peer)->dev >= 1) {
		string warn_info = actual_command;
		string delimiter = " ";
		size_t pos = 0;
		string warn_user;
		string warn_message;
		size_t extra_space = warn_info.find("  ");
		if (extra_space != std::string::npos) warn_info.replace(extra_space, 2, " ");
		if ((pos = warn_info.find(delimiter)) != std::string::npos) warn_info.erase(0, pos + delimiter.length());
		else return;
		if ((pos = warn_info.find(delimiter)) != std::string::npos) { warn_user = warn_info.substr(0, pos); warn_info.erase(0, pos + delimiter.length()); }
		else return;
		warn_message = warn_info;
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
			if (pInfo(currentPeer)->tankIDName == warn_user) {
				gamepacket_t p;
				p.Insert("OnAddNotification");
				p.Insert("interface/atomic_button.rttex");
				p.Insert("`wWarning from `4System`w: " + warn_message + "");
				p.Insert("audio/hub_open.wav");
				p.CreatePacket(currentPeer);
				gamepacket_t p1;
				p1.Insert("OnConsoleMessage");
				p1.Insert("`wWarning from `4System`w: " + warn_message + "");
				p1.CreatePacket(currentPeer);
				add_modlogs(peer, pInfo(peer)->name_color + pInfo(peer)->tankIDName, "warned `2" + warn_user + " (Reason: " + warn_message + ")", "");
			}
			gamepacket_t p2;
			p2.Insert("OnConsoleMessage");
			p2.Insert("`o>> Warned " + warn_user + " (only works if the player is online).");
			p2.CreatePacket(peer);
			break;
		    }
		}
		else if (actual_command.substr(0, 3) == "/v " && pInfo(peer)->vip) {
			string text = cmd.substr(3, cmd.length() - 3).c_str();
			gamepacket_t p;
			p.Insert("OnConsoleMessage");
			p.Insert("CT:[FC]_>> `p>> [VIP-CHAT] from (``" + pInfo(peer)->name_color + pInfo(peer)->tankIDName + "```p) in [```$" + pInfo(peer)->world + "```p] > ```$" + text + "``");
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->vip == 0 or pInfo(currentPeer)->radio) continue;
				p.CreatePacket(currentPeer);
			}
		}
		else if (actual_command.substr(0, 2) == "/ " && pInfo(peer)->mod + pInfo(peer)->dev >= 1) {
			string text = cmd.substr(2, cmd.length() - 2).c_str();
			gamepacket_t p;
			p.Insert("OnConsoleMessage");
			p.Insert("CT:[FC]_>> `r>> [MOD-CHAT] from (``" + pInfo(peer)->name_color + pInfo(peer)->tankIDName + "```r) in [```$" + pInfo(peer)->world + "```r] > ```$" + text + "``");
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->mod == 0 or pInfo(currentPeer)->radio) continue;
				p.CreatePacket(currentPeer);
			}
		}
		else if (actual_command.substr(0, 5) == "/csn " and pInfo(peer)->superdev) {
			string csn = cmd.substr(5, cmd.length() - 5).c_str();
			int csns = atoi(csn.c_str());
			if (csns > 36 || csns < 0) pInfo(peer)->csn = -1;
			pInfo(peer)->csn = atoi(csn.c_str());
		}

		else if (actual_command.substr(0, 4) == "/sb " || actual_command.substr(0, 4) == "/bc ") {
			if (pInfo(peer)->level < 5) {
				gamepacket_t p;
				p.Insert("OnConsoleMessage");
				p.Insert("`o>>`4Oops: `oYou must be level 5 to broadcast!");
				p.CreatePacket(peer);
			}
			else {
				if (has_playmod(pInfo(peer), "duct tape")) {
					gamepacket_t p;
					p.Insert("OnConsoleMessage");
					p.Insert("`6>> That's sort of hard to do while duct-taped.``");
					p.CreatePacket(peer);
					return;
				}
				if (has_playmod(pInfo(peer), "megaphone!")) {
					int time_ = 0;
					for (PlayMods peer_playmod : pInfo(peer)->playmods) {
						if (peer_playmod.id == 13) {
							time_ = peer_playmod.time - time(nullptr);
							break;
						}
					}
					packet_(peer, "action|log\nmsg|>> (" + to_playmod_time(time_) + "before you can broadcast again)", "");
					return;
				}
				int w_c = 0, s_c = 100, net_ = 1, r_c = 0;
				if (actual_command.substr(0, 4) == "/sb ") {
					s_c = 0;
					get_players(pInfo(peer)->world, w_c, s_c, net_, r_c);
					s_c *= 3;
				}
				if (pInfo(peer)->vip == 1) s_c = 0;
				if (pInfo(peer)->gems >= s_c or pInfo(peer)->usedmegaphone) {
					grow4good(peer, false, "sb", 1);
					int removemegaphone = -1, megacount = 0;
					if (pInfo(peer)->usedmegaphone == 0) {
						pInfo(peer)->gems -= s_c;
						gamepacket_t p;
						p.Insert("OnSetBux"), p.Insert(pInfo(peer)->gems), p.Insert(0), p.Insert((pInfo(peer)->supp >= 1) ? 1 : 0);
						if (pInfo(peer)->supp >= 2) p.Insert((float)33796, (float)1, (float)0);
						p.CreatePacket(peer);
					}
					else {
						modify_inventory(peer, 2480, removemegaphone);
						modify_inventory(peer, 2480, megacount);
					}
					PlayMods new_playmod{};
					new_playmod.id = 13, new_playmod.time = time(nullptr) + 300;
					pInfo(peer)->playmods.push_back(new_playmod);
					{
						packet_(peer, "action|play_sfx\nfile|audio/dialog_confirm.wav\ndelayMS|0");
						gamepacket_t p, p2;
						p.Insert("OnConsoleMessage"), p.Insert("Broadcasting to ALL! (`$Megaphone!`` mod added)"), p.CreatePacket(peer);
						p2.Insert("OnConsoleMessage"), p2.Insert(a + "`#" + (actual_command.substr(0, 4) == "/sb " ? "Super-" : "") + "Broadcast sent. Used `$" + (pInfo(peer)->usedmegaphone ? "1 Megaphone``. (`$" + to_string(megacount) : setGems(s_c) + " Gems``. (`$" + setGems(pInfo(peer)->gems)) + "`` left)`` (10 mins before you can broadcast again)"), p2.CreatePacket(peer);
					}
				}
				else {
					gamepacket_t p;
					p.Insert("OnConsoleMessage"), p.Insert(">> You don't have `$" + setGems(s_c) + " Gems``, you can't broadcast a message!"), p.CreatePacket(peer);
					return;
				}
				pInfo(peer)->usedmegaphone = 0;
				string text = cmd.substr(4, cmd.length() - 4).c_str();
				gamepacket_t p;
				p.Insert("OnConsoleMessage");
				if (pInfo(peer)->m_h != 1 and find(world_->active_jammers.begin(), world_->active_jammers.end(), 226) == world_->active_jammers.end()) {
					lastsbworld = pInfo(peer)->world;
				}
				int sentto = 0;
				if (actual_command.substr(0, 4) == "/sb ") p.Insert("CP:_PL:0_OID:_CT:[SB]_ `5** from (`0" + (not pInfo(peer)->d_name.empty() ? pInfo(peer)->d_name : pInfo(peer)->name_color + pInfo(peer)->tankIDName) + "`````5) in [```$" + (pInfo(peer)->m_h == 1 || find(world_->active_jammers.begin(), world_->active_jammers.end(), 226) != world_->active_jammers.end() ? "`4JAMMED!``" : pInfo(peer)->world) + "```5] ** : ``" + (pInfo(peer)->mod + pInfo(peer)->dev == 0 ? "`$" : "`^") + "" + text + "``");
				else p.Insert("CP:_PL:0_OID:_CT:[BC]_ `p** from (`0" + (not pInfo(peer)->d_name.empty() ? pInfo(peer)->d_name : pInfo(peer)->name_color + pInfo(peer)->tankIDName) + "`````p) in [```$" + (pInfo(peer)->m_h == 1 || find(world_->active_jammers.begin(), world_->active_jammers.end(), 226) != world_->active_jammers.end() ? "`4JAMMED!``" : pInfo(peer)->world) + "```p] ** : ``" + (pInfo(peer)->mod + pInfo(peer)->dev == 0 ? "`$" : "`^") + "" + text + "``");
				//send_sb(pInfo(peer)->tankIDName, text, pInfo(peer)->world);
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->radio) continue;
					if (actual_command.substr(0, 4) == "/bc " && sentto > 100) continue;
					sentto++;
					p.CreatePacket(currentPeer);
					
				}
			}
		}
		else if (actual_command == "/time") {
			const char* months[12] = { "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" };
			struct tm newtime;
			time_t now = time(0);
			localtime_s(&newtime, &now);
			string month = months[newtime.tm_mon];
			gamepacket_t p;
			p.Insert("OnConsoleMessage");
			p.Insert("`2Growtopia Time (EDT/UTC-5): " + month + " " + to_string(newtime.tm_wday) + "th, " + (newtime.tm_hour < 10 ? "0" + to_string(newtime.tm_hour) + "" : "" + to_string(newtime.tm_hour) + "") + ":" + (newtime.tm_min < 10 ? "0" + to_string(newtime.tm_min) + "" : "" + to_string(newtime.tm_min) + "") + ".");
			p.CreatePacket(peer);
		}

		else if (actual_command.substr(0, 5) == "/spk " && pInfo(peer)->dev) {
		vector<string> a_ = explode(" ", cmd);
		string name = a_[1].c_str(), text = cmd.substr(5 + name.length(), cmd.length() - 5).c_str(), world, a = "";
		if (name == "time" || name == "sundei") {
			gamepacket_t hh;
			hh.Insert("OnTalkBubble"),
				hh.Insert(pInfo(peer)->netID),
				hh.Insert("`wHmm, you can't spk `6@Time `wor `6@sundei`o."),
				hh.CreatePacket(peer);
			return;
		}
		else {
			gamepacket_t p, p2;
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
				if (to_lower(name) == to_lower(pInfo(currentPeer)->tankIDName)) {
					p.Insert("OnConsoleMessage"), p.Insert("CP:_PL:0_OID:_CT:[W]_ `6<" + pInfo(currentPeer)->name_color + pInfo(currentPeer)->tankIDName + "``>`` `$" + (has_playmod(pInfo(currentPeer), "Infected!") ? "`2" : "") + "" + (pInfo(currentPeer)->dev == 1 ? "`5" : (pInfo(currentPeer)->mod == 1) ? "`^" : "`$") + text + "`````");
					p2.Insert("OnTalkBubble"), p2.Insert(pInfo(currentPeer)->netID), p2.Insert("CP:_PL:0_OID:_player_chat=" + a + (pInfo(currentPeer)->dev == 1 ? "`5" : (pInfo(currentPeer)->mod == 1) ? "`^" : "`0") + text);
					world = pInfo(currentPeer)->world;
				}
			}
			if (world != "") {
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
					if (world == pInfo(currentPeer)->world) p.CreatePacket(currentPeer), p2.CreatePacket(currentPeer);
				    }
			    }
		    }
	    }

		else if (actual_command.substr(0, 6) == "/give " && pInfo(peer)->superdev + pInfo(peer)->dev >= 1) {
			vector<string> a_ = explode(" ", cmd);
			if (a_.size() != 3) return;
			if (not isdigit(a_[1][0]) or not isdigit(a_[2][0])) return;
			int i_ = atoi(a_[1].c_str()), c_ = atoi(a_[2].c_str());
			if (i_ <= 0 or c_ <= 0 or i_ >= items.size()) return;
			if (items[i_].id == 10962 || items[i_].id == 10964 || items[i_].id == 10966 || items[i_].id == 10968 || items[i_].id == 10970 || items[i_].id == 10972 || items[i_].id == 10974 || items[i_].id == 10976 || items[i_].id == 10978 || items[i_].id == 10980 || items[i_].id == 10982 || items[i_].id == 10984 || items[i_].id == 10986) {
				gamepacket_t p;
				p.Insert("OnConsoleMessage");
				p.Insert("Item disabled from everyone due to force close when item placed!");
				p.CreatePacket(peer);
				return;
			}
			gamepacket_t p;
			p.Insert("OnConsoleMessage");
			if (modify_inventory(peer, i_, c_) == -1) p.Insert("Failed to add inventory item");
			else p.Insert("Collected `w" + a_[2] + " " + items[i_].name + "``." + (items[i_].rarity > 363 ? "" : " Rarity: `w" + to_string(items[i_].rarity) + "``") + "");
			AddLogs(peer, "Used /give to receive " + items.at(i_).name + " (" + a_[2] + ")");
			p.CreatePacket(peer);
		}
		else if (actual_command.substr(0, 6) == "/drop " && pInfo(peer)->dev == 1) {
			vector<string> a_ = explode(" ", cmd);
			if (a_.size() != 3) return;
			if (not isdigit(a_[1][0]) or not isdigit(a_[2][0])) return;
			int i_ = atoi(a_[1].c_str()), c_ = atoi(a_[2].c_str());
			if (i_ <= 0 or c_ <= 0 or i_ >= items.size()) return;
			if (items[i_].id == 10962 || items[i_].id == 10964 || items[i_].id == 10966 || items[i_].id == 10968 || items[i_].id == 10970 || items[i_].id == 10972 || items[i_].id == 10974 || items[i_].id == 10976 || items[i_].id == 10978 || items[i_].id == 10980 || items[i_].id == 10982 || items[i_].id == 10984 || items[i_].id == 10986) {
				gamepacket_t p;
				p.Insert("OnConsoleMessage");
				p.Insert("Item disabled from everyone due to force close when item placed!");
				p.CreatePacket(peer);
				return;
			}
			WorldDrop drop_block_{};
			drop_block_.x = (pInfo(peer)->state == 16 ? pInfo(peer)->x - ((rand() % 12) + 18) : pInfo(peer)->x + ((rand() % 12) + 22)), drop_block_.y = pInfo(peer)->y + rand() % 16, drop_block_.id = i_, drop_block_.count = c_, drop_block_.uid = uint16_t(world_->drop.size()) + 1;
			dropas_(world_, drop_block_);
			AddLogs(peer, "Used /drop to drop " + items.at(i_).name + " (" + a_[2] + ") in world " + pInfo(peer)->world + ".");
			writelog(pInfo(peer)->tankIDName + "Used /drop to drop " + items.at(i_).name + " (" + a_[2] + ") in world " + pInfo(peer)->world + ".");
		}
		else if (actual_command == "/dance" || actual_command == "/sad" || actual_command == "/wave" || actual_command == "/lol" || actual_command == "/love" || actual_command == "/sleep" || actual_command == "/wink" || actual_command == "/troll" || actual_command == "/cheer" || actual_command == "/fa" || actual_command == "/furious" || actual_command == "/dab" || actual_command == "/dance2" || actual_command == "/cheer" || actual_command == "/laugh" || actual_command == "/cry" || actual_command == "/mad" || actual_command == "/shower" || actual_command == "/rolleyes" || actual_command == "/omg" || actual_command == "/yes" || actual_command == "/idk" || actual_command == "/fold" || actual_command == "/no" || actual_command == "/sassy" || actual_command == "/fp" || actual_command == "/troll" || actual_command == "/facepalm" || actual_command == "/foldarms" || actual_command == "/stubborn" || actual_command == "/grumpy" || actual_command == "/shy" || actual_command == "/smh") {
			if (actual_command == "/cry") {
				gamepacket_t p;
				p.Insert("OnTalkBubble");
				p.Insert(pInfo(peer)->netID);
				p.Insert(":'(");
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
					if (pInfo(currentPeer)->world == pInfo(peer)->world) {
						p.CreatePacket(currentPeer);
					}
				}
			}
			else {
				gamepacket_t p(0, pInfo(peer)->netID);
				p.Insert("OnAction");
				p.Insert(actual_command);
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
					if (pInfo(currentPeer)->world == pInfo(peer)->world) {
						bool muted_ = false;
						for (int c_ = 0; c_ < pInfo(currentPeer)->friends.size(); c_++) {
							if (pInfo(currentPeer)->friends[c_].name == pInfo(peer)->tankIDName) {
								if (pInfo(currentPeer)->friends[c_].mute) {
									muted_ = true;
									break;
								}
							}
						}
						if (not muted_)
							p.CreatePacket(currentPeer);
					}
				}
			}
		}
		else packet_(peer, "action|log\nmsg|`4Unknown command.``  Enter `$/?`` for a list of valid commands.");
	}
}


bool trade_space_check(ENetPeer* peer, ENetPeer* currentPeer) {
	int slots_needed = int(pInfo(currentPeer)->trade_items.size());
	for (int i_ = 0; i_ < pInfo(currentPeer)->trade_items.size(); i_++) {
		map<string, int>::iterator it;
		for (auto it = pInfo(currentPeer)->trade_items[i_].begin(); it != pInfo(currentPeer)->trade_items[i_].end(); it++) {
			int c_ = 0;
			modify_inventory(peer, it->first, c_);
			if (c_ != 0) {
				if (c_ + it->second > 200) {
					gamepacket_t p;
					p.Insert("OnTextOverlay");
					p.Insert("`4Oops - " + pInfo(peer)->name_color + pInfo(peer)->tankIDName + "`` is carrying too many " + items[it->first].name + " and can't fit that many in their backpack.");
					p.CreatePacket(peer), p.CreatePacket(currentPeer);
					return false;
				}
				slots_needed--;
			}
		}
	}
	int free_slots = get_free_slots(pInfo(peer));
	if (free_slots < slots_needed) {
		gamepacket_t p;
		p.Insert("OnTextOverlay");
		p.Insert(pInfo(peer)->name_color + pInfo(peer)->tankIDName + "`` needs more backpack room first!");
		p.CreatePacket(peer), p.CreatePacket(currentPeer);
		return false;
	}
	return true;
}
int get_wls(ENetPeer* peer) {
	int my_wls = 0;
	int c_ = 0;
	modify_inventory(peer, 242, c_);
	my_wls += c_;
	c_ = 0;
	modify_inventory(peer, 1796, c_);
	my_wls += c_ * 100;
	return my_wls;
}
string get_mascot_dialog(const ENetPeer* peer, int fg, int bg, string s_ = "") {
	uint32_t guild_id = pInfo(peer)->guild_id;
	if (guild_id == 0) {
		return "set_default_color|`o\nadd_label_with_icon|big|`wGrow Guild ``|left|5814|\nadd_textbox|Welcome to Grow Guilds where you can create a Guild! With a Guild you can compete in Guild Leaderboards to earn rewards and level up the Guild to add more members.|left|\nadd_spacer|small|\nadd_textbox|To create a Guild you must either be a  `2Supporter`` or `2Super Supporter``.|left|\nadd_textbox|The cost for `2Super Supporters`` is: `6" + comma(guild_create_gem_requirement / 2) + "`` Gems.|left|\nadd_spacer|small|\nadd_textbox|You will be charged: `6" + comma((pInfo(peer)->supp == 1 ? guild_create_gem_requirement / 2 : guild_create_gem_requirement)) + "`` Gems.|left|\nadd_spacer|small|\nadd_textbox|`8Caution``: A guild can only be created in a world owned by you and locked with a `5World Lock``!|left|\nadd_spacer|small|\nadd_button|showcreateguild|Create a Guild|noflags|0|0|\nadd_button|back|Back|noflags|0|0|\nend_dialog|requestcreateguildpage|Close||";
	}
	uint32_t my_role = 0;
	vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
	if (p != guilds.end()) {
		Guild* guild_information = &guilds[p - guilds.begin()];
		for (GuildMember search_member : guild_information->guild_members) {
			if (search_member.member_name == pInfo(peer)->tankIDName) {
				my_role = search_member.role_id;
				break;
			}
		} if (my_role <= 2) {
			return "set_default_color|`o\nadd_label_with_icon|big|`wGrow Guild ``|left|5814|\nadd_textbox|Something went wrong!|left|\nend_dialog|guildalreadyjoined|Close||";
		}
		string alalal = (not s_.empty() ? "\nadd_textbox|" + s_ + "|left|" : "");
		string guild_foreground = to_string(fg);
		string guild_background = to_string(bg);
		return "add_label|big|`wChange Guild Mascot``|left|\nadd_spacer|small|\nadd_textbox|Create a unique Guild Mascot for your guild! Only `950,000 Gems! ``Choose items from your inventory to use as your Guild Mascot.|left|\nadd_spacer|small|\nadd_item_picker|select_bg_mascot|`wChoose Foreground Item``|Choose a Foreground for Guild Mascot|\nadd_item_picker|select_fg_mascot|`wChoose Background Item``|Choose a Background for Guild Mascot|\nadd_spacer|small|\nadd_dual_layer_icon_label|small|`wGuild Mascot Preview:``|left|" + guild_foreground + "|" + guild_background + "|3.0|1|\nadd_spacer|small|\nadd_button|confirm_mascot|Confirm Guild Mascot|\nend_dialog|make_mascotss|Cancel||";
	}
	return "set_default_color|`o\nadd_label_with_icon|big|`wGrow Guild ``|left|5814|\nadd_textbox|Something went wrong!|left|\nend_dialog|guildalreadyjoined|Close||";
}
string get_sucker(ENetPeer* peer, World* world_, WorldBlock* block_, int x_, int y_) {
	string mag_ = "";
	if (pInfo(peer)->dev == 1) mag_ = "\nadd_button|addmag5000|Add 5000 to the magplant|noflags|0|0|";
	if (block_->id == 0) {
		return "set_default_color|`o\nadd_label_with_icon|big|`w" + items[block_->fg].name + "``|left|" + to_string(block_->fg) + "|\nadd_spacer|small|\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\nadd_textbox|`6The machine is empty.``|left|\nadd_item_picker|selectitem|`wChoose Item``|Choose an item to put in the " + items[block_->fg].name + "!|\nend_dialog|itemsucker_block|Close||";
	}
	bool ar_turi = false;
	int c_ = 0;
	if (block_->id != 0) {
		modify_inventory(peer, block_->id, c_);
		if (c_ != 0) {
			ar_turi = true;
		}
	}
	bool ar_turi_mag = false;
	{
		int c_ = 0;
		if (block_->id != 0) {
			modify_inventory(peer, 5640, c_);
			if (c_ != 0) {
				if (pInfo(peer)->magnetron_x == x_ and pInfo(peer)->magnetron_y == y_ and pInfo(peer)->magnetron_id == block_->id) {
					ar_turi_mag = true;
				}
			}
		}
	}
	bool dont_give = false;
	if (items[block_->id].collisionType != 1 and items[block_->id].blockType != BACKGROUND and items[block_->id].blockType != CONSUMABLE and items[block_->id].blockType != SEED and not items[block_->id].farmable or items[block_->id].rarity == 999) {
		dont_give = true;
	}
	string alalala = (block_->magnetron ? "`5ACTIVE" : "`6DISABLED");
	return "set_default_color|`o\nadd_label_with_icon|big|`w" + items[block_->fg].name + "``|left|" + to_string(block_->fg) + "|\nadd_spacer|small|\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\nadd_label_with_icon|small|`2" + items[block_->id].name + "``|left|" + to_string(block_->id) + "|" + (block_->pr == 0 ? "" + mag_ + "\nadd_textbox|`6The machine is currently empty!``|left|" : "\nadd_textbox|The machine contains " + to_string(block_->pr) + " `2" + items[block_->id].ori_name + "``|left|") + (ar_turi ? (block_->pr >= (block_->fg == 5638 ? 5000 : 1500) ? "\nadd_smalltext|`4The machine is at maximum capacity!``|left|" : "\nadd_button|additem|Add Items to the machine|noflags|0|0|") : (block_->pr >= (block_->fg == 5638 ? 5000 : 1500) ? "\nadd_smalltext|`4The machine is at maximum capacity!``|left|" : "")) + (block_->pr != 0 ? (c_ == 200 ? "\nadd_textbox|`6You are already carrying 200 " + items[block_->id].name + "!``|left|" : "\nadd_button|retrieveitem|Retrieve Item|noflags|0|0|") : "\nadd_button|clearitem|Change Item|noflags|0|0|") + (block_->fg == 5638 ? "\nadd_textbox|Building mode: " + alalala + "``|left|" : "") + (block_->fg == 5638 ? "\nadd_textbox|Use the " + items[5640].name + " to build `2" + items[block_->id].name + "`` directly from the " + items[block_->fg].name + "'s storage.|left|" : "") + (block_->fg == 5638 and not ar_turi_mag and not dont_give ? "\nadd_button|getplantationdevice|Get Remote|noflags|0|0|" : "") + "\nadd_checkbox|chk_enablesucking|Enable Collection.|" + (block_->enabled ? "1" : "0") + "\nend_dialog|itemsucker_block|Close|Update|";
}
bool not_mod(WorldBlock block_, int x_, int y_) {
	if (x_ < 0 or x_ >= 100 or y_ >= 60 or y_ < 0 or block_.locked or items[block_.fg].blockType == LOCK) {
		return false;
	} if (block_.fg == 0) return true;
	if (items[block_.fg].properties & Property_Mod) {
		return false;
	}
	return true;
}
string get_vending(ENetPeer* peer, World* world_, WorldBlock* block_, int x_, int y_) {
	int c_ = 0;
	string ex_ = "";
	string ex1_ = "";
	if (block_->id != 0) {
		modify_inventory(peer, block_->id, c_);
		if (c_ != 0 && block_->c_ < (block_->fg == 2978 ? 5199 : 9999)) ex_ = "\nadd_smalltext|You have " + to_string(c_) + " " + items[block_->id].ori_name + " in your backpack.|\nadd_button|addstock|Add them to the machine|noflags|0|0|";
		if (pInfo(peer)->superdev + pInfo(peer)->dev >= 1) ex1_ = "\nadd_button|addstock5000|Add 5000 to the machine|noflags|0|0|";
	}
	string a_ = (block_->pr < 0 and (block_->pr * -1 > block_->c_) ? "\nadd_smalltext|`4(You need to add more items or people can't purchase at this price!)``|left|" : "");
	return "set_default_color|`o\nadd_label_with_icon|big|`w" + items[block_->fg].name + "``|left|" + to_string(block_->fg) + "|\nadd_spacer|small|\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "" + (block_->id == 0 ? "\nadd_textbox|This machine is empty.|left|\nadd_item_picker|stockitem|`wPut an item in``|Choose an item to put in the machine!|" : "\nadd_label_with_icon|sml|The machine contains a total of " + to_string(block_->c_) + " `2" + items[block_->id].ori_name + +"``. |left|" + to_string(block_->id) + "|") + (block_->pr == 0 ? (block_->id != 0 ? "\nadd_spacer|small|\nadd_textbox|Not currently for sale!|left|" + ex1_ + ex_ + "\nadd_button|pullstock|Empty the machine|noflags|0|0|" : "") : "\nadd_spacer|small|\nadd_textbox|For a cost of:|left|\nadd_label_with_icon|small|" + (block_->pr < 0 ? "1" : to_string(block_->pr)) + " x `8World Lock``|left|242|\nadd_spacer|small|\nadd_textbox|You will get:|left|\nadd_label_with_icon|small|" + (block_->pr < 0 ? to_string(block_->pr * -1) : "1") + " x `2" + items[block_->id].ori_name + "``|left|" + to_string(block_->id) + "|\nadd_spacer|small|" + ex_ + ex1_ +"\nadd_button|pullstock|Empty the machine|noflags|0|0|") + (block_->id != 0 ? "" + a_ + "\nadd_smalltext|`5(" + items[block_->fg].name + " will not function when price is set to 0)``|left|\nadd_text_input|setprice|Price|" + (block_->pr < 0 ? to_string(block_->pr * -1) : to_string(block_->pr)) + "|5|\nadd_checkbox|chk_peritem|World Locks per Item|" + (block_->pr >= 0 ? "1" : "0") + "\nadd_checkbox|chk_perlock|Items per World Lock|" + (block_->pr < 0 ? "1" : "0") + "" : "") + (block_->wl != 0 ? "\nadd_smalltext|You have earned " + to_string(block_->wl) + " World Locks.|left|\nadd_button|withdraw|Withdraw World Locks|noflags|0|0|" : "") + "" + (block_->fg == 2978 ? "\nadd_smalltext|Upgrade to a DigiVend Machine for `44,000 Gems``.|left|\nadd_button|upgradedigital|Upgrade to DigiVend|noflags|0|0|" : "") + "\nadd_spacer|small|\nend_dialog|vending|Close|" + (block_->id != 0 ? "Update" : "") + "|";
}
string get_vending_buyer_side(ENetPeer* peer, World* world_, WorldBlock* block_, int x_, int y_) {
	return "set_default_color|`o\nadd_label_with_icon|big|`w" + items[block_->fg].name + "``|left|" + to_string(block_->fg) + "|\nadd_spacer|small|\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "" + (block_->id == 0 or block_->pr == 0 ? "\nadd_textbox|This machine is out of order.|left|\nend_dialog|vending|Close||" : "\nadd_label_with_icon|sml|The machine contains a total of " + to_string(block_->c_) + " `2" + items[block_->id].ori_name + "``. |left|" + to_string(block_->id) + "|\nadd_spacer|small|\nadd_textbox|For a cost of:|left|\nadd_label_with_icon|small|" + (block_->pr < 0 ? "1" : to_string(block_->pr)) + " x `8World Lock``|left|242|\nadd_spacer|small|\nadd_textbox|You will get:|left|\nadd_label_with_icon|small|" + (block_->pr < 0 ? to_string(block_->pr * -1) : "1") + " x `2" + items[block_->id].ori_name + "``|left|" + to_string(block_->id) + "|\nadd_spacer|small|" + (block_->pr < 0 and (block_->pr * -1 > block_->c_) ? "\nadd_textbox|You'll need to wait for the owner to stock up to at least 1 World Lock's worth before you can buy.|left|\nend_dialog|vending|Close||" : "\nadd_textbox|You have " + to_string(get_wls(peer)) + " World Locks.|left|\nadd_text_input|buycount|How many would you like to buy?|0|3|\nembed_data|expectprice|" + to_string(block_->pr) + "\nembed_data|expectitem|" + to_string(block_->id) + "\nend_dialog|vending|Close|Buy|"));
}
uint16_t get_weather_id(uint32_t block_id) {
	switch (block_id) {
	case 3694: {
		return 28;
	}
	case 3832: {
		return 29;
	}
	case 5000: {
		return 34;
	}
	case 1490: {
		return 10;
	}
	case 934: {
		return 2;
	}
	case 946: {
		return 3;
	}
	case 932: {
		return 4;
	}
	case 984: {
		return 5;
	}
	case 1210: {
		return 8;
	}
	case 1364: {
		return 11;
	}
	case 1750: {
		return 15;
	}
	case 2046: {
		return 17;
	}
	case 2284: {
		return 18;
	}
	case 2744: {
		return 19;
	}
	case 3252: {
		return 20;
	}
	case 3446: {
		return 21;
	}
	case 3534: {
		return 22;
	}
	case 4242: {
		return 30;
	}
	case 4486: {
		return 31;
	}
	case 4776: {
		return 32;
	}
	case 4892: {
		return 33;
	}
	case 5112: {
		return 35;
	}
	case 5654: {
		return 36;
	}
	case 5716: {
		return 37;
	}
	case 5958: {
		return 38;
	}
	case 6854: {
		return 42;
	}
	case 7644: {
		return 44;
	}
	case 8896: {
		return 47;
	}
	case 8836: {
		return 48;
	}
	case 10286: {
		return 51;
	}
	case 11880: {
		return 59;
	}
	case 12054: {
		return 60;
	}
	case 12056: {
		return 61;
	}
	}
	return 0;
}
bool is_false_state(WorldBlock block_, int t_) {
	if (items[block_.fg].collisionType == 0) return false;
	if (items[block_.fg].collisionType == 1) {
		return true;
	}
	if (block_.flags & t_) {
		return false;
	}
	return true;
}
vector<vector<int>> lock_tiles(World* w_, int st_x, int st_y, int lock_size) {
	try {
		int layer_ = 0;
		int og_lock_size = lock_size;
		vector<vector<int>> new_tiles{};
		vector<vector<int>> new_lock{};
		if (w_->blocks.at(st_x + (st_y * 100)).locked) {
			return new_lock;
		}
		if (st_x - 1 > 0) {
			new_tiles.push_back({ st_x - 1 + (st_y * 100), 1 });
			if (not_mod(w_->blocks.at(st_x - 1 + (st_y * 100)), st_x - 1, st_y)) new_lock.push_back({ st_x - 1, st_y });
		}
		if (st_y - 1 > 0) {
			new_tiles.push_back({ st_x + ((st_y - 1) * 100), 2 });
			if (not_mod(w_->blocks.at(st_x + ((st_y - 1) * 100)), st_x, st_y - 1)) new_lock.push_back({ st_x, st_y - 1 });
		}
		if (st_x + 1 < 100) {
			new_tiles.push_back({ st_x + 1 + (st_y * 100), 3 });
			if (not_mod(w_->blocks.at(st_x + 1 + (st_y * 100)), st_x + 1, st_y)) new_lock.push_back({ st_x + 1, st_y });
		}
		if (st_y + 1 < 60) {
			new_tiles.push_back({ st_x + ((st_y + 1) * 100), 4 });
			if (not_mod(w_->blocks.at(st_x + ((st_y + 1) * 100)), st_x, st_y + 1)) new_lock.push_back({ st_x, st_y + 1 });
		}
		int ySize = w_->blocks.size() / 100, xSize = w_->blocks.size() / ySize;
		int max_up = 0;
		int max_down = 0;
		int max_right = 0;
		int max_left = 0;
		vector<WorldBlock> shadow_copy = w_->blocks;
		for (int i_ = 0; i_ < new_tiles.size(); i_++) {
			if (new_lock.size() >= og_lock_size) {
				break;
			}
			vector<int> test__ = new_tiles.at(i_);
			int x_ = test__.at(0) % 100, y_ = test__.at(0) / 100;
			int where_ = test__.at(1);
			if (where_ == 1) {
				if (y_ - 1 < 0) {
				}
				else {
					if (not shadow_copy.at(x_ + ((y_ - 1) * 100)).scanned) {
						if (not_mod(shadow_copy.at(x_ + ((y_ - 1) * 100)), x_, y_ - 1)) {
							shadow_copy.at(x_ + (y_ * 100)).scanned = true;
							if (max_up != 0 and y_ > max_up + 1 and y_ - 1 > 0) {
								new_tiles.push_back({ x_ + ((y_ - 1) * 100), 1 });
							}
							new_lock.push_back({ x_, y_ - 1 });
							if (new_lock.size() >= og_lock_size) {
								break;
							}
						}
						else {
							shadow_copy.at(x_ + (y_ * 100)).scanned = true;
							if (max_up != 0 and y_ > max_up + 1 and y_ - 1 > 0) {
								new_tiles.push_back({ x_ + ((y_ - 1) * 100), 1 });
								if (new_lock.size() >= og_lock_size) {
									break;
								}
							}
							lock_size++;
						}
					}
				}
			}
			if (where_ == 2) {
				if (x_ + 1 > 100) {

				}
				else {
					if (not shadow_copy.at(x_ + 1 + (y_ * 100)).scanned) {
						if (not_mod(shadow_copy.at(x_ + 1 + (y_ * 100)), x_ + 1, y_)) {
							shadow_copy.at(x_ + (y_ * 100)).scanned = true;
							if (max_left != 0 and x_ < max_left - 1 and x_ + 1 < 100) {
								new_tiles.push_back({ x_ + 1 + (y_ * 100), 2 });
							}
							new_lock.push_back({ x_ + 1, y_ });
							if (new_lock.size() >= og_lock_size) {
								break;
							}
						}
						else {
							shadow_copy.at(x_ + (y_ * 100)).scanned = true;
							if (max_left != 0 and x_ < max_left - 1 and x_ + 1 < 100) {
								new_tiles.push_back({ x_ + 1 + (y_ * 100), 2 });
								if (new_lock.size() >= og_lock_size) {
									break;
								}
							}
							lock_size++;
						}
					}
				}

			}
			if (where_ == 3) {
				if (y_ + 1 > 60) {

				}
				else {
					if (not shadow_copy.at(x_ + ((y_ + 1) * 100)).scanned) {
						if (not_mod(shadow_copy.at(x_ + ((y_ + 1) * 100)), x_, y_ + 1)) {
							shadow_copy.at(x_ + (y_ * 100)).scanned = true;
							if (max_down != 0 and y_ < max_down - 1 and y_ + 1 < 60) {
								new_tiles.push_back({ x_ + ((y_ + 1) * 100), 3 });
							}
							new_lock.push_back({ x_, y_ + 1 });
							if (new_lock.size() >= og_lock_size) {
								break;
							}
						}
						else {
							shadow_copy.at(x_ + (y_ * 100)).scanned = true;
							if (max_down != 0 and y_ < max_down - 1 and y_ + 1 < 60) {
								new_tiles.push_back({ x_ + ((y_ + 1) * 100), 3 });
								if (new_lock.size() >= og_lock_size) {
									break;
								}
							}
							lock_size++;
						}
					}
				}

			}
			if (where_ == 4) {
				if (x_ - 1 < 0) {
				}
				else {
					if (not shadow_copy.at(x_ - 1 + (y_ * 100)).scanned) {
						if (not_mod(shadow_copy.at(x_ - 1 + (y_ * 100)), x_ - 1, y_)) {
							shadow_copy.at(x_ + (y_ * 100)).scanned = true;
							if (max_right != 0 and x_ > max_right + 1 and x_ - 1 > 0) {
								new_tiles.push_back({ x_ - 1 + (y_ * 100), 4 });
							}
							new_lock.push_back({ x_ - 1, y_ });
							if (new_lock.size() >= og_lock_size) {
								break;
							}
						}
						else {
							shadow_copy.at(x_ + (y_ * 100)).scanned = true;
							if (max_right != 0 and x_ > max_right + 1 and x_ - 1 > 0) {
								new_tiles.push_back({ x_ - 1 + (y_ * 100), 4 });
								if (new_lock.size() >= og_lock_size) {
									break;
								}
							}
							lock_size++;
						}
					}
				}

			}
			if (i_ == new_tiles.size() - 1) {
				layer_++;
				if (og_lock_size <= 10 or lock_size - new_lock.size() <= 5) layer_ = 0;
				int t_ = 1;
				if (st_x - t_ < 0) {
					//lock_size++;

				}
				else {
					while (shadow_copy.at(st_x - t_ + (st_y * 100)).scanned) {
						t_++;
						if (st_x - t_ < 0) {
							break;
						}
						else {
							if (not shadow_copy.at(st_x - t_ + (st_y * 100)).scanned) {
								if (not_mod(shadow_copy.at(st_x - t_ + ((st_y + layer_) * 100)), st_x - t_, st_y + layer_)) {
									max_right = st_x - t_;
									new_tiles.push_back({ st_x - t_ + ((st_y + layer_) * 100), 1 });
									new_lock.push_back({ st_x - t_, (st_y + layer_) });
									if (new_lock.size() >= og_lock_size) {
										break;
									}
								}
								else {
									max_right = st_x - t_;
									new_tiles.push_back({ st_x - t_ + ((st_y + layer_) * 100), 1 });
									if (new_lock.size() >= og_lock_size) {
										break;
									}
									lock_size++;
								}
								break;
							}
						}
					}
				}
				t_ = 1;
				if (st_y - t_ < 0) {
					//lock_size++;

				}
				else {
					while (shadow_copy.at(st_x + ((st_y - t_) * 100)).scanned) {
						t_++;
						if (st_y - t_ < 0) {
							break;
						}
						else {
							if (not shadow_copy.at(st_x + ((st_y - t_) * 100)).scanned) {
								if (not_mod(shadow_copy.at(st_x - layer_ + ((st_y - t_) * 100)), st_x - layer_, st_y - t_)) {
									max_up = st_y - t_;
									new_tiles.push_back({ st_x - layer_ + ((st_y - t_) * 100), 2 });
									new_lock.push_back({ st_x - layer_, st_y - t_ });
									if (new_lock.size() >= og_lock_size) {
										break;
									}
								}
								else {
									max_up = st_y - t_;
									new_tiles.push_back({ st_x - layer_ + ((st_y - t_) * 100), 2 });
									if (new_lock.size() >= og_lock_size) {
										break;
									}
									lock_size++;
								}
								break;
							}
						}
					}
				}
				t_ = 1;
				if (st_x + t_ > 100) {

				}
				else {
					while (shadow_copy.at(st_x + t_ + (st_y * 100)).scanned) {
						t_++;
						if (st_x + t_ > 100) {
							break;
						}
						else {
							if (st_y - layer_ < 0) layer_ = 0;
							if (not shadow_copy.at(st_x + t_ + (st_y * 100)).scanned) {
								if (not_mod(shadow_copy.at(st_x + t_ + ((st_y - layer_) * 100)), st_x + t_, st_y - layer_)) {
									max_left = st_x + t_;
									new_tiles.push_back({ st_x + t_ + ((st_y - layer_) * 100), 3 });
									new_lock.push_back({ st_x + t_, st_y - layer_ });
									if (new_lock.size() >= og_lock_size) {
										break;
									}
								}
								else {
									max_left = st_x + t_;
									new_tiles.push_back({ st_x + t_ + ((st_y - layer_) * 100), 3 });
									if (new_lock.size() >= og_lock_size) {
										break;
									}
									lock_size++;
								}
								break;
							}
						}
					}
				}
				t_ = 1;
				if (st_y + t_ > 60) {

				}
				else {
					while (shadow_copy.at(st_x + ((st_y + t_) * 100)).scanned) {
						t_++;
						if (st_y + t_ > 60) {
							break;
						}
						else {
							if (not shadow_copy.at(st_x + ((st_y + t_) * 100)).scanned) {
								if (not_mod(shadow_copy.at(st_x + layer_ + ((st_y + t_) * 100)), st_x + layer_, st_y + t_)) {
									max_down = st_y + t_;
									new_tiles.push_back({ st_x + layer_ + ((st_y + t_) * 100), 4 });
									new_lock.push_back({ st_x + layer_, st_y + t_ });
									if (new_lock.size() >= og_lock_size) {
										break;
									}
								}
								else {
									max_down = st_y + t_;
									new_tiles.push_back({ st_x + layer_ + ((st_y + t_) * 100), 4 });
									if (new_lock.size() >= og_lock_size) {
										break;
									}
									lock_size++;
								}
								break;
							}
						}
					}
				}
			}
		}
		if (new_lock.size() > og_lock_size) {
			int fix_size = (new_lock.size() - og_lock_size);
			for (int i_ = 0; i_ < fix_size; i_++) {
				new_lock.pop_back();
			}
		} vector<int> erase_later{};
		vector<WorldBlock> shadow_copy_2 = w_->blocks;
		for (int i_ = 0; i_ < new_lock.size(); i_++) {
			vector<int> asd_ = new_lock.at(i_);
			shadow_copy_2.at(asd_.at(0) + (asd_.at(1) * 100)).locked = true;
			shadow_copy_2.at(asd_.at(0) + (asd_.at(1) * 100)).lock_origin = (st_x + (st_y * 100));
		}
		WorldBlock target_to_reach = shadow_copy_2.at(st_x + (st_y * 100)); // og coordinatess
		for (int i_ = 0; i_ < new_lock.size(); i_++) {
			vector<int> asd_ = new_lock.at(i_);
			vector<int> new_tiles{};
			new_tiles.push_back(asd_.at(0) + (asd_.at(1) * 100));
			int ySize = w_->blocks.size() / 100, xSize = w_->blocks.size() / ySize;
			bool reachable = false;
			vector<vector<int>> after_process{};
			for (int i2 = 0; i2 < new_tiles.size(); i2++) {
				int x_ = new_tiles.at(i2) % 100, y_ = new_tiles.at(i2) / 100;
				if ((x_ + (y_ * 100)) == st_x + (st_y * 100) or (x_ + 1 + (y_ * 100)) == st_x + (st_y * 100) or (x_ - 1 + (y_ * 100)) == st_x + (st_y * 100) or (x_ + ((y_ + 1) * 100)) == st_x + (st_y * 100) or (x_ + ((y_ - 1) * 100)) == st_x + (st_y * 100)) {
					reachable = true;
				} if (x_ < 99 and shadow_copy_2.at(x_ + 1 + (y_ * 100)).locked and shadow_copy_2.at(x_ + 1 + (y_ * 100)).lock_origin == (st_x + (st_y * 100))) {
					if (not shadow_copy_2.at(x_ + 1 + (y_ * 100)).scanned) {
						shadow_copy_2.at(x_ + 1 + (y_ * 100)).scanned = true;
						after_process.push_back({ x_ + 1, y_ });
						new_tiles.push_back(x_ + 1 + (y_ * 100));
					}
				} if (x_ > 0 and shadow_copy_2.at(x_ - 1 + (y_ * 100)).locked and shadow_copy_2.at(x_ - 1 + (y_ * 100)).lock_origin == (st_x + (st_y * 100))) {
					if (not shadow_copy_2.at(x_ - 1 + (y_ * 100)).scanned) {
						shadow_copy_2.at(x_ - 1 + (y_ * 100)).scanned = true;
						after_process.push_back({ x_ - 1, y_ });
						new_tiles.push_back(x_ - 1 + (y_ * 100));
					}
				} if (y_ < 59 and shadow_copy_2.at(x_ + ((y_ + 1) * 100)).locked and shadow_copy_2.at(x_ + ((y_ + 1) * 100)).lock_origin == (st_x + (st_y * 100))) {
					if (not shadow_copy_2.at(x_ + ((y_ + 1) * 100)).scanned) {
						shadow_copy_2.at(x_ + ((y_ + 1) * 100)).scanned = true;
						after_process.push_back({ x_, y_ + 1 });
						new_tiles.push_back(x_ + ((y_ + 1) * 100));
					}
				} if (y_ > 0 and shadow_copy_2.at(x_ + ((y_ - 1) * 100)).locked and shadow_copy_2.at(x_ + ((y_ - 1) * 100)).lock_origin == (st_x + (st_y * 100))) {
					if (not shadow_copy_2.at(x_ + ((y_ - 1) * 100)).scanned) {
						shadow_copy_2.at(x_ + ((y_ - 1) * 100)).scanned = true;
						after_process.push_back({ x_, y_ - 1 });
						new_tiles.push_back(x_ + ((y_ - 1) * 100));
					}
				}
			}
			for (vector<int> cleanup : after_process) {
				shadow_copy_2.at(cleanup.at(0) + ((cleanup.at(1)) * 100)).scanned = false;
			}
			if (not reachable) {
				erase_later.push_back(i_);
			}
		}
		int er_ = 0;
		for (int a_ : erase_later) {
			int aa = a_ - er_;
			new_lock.erase(new_lock.begin() + aa);
			er_++;
		} return new_lock;
	}
	catch (out_of_range) {
		vector<vector<int>> asd{};
		return asd;
	}
}
void send_edit_lock(ENetPeer* peer, World* world_, int t_, int x_, int y_) {
	uint32_t guild_id = world_->guild_id;
	vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
	if (p != guilds.end()) {
		string access_list_ = "";
		for (int i_ = 0; i_ < world_->admins.size(); i_++) {
			access_list_ += "\nadd_checkbox|checkbox_/" + world_->admins[i_] + "|`w" + world_->admins[i_] + "``|1";
		}
		if (access_list_.empty())
			access_list_ = "\nadd_label|small|Currently, you're the only one with access.``|left";
		Guild* guild_information = &guilds[p - guilds.begin()];
		string guild_key = "\nadd_button|getKey|Get Guild Key|noflags|0|0|";
		string guild_upg = "";
		string guild_mas = "\nadd_textbox|Increase your guild level to `w3`` or more and you can set a guild mascot!|left|";
		int c_ = 0;
		modify_inventory(peer, 5816, c_);
		if (c_ != 0) {
			guild_key = "";
		}
		if (guild_information->guild_level == 1 and guild_information->guild_xp >= 405000) {
			guild_upg = "\nadd_button|upg2|Upgrade Guild|noflags|0|0|\nadd_label|small|`0Cost: `2200000 Gems|left|\nadd_spacer|small|";
		}
		if (guild_information->guild_level == 2 and guild_information->guild_xp >= 1215000) {
			guild_upg = "\nadd_button|upg3|Upgrade Guild|noflags|0|0|\nadd_label|small|`0Cost: `2300000 Gems|left|\nadd_spacer|small|";
		}
		if (guild_information->guild_level == 3 and guild_information->guild_xp >= 2430000) {
			guild_upg = "\nadd_button|upg4|Upgrade Guild|noflags|0|0|\nadd_label|small|`0Cost: `2400000 Gems|left|\nadd_spacer|small|";
		}
		if (guild_information->guild_level == 4 and guild_information->guild_xp >= 4050000) {
			guild_upg = "\nadd_button|upg5|Upgrade Guild|noflags|0|0|\nadd_label|small|`0Cost: `2500000 Gems|left|\nadd_spacer|small|";
		}
		if (guild_information->guild_level == 5 and guild_information->guild_xp >= 7290000) {
			guild_upg = "\nadd_button|upg6|Upgrade Guild|noflags|0|0|\nadd_label|small|`0Cost: `21000000 Gems|left|\nadd_spacer|small|";
		}
		if (guild_information->guild_level == 6 and guild_information->guild_xp >= 11430000) {
			guild_upg = "\nadd_button|upg7|Upgrade Guild|noflags|0|0|\nadd_label|small|`0Cost: `22000000 Gems|left|\nadd_spacer|small|";
		}
		if (guild_information->guild_level == 7 and guild_information->guild_xp >= 16200000) {
			guild_upg = "\nadd_button|upg8|Upgrade Guild|noflags|0|0|\nadd_label|small|`0Cost: `23000000 Gems|left|\nadd_spacer|small|";
		}
		if (guild_information->guild_level == 8 and guild_information->guild_xp >= 21870000) {
			guild_upg = "\nadd_button|upg9|Upgrade Guild|noflags|0|0|\nadd_label|small|`0Cost: `24000000 Gems|left|\nadd_spacer|small|";
		}
		if (guild_information->guild_level == 9 and guild_information->guild_xp >= 28350000) {
			guild_upg = "\nadd_button|upg10|Upgrade Guild|noflags|0|0|\nadd_label|small|`0Cost: `25000000 Gems|left|\nadd_spacer|small|";
		}
		if (guild_information->guild_level == 10 and guild_information->guild_xp >= 38700000) {
			guild_upg = "\nadd_button|upg11|Upgrade Guild|noflags|0|0|\nadd_label|small|`0Cost:`26000000 Gems|left|\nadd_spacer|small|";
		}
		if (guild_information->guild_level == 11 and guild_information->guild_xp >= 48600000) {
			guild_upg = "\nadd_button|upg12|Upgrade Guild|noflags|0|0|\nadd_label|small|`0Cost: `28000000 Gems|left|\nadd_spacer|small|";
		}
		if (guild_information->guild_level == 12 and guild_information->guild_xp >= 60547500) {
			guild_upg = "\nadd_button|upg13|Upgrade Guild|noflags|0|0|\nadd_label|small|`0Cost: `29000000 Gems|left|\nadd_spacer|small|";
		}
		if (guild_information->guild_level == 13 and guild_information->guild_xp >= 73710000) {
			guild_upg = "\nadd_button|upg14|Upgrade Guild|noflags|0|0|\nadd_label|small|`0Cost: `210000000 Gems|left|\nadd_spacer|small|";
		}//create_guild_mascot
		if (guild_information->guild_level >= 3) guild_mas = "\nadd_button|create_guild_mascot|`0Change Guild Mascot|noflags|0|0|";
		gamepacket_t p;
		p.Insert("OnDialogRequest");
		p.Insert("add_label_with_icon|big|`wEdit " + items[t_].name + "``|left|" + to_string(t_) + "|\nadd_spacer|small|\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\nadd_player_info|" + guild_information->guild_name + " | " + to_string(guild_information->guild_level) + "|" + to_string(guild_information->guild_xp) + "|" + to_string(guild_lvl[guild_information->guild_level - 1][0]) + "|\nadd_spacer|small|"+ guild_upg +"\nadd_textbox|`wManage Guild Member access:``|left|\nadd_checkbox|checkbox_coleader|Enable Co-Leader access|" + (guild_information->coleader_access ? "1" : "0") + "\nadd_checkbox|checkbox_elder|Enable Co-Leader and Elder access|" + (guild_information->coleader_elder_access ? "1" : "0") + "\nadd_checkbox|checkbox_member|Enable all Members access|" + (guild_information->all_access ? "1" : "0") + "\nadd_spacer|small|" + (guild_information->all_access ? "\nadd_label|small|`2All guild members have access.``|left" : (guild_information->coleader_elder_access ? "\nadd_label|small|`2Guild Co-Leaders and Elders have access.``|left" : (guild_information->coleader_access ? "\nadd_label|small|`2Guild Co-Leaders have access.``|left" : ""))) + "\nadd_spacer|small|\nadd_label|small|`wAccess List:``|left\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\nadd_spacer|small|" + access_list_ + "\nadd_spacer|small|\nadd_player_picker|playerNetID|`wAdd``|\nadd_spacer|small|"+ guild_mas +"\nadd_spacer|small|\nadd_checkbox|checkbox_displaymascot|Display Guild Mascot on the Guild Lock|" + (guild_information->unlocked_mascot == 1 ? "1" : "0") + "\nadd_checkbox|checkbox_public|Allow anyone to build|" + (world_->open_to_public ? "1" : "0") + "\nadd_checkbox|checkbox_disable_music|Disable Custom Music Blocks|" + (world_->disable_music_blocks ? "1" : "0") + "\nadd_text_input|tempo|Music BPM|" + to_string(world_->music_bpm) + "|3|\nadd_checkbox|checkbox_disable_music_render|Make Custom Music Blocks invisible|" + (world_->make_music_blocks_invisible ? "1" : "0") + (not pInfo(peer)->home_world.empty() ? "\nadd_smalltext|Your current home world is: " + pInfo(peer)->home_world + "|left|" : "") + "\nadd_checkbox|checkbox_set_as_home_world|Set as Home World|" + (pInfo(peer)->home_world == world_->name ? "1" : "0") + "|\nadd_text_input|minimum_entry_level|World Level: |" + to_string(world_->entry_level) + "|3|\nadd_smalltext|Set minimum world entry level.|\nadd_button|sessionlength_dialog|`wSet World Timer``|noflags|0|0|\nadd_spacer|small|\nadd_button|changecat|`wCategory: None``|noflags|0|0|" + guild_key + "\nadd_button|abondonguildconfirm|`wAbandon Guild``|noflags|0|0|\nend_dialog|editguildlock|Cancel|OK|\nadd_quick_exit|");
		p.CreatePacket(peer);
	}
}
void reset_(WorldBlock* block_, int x_, int y_, World* world_) {
	for (int i_ = 0; i_ < world_->machines.size(); i_++) {
		if (world_->machines[i_].x == x_ and world_->machines[i_].y == y_) {
			world_->machines.erase(world_->machines.begin() + i_);
			break;
		}
	}
	if (items[block_->fg].blockType == BlockTypes::BULLETIN_BOARD || items[block_->fg].blockType == BlockTypes::MAILBOX) {
		for (int i_ = 0; i_ < world_->bulletin.size(); i_++) {
			if (world_->bulletin[i_].x == x_ and world_->bulletin[i_].y == y_) {
				world_->bulletin.erase(world_->bulletin.begin() + i_);
				i_--;
			}
		}
		for (int i_ = 0; i_ < world_->bulletins.size(); i_++) {
			if (world_->bulletins[i_].x == x_ and world_->bulletins[i_].y == y_) {
				world_->bulletins.erase(world_->bulletins.begin() + i_);
				i_--;
			}
		}
	}
	if (block_->fg == 6016) {
		for (int i_ = 0; i_ < world_->gscan.size(); i_++) {
			if (world_->gscan[i_].x == x_ and world_->gscan[i_].y == y_) {
				world_->gscan.erase(world_->gscan.begin() + i_);
				i_--;
			}
		}
	}
	if (block_->fg == 8246 || block_->fg == 10258 || block_->fg == 1436) {
		for (int i_ = 0; i_ < world_->cctv_settings.size(); i_++) {
			if (world_->cctv_settings[i_].x == x_ and world_->cctv_settings[i_].y == y_) {
				world_->cctv_settings.erase(world_->cctv_settings.begin() + i_);
				i_--;
			}
		}
		for (int i_ = 0; i_ < world_->cctv.size(); i_++) {
			if (world_->cctv[i_].x == x_ and world_->cctv[i_].y == y_) {
				world_->cctv.erase(world_->cctv.begin() + i_);
				i_--;
			}
		}
	}
	if (block_->fg == 2646) {
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or world_->name != pInfo(currentPeer)->world or block_->spotlight != pInfo(currentPeer)->tankIDName) continue;
			pInfo(currentPeer)->spotlight = false, update_clothes(currentPeer);
			gamepacket_t p, p2;
			p.Insert("OnConsoleMessage"), p.Insert("Back to anonymity. (`$In the Spotlight`` mod removed)"), p.CreatePacket(currentPeer);
			p2.Insert("OnTalkBubble"), p2.Insert(pInfo(currentPeer)->netID), p2.Insert("Lights out!"), p2.CreatePacket(currentPeer);
		}
	}
	if (block_->fg == 0) block_->bg = 0;
	else block_->fg = 0;
	block_->id = 0, block_->hp = -1, block_->planted = 0, block_->fruit = 1, block_->sp = 0, block_->txt = "";
	block_->wl = 0, block_->pr = 0, block_->c_ = 0;
	block_->door_destination = "", block_->door_id = "", block_->open = true;
	block_->flags = 0x00000000;
	block_->last_punch_weather = 0;
	block_->projectile_speed = 100, block_->rate_of_fire = 10;
	block_->enabled = false;
	block_->invert = false, block_->spin = false, block_->gravity = 50;
	block_->ice_age = false, block_->volcano = false, block_->islands = false;
	block_->magnetron = false;
	block_->open_to_public = false;
	block_->empty_air = false;
	block_->admins.clear();
	block_->owner_name = "";
	block_->build_only = false;
	block_->limit_admins = false;
	block_->crystals.clear();
	block_->r = 255;
	block_->g = 128;
	block_->b = 64;
	block_->portrait.c_expression = 1;
	block_->portrait.c_face = 0;
	block_->portrait.c_hair = 0;
	block_->portrait.c_hair_colour = 0;
	block_->portrait.c_head = 0;
	block_->portrait.c_skin = 0;
	block_->bunny_egg_progress = 0;
	block_->heart_monitor = "";
	block_->spotlight = "";
}
bool nosymbols(string name) {
	if (name.find_first_not_of("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789") != string::npos) {
		return false;
	}
	else {
		return true;
	}
}
inline long long GetCurrentTimeInternalSeconds() {
	return (duration_cast<seconds>(system_clock::now().time_since_epoch())).count();
}
inline int calcBanDuration(const long long banDuration)
{
	// ReSharper disable once CppInitializedValueIsAlwaysRewritten
	auto duration = 0;
	duration = banDuration - GetCurrentTimeInternalSeconds();
	if (duration <= 0) return 0;
	else return duration;
}
void call_dialog(ENetPeer* p_, string cch) {
	if (pInfo(p_)->trading_with != -1 and cch.find("trade_") == string::npos) {
		cancel_trade(p_, false, true);
		return;
	}
	if (pInfo(p_)->world.empty() and not pInfo(p_)->tankIDName.empty()) return;
	

	if (cch.find("banner_update") != string::npos) {
		stringstream ss(cch);
		string to = "", btn = "";
		bool teaa = false;
		while (getline(ss, to, '\n')) {
			vector<string> infoDat = explode("|", to);
			auto InfoDat = infoDat;
			bool isBandolier = false;
			if (infoDat.size() == 2) {
				if (infoDat[0] == "buttonClicked") btn = infoDat[1];
				if (infoDat[0] == "changeitem") {
					int id = atoi(infoDat[1].c_str());
					if (id == 18 || id == 32) {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(p_)->netID);
						p.Insert("`4OOPS`o, you can't put this item on bZandolier.");
						p.Insert(0);
						p.CreatePacket(p_);
						banner_dialog(p_);
						return;
					}
					pInfo(p_)->banner_item = id;
					banner_dialog(p_);
				}
				if (btn == "reset") {
					pInfo(p_)->banner_item = 0;
					pInfo(p_)->banner_type = 0;
					banner_dialog(p_);
				}
				if (btn == "edit_pattern") {
					cout << "?" << endl;
					gamepacket_t p;
					p.Insert("OnDialogRequest");
					p.Insert(
						"set_default_color|`o\n"
						"add_label_with_icon|big|`wBanner Bandolier``|left|" + to_string(bandolier_pattern::get_pattern_as_display(pInfo(p_)->banner_type).second) + "|\n"
						"add_spacer|small|\n"
						"add_textbox|Pick a pattern for your banner.|left|\n"
						"add_label_with_icon_button|big|" + bandolier_pattern::get_pattern_as_display(bandolier_pattern::HARLEQUIN).first + "|left|" + to_string(bandolier_pattern::get_pattern_as_display(bandolier_pattern::HARLEQUIN).second) + "|pattern_0|\n"
						"add_label_with_icon_button|big|" + bandolier_pattern::get_pattern_as_display(bandolier_pattern::SLANT).first + "|left|" + to_string(bandolier_pattern::get_pattern_as_display(bandolier_pattern::SLANT).second) + "|pattern_1|\n"
						"add_label_with_icon_button|big|" + bandolier_pattern::get_pattern_as_display(bandolier_pattern::STRIPE).first + "|left|" + to_string(bandolier_pattern::get_pattern_as_display(bandolier_pattern::STRIPE).second) + "|pattern_2|\n"
						"add_label_with_icon_button|big|" + bandolier_pattern::get_pattern_as_display(bandolier_pattern::PANEL).first + "|left|" + to_string(bandolier_pattern::get_pattern_as_display(bandolier_pattern::PANEL).second) + "|pattern_3|\n"
						"add_label_with_icon_button|big|" + bandolier_pattern::get_pattern_as_display(bandolier_pattern::CROSS).first + "|left|" + to_string(bandolier_pattern::get_pattern_as_display(bandolier_pattern::CROSS).second) + "|pattern_4|\n"
						"end_dialog|banner_update|Cancel||"
					);
					p.CreatePacket(p_);
				}
				if (btn == "pattern_0") {
					pInfo(p_)->banner_type = 0;
					banner_dialog(p_);
				}
				if (btn == "pattern_1") {
					pInfo(p_)->banner_type = 1;
					banner_dialog(p_);
				}
				if (btn == "pattern_2") {
					pInfo(p_)->banner_type = 2;
					banner_dialog(p_);
				}
				if (btn == "pattern_3") {
					pInfo(p_)->banner_type = 3;
					banner_dialog(p_);
				}
				if (btn == "pattern_4") {
					pInfo(p_)->banner_type = 4;
					banner_dialog(p_);
				}
				update_clothes(p_);
			}
		}
	}
	else if (cch.find("changename") != string::npos) {
		stringstream ss(cch);
		string to = "", btn = "";
		bool changename = false;
		string newname = "";
		while (getline(ss, to, '\n')) {
			vector<string> infoDat = explode("|", to);
			auto InfoDat = infoDat;
			if (infoDat.size() == 2) {
				if (infoDat[0] == "buttonClicked") btn = infoDat[1];
				if (infoDat[0] == "dialog_name" && infoDat[1] == "changename") changename = true;
				if (changename) {
					if (pInfo(p_)->tankIDName.empty()) continue;
					if (infoDat[0] == "newname") {
						newname = infoDat[1];
						if (newname == "") continue;
						if (!experimental::filesystem::exists("players/" + PlayerDB::getProperName(newname) + "_.json")) {
							if (!nosymbols(newname)) {
								gamepacket_t p;
								p.Insert("OnDialogRequest");
								p.Insert("set_default_color|`o\n\nadd_label_with_icon|big|`wChange your GrowID`|left|1280|\nadd_label|small|`oPlease don't use `wsymbols `oon the name you are changing to.|left||left|\nadd_smalltext|`oThis will change your GrowID `4permanently`o. You can't change it again after 30 days.|left|\nadd_smalltext|`oYour `wBirth Certificate `owill be consumed if you click `5Change it`o.|left|\nadd_smalltext|`oChoose an appropriate name or `6we will change it for you`o!|left|\nadd_smalltext|`4Warning `o: Worlds owned won't be transfered if you change your name!|left|\nadd_label|small|`oEnter your new name :|left|\nadd_text_input|newname|||14|\nend_dialog|changename|Cancel|`oChange it|\n");
								p.CreatePacket(p_);
								continue;
							}
							if (std::experimental::filesystem::exists("players/" + pInfo(p_)->tankIDName + "_.json")) {

								ifstream fg("players/" + pInfo(p_)->tankIDName + "_.json");
								json j;
								fg >> j;
								fg.close();
								j["name"] = PlayerDB::getProperName(newname);
								ofstream fs("players/" + pInfo(p_)->tankIDName + "_.json");
								fs << j;
								fs.close();
							}
							if (experimental::filesystem::exists("players/" + pInfo(p_)->tankIDName + "_.json")) {
								rename(("players/" + pInfo(p_)->tankIDName + "_.json").c_str(), ("players/" + PlayerDB::getProperName(newname) + "_.json").c_str());
							}
							gamepacket_t p;
							p.Insert("SetHasGrowID");
							p.Insert(1);
							p.Insert(PlayerDB::getProperName(newname));
							p.Insert(pInfo(p_)->tankIDPass);
							p.CreatePacket(p_);
						}
						int got = 0;
						modify_inventory(p_, 1280, got);
						if (got == 0) break;
						modify_inventory(p_, 1280, got = -1);
						ofstream savebantime("db/birth_certificate/_" + (pInfo(p_)->tankIDName + ".txt"));
						savebantime << (GetCurrentTimeInternalSeconds() + (7 * 86400)) << endl;
						savebantime.close();
						gamepacket_t p;
						p.Insert("OnDialogRequest");
						p.Insert("set_default_color|`o\n\nadd_label_with_icon|big|`wGrowID Change!`|left|1280|\nadd_label|small|`oYour new `wGrowID `ois `w" + PlayerDB::getProperName(newname) + "`o. Write it down, it will be required to log on from now on!|left|\nadd_quick_exit|\nend_dialog||Continue|");
						p.CreatePacket(p_);
						//Server::OnDialogRequest(peer, "set_default_color|`o\n\nadd_label_with_icon|big|`wGrowID Change!`|left|1280|\nadd_label|small|`oYour new `wGrowID `ois `w" + PlayerDB::getProperName(newname) + "`o. Write it down, it will be required to log on from now on!|left|\nadd_quick_exit|\nend_dialog||Continue|");
					}
				}
			}
		}
	}
	
	else if (cch.find("make_mascotss") != string::npos) {
		stringstream ss(cch);
		string to = "", btn = "";
		bool mascot_dialog = false;
		while (getline(ss, to, '\n')) {
			vector<string> infoDat = explode("|", to);
			auto InfoDat = infoDat;
			if (infoDat.size() == 2) {
				if (infoDat[0] == "buttonClicked") btn = infoDat[1];
				if (infoDat[0] == "dialog_name" && infoDat[1] == "make_mascotss") mascot_dialog = true;

				if (mascot_dialog) {
					if (InfoDat[0] == "select_bg_mascot") {
						string name_ = pInfo(p_)->world;
						vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
						if (p != worlds.end()) {
							int item = atoi(InfoDat[1].c_str());
							if (item < 0 or item > items.size()) break;
							World* world_ = &worlds[p - worlds.begin()];
							WorldBlock* block_ = &world_->blocks[pInfo(p_)->lastwrenchx + (pInfo(p_)->lastwrenchy * 100)];
							if (block_->fg != 5814) break;
							if (pInfo(p_)->guild_id != world_->guild_id) break;
							uint32_t guild_id = pInfo(p_)->guild_id;
							vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
							if (p != guilds.end()) {
								Guild* guild_information = &guilds[p - guilds.begin()];
								if (item == guild_information->guild_mascot[1]) break;
								uint32_t my_rank = 0;
								for (GuildMember member_search : guild_information->guild_members) {
									if (member_search.member_name == pInfo(p_)->tankIDName) {
										my_rank = member_search.role_id;
										break;
									}
								}
								if (my_rank <= 2) break;
								pInfo(p_)->choose_bg = item;
								gamepacket_t p;
								p.Insert("OnDialogRequest");
								p.Insert(get_mascot_dialog(p_, pInfo(p_)->choose_fg, pInfo(p_)->choose_bg, ""));
								p.CreatePacket(p_);
							}
						}
					}
					if (InfoDat[0] == "select_fg_mascot") {
						string name_ = pInfo(p_)->world;
						vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
						if (p != worlds.end()) {
							int item = atoi(InfoDat[1].c_str());
							if (item < 0 or item > items.size()) break;
							World* world_ = &worlds[p - worlds.begin()];
							WorldBlock* block_ = &world_->blocks[pInfo(p_)->lastwrenchx + (pInfo(p_)->lastwrenchy * 100)];
							if (block_->fg != 5814) break;
							if (pInfo(p_)->guild_id != world_->guild_id) break;
							uint32_t guild_id = pInfo(p_)->guild_id;
							vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
							if (p != guilds.end()) {
								Guild* guild_information = &guilds[p - guilds.begin()];
								if (item == guild_information->guild_mascot[0]) break;
								uint32_t my_rank = 0;
								for (GuildMember member_search : guild_information->guild_members) {
									if (member_search.member_name == pInfo(p_)->tankIDName) {
										my_rank = member_search.role_id;
										break;
									}
								}
								if (my_rank <= 2) break;
								pInfo(p_)->choose_fg = item;
								gamepacket_t p;
								p.Insert("OnDialogRequest");
								p.Insert(get_mascot_dialog(p_, pInfo(p_)->choose_fg, pInfo(p_)->choose_bg, ""));
								p.CreatePacket(p_);
							}
						}
					}
					if (btn == "confirm_mascot") {
						gamepacket_t p;
						p.Insert("OnDialogRequest");
						p.Insert("add_dual_layer_icon_label|big|`wConfirm Guild Mascot``|left|" + to_string(pInfo(p_)->choose_bg) + "|" + to_string(pInfo(p_)->choose_fg) + "|1.0|0|\nadd_textbox|Are you sure you wish to create this Guild Mascot for `950,000 gems`o?|left|\nadd_spacer|small|\nadd_textbox|Confirm your choice.|left|\nend_dialog|confirm_mascot_guild|Cancel|Confirm Guild Mascot|");
						p.CreatePacket(p_);
					}
				}
			}
		}
	}
	else if (cch.find("confirm_mascot_guild") != string::npos) {
		stringstream ss(cch);
		string to = "", btn = "";
		bool mascot_dialog = false;
		while (getline(ss, to, '\n')) {
			vector<string> infoDat = explode("|", to);
			auto InfoDat = infoDat;
			if (infoDat.size() == 2) {
				if (infoDat[0] == "buttonClicked") btn = infoDat[1];
				if (infoDat[0] == "dialog_name" && infoDat[1] == "confirm_mascot_guild") mascot_dialog = true;

				if (mascot_dialog) {
					pInfo(p_)->gems -= 50000;
					string name_ = pInfo(p_)->world;
					gamepacket_t gem_upd;
					gem_upd.Insert("OnSetBux"), gem_upd.Insert(pInfo(p_)->gems), gem_upd.Insert(0), gem_upd.Insert((pInfo(p_)->supp >= 1) ? 1 : 0);
					if (pInfo(p_)->supp >= 2) {
						gem_upd.Insert((float)33796, (float)1, (float)0);
					}
					gem_upd.CreatePacket(p_);
					vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
					if (p != worlds.end()) {
						World* world_ = &worlds[p - worlds.begin()];
						WorldBlock* block_ = &world_->blocks[pInfo(p_)->lastwrenchx + (pInfo(p_)->lastwrenchy * 100)];
						if (block_->fg != 5814) break;
						if (pInfo(p_)->guild_id != world_->guild_id) break;
						uint32_t guild_id = pInfo(p_)->guild_id;
						vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
						if (p != guilds.end()) {
							Guild* guild_information = &guilds[p - guilds.begin()];
							uint32_t my_rank = 0;
							for (GuildMember member_search : guild_information->guild_members) {
								if (member_search.member_name == pInfo(p_)->tankIDName) {
									my_rank = member_search.role_id;
									break;
								}
							}
							if (my_rank <= 2) break;
							guild_information->guild_mascot[1] = pInfo(p_)->choose_fg, guild_information->guild_mascot[0] = pInfo(p_)->choose_bg, pInfo(p_)->choose_fg = 0, pInfo(p_)->choose_bg = 0;
							PlayerMoving data_{};
							data_.packetType = 5, data_.punchX = pInfo(p_)->lastwrenchx, data_.punchY = pInfo(p_)->lastwrenchy, data_.characterState = 0x8;
							BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
							BYTE* blc = raw + 56;
							form_visual(blc, *block_, *world_, p_, false);
							for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
								if (pInfo(currentPeer)->world == pInfo(p_)->world) {
									send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
								}
							}
							delete[] raw, blc;
							if (block_->locked) {
								upd_lock(*block_, *world_, p_);
							}
						}
					}
				}
			}
		}
	}
	if (cch.find("dialog_rift_wing") != string::npos) {
		stringstream ss(cch);
		string to = "", btn = "";
		bool isRiftDialog = false;
		while (getline(ss, to, '\n')) {
			vector<string> infoDat = explode("|", to);
			if (infoDat.size() == 2) {
				if (infoDat[0] == "buttonClicked") btn = infoDat[1];
				if (infoDat[0] == "dialog_name" && infoDat[1] == "dialog_rift_wing") isRiftDialog = true;

				if (isRiftDialog) {
					auto* wings = &pInfo(p_)->m_riftwings;
					if (infoDat[0] == "checkbox_time_cycle") {
						if (infoDat.at(1) == "1") {
							wings->enableDilation();
						}
						else if (infoDat.at(1) == "0") {
							wings->disableDilation();
						}
					}
					if (infoDat[0] == "text_input_time_cycle") {
						wings->time = atoi(infoDat.at(1).c_str());
					}
					if (infoDat.at(0) == "checkbox_trail0") {
						if (infoDat.at(1) == "1") {
							wings->enableTrail(1);
						}
						else if (infoDat.at(1) == "0") {
							wings->disableTrail(1);
						}
					}
					if (infoDat.at(0) == "checkbox_closed_wings0") {
						if (infoDat.at(1) == "1") {
							wings->enableClosed(1);
						}
						else if (infoDat.at(1) == "0") {
							wings->disableClosed(1);
						}
					}
					if (infoDat.at(0) == "checkbox_open_wings0") {
						if (infoDat.at(1) == "1") {
							wings->enableOpenWings(1);
						}
						else if (infoDat.at(1) == "0") {
							wings->disableOpenWings(1);
						}
					}
					if (infoDat.at(0) == "checkbox_stamp_particle0") {
						if (infoDat.at(1) == "1") {
							wings->enableStampParticle(1);
						}
						else if (infoDat.at(1) == "0") {
							wings->disableStampParticle(1);
						}
					}
					if (infoDat.at(0) == "text_input_wings_color0") { /*decimal wings color*/
						auto ex = explode(",", infoDat.at(1));
						int r = atoi(ex.at(0).c_str());
						int g = atoi(ex.at(1).c_str());
						int b = atoi(ex.at(2).c_str());
						wings->wings_color1->set(r, g, b);
					}
					if (infoDat.at(0) == "checkbox_material_1st0") { /*feathers*/
						if (infoDat.at(1) == "1" && wings->style1_trail != STYLE1_FEATHERS_MATERIAL) {
							wings->setMaterial1(STYLE1_FEATHERS_MATERIAL);

						}
					}
					if (infoDat.at(0) == "checkbox_material_2nd0") { /*blades*/
						if (infoDat.at(1) == "1" && wings->style1_trail != STYLE1_BLADES_MATERIAL) {
							wings->setMaterial1(STYLE1_BLADES_MATERIAL);

						}
					}
					if (infoDat.at(0) == "checkbox_material_3rd0") { /*scaels*/
						if (infoDat.at(1) == "1" && wings->style1_trail != STYLE1_SCAELS_MATERIAL) {
							wings->setMaterial1(STYLE1_SCAELS_MATERIAL);

						}
					}
					/*trails*/
					if (infoDat.at(0) == "checkbox_trail_1st0") { /*portal*/
						if (infoDat.at(1) == "1" && wings->style1_trail != STYLE1_PORTAL_TRAIL) {
							wings->setTrail1(STYLE1_PORTAL_TRAIL);

						}
					}
					if (infoDat.at(0) == "checkbox_trail_2nd0") { /*starfield*/
						if (infoDat.at(1) == "1" && wings->style1_trail != STYLE1_STARFIELD_TRAIL) {
							wings->setTrail1(STYLE1_STARFIELD_TRAIL);

						}
					}
					if (infoDat.at(0) == "checkbox_trail_3rd0") { /*electrical*/
						if (infoDat.at(1) == "1" && wings->style1_trail != STYLE1_ELECTRICAL_TRAIL) {
							wings->setTrail1(STYLE1_ELECTRICAL_TRAIL);

						}
					}
					if (infoDat.at(0) == "text_input_metal_color0") { /*decimal collar color*/
						auto ex = explode(",", infoDat.at(1));
						int r = atoi(ex.at(0).c_str());
						int g = atoi(ex.at(1).c_str());
						int b = atoi(ex.at(2).c_str());
						wings->wings_metal_color1->set(r, g, b);
					}
					// ST2
					if (infoDat.at(0) == "checkbox_trail1") {
						if (infoDat.at(1) == "1") {
							wings->enableTrail(2);
						}
						else if (infoDat.at(1) == "0") {
							wings->disableTrail(2);
						}
					}
					if (infoDat.at(0) == "checkbox_closed_wings1") {
						if (infoDat.at(1) == "1") {
							wings->enableClosed(2);
						}
						else if (infoDat.at(1) == "0") {
							wings->disableClosed(2);
						}
					}
					if (infoDat.at(0) == "checkbox_stamp_particle1") {
						if (infoDat.at(1) == "1") {
							wings->enableStampParticle(2);
						}
						else if (infoDat.at(1) == "0") {
							wings->disableStampParticle(2);
						}
					}
					if (infoDat.at(0) == "checkbox_open_wings1") {
						if (infoDat.at(1) == "1") {
							wings->enableOpenWings(2);
						}
						else if (infoDat.at(1) == "0") {
							wings->disableOpenWings(2);
						}
					}
					if (infoDat.at(0) == "text_input_wings_color1") { /*decimal cape color*/
						auto ex = explode(",", infoDat.at(1));
						int r = atoi(ex.at(0).c_str());
						int g = atoi(ex.at(1).c_str());
						int b = atoi(ex.at(2).c_str());
						wings->wings_color2->set(r, g, b);
					}
					/*trails*/
					if (infoDat.at(0) == "checkbox_trail_1st1") { /*portal*/
						if (infoDat.at(1) == "1" && wings->style2_trail != STYLE2_PORTAL_TRAIL) {
							wings->setTrail2(STYLE2_PORTAL_TRAIL);

						}
					}
					if (infoDat.at(0) == "checkbox_trail_2nd1") { /*starfield*/
						if (infoDat.at(1) == "1" && wings->style2_trail != STYLE2_STARFIELD_TRAIL) {
							wings->setTrail2(STYLE2_STARFIELD_TRAIL);

						}
					}
					if (infoDat.at(0) == "checkbox_trail_3rd1") { /*electrical*/
						if (infoDat.at(1) == "1" && wings->style2_trail != STYLE2_ELECTRICAL_TRAIL) {
							wings->setTrail2(STYLE2_ELECTRICAL_TRAIL);

						}
					}
					/*materials*/
					if (infoDat.at(0) == "checkbox_material_1st1") { /*feathers*/
						if (infoDat.at(1) == "1" && wings->style2_trail != STYLE1_FEATHERS_MATERIAL) {
							wings->setMaterial2(STYLE2_FEATHERS_MATERIAL);

						}
					}
					if (infoDat.at(0) == "checkbox_material_2nd1") { /*blades*/
						if (infoDat.at(1) == "1" && wings->style2_trail != STYLE2_BLADES_MATERIAL) {
							wings->setMaterial2(STYLE2_BLADES_MATERIAL);

						}
					}
					if (infoDat.at(0) == "checkbox_material_3rd1") { /*scaels*/
						if (infoDat.at(1) == "1" && wings->style2_trail != STYLE2_SCAELS_MATERIAL) {
							wings->setMaterial2(STYLE2_SCAELS_MATERIAL);

						}
					}
					if (infoDat.at(0) == "text_input_metal_color1") { /*decimal collar color*/
						auto ex = explode(",", infoDat.at(1));
						int r = atoi(ex.at(0).c_str());
						int g = atoi(ex.at(1).c_str());
						int b = atoi(ex.at(2).c_str());
						wings->wings_metal_color2->set(r, g, b);
					}
					update_clothes(p_);

				}
			}
		}
	}
	if (cch.find("dialog_rift_cape") != string::npos) {
		stringstream ss(cch);
		string to = "", btn = "";
		bool isRiftDialog = false;
		while (getline(ss, to, '\n')) {
			vector<string> infoDat = explode("|", to);
			if (infoDat.size() == 2) {
				if (infoDat[0] == "buttonClicked") btn = infoDat[1];
				if (infoDat[0] == "dialog_name" && infoDat[1] == "dialog_rift_cape") isRiftDialog = true;

				if (isRiftDialog) {
					auto* cape = &pInfo(p_)->m_riftcape;
					if (infoDat[0] == "checkbox_time_cycle") {
						if (infoDat.at(1) == "1") {
							cape->enableDilation();
						}
						else if (infoDat.at(1) == "0") {
							cape->disableDilation();
						}
					}
					if (infoDat[0] == "text_input_time_cycle") {
						cape->time = atoi(infoDat.at(1).c_str());
					}
					if (infoDat.at(0) == "checkbox_aura0") {
						if (infoDat.at(1) == "1") {
							cape->enableAura(1);
						}
						else if (infoDat.at(1) == "0") {
							cape->disableAura(1);
						}
					}
					if (infoDat.at(0) == "checkbox_closed_cape0") {
						if (infoDat.at(1) == "1") {
							cape->enableClosed(1);
						}
						else if (infoDat.at(1) == "0") {
							cape->disableClosed(1);
						}
					}
					if (infoDat.at(0) == "checkbox_open_on_move0") {
						if (infoDat.at(1) == "1") {
							cape->enableMovement(1);
						}
						else if (infoDat.at(1) == "0") {
							cape->disableMovement(1);
						}
					}
					if (infoDat.at(0) == "checkbox_cape_collar0") {
						if (infoDat.at(1) == "1") {
							cape->enableCollar(1);
						}
						else if (infoDat.at(1) == "0") {
							cape->disableCollar(1);
						}
					}
					if (infoDat.at(1) == "restore_default") { /*restore*/
						cape->setAura1(STYLE1_ELECTRICAL);
						cape->cape_color1->set(147, 56, 143);
						cape->cape_collar_color1->set(147, 56, 143);
						break;
					}
					if (infoDat.at(0) == "text_input_cape_color0") { /*decimal cape color*/
						auto ex = explode(",", infoDat.at(1));
						int r = atoi(ex.at(0).c_str());
						int g = atoi(ex.at(1).c_str());
						int b = atoi(ex.at(2).c_str());
						cape->cape_color1->set(r, g, b);
					}
					if (infoDat.at(0) == "checkbox_aura_1st0") { /*portal*/
						if (infoDat.at(1) == "1" && cape->style1_aura != STYLE1_PORTAL) {
							cape->setAura1(STYLE1_PORTAL);
							break;
						}
					}
					if (infoDat.at(0) == "checkbox_aura_2nd0") { /*starfield*/
						if (infoDat.at(1) == "1" && cape->style1_aura != STYLE1_STARFIELD) {
							cape->setAura1(STYLE1_STARFIELD);
							break;
						}
					}
					if (infoDat.at(0) == "checkbox_aura_3rd0") { /*electrical*/
						if (infoDat.at(1) == "1" && cape->style1_aura != STYLE1_ELECTRICAL) {
							cape->setAura1(STYLE1_ELECTRICAL);
							break;
						}
					}
					if (infoDat.at(0) == "text_input_collar_color0") { /*decimal collar color*/
						auto ex = explode(",", infoDat.at(1));
						int r = atoi(ex.at(0).c_str());
						int g = atoi(ex.at(1).c_str());
						int b = atoi(ex.at(2).c_str());
						cape->cape_collar_color1->set(r, g, b);
					}
					// ST2
					if (infoDat.at(0) == "checkbox_aura1") {
						if (infoDat.at(1) == "1") {
							cape->enableAura(2);
						}
						else if (infoDat.at(1) == "0") {
							cape->disableAura(2);
						}
					}
					if (infoDat.at(0) == "checkbox_closed_cape1") {
						if (infoDat.at(1) == "1") {
							cape->enableClosed(2);
						}
						else if (infoDat.at(1) == "0") {
							cape->disableClosed(2);
						}
					}
					if (infoDat.at(0) == "checkbox_open_on_move1") {
						if (infoDat.at(1) == "1") {
							cape->enableMovement(2);
						}
						else if (infoDat.at(1) == "0") {
							cape->disableMovement(2);
						}
					}
					if (infoDat.at(0) == "checkbox_cape_collar1") {
						if (infoDat.at(1) == "1") {
							cape->enableCollar(2);
						}
						else if (infoDat.at(1) == "0") {
							cape->disableCollar(2);
						}
					}
					if (infoDat.at(0) == "text_input_cape_color1") { /*decimal cape color*/
						auto ex = explode(",", infoDat.at(1));
						int r = atoi(ex.at(0).c_str());
						int g = atoi(ex.at(1).c_str());
						int b = atoi(ex.at(2).c_str());
						cape->cape_color2->set(r, g, b);
					}
					if (infoDat.at(0) == "checkbox_aura_1st1") { /*portal*/
						if (infoDat.at(1) == "1" && cape->style2_aura != STYLE2_PORTAL) {
							cape->setAura2(STYLE2_PORTAL);
							break;
						}
					}
					if (infoDat.at(0) == "checkbox_aura_2nd1") { /*starfield*/
						if (infoDat.at(1) == "1" && cape->style2_aura != STYLE2_STARFIELD) {
							cape->setAura2(STYLE2_STARFIELD);
							break;
						}
					}
					if (infoDat.at(0) == "checkbox_aura_3rd1") { /*electrical*/
						if (infoDat.at(1) == "1" && cape->style2_aura != STYLE2_ELECTRICAL) {
							cape->setAura2(STYLE2_ELECTRICAL);
							break;
						}
					}
					if (infoDat.at(0) == "text_input_collar_color1") { /*decimal collar color*/
						auto ex = explode(",", infoDat.at(1));
						int r = atoi(ex.at(0).c_str());
						int g = atoi(ex.at(1).c_str());
						int b = atoi(ex.at(2).c_str());
						cape->cape_collar_color2->set(r, g, b);
					}
					update_clothes(p_);
				}
			}
		}
	}
	vector<string> a_ = explode("|", replace_str(cch, "\n", "|"));
	for (int i_ = 0; i_ < a_.size(); i_++) {
		if (a_[i_] == "dispshelf") {
			if (a_.size() != 13 and a_.size() != 14) break;
			if (not isdigit(a_.at(i_ + 2).at(0)) or not isdigit(a_.at(i_ + 5).at(0))) break;
			int x_ = atoi(a_.at(i_ + 2).c_str()), y_ = atoi(a_.at(i_ + 5).c_str());
			if (x_ < 0 or x_ >= 100 or y_ < 0 or y_ >= 60) break;
			string name_ = pInfo(p_)->world;
			vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
			if (p != worlds.end()) {
				World* world_ = &worlds[p - worlds.begin()];
				WorldBlock* block_ = &world_->blocks.at(x_ + (y_ * 100));
				uint16_t t_ = (block_->fg ? block_->fg : block_->bg);
				if (not items[t_].dshelf) break;
				string owner_name = world_->owner_name, user_name = pInfo(p_)->tankIDName;
				if (not world_->open_to_public and owner_name != user_name and not pInfo(p_)->dev and not world_->owner_name.empty() and (!guild_access(p_, world_->guild_id) and find(world_->admins.begin(), world_->admins.end(), pInfo(p_)->tankIDName) == world_->admins.end())) {
					if (block_->locked) {
						WorldBlock* check_lock = &world_->blocks.at(block_->lock_origin);
						if (not check_lock->open_to_public and check_lock->owner_name != pInfo(p_)->tankIDName and (find(check_lock->admins.begin(), check_lock->admins.end(), pInfo(p_)->tankIDName) == check_lock->admins.end())) break;
					}
					else {
						break;
					}
				}
				for (int b_ = 0; b_ < a_.size(); b_++) {
					if (a_.at(b_) == "replace1" || a_.at(b_) == "replace2" || a_.at(b_) == "replace3" || a_.at(b_) == "replace4") {
						if (a_.size() >= (b_ + 1) - 1) {
							if (not isdigit(a_[b_ + 1][0])) break;
							int item_id = atoi(a_[b_ + 1].c_str());
							if (item_id <= 0 || item_id >= items.size()) break;
							if (items[item_id].untradeable) {
								gamepacket_t p;
								p.Insert("OnTalkBubble");
								p.Insert(pInfo(p_)->netID);
								p.Insert("You can't display untradeable items.");
								p.Insert(0), p.Insert(0);
								p.CreatePacket(p_);
								return;
							}
							if ((a_.at(b_) == "replace1" ? block_->shelf_1 : a_.at(b_) == "replace2" ? block_->shelf_2 : a_.at(b_) == "replace3" ? block_->shelf_3 : block_->shelf_4) != 0) {
								int b = 1;
								if (modify_inventory(p_, (a_.at(b_) == "replace1" ? block_->shelf_1 : a_.at(b_) == "replace2" ? block_->shelf_2 : a_.at(b_) == "replace3" ? block_->shelf_3 : block_->shelf_4), b) == 0) {
									gamepacket_t p;
									p.Insert("OnConsoleMessage");
									p.Insert("Picked up 1 " + items[(a_.at(b_) == "replace1" ? block_->shelf_1 : a_.at(b_) == "replace2" ? block_->shelf_2 : a_.at(b_) == "replace3" ? block_->shelf_3 : block_->shelf_4)].name + ".");
									p.CreatePacket(p_);
									(a_.at(b_) == "replace1" ? block_->shelf_1 : a_.at(b_) == "replace2" ? block_->shelf_2 : a_.at(b_) == "replace3" ? block_->shelf_3 : block_->shelf_4) = 0;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(p_)->netID);
									p.Insert("No room to take " + items[(a_.at(b_) == "replace1" ? block_->shelf_1 : a_.at(b_) == "replace2" ? block_->shelf_2 : a_.at(b_) == "replace3" ? block_->shelf_3 : block_->shelf_4)].name + ".");
									p.Insert(0), p.Insert(0);
									p.CreatePacket(p_);
									break;
								}
							}
							int b = -1;
							if (modify_inventory(p_, item_id, b) == 0) {
								(a_.at(b_) == "replace1" ? block_->shelf_1 : a_.at(b_) == "replace2" ? block_->shelf_2 : a_.at(b_) == "replace3" ? block_->shelf_3 : block_->shelf_4) = item_id;
								gamepacket_t p;
								p.Insert("OnConsoleMessage");
								p.Insert("Put " + items[(a_.at(b_) == "replace1" ? block_->shelf_1 : a_.at(b_) == "replace2" ? block_->shelf_2 : a_.at(b_) == "replace3" ? block_->shelf_3 : block_->shelf_4)].name + " on display.");
								p.CreatePacket(p_);
							}
						}
					}

					else if (a_.at(b_) == "remove") {
						if (block_->shelf_1 != 0) {
							int b = 1;
							if (modify_inventory(p_, block_->shelf_1, b) == 0) {
								gamepacket_t p;
								p.Insert("OnConsoleMessage");
								p.Insert("Picked up 1 " + items[block_->shelf_1].name + ".");
								p.CreatePacket(p_);
								block_->shelf_1 = 0;
							}
							else {
								gamepacket_t p;
								p.Insert("OnTalkBubble");
								p.Insert(pInfo(p_)->netID);
								p.Insert("No room to take " + items[block_->shelf_1].name + ".");
								p.Insert(0), p.Insert(0);
								p.CreatePacket(p_);
								break;
							}
						}
						if (block_->shelf_2 != 0) {
							int b = 1;
							if (modify_inventory(p_, block_->shelf_2, b) == 0) {
								gamepacket_t p;
								p.Insert("OnConsoleMessage");
								p.Insert("Picked up 1 " + items[block_->shelf_2].name + ".");
								p.CreatePacket(p_);
								block_->shelf_2 = 0;
							}
							else {
								gamepacket_t p;
								p.Insert("OnTalkBubble");
								p.Insert(pInfo(p_)->netID);
								p.Insert("No room to take " + items[block_->shelf_2].name + ".");
								p.Insert(0), p.Insert(0);
								p.CreatePacket(p_);
								break;
							}
						}
						if (block_->shelf_3 != 0) {
							int b = 1;
							if (modify_inventory(p_, block_->shelf_3, b) == 0) {
								gamepacket_t p;
								p.Insert("OnConsoleMessage");
								p.Insert("Picked up 1 " + items[block_->shelf_3].name + ".");
								p.CreatePacket(p_);
								block_->shelf_3 = 0;
							}
							else {
								gamepacket_t p;
								p.Insert("OnTalkBubble");
								p.Insert(pInfo(p_)->netID);
								p.Insert("No room to take " + items[block_->shelf_3].name + ".");
								p.Insert(0), p.Insert(0);
								p.CreatePacket(p_);
								break;
							}
						}
						if (block_->shelf_4 != 0) {
							int b = 1;
							if (modify_inventory(p_, block_->shelf_4, b) == 0) {
								gamepacket_t p;
								p.Insert("OnConsoleMessage");
								p.Insert("Picked up 1 " + items[block_->shelf_4].name + ".");
								p.CreatePacket(p_);
								block_->shelf_4 = 0;
							}
							else {
								gamepacket_t p;
								p.Insert("OnTalkBubble");
								p.Insert(pInfo(p_)->netID);
								p.Insert("No room to take " + items[block_->shelf_4].name + ".");
								p.Insert(0), p.Insert(0);
								p.CreatePacket(p_);
								break;
							}
						}
						break;
					}
				}
				PlayerMoving data_{};
				data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
				BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
				BYTE* blc = raw + 56;
				form_visual(blc, *block_, *world_, p_, false);
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
					if (pInfo(currentPeer)->world == pInfo(p_)->world) {
						send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
					}
				}
				delete[] raw, blc;
				if (block_->locked) {
					upd_lock(*block_, *world_, p_);
				}
			}
			
			return;
		}
		
		else if (a_[i_] == "sdbrespond") {
			if (a_.size() != 8) break;
			SendCmd(p_, "/go", true);
			return;
		}
		else if (a_[i_] == "sdbsend") {
			if (a_.size() != 11) break;
			string line_1 = a_[i_ + 2];
			string line_2 = a_[i_ + 4];
			string line_3 = a_[i_ + 6];
			if (line_1.empty() and line_2.empty() and line_3.empty()) {
				gamepacket_t p;
				p.Insert("OnTalkBubble");
				p.Insert(pInfo(p_)->netID);
				p.Insert("`5[`2I'm not wasting Growtokens on an empty broadcast!``]``");
				p.Insert(0), p.Insert(0);
				p.CreatePacket(p_);
				break;
			}
			if (has_playmod(pInfo(p_), "megaphone!")) {
				int time_ = 0;
				for (PlayMods peer_playmod : pInfo(p_)->playmods) {
					if (peer_playmod.id == 13) {
						time_ = peer_playmod.time - time(nullptr);
						break;
					}
				}
				packet_(p_, "action|log\nmsg|>> (" + to_playmod_time(time_) + "before you can broadcast again)", "");
				return;
			}
			string name_ = pInfo(p_)->world;
			vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
			if (p != worlds.end()) {
				World* world_ = &worlds[p - worlds.begin()];
				bool jammed = find(world_->active_jammers.begin(), world_->active_jammers.end(), 226) != world_->active_jammers.end() ? true : false;
				if (pInfo(p_)->m_h == 1) jammed = true;
				int b = -50;
				if (modify_inventory(p_, 1486, b) == 0) {
					{
						PlayMods new_playmod{};
						new_playmod.id = 13;
						new_playmod.time = time(nullptr) + 300;
						pInfo(p_)->playmods.push_back(new_playmod);
						{
							gamepacket_t p;
							p.Insert("OnConsoleMessage");
							p.Insert("Broadcasting to ALL! (`$Megaphone!`` mod added)");
							p.CreatePacket(p_);
							packet_(p_, "action|play_sfx\nfile|audio/dialog_confirm.wav\ndelayMS|0");
						}
					}
					gamepacket_t p;
					p.Insert("OnSDBroadcast");
					p.Insert(((not pInfo(p_)->d_name.empty() ? pInfo(p_)->d_name : pInfo(p_)->name_color + pInfo(p_)->tankIDName) + (pInfo(p_)->is_legend ? " of Legend" : "") + "``") + "\n" + (jammed ? "`4JAMMED!``" : pInfo(p_)->world) + "\n" + line_1 + "\n" + line_2 + "\n" + line_3);
					p.Insert(jammed ? 0 : 1);
					if (not jammed) {
						lastsbworld = pInfo(p_)->world;
					}
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->radio) continue;
						if (pInfo(currentPeer)->world.empty()) continue;
						p.CreatePacket(currentPeer);
					}
				}
				else {
					gamepacket_t p;
					p.Insert("OnTalkBubble");
					p.Insert(pInfo(p_)->netID);
					p.Insert("You need 50 Growtoken to do this!");
					p.Insert(0), p.Insert(1);
					p.CreatePacket(p_);
					{
						gamepacket_t p;
						p.Insert("OnConsoleMessage");
						p.Insert("You need 50 Growtoken to do this!");
						p.CreatePacket(p_);
					}
				}
			}
			return;
		}

		else if (a_[i_] == "portrait") {
			try {
				if (not isdigit(a_.at(i_ + 2).at(0)) or not isdigit(a_.at(i_ + 5).at(0))) break;
				int x_ = atoi(a_.at(i_ + 2).c_str()), y_ = atoi(a_.at(i_ + 5).c_str());
				if (x_ < 0 or x_ >= 100 or y_ < 0 or y_ >= 60) break;
				string name_ = pInfo(p_)->world;
				vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
				if (p != worlds.end()) {
					World* world_ = &worlds[p - worlds.begin()];
					WorldBlock* block_ = &world_->blocks.at(x_ + (y_ * 100));
					uint16_t t_ = (block_->fg ? block_->fg : block_->bg);
					if (not items.at(t_).portrait) break;
					string owner_name = world_->owner_name, user_name = pInfo(p_)->tankIDName;
					if (not world_->open_to_public and owner_name != user_name and not pInfo(p_)->dev and not world_->owner_name.empty() and (!guild_access(p_, world_->guild_id) and find(world_->admins.begin(), world_->admins.end(), pInfo(p_)->tankIDName) == world_->admins.end())) {
						if (block_->locked) {
							WorldBlock* check_lock = &world_->blocks.at(block_->lock_origin);
							if (not check_lock->open_to_public and check_lock->owner_name != pInfo(p_)->tankIDName and (find(check_lock->admins.begin(), check_lock->admins.end(), pInfo(p_)->tankIDName) == check_lock->admins.end())) break;
						}
						else {
							break;
						}
					} for (int b_ = 0; b_ < a_.size(); b_++) {
						if (a_.size() > b_ + 1) {
							if (a_.at(b_ + 1) == "chk1") {
								if (block_->portrait.c_skin == 0 and block_->portrait.c_face == 0 and block_->portrait.c_hair == 0 and block_->portrait.c_head == 0) continue;
								if (a_.size() >= (b_ + 2) - 1) {
									if (not isdigit(a_.at(b_ + 2).at(0))) break;
									if (a_.at(b_ + 2) == "1") block_->portrait.c_expression = 1;
								}
							}
							else if (a_.at(b_ + 1) == "chk2") {
								if (block_->portrait.c_skin == 0 and block_->portrait.c_face == 0 and block_->portrait.c_hair == 0 and block_->portrait.c_head == 0) continue;
								if (a_.size() >= (b_ + 2) - 1) {
									if (not isdigit(a_.at(b_ + 2).at(0))) break;
									if (a_.at(b_ + 2) == "1") block_->portrait.c_expression = 2;
								}
							}
							else if (a_.at(b_ + 1) == "chk3") {
								if (block_->portrait.c_skin == 0 and block_->portrait.c_face == 0 and block_->portrait.c_hair == 0 and block_->portrait.c_head == 0) continue;
								if (a_.size() >= (b_ + 2) - 1) {
									if (not isdigit(a_.at(b_ + 2).at(0))) break;
									if (a_.at(b_ + 2) == "1") block_->portrait.c_expression = 3;
								}
							}
							else if (a_.at(b_ + 1) == "chk4") {
								if (block_->portrait.c_skin == 0 and block_->portrait.c_face == 0 and block_->portrait.c_hair == 0 and block_->portrait.c_head == 0) continue;
								if (a_.size() >= (b_ + 2) - 1) {
									if (not isdigit(a_.at(b_ + 2).at(0))) break;
									if (a_.at(b_ + 2) == "1") block_->portrait.c_expression = 4;
								}
							}
							else if (a_.at(b_ + 1) == "chk5") {
								if (block_->portrait.c_skin == 0 and block_->portrait.c_face == 0 and block_->portrait.c_hair == 0 and block_->portrait.c_head == 0) continue;
								if (a_.size() >= (b_ + 2) - 1) {
									if (not isdigit(a_.at(b_ + 2).at(0))) break;
									if (a_.at(b_ + 2) == "1") block_->portrait.c_expression = 5;
								}
							}
							else if (a_.at(b_ + 1) == "chk6") {
								if (block_->portrait.c_skin == 0 and block_->portrait.c_face == 0 and block_->portrait.c_hair == 0 and block_->portrait.c_head == 0) continue;
								if (a_.size() >= (b_ + 2) - 1) {
									if (not isdigit(a_.at(b_ + 2).at(0))) break;
									if (a_.at(b_ + 2) == "1") block_->portrait.c_expression = 6;
								}
							}
							else if (a_.at(b_ + 1) == "chk7") {
								if (block_->portrait.c_skin == 0 and block_->portrait.c_face == 0 and block_->portrait.c_hair == 0 and block_->portrait.c_head == 0) continue;
								if (a_.size() >= (b_ + 2) - 1) {
									if (not isdigit(a_.at(b_ + 2).at(0))) break;
									if (a_.at(b_ + 2) == "1") block_->portrait.c_expression = 7;
								}
							}
							else if (a_.at(b_ + 1) == "chk9") {
								if (block_->portrait.c_skin == 0 and block_->portrait.c_face == 0 and block_->portrait.c_hair == 0 and block_->portrait.c_head == 0) continue;
								if (a_.size() >= (b_ + 2) - 1) {
									if (not isdigit(a_.at(b_ + 2).at(0))) break;
									if (a_.at(b_ + 2) == "1") block_->portrait.c_expression = 9;
								}
							}
							else if (a_.at(b_ + 1) == "chk11") {
								if (block_->portrait.c_skin == 0 and block_->portrait.c_face == 0 and block_->portrait.c_hair == 0 and block_->portrait.c_head == 0) continue;
								if (a_.size() >= (b_ + 2) - 1) {
									if (not isdigit(a_.at(b_ + 2).at(0))) break;
									if (a_.at(b_ + 2) == "1") block_->portrait.c_expression = 11;
								}
							}
							else if (a_.at(b_ + 1) == "chk12") {
								if (block_->portrait.c_skin == 0 and block_->portrait.c_face == 0 and block_->portrait.c_hair == 0 and block_->portrait.c_head == 0) continue;
								if (a_.size() >= (b_ + 2) - 1) {
									if (not isdigit(a_.at(b_ + 2).at(0))) break;
									if (a_.at(b_ + 2) == "1") block_->portrait.c_expression = 12;
								}
							}
							else if (a_.at(b_ + 1) == "chk14") {
								if (block_->portrait.c_skin == 0 and block_->portrait.c_face == 0 and block_->portrait.c_hair == 0 and block_->portrait.c_head == 0) continue;
								if (a_.size() >= (b_ + 2) - 1) {
									if (not isdigit(a_.at(b_ + 2).at(0))) break;
									if (a_.at(b_ + 2) == "1") block_->portrait.c_expression = 14;
								}
							}
							else if (a_.at(b_ + 1) == "chk16") {
								if (block_->portrait.c_skin == 0 and block_->portrait.c_face == 0 and block_->portrait.c_hair == 0 and block_->portrait.c_head == 0) continue;
								if (a_.size() >= (b_ + 2) - 1) {
									if (not isdigit(a_.at(b_ + 2).at(0))) break;
									if (a_.at(b_ + 2) == "1") block_->portrait.c_expression = 16;
								}
							}
							else if (a_.at(b_ + 1) == "chk18") {
								if (block_->portrait.c_skin == 0 and block_->portrait.c_face == 0 and block_->portrait.c_hair == 0 and block_->portrait.c_head == 0) continue;
								if (a_.size() >= (b_ + 2) - 1) {
									if (not isdigit(a_.at(b_ + 2).at(0))) break;
									if (a_.at(b_ + 2) == "1") block_->portrait.c_expression = 18;
								}
							}
							else if (a_.at(b_ + 1) == "chk22") {
								if (block_->portrait.c_skin == 0 and block_->portrait.c_face == 0 and block_->portrait.c_hair == 0 and block_->portrait.c_head == 0) continue;
								if (a_.size() >= (b_ + 2) - 1) {
									if (not isdigit(a_.at(b_ + 2).at(0))) break;
									if (a_.at(b_ + 2) == "1") block_->portrait.c_expression = 22;
								}
							}
						}
						if (a_.at(b_) == "erase") {
							int b = -4;
							if (modify_inventory(p_, 3492, b) == 0) {
								block_->portrait.c_expression = 1;
								block_->portrait.c_skin = 0;
								block_->portrait.c_face = 0;
								block_->portrait.c_head = 0;
								block_->portrait.c_hair = 0;
							}
						}
						else if (a_.at(b_) == "playerNetID") {
							if (block_->portrait.c_skin == 0 and block_->portrait.c_face == 0 and block_->portrait.c_hair == 0 and block_->portrait.c_head == 0) {
								if (a_.size() >= (b_ + 1) - 1) {
									if (not isdigit(a_.at(b_ + 1).at(0))) break;
									uint32_t netID = atoi(a_.at(b_ + 1).c_str());
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
										if (pInfo(currentPeer)->world == pInfo(p_)->world and pInfo(currentPeer)->netID == netID) {
											int red = 0, yellow = 0, green = 0, aqua = 0, blue = 0, purple = 0, charcoal = 0, varnish = 0;
											{
												modify_inventory(p_, 3478, red);
												modify_inventory(p_, 3480, yellow);
												modify_inventory(p_, 3482, green);
												modify_inventory(p_, 3484, aqua);
												modify_inventory(p_, 3486, blue);
												modify_inventory(p_, 3488, purple);
												modify_inventory(p_, 3490, charcoal);
												modify_inventory(p_, 3492, varnish);
												if (red >= 2 and yellow >= 2 and green >= 2 and aqua >= 2 and blue >= 2 and purple >= 2 and charcoal >= 2 and varnish >= 2) {
													red = -2, yellow = -2, green = -2, aqua = -2, blue = -2, purple = -2, charcoal = -2, varnish = -2;
													if (modify_inventory(p_, 3478, red) == 0 and modify_inventory(p_, 3480, yellow) == 0 and modify_inventory(p_, 3482, green) == 0
														and modify_inventory(p_, 3484, aqua) == 0 and modify_inventory(p_, 3486, blue) == 0 and modify_inventory(p_, 3488, purple) == 0
														and modify_inventory(p_, 3490, charcoal) == 0 and modify_inventory(p_, 3492, varnish) == 0) {
														block_->portrait.c_expression = 1;
														block_->portrait.c_skin = pInfo(currentPeer)->skin;
														block_->portrait.c_face = pInfo(currentPeer)->face;
														block_->portrait.c_head = pInfo(currentPeer)->hair;
														block_->portrait.c_hair = pInfo(currentPeer)->mask;
														block_->txt = pInfo(currentPeer)->name_color + pInfo(currentPeer)->tankIDName;
													}
												}
											}
											break;
										}
									}
								}
							}
						}
						else if (a_.at(b_) == "artname") {
							if (block_->portrait.c_skin == 0 and block_->portrait.c_face == 0 and block_->portrait.c_hair == 0 and block_->portrait.c_head == 0) continue;
							if (a_.size() >= (b_ + 1) - 1) {
								string txt = a_.at(b_ + 1);
								if (txt.size() > 60) break;
								block_->txt = txt;
							}
						}
					}
					PlayerMoving data_{};
					data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
					BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
					BYTE* blc = raw + 56;
					form_visual(blc, *block_, *world_, p_, false);
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
						if (pInfo(currentPeer)->world == pInfo(p_)->world) {
							send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
						}
					}
					delete[] raw, blc;
					if (block_->locked) {
						upd_lock(*block_, *world_, p_);
					}
				}
			}
			catch (out_of_range) {
				return;
			}
			return;
		}

		else if (a_.at(i_) == "artcanvas") {
			try {
				if (not isdigit(a_.at(i_ + 2).at(0)) or not isdigit(a_.at(i_ + 5).at(0))) break;
				int x_ = atoi(a_.at(i_ + 2).c_str()), y_ = atoi(a_.at(i_ + 5).c_str());
				if (x_ < 0 or x_ >= 100 or y_ < 0 or y_ >= 60) break;
				string name_ = pInfo(p_)->world;
				vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
				if (p != worlds.end()) {
					World* world_ = &worlds[p - worlds.begin()];
					WorldBlock* block_ = &world_->blocks.at(x_ + (y_ * 100));
					uint16_t t_ = (block_->fg ? block_->fg : block_->bg);
					if (not items.at(t_).easel) break;
					string owner_name = world_->owner_name, user_name = pInfo(p_)->tankIDName;
					if (not world_->open_to_public and owner_name != user_name and not pInfo(p_)->dev and not world_->owner_name.empty() and (!guild_access(p_, world_->guild_id) and find(world_->admins.begin(), world_->admins.end(), pInfo(p_)->tankIDName) == world_->admins.end())) {
						if (block_->locked) {
							WorldBlock* check_lock = &world_->blocks.at(block_->lock_origin);
							if (not check_lock->open_to_public and check_lock->owner_name != pInfo(p_)->tankIDName and (find(check_lock->admins.begin(), check_lock->admins.end(), pInfo(p_)->tankIDName) == check_lock->admins.end())) break;
						}
						else {
							break;
						}
					} for (int b_ = 0; b_ < a_.size(); b_++) {
						if (a_.at(b_) == "erase") {
							int b = -4;
							if (modify_inventory(p_, 3492, b) == 0) {
								block_->id = 0;
							}
						}
						else if (a_.at(b_) == "paint") {
							if (a_.size() >= (b_ + 1) - 1) {
								if (not isdigit(a_.at(b_ + 1).at(0))) break;
								int item_id = atoi(a_.at(b_ + 1).c_str());
								if (item_id <= 0 || item_id >= items.size()) break;
								int kiek_turi = 0;
								modify_inventory(p_, item_id, kiek_turi);
								if (kiek_turi == 0) break;
								{
									int red = 0, yellow = 0, green = 0, aqua = 0, blue = 0, purple = 0, charcoal = 0, varnish = 0;
									{
										modify_inventory(p_, 3478, red);
										modify_inventory(p_, 3480, yellow);
										modify_inventory(p_, 3482, green);
										modify_inventory(p_, 3484, aqua);
										modify_inventory(p_, 3486, blue);
										modify_inventory(p_, 3488, purple);
										modify_inventory(p_, 3490, charcoal);
										modify_inventory(p_, 3492, varnish);
										if (red >= 2 and yellow >= 2 and green >= 2 and aqua >= 2 and blue >= 2 and purple >= 2 and charcoal >= 2 and varnish >= 2) {
											red = -2, yellow = -2, green = -2, aqua = -2, blue = -2, purple = -2, charcoal = -2, varnish = -2;
											if (modify_inventory(p_, 3478, red) == 0 and modify_inventory(p_, 3480, yellow) == 0 and modify_inventory(p_, 3482, green) == 0
												and modify_inventory(p_, 3484, aqua) == 0 and modify_inventory(p_, 3486, blue) == 0 and modify_inventory(p_, 3488, purple) == 0
												and modify_inventory(p_, 3490, charcoal) == 0 and modify_inventory(p_, 3492, varnish) == 0) {
												block_->id = item_id;
											}
										}
									}
								}
							}
						}
						else if (a_.at(b_) == "artname") {
							if (a_.size() >= (b_ + 1) - 1) {
								string txt = a_.at(b_ + 1);
								if (txt.size() > 60) break;
								block_->txt = txt;
							}
						}
					}
					PlayerMoving data_{};
					data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
					BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
					BYTE* blc = raw + 56;
					form_visual(blc, *block_, *world_, p_, false);
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
						if (pInfo(currentPeer)->world == pInfo(p_)->world) {
							send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
						}
					}
					delete[] raw, blc;
					if (block_->locked) {
						upd_lock(*block_, *world_, p_);
					}
				}
			}
			catch (out_of_range) {
				cout << "crash try by " << pInfo(p_)->tankIDName << endl;
				return;
			}
			return;
		}
		else if (a_[i_] == "mannequin_edit") {
			if (a_.size() == 14) { // put item
				if (not isdigit(a_[i_ + 2][0]) or not isdigit(a_[i_ + 5][0]) or not isdigit(a_[i_ + 8][0])) break;
				int x_ = atoi(a_[i_ + 2].c_str()), y_ = atoi(a_[i_ + 5].c_str()), tile_ = atoi(a_[i_ + 8].c_str());
				if (x_ < 0 or x_ >= 100 or y_ < 0 or y_ >= 60) break;
				if (tile_ <= 0 || tile_ >= items.size()) break;
				if (items[tile_].blockType != CLOTHING or items[tile_].untradeable or items[tile_].clothType == ClothTypes::ANCES) return;
				string name_ = pInfo(p_)->world;
				vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
				if (p != worlds.end()) {
					World* world_ = &worlds[p - worlds.begin()];
					WorldBlock* block_ = &world_->blocks[x_ + (y_ * 100)];
					uint16_t t_ = (block_->fg ? block_->fg : block_->bg);
					if (not items[t_].mannequin) break;
					string owner_name = world_->owner_name, user_name = pInfo(p_)->tankIDName;
					if (not world_->open_to_public and owner_name != user_name and not pInfo(p_)->dev and not world_->owner_name.empty() and (!guild_access(p_, world_->guild_id) and find(world_->admins.begin(), world_->admins.end(), pInfo(p_)->tankIDName) == world_->admins.end())) {
						if (block_->locked) {
							WorldBlock* check_lock = &world_->blocks[block_->lock_origin];
							if (not check_lock->open_to_public and check_lock->owner_name != pInfo(p_)->tankIDName and (find(check_lock->admins.begin(), check_lock->admins.end(), pInfo(p_)->tankIDName) == check_lock->admins.end())) break;
						}
						else {
							break;
						}
					}
					uint16_t current_mannequin_item = 0;
					switch (items[tile_].clothingType) {
					case 0: current_mannequin_item = block_->mannequin.c_hair;
						break;
					case 1: current_mannequin_item = block_->mannequin.c_shirt;
						break;
					case 2: current_mannequin_item = block_->mannequin.c_pants;
						break;
					case 3: current_mannequin_item = block_->mannequin.c_feet;
						break;
					case 4: current_mannequin_item = block_->mannequin.c_head;
						break;
					case 5: current_mannequin_item = block_->mannequin.c_hand;
						break;
					case 6: current_mannequin_item = block_->mannequin.c_back;
						break;
					case 7: current_mannequin_item = block_->mannequin.c_mask;
						break;
					case 8: current_mannequin_item = block_->mannequin.c_neck;
						break;
					case 9: {
						return;
					}
					} if (current_mannequin_item == tile_) {
						return;
					}
					else {
						if (current_mannequin_item != 0) {
							int b = 1;
							if (modify_inventory(p_, int(current_mannequin_item), b) != 0) {
								gamepacket_t p;
								p.Insert("OnTalkBubble");
								p.Insert(pInfo(p_)->netID);
								p.Insert("`5[`2You don't have inventory space!``]``");
								p.Insert(0), p.Insert(0);
								p.CreatePacket(p_);
								return;
							}
						}
						int c_ = -1;
						if (modify_inventory(p_, tile_, c_) == 0) {
							switch (items[tile_].clothingType) {
							case 0: block_->mannequin.c_hair = tile_;
								break;
							case 1: block_->mannequin.c_shirt = tile_;
								break;
							case 2: block_->mannequin.c_pants = tile_;
								break;
							case 3: block_->mannequin.c_feet = tile_;
								break;
							case 4: block_->mannequin.c_head = tile_;
								break;
							case 5: block_->mannequin.c_hand = tile_;
								break;
							case 6: block_->mannequin.c_back = tile_;
								break;
							case 7: block_->mannequin.c_mask = tile_;
								break;
							case 8: block_->mannequin.c_neck = tile_;
								break;
							case 9: {
								return;
							}
							}
							gamepacket_t p(0, pInfo(p_)->netID);
							p.Insert("OnPlayPositioned");
							p.Insert("audio/change_clothes.wav");
							PlayerMoving data_{};
							data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
							BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
							BYTE* blc = raw + 56;
							form_visual(blc, *block_, *world_, p_, false);
							for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
								if (pInfo(currentPeer)->world == pInfo(p_)->world) {
									p.CreatePacket(currentPeer);
									send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
								}
							}
							delete[] raw, blc;
							if (block_->locked) {
								upd_lock(*block_, *world_, p_);
							}
						}
					}
				}
			}
			else {
				int x_ = 0, y_ = 0;
				try {
					if (not isdigit(a_.at(i_ + 2).at(0) or not isdigit(a_.at(i_ + 5).at(0)))) break;
					int x_ = atoi(a_.at(i_ + 2).c_str()), y_ = atoi(a_.at(i_ + 5).c_str());
				}
				catch (out_of_range) {
					return;
				}
				string name_ = pInfo(p_)->world;
				vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
				if (p != worlds.end()) {
					World* world_ = &worlds[p - worlds.begin()];
					WorldBlock* block_ = &world_->blocks[x_ + (y_ * 100)];
					uint16_t t_ = (block_->fg ? block_->fg : block_->bg);
					if (not items[t_].mannequin) break;
					string owner_name = world_->owner_name, user_name = pInfo(p_)->tankIDName;
					if (not world_->open_to_public and owner_name != user_name and not pInfo(p_)->dev and not world_->owner_name.empty() and (!guild_access(p_, world_->guild_id) and find(world_->admins.begin(), world_->admins.end(), pInfo(p_)->tankIDName) == world_->admins.end())) {
						if (block_->locked) {
							WorldBlock* check_lock = &world_->blocks[block_->lock_origin];
							if (not check_lock->open_to_public and check_lock->owner_name != pInfo(p_)->tankIDName and (find(check_lock->admins.begin(), check_lock->admins.end(), pInfo(p_)->tankIDName) == check_lock->admins.end())) break;
						}
						else {
							break;
						}
					}
					bool clear_all = false;
					int fkthis = 0;
					for (int b_ = 0; b_ < a_.size(); b_++) {
						if (a_[b_].substr(0, 9) == "checkbox_") {
							if (a_.size() >= (b_ + 1) - 1) {
								vector<string> target_ = explode("_", a_[b_]);
								if (not isdigit(target_[1][0])) continue;
								int item_remove = atoi(target_[1].c_str());
								int aa = 1;
								if (item_remove <= 0 || item_remove >= items.size()) continue;
								if (a_[b_ + 1] == "1" or clear_all) {
									if (block_->mannequin.c_hair != item_remove and block_->mannequin.c_shirt != item_remove and block_->mannequin.c_pants != item_remove and block_->mannequin.c_feet != item_remove
										and block_->mannequin.c_head != item_remove and block_->mannequin.c_hand != item_remove and block_->mannequin.c_back != item_remove
										and block_->mannequin.c_mask != item_remove and block_->mannequin.c_neck != item_remove) return;
									if (modify_inventory(p_, item_remove, aa) == 0) {
										switch (items[item_remove].clothingType) {
										case 0: block_->mannequin.c_hair = 0;
											break;
										case 1: block_->mannequin.c_shirt = 0;
											break;
										case 2: block_->mannequin.c_pants = 0;
											break;
										case 3: block_->mannequin.c_feet = 0;
											break;
										case 4: block_->mannequin.c_head = 0;
											break;
										case 5: block_->mannequin.c_hand = 0;
											break;
										case 6: block_->mannequin.c_back = 0;
											break;
										case 7: block_->mannequin.c_mask = 0;
											break;
										case 8: block_->mannequin.c_neck = 0;
											break;
										}
									}
								}
							}
						}
						else if (a_[b_] == "buttonClicked") {
							if (a_.size() >= (b_ + 1) - 1) {
								if (a_[b_ + 1] == "clear") clear_all = true;
							}
						}
						else if (a_[b_] == "sign_text") {
							if (a_.size() >= (b_ + 1) - 1) {
								string txt = a_[b_ + 1];
								if (txt.size() > 128) break;
								block_->txt = txt;
							}
						}
					}
					PlayerMoving data_{};
					data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
					BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
					BYTE* blc = raw + 56;
					form_visual(blc, *block_, *world_, p_, false);
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
						if (pInfo(currentPeer)->world == world_->name) {
							send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
						}
					}
					delete[] raw, blc;
				}
			}
			return;
		}
		else if (a_[i_] == "xenonite_edit") {
			gamepacket_t p;
			p.Insert("OnTalkBubble");
			p.Insert(pInfo(p_)->netID);
			p.Insert("Xenonite not yet finished!");
			p.Insert(0), p.Insert(0);
			p.CreatePacket(p_);
			return;
		}
		else if (a_.at(i_) == "vip_edit") {
			try {
				if (not isdigit(a_.at(i_ + 2).at(0)) or not isdigit(a_.at(i_ + 5).at(0))) break;
				int x_ = atoi(a_.at(i_ + 2).c_str()), y_ = atoi(a_.at(i_ + 5).c_str());
				string name_ = pInfo(p_)->world;
				vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
				if (p != worlds.end()) {
					World* world_ = &worlds[p - worlds.begin()];
					WorldBlock* block_ = &world_->blocks.at(x_ + (y_ * 100));
					uint16_t t_ = (block_->fg ? block_->fg : block_->bg);
					if (not items.at(t_).vipentrance) break;
					string owner_name = world_->owner_name, user_name = pInfo(p_)->tankIDName;
					if (owner_name != user_name and not pInfo(p_)->dev and not world_->owner_name.empty()) {
						if (block_->locked) {
							WorldBlock* check_lock = &world_->blocks.at(block_->lock_origin);
							if (check_lock->owner_name != pInfo(p_)->tankIDName) break;
						}
						else {
							break;
						}
					}
					for (int b_ = 0; b_ < a_.size(); b_++) {
						if (a_.at(b_).substr(0, 9) == "checkbox_") {
							vector<string> target_ = explode("_", a_.at(b_));
							if (target_.at(1) == "public") {
								if (not block_->limit_admins and a_.at(b_ + 1) == "1") {
									block_->limit_admins = true;
									gamepacket_t p;
									p.Insert("OnConsoleMessage");
									p.Insert(pInfo(p_)->name_color + pInfo(p_)->tankIDName + "`` has set a `$VIP Entrance`` to `$PUBLIC");
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
										if (pInfo(currentPeer)->world == world_->name) {
											p.CreatePacket(currentPeer);
										}
									}
								}
								else if (block_->limit_admins and a_[b_ + 1] == "0") {
									block_->limit_admins = false;
									gamepacket_t p;
									p.Insert("OnConsoleMessage");
									p.Insert(pInfo(p_)->name_color + pInfo(p_)->tankIDName + "`` has set a `$VIP Entrance`` to `4PRIVATE``");
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
										if (pInfo(currentPeer)->world == world_->name) {
											p.CreatePacket(currentPeer);
										}
									}
								}
							}
							else if (target_.size() == 2 and a_.at(b_ + 1) == "0") {
								string user_name = target_.at(1);
								if (find(block_->admins.begin(), block_->admins.end(), user_name) != block_->admins.end()) {
									block_->admins.erase(remove(block_->admins.begin(), block_->admins.end(), user_name), block_->admins.end());
									gamepacket_t p;
									p.Insert("OnConsoleMessage");
									p.Insert(user_name + " was removed from a VIP List.");
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
										if (pInfo(currentPeer)->tankIDName == user_name) {
											packet_(currentPeer, "action|play_sfx\nfile|audio/dialog_cancel.wav\ndelayMS|0");
											gamepacket_t p;
											p.Insert("OnTalkBubble");
											p.Insert(pInfo(currentPeer)->netID);
											if (pInfo(p_)->mod == 0 && pInfo(p_)->dev == 0)pInfo(p_)->name_color = "`2";
											p.Insert(pInfo(p_)->name_color + pInfo(p_)->tankIDName + "`` has `4removed`` you from a VIP List in `w" + world_->name + "``.");
											p.Insert(0), p.Insert(0);
											p.CreatePacket(currentPeer);
										}
										if (pInfo(currentPeer)->world == world_->name) {
											p.CreatePacket(currentPeer);
										}
									}
								}
							}
						}
						else if (a_.at(b_) == "playerNetID") {
							if (a_.size() >= (b_ + 1) - 1) {
								if (not isdigit(a_.at(b_ + 1).at(0))) break;
								uint32_t netID = atoi(a_.at(b_ + 1).c_str());
								if (netID == pInfo(p_)->netID) {
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(p_)->netID);
									p.Insert("I'm already a VIP!");
									p.Insert(0), p.Insert(0);
									p.CreatePacket(p_);
									break;
								}
								if (block_->admins.size() >= 26) {
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(p_)->netID);
									p.Insert("VIP Entrance has reached access limit!");
									p.Insert(0);
									p.Insert(0);
									p.CreatePacket(p_);
									continue;
								}
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
									if (pInfo(currentPeer)->world == world_->name and pInfo(currentPeer)->netID == netID) {
										if (find(block_->admins.begin(), block_->admins.end(), pInfo(currentPeer)->tankIDName) != block_->admins.end()) {
											gamepacket_t p;
											p.Insert("OnTalkBubble");
											p.Insert(pInfo(p_)->netID);
											p.Insert(pInfo(currentPeer)->name_color + pInfo(currentPeer)->tankIDName + "`` is already on the VIP list.");
											p.Insert(0), p.Insert(0);
											p.CreatePacket(p_);
											return;
										}
										block_->admins.push_back(pInfo(currentPeer)->tankIDName);
										gamepacket_t p;
										p.Insert("OnTalkBubble");
										p.Insert(pInfo(p_)->netID);
										p.Insert("Put " + pInfo(currentPeer)->name_color + pInfo(currentPeer)->tankIDName + "`` on the VIP List.");
										p.Insert(0), p.Insert(0);
										p.CreatePacket(p_);
										{
											gamepacket_t p;
											p.Insert("OnConsoleMessage");
											p.Insert(pInfo(currentPeer)->tankIDName + " was added to a VIP List.");
											for (ENetPeer* currentPeer2 = server->peers; currentPeer2 < &server->peers[server->peerCount]; ++currentPeer2) {
												if (currentPeer2->state != ENET_PEER_STATE_CONNECTED or currentPeer2->data == NULL) continue;
												if (pInfo(currentPeer2)->world == world_->name) {
													p.CreatePacket(currentPeer2);
												}
											}
										}
										break;
									}
								}
								break;
							}
						}
					}
					PlayerMoving data_{};
					data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
					BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
					BYTE* blc = raw + 56;
					form_visual(blc, *block_, *world_, p_, false);
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
						if (pInfo(currentPeer)->world == world_->name) {
							send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
						}
					}
					delete[] raw, blc;
				}
			}
			catch (out_of_range) {
				return;
			}
			return;
		}
		else if (a_[i_] == "crystal_exchange") {
			if (a_.size() != 14) break;
			if (not isdigit(a_[i_ + 2][0]) or not isdigit(a_[i_ + 5][0]) or not isdigit(a_[11][0])) break;
			int x_ = atoi(a_[i_ + 2].c_str()), y_ = atoi(a_[i_ + 5].c_str());
			if (x_ < 0 or x_ >= 100 or y_ < 0 or y_ >= 60) break;
			int item_id = atoi(a_[11].c_str());
			if (item_id <= 0 || item_id >= items.size()) break;
			string name_ = pInfo(p_)->world;
			vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
			if (p != worlds.end()) {
				World* world_ = &worlds[p - worlds.begin()];
				WorldBlock* block_ = &world_->blocks[x_ + (y_ * 100)];
				uint16_t t_ = (block_->fg ? block_->fg : block_->bg);
				if (items[t_].blockType != BlockTypes::CRYSTAL) break;
				string owner_name = world_->owner_name, user_name = pInfo(p_)->tankIDName;
				if (not world_->open_to_public and owner_name != user_name and not pInfo(p_)->dev and not world_->owner_name.empty() and (!guild_access(p_, world_->guild_id) and find(world_->admins.begin(), world_->admins.end(), pInfo(p_)->tankIDName) == world_->admins.end())) {
					if (block_->locked) {
						WorldBlock* check_lock = &world_->blocks[block_->lock_origin];
						if (not check_lock->open_to_public and check_lock->owner_name != pInfo(p_)->tankIDName and (find(check_lock->admins.begin(), check_lock->admins.end(), pInfo(p_)->tankIDName) == check_lock->admins.end())) break;
					}
					else {
						break;
					}
				}
				vector<vector<int>> current_{ {2242, 0}, {2244, 0}, {2246, 0}, {2248, 0}, {2250, 0} };
				for (int i = 0; i < block_->crystals.size(); i++) {
					vector<int> c_ = block_->crystals[i];
					for (int a = 0; a < current_.size(); a++) {
						if (current_[a][0] == c_[0]) {
							current_[a][1] = block_->crystals[i][1];
							break;
						}
					}
				}
				for (vector<vector<int>> a_ : crystal_receptai) {
					if (a_[5][0] == item_id) {
						bool can_ = true;
						for (vector<int> b_ : a_) {
							for (int i = 0; i < current_.size(); i++) {
								if (current_[i][0] == b_[0] and current_[i][1] < b_[1]) {
									can_ = false;
									break;
								}
							} if (not can_) {
								break;
							}
						} if (can_) {
							PlayerMoving data_{};
							data_.packetType = 0x11, data_.x = x_ * 32 + 16, data_.y = y_ * 32 + 16;
							data_.YSpeed = 97, data_.XSpeed = t_;
							BYTE* raw = packPlayerMoving(&data_);
							for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
								if (pInfo(currentPeer)->world == world_->name) {
									send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
								}
							}
							delete[] raw;
							{
								gamepacket_t p;
								p.Insert("OnTalkBubble");
								p.Insert(pInfo(p_)->netID);
								p.Insert("The crystal shatters and drops " + items[a_[5][0]].name + "!");
								p.Insert(0), p.Insert(1);
								p.CreatePacket(p_);

								WorldDrop drop_block_{};
								drop_block_.id = a_[5][0], drop_block_.count = a_[5][1], drop_block_.uid = uint16_t(world_->drop.size()) + 1, drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
								dropas_(world_, drop_block_);
							}
							reset_(block_, x_, y_, world_);
							{
								PlayerMoving data_{};
								data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
								BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
								BYTE* blc = raw + 56;
								form_visual(blc, *block_, *world_, p_, false);
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
									if (pInfo(currentPeer)->world == world_->name) {
										send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
									}
								}
								delete[] raw, blc;
							}
						}
						else {
							break;
						}
						break;
					}
				}
			}
			return;
		}
		else if (a_[i_] == "nupirkti") {
			if (a_.size() != 17 and a_.size() != 14) break;
			if (not isdigit(a_[8][0]) or not isdigit(a_[11][0])) break;
			string item_name = a_[5];
			int item_id = atoi(a_[8].c_str());
			int item_price = atoi(a_[11].c_str());
			if (a_.size() == 17) {
				SendCmd(p_, "/buy " + item_name, true);
				break;
			}
			if (pInfo(p_)->vip + pInfo(p_)->mod + pInfo(p_)->superdev + pInfo(p_)->dev >= 1) {
				for (int i_ = 0; i_ < items.size(); i_++) {
					uint32_t item_ids = items[i_].id;
					if (items[i_].ori_name == items[item_id].ori_name) {
						int free_slots = get_free_slots(pInfo(p_));
						if (free_slots == 0) {
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(p_)->netID);
							p.Insert("You don't have room in your backpack!");
							p.Insert(0), p.Insert(1);
							p.CreatePacket(p_);
							{
								gamepacket_t p;
								p.Insert("OnConsoleMessage");
								p.Insert("You don't have room in your backpack!");
								p.CreatePacket(p_);
							}
							break;
						}
						int a_ = 1;
						int jau_turi = 0;
						modify_inventory(p_, item_ids, jau_turi);
						a_ = 200 - jau_turi;
						if (modify_inventory(p_, item_ids, a_) == 0) {
							{
								PlayerMoving data_{};
								data_.x = pInfo(p_)->x + 10, data_.y = pInfo(p_)->y + 16;
								data_.packetType = 19, data_.plantingTree = 100;
								data_.punchX = item_ids, data_.punchY = pInfo(p_)->netID;
								int32_t to_netid = pInfo(p_)->netID;
								BYTE* raw = packPlayerMoving(&data_);
								raw[3] = 5;
								memcpy(raw + 8, &to_netid, 4);
								send_raw(p_, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
								delete[] raw;
							}
							gamepacket_t p(0, pInfo(p_)->netID);
							p.Insert("OnPlayPositioned");
							p.Insert("audio/cash_register.wav");
							p.CreatePacket(p_);
							{
								gamepacket_t p;
								p.Insert("OnConsoleMessage");
								p.Insert("`9You recieved " + to_string(a_) + " " + items[item_ids].ori_name + ".");
								p.CreatePacket(p_);
							}
						}
						break;
					}
				}
			}
			else {
				for (int i_ = 0; i_ < kainos.size(); i_++) {
					uint32_t item_ids = kainos[i_][0];
					if (items[item_ids].ori_name == items[item_id].ori_name) {
						if (item_price != kainos[i_][1]) break;
						int my_wls = get_wls(p_);
						if (kainos[i_][1] > my_wls) break;
						int free_slots = get_free_slots(pInfo(p_));
						if (free_slots == 0) {
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(p_)->netID);
							p.Insert("You don't have room in your backpack!");
							p.Insert(0), p.Insert(1);
							p.CreatePacket(p_);
							{
								gamepacket_t p;
								p.Insert("OnConsoleMessage");
								p.Insert("You don't have room in your backpack!");
								p.CreatePacket(p_);
							}
							break;
						}
						int diamond_lock = 0, world_lock = 0, grazinti_wl = 0;
						int is_viso_worldlock = kainos[i_][1];
						while (is_viso_worldlock >= 100) {
							is_viso_worldlock -= 100;
							diamond_lock++;
						}
						world_lock = is_viso_worldlock;
						int c_ = 0;
						modify_inventory(p_, 242, c_);
						int turi_world_lock = c_, t_w = c_ * -1;
						c_ = 0;
						modify_inventory(p_, 1796, c_);
						int turi_diamond_lock = c_, t_d = c_ * -1;
						while (diamond_lock > turi_diamond_lock && turi_world_lock >= 100) {
							turi_diamond_lock++, turi_world_lock -= 100;
						} if (diamond_lock > turi_diamond_lock) break;
						while (world_lock > turi_world_lock && turi_diamond_lock >= 1) {
							turi_diamond_lock--, turi_world_lock += 100;
						} if (world_lock > turi_world_lock) break;
						turi_world_lock -= world_lock, turi_diamond_lock -= diamond_lock;
						int a_ = 1;
						if (modify_inventory(p_, item_ids, a_) == 0) {
							modify_inventory(p_, 242, t_w), modify_inventory(p_, 1796, t_d);
							modify_inventory(p_, 242, turi_world_lock), modify_inventory(p_, 1796, turi_diamond_lock);
						}
						{
							PlayerMoving data_{};
							data_.x = pInfo(p_)->x + 10, data_.y = pInfo(p_)->y + 16;
							data_.packetType = 19, data_.plantingTree = 100;
							data_.punchX = item_ids, data_.punchY = pInfo(p_)->netID;
							int32_t to_netid = pInfo(p_)->netID;
							BYTE* raw = packPlayerMoving(&data_);
							raw[3] = 5;
							memcpy(raw + 8, &to_netid, 4);
							send_raw(p_, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
							delete[] raw;
						}
						gamepacket_t p(0, pInfo(p_)->netID);
						p.Insert("OnPlayPositioned");
						p.Insert("audio/cash_register.wav");
						p.CreatePacket(p_);
						{
							gamepacket_t p;
							p.Insert("OnConsoleMessage");
							p.Insert("`7[```9" + pInfo(p_)->tankIDName + " bought 1 " + items[item_ids].ori_name + " for " + to_string(kainos[i_][1]) + " World Locks.```7]``");
							p.CreatePacket(p_);
						}
						break;
					}
				}
			}
			break;
		}
		else if (a_[i_] == "buy_option") {
			if (a_.size() != 11) break;
			string name_ = a_[5];
			string target_ = a_[8];
			vector<string> buys = explode("_", target_);
			if (buys.size() != 2) break;
			if (not isdigit(buys[1][0])) break;
			int item_id = atoi(buys[1].c_str());
			if (item_id <= 0 || item_id >= items.size()) break;
			if (pInfo(p_)->vip + pInfo(p_)->mod + pInfo(p_)->superdev + pInfo(p_)->dev >= 1) {
				for (int i_ = 0; i_ < items.size(); i_++) {
					uint32_t item_ids = items[i_].id;
					//if (item_ids < 0 || item_ids >= items.size()) break;
					if (items[i_].ori_name == items[item_id].ori_name) {
						uint32_t item_count = 200;
						gamepacket_t p;
						p.Insert("OnDialogRequest");
						p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wAre You Sure?``|left|1366|\nadd_spacer|small|\nembed_data|name|" + name_ + "\nembed_data|pirkti_id|" + to_string(item_ids) + "\nembed_data|pirkti_kaina|" + to_string(item_count) + "\nadd_spacer|small|\nadd_textbox|`2You'll get:``|left|\nadd_spacer|small|\nadd_label_with_icon|small|(`w200``) `2" + items[item_ids].ori_name + "``|left|" + to_string(item_ids) + "|\nadd_spacer|small|\nend_dialog|nupirkti|Cancel|OK");
						p.CreatePacket(p_);
						break;
					}
				}
			}
			else {
				for (int i_ = 0; i_ < kainos.size(); i_++) {
					uint32_t item_ids = kainos[i_][0];
					if (item_ids <= 0 || item_ids >= items.size()) break;
					if (items[item_ids].ori_name == items[item_id].ori_name) {
						int my_wls = get_wls(p_), item_count = kainos[i_][1];
						gamepacket_t p;
						p.Insert("OnDialogRequest");
						p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wItem Confirmation``|left|1366|\nadd_spacer|small|\nembed_data|name|" + name_ + "\nembed_data|pirkti_id|" + to_string(item_ids) + "\nembed_data|pirkti_kaina|" + to_string(item_count) + "\nadd_spacer|small|\nadd_spacer|small|\nadd_textbox|`2You'll get:``|left|\nadd_spacer|small|\nadd_label_with_icon|small|(`w1``) `2" + items[item_ids].ori_name + "``|left|" + to_string(item_ids) + "|\nadd_spacer|small|\nadd_spacer|small|\nadd_textbox|" + (item_count > my_wls ? "`4You can't afford this item you're " + to_string(item_count - my_wls) + " World Lock's short" : "Are you sure you want to make this purchase?") + "|left|\nadd_spacer|small|\nend_dialog|nupirkti|Cancel|" + (item_count > my_wls ? "" : "OK") + "|");
						p.CreatePacket(p_);
						break;
					}
				}
			}
			break;
		}
		else if (a_[i_] == "weatherspcl") {
			if (a_.size() != 13 and a_.size() != 17 and a_.size() != 19) break;
			if (not isdigit(a_[i_ + 2][0]) or not isdigit(a_[i_ + 5][0])) break;
			int x_ = atoi(a_[i_ + 2].c_str()), y_ = atoi(a_[i_ + 5].c_str());
			if (x_ < 0 or x_ >= 100 or y_ < 0 or y_ >= 60) break;
			string name_ = pInfo(p_)->world;
			vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
			if (p != worlds.end()) {
				World* world_ = &worlds[p - worlds.begin()];
				WorldBlock* block_ = &world_->blocks[x_ + (y_ * 100)];
				uint16_t t_ = (block_->fg ? block_->fg : block_->bg);
				string owner_name = world_->owner_name, user_name = pInfo(p_)->tankIDName;
				if (not world_->open_to_public and owner_name != user_name and not pInfo(p_)->dev and not world_->owner_name.empty() and (!guild_access(p_, world_->guild_id) and find(world_->admins.begin(), world_->admins.end(), pInfo(p_)->tankIDName) == world_->admins.end())) {
					if (block_->locked) {
						WorldBlock* check_lock = &world_->blocks[block_->lock_origin];
						if (not check_lock->open_to_public and check_lock->owner_name != pInfo(p_)->tankIDName and (find(check_lock->admins.begin(), check_lock->admins.end(), pInfo(p_)->tankIDName) == check_lock->admins.end())) break;
					}
					else {
						break;
					}
				}
				if (block_->fg != 5000 and block_->fg != 3832 and block_->fg != 3694 and block_->fg != 5958) break;
				bool update_ = false;
				if (block_->fg == 3694 and a_.size() == 17) {
					if (not isdigit(a_[i_ + 8][0]) or not isdigit(a_[i_ + 10][0]) or not isdigit(a_[i_ + 12][0])) break;
					int r = atoi(a_[i_ + 8].c_str()), g = atoi(a_[i_ + 10].c_str()), b = atoi(a_[i_ + 12].c_str());
					if (r < 0 or g < 0 or b < 0 or r > 255 or g > 255 or b > 255) return;
					if (r < 40 and g < 40 and b < 40) {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(p_)->netID);
						p.Insert("You can't make a heatwave that dark (one of the colors must be 40+)!");
						p.Insert(0), p.Insert(1);
						p.CreatePacket(p_);
						return;
					}
					block_->r = r;
					block_->g = g;
					block_->b = b;
					update_ = true;
				}
				else if (block_->fg == 3832 and a_.size() == 19) {
					if (not isdigit(a_[i_ + 8][0])) break;
					uint32_t new_id = atoi(a_[i_ + 8].c_str());
					if (block_->id != new_id) {
						block_->id = new_id;
						update_ = true;
					}
					int new_gravity = atoi(a_[i_ + 10].c_str());
					if (new_gravity > 500) new_gravity = 500;
					if (new_gravity < -500) new_gravity = -500;
					if (block_->gravity != new_gravity) {
						block_->gravity = new_gravity;
						update_ = true;
					}
					if (not isdigit(a_[i_ + 12][0])) break;
					bool new_spin = atoi(a_[i_ + 12].c_str());
					if (block_->spin != new_spin) block_->spin = new_spin, update_ = true;
					if (not isdigit(a_[i_ + 14][0])) break;
					bool new_invert = atoi(a_[i_ + 14].c_str());
					if (block_->invert != new_invert) block_->invert = new_invert, update_ = true;
				}
				else if (block_->fg == 3832 and a_.size() == 17) {
					int new_gravity = atoi(a_[i_ + 8].c_str());
					if (new_gravity > 500) new_gravity = 500;
					if (new_gravity < -500) new_gravity = -500;
					if (block_->gravity != new_gravity) {
						block_->gravity = new_gravity;
						update_ = true;
					}
					if (not isdigit(a_[i_ + 10][0])) break;
					bool new_spin = atoi(a_[i_ + 10].c_str());
					if (block_->spin != new_spin) block_->spin = new_spin, update_ = true;
					if (not isdigit(a_[i_ + 12][0])) break;
					bool new_invert = atoi(a_[i_ + 12].c_str());
					if (block_->invert != new_invert) block_->invert = new_invert, update_ = true;
				}
				else {
					if (not isdigit(a_[i_ + 8][0])) break;
					uint32_t new_id = atoi(a_[i_ + 8].c_str());
					if (block_->fg == 5000 and items[new_id].blockType != BlockTypes::BACKGROUND) {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(p_)->netID);
						p.Insert("That's not a background!");
						p.Insert(0), p.Insert(1);
						p.CreatePacket(p_);
						break;
					} if (block_->id != new_id) {
						block_->id = new_id;
						update_ = true;
					}
				}
				PlayerMoving data_{};
				data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
				BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
				BYTE* blc = raw + 56;
				form_visual(blc, *block_, *world_, p_, false);
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
					if (pInfo(currentPeer)->world == world_->name) {
						send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
					}
				}
				delete[] raw, blc;
				if (block_->locked) {
					upd_lock(*block_, *world_, p_);
				}
				if (block_->enabled and update_) {
					gamepacket_t p;
					p.Insert("OnSetCurrentWeather");
					p.Insert(world_->weather == 0 ? 80 : world_->weather);
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
						if (pInfo(currentPeer)->world == name_) {
							p.CreatePacket(currentPeer);
						}
					}
				}
			}
			break;
		}
		else if (a_[i_] == "itemaddedtosucker" or a_[i_] == "itemremovedfromsucker") {
			if (a_.size() != 13) break;
			if (not isdigit(a_[i_ + 2][0]) or not isdigit(a_[i_ + 5][0])) break;
			int x_ = atoi(a_[i_ + 2].c_str()), y_ = atoi(a_[i_ + 5].c_str());
			if (x_ < 0 or x_ >= 100 or y_ < 0 or y_ >= 60) break;
			string name_ = pInfo(p_)->world;
			vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
			if (p != worlds.end()) {
				World* world_ = &worlds[p - worlds.begin()];
				WorldBlock* block_ = &world_->blocks[x_ + (y_ * 100)];
				uint16_t t_ = (block_->fg ? block_->fg : block_->bg);
				string owner_name = world_->owner_name, user_name = pInfo(p_)->tankIDName;
				if (owner_name != user_name and not pInfo(p_)->dev and not owner_name.empty()) {
					if (block_->locked) {
						WorldBlock* check_lock = &world_->blocks[block_->lock_origin];
						if (check_lock->owner_name != pInfo(p_)->tankIDName) break;
					}
					else {
						break;
					}
				}
				if (not items[block_->fg].item_sucker) break;
				if (not isdigit(a_[i_ + 8][0])) break;
				if (t_ == 6948 and block_->pr >= 1500 and a_[i_] != "itemremovedfromsucker" or t_ == 6946 and block_->pr >= 1500 and a_[i_] != "itemremovedfromsucker" or t_ == 5638 and block_->pr >= 5000 and a_[i_] != "itemremovedfromsucker") break;
				int add_count = atoi(a_[i_ + 8].c_str());
				if (a_[i_] == "itemremovedfromsucker") {
					if (add_count > block_->pr) {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(p_)->netID);
						p.Insert("You are removing what you dont have.");
						p.Insert(0), p.Insert(1);
						p.CreatePacket(p_);
						{
							gamepacket_t p;
							p.Insert("OnConsoleMessage");
							p.Insert("You are removing what you dont have.");
							p.CreatePacket(p_);
						}
						break;
					}
					int c_ = 0;
					modify_inventory(p_, block_->id, c_);
					add_count = (add_count + c_ > 200 ? (add_count > 200 ? 200 - c_ : (add_count > c_ ? 200 - add_count : 200 - c_)) : add_count);
					if (add_count > block_->pr or c_ + add_count > 200) break;
					int add_ = add_count;
					if (modify_inventory(p_, block_->id, add_) == 0) {
						block_->pr -= add_count;
					}
					if (block_->islands == true) {
						gamepacket_t p;
						p.Insert("OnSetCurrentWeather");
						p.Insert(world_->weather == 40);
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
							if (pInfo(currentPeer)->world == name_) {
								p.CreatePacket(currentPeer);
							}
						}
					}
					if (block_->ice_age == true) {
						gamepacket_t p;
						p.Insert("OnSetCurrentWeather");
						p.Insert(world_->weather == 38);
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
							if (pInfo(currentPeer)->world == name_) {
								p.CreatePacket(currentPeer);
							}
						}
					}
					if (block_->volcano == true) {
						gamepacket_t p;
						p.Insert("OnSetCurrentWeather");
						p.Insert(world_->weather == 39);
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
							if (pInfo(currentPeer)->world == name_) {
								p.CreatePacket(currentPeer);
							}
						}
					}
				}
				else {
					int c_ = 0;
					modify_inventory(p_, block_->id, c_);
					if (c_ < add_count) {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(p_)->netID);
						p.Insert("You dont have " + items[block_->id].name);
						p.Insert(0), p.Insert(1);
						p.CreatePacket(p_);
						{
							gamepacket_t p;
							p.Insert("OnConsoleMessage");
							p.Insert("You dont have " + items[block_->id].name);
							p.CreatePacket(p_);
						}
						break;
					}
					int remove_count = add_count * -1;
					if (modify_inventory(p_, block_->id, remove_count) == 0) {
						block_->pr += add_count;
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(p_)->netID);
						p.Insert("Items added.");
						p.Insert(0), p.Insert(1);
						p.CreatePacket(p_);
						{
							gamepacket_t p;
							p.Insert("OnConsoleMessage");
							p.Insert("Items added.");
							p.CreatePacket(p_);
						}
					}
				}
				bool found_ = false;
				for (int i_ = 0; i_ < world_->machines.size(); i_++) {
					WorldMachines* machine_ = &world_->machines[i_];
					if (machine_->x == x_ and machine_->y == y_) {
						machine_->enabled = block_->enabled;
						machine_->target_item = block_->id;
						found_ = true;
						break;
					}
				} if (not found_) {
					//cout << "created new world machine" << endl;
					WorldMachines new_machine;
					new_machine.enabled = block_->enabled;
					new_machine.x = x_, new_machine.y = y_;
					new_machine.id = block_->fg;
					new_machine.target_item = block_->id;
					world_->machines.push_back(new_machine);
					if (find(t_worlds.begin(), t_worlds.end(), world_->name) == t_worlds.end()) {
						t_worlds.push_back(world_->name);
					}
				}
				PlayerMoving data_{};
				data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
				BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
				BYTE* blc = raw + 56;
				form_visual(blc, *block_, *world_, p_, false);
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
					if (pInfo(currentPeer)->world == world_->name) {
						send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
					}
				}
				delete[] raw, blc;
				if (block_->locked) {
					upd_lock(*block_, *world_, p_);
				}
			}
			break;
		}
		else if (a_[i_] == "itemsucker_block") {
			if (a_.size() != 13 and a_.size() != 16 and a_.size() != 14) break;
			if (not isdigit(a_[i_ + 2][0]) or not isdigit(a_[i_ + 5][0])) break;
			int x_ = atoi(a_[i_ + 2].c_str()), y_ = atoi(a_[i_ + 5].c_str());
			if (x_ < 0 or x_ >= 100 or y_ < 0 or y_ >= 60) break;
			string name_ = pInfo(p_)->world;
			vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
			if (p != worlds.end()) {
				World* world_ = &worlds[p - worlds.begin()];
				WorldBlock* block_ = &world_->blocks[x_ + (y_ * 100)];
				uint16_t t_ = (block_->fg ? block_->fg : block_->bg);
				string owner_name = world_->owner_name, user_name = pInfo(p_)->tankIDName;
				if (owner_name != user_name and not pInfo(p_)->dev and not owner_name.empty() and a_[11] != "getplantationdevice" and a_.size() != 14) {
					if (block_->locked) {
						WorldBlock* check_lock = &world_->blocks[block_->lock_origin];
						if (check_lock->owner_name != pInfo(p_)->tankIDName and a_[11] != "getplantationdevice" and a_.size() != 14) break;
					}
					else {
						break;
					}
				}

				if (not items[t_].item_sucker) break;
				if (a_.size() == 14 or a_[11] == "getplantationdevice") {
					if (block_->id != 0 and block_->fg == 5638) {
						if (items[block_->id].collisionType != 1 and items[block_->id].blockType != BACKGROUND and items[block_->id].blockType != CONSUMABLE and items[block_->id].blockType != SEED and not items[block_->id].farmable or items[block_->id].rarity == 999) {
							break;
						}
						if (pInfo(p_)->magnetron_x != 0 and pInfo(p_)->magnetron_y != 0 and pInfo(p_)->magnetron_x != x_ and pInfo(p_)->magnetron_x != y_) {
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(p_)->netID);
							p.Insert("You received a " + items[5640].name + ".");
							p.Insert(0), p.Insert(0);
							p.CreatePacket(p_);
							{
								gamepacket_t p;
								p.Insert("OnConsoleMessage");
								p.Insert("You received a " + items[5640].name + ".");
								p.CreatePacket(p_);
							}
							{
								pInfo(p_)->magnetron_id = block_->id;
								pInfo(p_)->magnetron_x = x_;
								pInfo(p_)->magnetron_y = y_;
								gamepacket_t p;
								p.Insert("OnPlanterActivated");
								p.Insert(block_->id);
								p.Insert(x_);
								p.Insert(y_);
								p.CreatePacket(p_);
							}
						}
						else {
							int c_ = 0;
							modify_inventory(p_, 5640, c_);
							if (c_ == 0) {
								{
									int c_ = 1;
									if (modify_inventory(p_, 5640, c_) == 0) {
										gamepacket_t p;
										p.Insert("OnTalkBubble");
										p.Insert(pInfo(p_)->netID);
										p.Insert("You received a " + items[5640].name + ".");
										p.Insert(0), p.Insert(0);
										p.CreatePacket(p_);
										{
											gamepacket_t p;
											p.Insert("OnConsoleMessage");
											p.Insert("You received a " + items[5640].name + ".");
											p.CreatePacket(p_);
										}
										{
											pInfo(p_)->magnetron_id = block_->id;
											pInfo(p_)->magnetron_x = x_;
											pInfo(p_)->magnetron_y = y_;
											gamepacket_t p;
											p.Insert("OnPlanterActivated");
											p.Insert(block_->id);
											p.Insert(x_);
											p.Insert(y_);
											p.CreatePacket(p_);
										}
									}
								}
							}
						}
					}
					break;
				}
				if (a_.size() == 13 and a_[i_ + 7] == "selectitem") {
					if (not isdigit(a_[i_ + 8][0])) break;
					uint32_t putting_item = atoi(a_[i_ + 8].c_str());
					if (putting_item >= items.size() or putting_item < 0) break;
					if (t_ == 5638) {
						if (items[putting_item].untradeable or items[putting_item].rarity == 999 and items[putting_item].blockType == BlockTypes::CLOTHING and items[putting_item].blockType != BlockTypes::CONSUMABLE) {
							if (not items[putting_item].farmable || items[putting_item].blockType == BlockTypes::CLOTHING) {
								gamepacket_t p;
								p.Insert("OnTalkBubble");
								p.Insert(pInfo(p_)->netID);
								p.Insert("This item is not compatible.");
								p.Insert(0), p.Insert(1);
								p.CreatePacket(p_);
								{
									gamepacket_t p;
									p.Insert("OnConsoleMessage");
									p.Insert("This item is not compatible.");
									p.CreatePacket(p_);
								}
								break;
							}
						}
						block_->id = putting_item;
						block_->enabled = true;
					}
					else if (t_ == 6948) {
						if (items[putting_item].blockType == BlockTypes::SEED) {
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(p_)->netID);
							p.Insert("You cannot store seeds in this machine.");
							p.Insert(0), p.Insert(1);
							p.CreatePacket(p_);
							{
								gamepacket_t p;
								p.Insert("OnConsoleMessage");
								p.Insert("You cannot store seeds in this machine.");
								p.CreatePacket(p_);
							}
							break;
						}
						if (items[putting_item].collisionType != 1 or items[putting_item].rarity == 999) {
							if (items[putting_item].blockType != BACKGROUND or items[putting_item].rarity == 999) {
								if (not items[putting_item].farmable) {
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(p_)->netID);
									p.Insert("This item is not compatible.");
									p.Insert(0), p.Insert(1);
									p.CreatePacket(p_);
									{
										gamepacket_t p;
										p.Insert("OnConsoleMessage");
										p.Insert("This item is not compatible.");
										p.CreatePacket(p_);
									}
									break;
								}
							}
						}
						block_->id = putting_item;
						block_->enabled = true;
					}
					else if (t_ == 6946) {
						if (items[putting_item].blockType != BlockTypes::SEED) {
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(p_)->netID);
							p.Insert("You can only store seeds in this machine.");
							p.Insert(0), p.Insert(1);
							p.CreatePacket(p_);
							{
								gamepacket_t p;
								p.Insert("OnConsoleMessage");
								p.Insert("You can only store seeds in this machine.");
								p.CreatePacket(p_);
							}
							break;
						}
						block_->id = putting_item;
						block_->enabled = true;
					}
				}
				else {
					for (int b_ = 0; b_ < a_.size(); b_++) {
						if (a_[b_] == "retrieveitem") {
							if (block_->id != 0) {
								int c_ = 0;
								modify_inventory(p_, block_->id, c_);
								if (c_ < 200) {
									gamepacket_t p;
									p.Insert("OnDialogRequest");
									p.Insert("set_default_color|`o\nadd_spacer|small|\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\nadd_label_with_icon|small|`2" + items[block_->id].name + "``|left|" + to_string(block_->id) + "|\nadd_textbox|`wHow many `2" + items[block_->id].name + "`` would you like to remove?``|left||\nadd_text_input|itemtoremove|Amount:|" + (block_->pr + c_ > 200 ? (block_->pr > 200 ? to_string(200 - c_) : (block_->pr > c_ ? to_string(200 - block_->pr) : to_string(200 - c_))) : to_string(block_->pr)) + "|20|\nend_dialog|itemremovedfromsucker|Close|Retrieve|\nadd_spacer|small|");
									p.CreatePacket(p_);
								}
							}
							break;
						}
						else if (a_[b_] == "additem") {
							if (block_->id != 0) {
								int c_ = 0;
								modify_inventory(p_, block_->id, c_);
								if (c_ != 0) {
									gamepacket_t p;
									p.Insert("OnDialogRequest");
									p.Insert("set_default_color|`o\nadd_spacer|small|\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\nadd_label_with_icon|small|`2" + items[block_->id].name + "``|left|" + to_string(block_->id) + "|\nadd_smalltext|You have " + to_string(c_) + " `2" + items[block_->id].name + "`` in your backpack.|left|\nadd_textbox|`wHow many `2" + items[block_->id].name + "`` would you like to add?``|left|\nadd_text_input|itemtoadd|Amount:|" + (block_->pr + c_ > (block_->fg == 5638 ? 5000 : 1500) ? to_string((block_->fg == 5638 ? 5000 : 1500) - block_->pr) : to_string(c_)) + "|20|\nend_dialog|itemaddedtosucker|Close|Add|\nadd_spacer|small|");
									p.CreatePacket(p_);
								}
							}
							break;
						}
						else if (a_[b_] == "clearitem") {
							if (block_->id != 0 and block_->pr == 0) {
								if (block_->fg == 5638 and pInfo(p_)->magnetron_id != 0 and pInfo(p_)->magnetron_x == x_ and pInfo(p_)->magnetron_y == y_) {
									int c_ = 0;
									modify_inventory(p_, 5640, c_);
									if (c_ != 0) {
										c_ *= -1;
										modify_inventory(p_, 5640, c_);
										pInfo(p_)->magnetron_id = 0;
										pInfo(p_)->magnetron_x = 0;
										pInfo(p_)->magnetron_y = 0;
									}
								}
								block_->id = 0, block_->enabled = true;
								gamepacket_t p;
								p.Insert("OnDialogRequest");
								p.Insert(get_sucker(p_, world_, block_, x_, y_));
								p.CreatePacket(p_);
								break;
							}
							break;
						}
						else if (a_[b_].substr(0, 4) == "chk_") {
							vector<string> target_ = explode("_", a_[b_]);
							if (target_[1] == "enablesucking") {
								block_->enabled = (a_[b_ + 1] == "1" and not block_->enabled ? true : (a_[b_ + 1] == "0" and block_->enabled ? false : false));
							}
						}
					}
				}
				bool found_ = false;
				for (int i_ = 0; i_ < world_->machines.size(); i_++) {
					WorldMachines* machine_ = &world_->machines[i_];
					if (machine_->x == x_ and machine_->y == y_) {
						machine_->enabled = block_->enabled;
						machine_->target_item = block_->id;
						found_ = true;
						break;
					}
				} if (not found_) {
					//cout << "created new world machine" << endl;
					WorldMachines new_machine;
					new_machine.enabled = block_->enabled;
					new_machine.x = x_, new_machine.y = y_;
					new_machine.id = block_->fg;
					new_machine.target_item = block_->id;
					world_->machines.push_back(new_machine);
					if (find(t_worlds.begin(), t_worlds.end(), world_->name) == t_worlds.end()) {
						t_worlds.push_back(world_->name);
					}
				}
				PlayerMoving data_{};
				data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
				BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
				BYTE* blc = raw + 56;
				form_visual(blc, *block_, *world_, p_, false);
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
					if (pInfo(currentPeer)->world == world_->name) {
						send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
					}
				}
				delete[] raw, blc;
				if (block_->locked) {
					upd_lock(*block_, *world_, p_);
				}
			}
			break;
		}
		
		else if (a_[i_] == "autoactionblock") {
			if (a_.size() != 15 and a_.size() != 16) break;
			if (not isdigit(a_[i_ + 2][0]) or not isdigit(a_[i_ + 5][0])) break;
			int x_ = atoi(a_[i_ + 2].c_str()), y_ = atoi(a_[i_ + 5].c_str());
			if (x_ < 0 or x_ >= 100 or y_ < 0 or y_ >= 60) break;
			string name_ = pInfo(p_)->world;
			vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
			if (p != worlds.end()) {
				World* world_ = &worlds[p - worlds.begin()];
				WorldBlock* block_ = &world_->blocks[x_ + (y_ * 100)];
				uint16_t t_ = (block_->fg ? block_->fg : block_->bg);
				string owner_name = world_->owner_name, user_name = pInfo(p_)->tankIDName;
				if (owner_name != user_name and not pInfo(p_)->dev) {
					if (block_->locked) {
						WorldBlock* check_lock = &world_->blocks[block_->lock_origin];
						if (check_lock->owner_name != pInfo(p_)->tankIDName) break;
					}
					else {
						break;
					}
				}
				switch (t_) {
				case 6950: case 6952:
				{
					for (int b_ = 0; b_ < a_.size(); b_++) {
						if (a_[b_] == "refillfuel") {
							if (not isdigit(a_[b_ + 1][0])) return;
							int target_amount = atoi(a_[b_ + 1].c_str());
							if (target_amount > pInfo(p_)->gems) target_amount = pInfo(p_)->gems;
							if (target_amount == 0) continue;
							if (block_->pr + target_amount > 8000) {
								target_amount = 8000 - block_->pr;
							}
							pInfo(p_)->gems -= target_amount;
							{
								gamepacket_t p;
								p.Insert("OnSetBux");
								p.Insert(pInfo(p_)->gems);
								p.Insert(0);
								p.Insert((pInfo(p_)->supp >= 1) ? 1 : 0);
								if (pInfo(p_)->supp >= 2) {
									p.Insert((float)33796, (float)1, (float)0);
								}
								p.CreatePacket(p_);
							}
							block_->pr += target_amount;
						}
						else if (a_[b_] == "selecttarget") {
							if (not isdigit(a_[b_ + 1][0])) return;
							uint32_t target_item = atoi(a_[b_ + 1].c_str());
							if (t_ == 6952) {
								if (items[target_item].blockType == BlockTypes::SEED) target_item--;
								if (items[target_item].rarity == 999) {
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(p_)->netID);
									p.Insert("Sorry that item is `4NOT`` allowed in this machine!");
									p.Insert(0), p.Insert(1);
									p.CreatePacket(p_);
									{
										gamepacket_t p;
										p.Insert("OnConsoleMessage");
										p.Insert("Sorry that item is `4NOT`` allowed in this machine!");
										p.CreatePacket(p_);
									}
									return;
								} if (items[target_item].blockType == BlockTypes::CLOTHING or items[target_item].properties & Property_Mod) {
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(p_)->netID);
									p.Insert("`4NOPE!``");
									p.Insert(0), p.Insert(1);
									p.CreatePacket(p_);
									{
										gamepacket_t p;
										p.Insert("OnConsoleMessage");
										p.Insert("`4NOPE!``");
										p.CreatePacket(p_);
									}
									return;
								}
							}
							else {
								if (items[target_item].blockType != BlockTypes::SEED) target_item++;
								if (items[target_item].rarity == 999) {
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(p_)->netID);
									p.Insert("Sorry that item is `4NOT`` allowed in this machine!");
									p.Insert(0), p.Insert(1);
									p.CreatePacket(p_);
									{
										gamepacket_t p;
										p.Insert("OnConsoleMessage");
										p.Insert("Sorry that item is `4NOT`` allowed in this machine!");
										p.CreatePacket(p_);
									}
									return;
								}
								if (items[target_item].collisionType != 1 and items[target_item].blockType != BlockTypes::SEED) {
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(p_)->netID);
									p.Insert("`4NOPE!``");
									p.Insert(0), p.Insert(1);
									p.CreatePacket(p_);
									{
										gamepacket_t p;
										p.Insert("OnConsoleMessage");
										p.Insert("`4NOPE!``");
										p.CreatePacket(p_);
									}
									return;
								}
							}
							block_->id = target_item;
						}
					}
					{
						bool found_ = false;
						for (int i_ = 0; i_ < world_->machines.size(); i_++) {
							WorldMachines* machine_ = &world_->machines[i_];
							if (machine_->x == x_ and machine_->y == y_) {
								machine_->enabled = block_->enabled;
								machine_->target_item = block_->id;
								found_ = true;
								break;
							}
						} if (not found_) {
							//cout << "created new world machine" << endl;
							WorldMachines new_machine;
							new_machine.enabled = block_->enabled;
							new_machine.x = x_, new_machine.y = y_;
							new_machine.id = block_->fg;
							new_machine.target_item = block_->id;
							world_->machines.push_back(new_machine);
							if (find(t_worlds.begin(), t_worlds.end(), world_->name) == t_worlds.end()) {
								t_worlds.push_back(world_->name);
							}
						}
					}
					PlayerMoving data_{};
					data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
					BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
					BYTE* blc = raw + 56;
					form_visual(blc, *block_, *world_, p_, false);
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
						if (pInfo(currentPeer)->world == world_->name) {
							send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
						}
					}
					delete[] raw, blc;
					if (block_->locked) {
						upd_lock(*block_, *world_, p_);
					}
					break;
				}
				default:
					break;
				}
			}
			break;
		}
		else if (a_[i_] == "blaster") {
			if (a_.size() != 17) break;
			if (not isdigit(a_[i_ + 2][0]) or not isdigit(a_[i_ + 5][0]) or not isdigit(a_[i_ + 8][0]) or not isdigit(a_[i_ + 10][0]) or not isdigit(a_[i_ + 12][0])) break;
			int x_ = atoi(a_[i_ + 2].c_str()), y_ = atoi(a_[i_ + 5].c_str()), often_ = atoi(a_[i_ + 8].c_str()), speed_ = atoi(a_[i_ + 10].c_str());
			if (x_ < 0 or x_ >= 100 or y_ < 0 or y_ >= 60) break;
			if (speed_ > 250) speed_ = 250;
			if (speed_ < 10) speed_ = 10;
			if (often_ > 20) often_ = 20;
			if (often_ < 2) often_ = 2;
			string name_ = pInfo(p_)->world;
			vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
			if (p != worlds.end()) {
				World* world_ = &worlds[p - worlds.begin()];
				WorldBlock* block_ = &world_->blocks[x_ + (y_ * 100)];
				uint16_t t_ = (block_->fg ? block_->fg : block_->bg);
				string owner_name = world_->owner_name, user_name = pInfo(p_)->tankIDName;
				if (not world_->open_to_public and owner_name != user_name and not pInfo(p_)->dev and not world_->owner_name.empty() and (!guild_access(p_, world_->guild_id) and find(world_->admins.begin(), world_->admins.end(), pInfo(p_)->tankIDName) == world_->admins.end())) {
					if (block_->locked) {
						WorldBlock* check_lock = &world_->blocks[block_->lock_origin];
						if (not check_lock->open_to_public and check_lock->owner_name != pInfo(p_)->tankIDName and (find(check_lock->admins.begin(), check_lock->admins.end(), pInfo(p_)->tankIDName) == check_lock->admins.end())) break;
					}
					else {
						break;
					}
				}
				if (not items[t_].trickster) break;
				block_->flags = (block_->flags & 0x00400000 and a_[i_ + 12] == "1" ? block_->flags ^ 0x00400000 : (a_[i_ + 12] == "0" ? block_->flags | 0x00400000 : block_->flags));
				bool found_ = false;
				block_->rate_of_fire = often_;
				block_->projectile_speed = speed_;
				for (int i_ = 0; i_ < world_->npc.size(); i_++) {
					WorldNPC* npc_ = &world_->npc[i_];
					if (npc_->x == x_ and npc_->y == y_) {
						npc_->enabled = (block_->flags & 0x00400000 ? true : false);
						npc_->rate_of_fire = often_;
						npc_->projectile_speed = speed_;
						npc_->kryptis = (block_->flags & 0x00200000 ? 180 : 0);
						found_ = true;
						break;
					}
				} if (not found_) {
					WorldNPC new_npc;
					new_npc.enabled = (block_->flags & 0x00400000 ? true : false);
					new_npc.x = x_, new_npc.y = y_;
					new_npc.id = block_->fg;
					new_npc.projectile_speed = speed_;
					new_npc.rate_of_fire = often_;
					new_npc.kryptis = (block_->flags & 0x00200000 ? 180 : 0);
					world_->npc.push_back(new_npc);
					if (find(t_worlds.begin(), t_worlds.end(), world_->name) == t_worlds.end()) {
						t_worlds.push_back(world_->name);
					}
				}
				block_->enabled = (block_->flags & 0x00400000 ? true : false);
				PlayerMoving data_{};
				data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
				BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
				BYTE* blc = raw + 56;
				form_visual(blc, *block_, *world_, p_, false);
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
					if (pInfo(currentPeer)->world == world_->name) {
						send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
					}
				}
				delete[] raw, blc;
				if (block_->locked) {
					upd_lock(*block_, *world_, p_);
				}
				gamepacket_t p;
				p.Insert("OnTalkBubble");
				p.Insert(pInfo(p_)->netID);
				p.Insert("Settings updated!");
				p.Insert(0), p.Insert(0);
				p.CreatePacket(p_);
			}
			break;
		}
		else if (a_[i_] == "boombox_edit") {
			if (a_.size() != 15) break;
			if (not isdigit(a_[i_ + 2][0]) or not isdigit(a_[i_ + 5][0])) break;
			int x_ = atoi(a_[i_ + 2].c_str()), y_ = atoi(a_[i_ + 5].c_str());
			if (x_ < 0 or x_ >= 100 or y_ < 0 or y_ >= 60) break;
			string name_ = pInfo(p_)->world;
			vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
			if (p != worlds.end()) {
				World* world_ = &worlds[p - worlds.begin()];
				WorldBlock* block_ = &world_->blocks[x_ + (y_ * 100)];
				uint16_t t_ = (block_->fg ? block_->fg : block_->bg);
				string owner_name = world_->owner_name, user_name = pInfo(p_)->tankIDName;
				if (not world_->open_to_public and owner_name != user_name and not pInfo(p_)->dev and not world_->owner_name.empty() and (!guild_access(p_, world_->guild_id) and find(world_->admins.begin(), world_->admins.end(), pInfo(p_)->tankIDName) == world_->admins.end())) {
					if (block_->locked) {
						WorldBlock* check_lock = &world_->blocks[block_->lock_origin];
						if (not check_lock->open_to_public and check_lock->owner_name != pInfo(p_)->tankIDName and (find(check_lock->admins.begin(), check_lock->admins.end(), pInfo(p_)->tankIDName) == check_lock->admins.end())) break;
					}
					else {
						break;
					}
				}
				if (not items[t_].can_be_changed_two_types) break;
				block_->flags = (block_->flags & 0x00800000 and a_[i_ + 8] == "0" ? block_->flags ^ 0x00800000 : (a_[i_ + 8] == "1" ? block_->flags | 0x00800000 : block_->flags));
				block_->flags = (block_->flags & 0x02000000 and a_[i_ + 10] == "0" ? block_->flags ^ 0x02000000 : (a_[i_ + 10] == "1" ? block_->flags | 0x02000000 : block_->flags));
				PlayerMoving data_{};
				data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
				BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
				BYTE* blc = raw + 56;
				form_visual(blc, *block_, *world_, p_, false);
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
					if (pInfo(currentPeer)->world == world_->name) {
						send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
					}
				}
				delete[] raw, blc;
				if (block_->locked) {
					upd_lock(*block_, *world_, p_);
				}
			}
			break;
		}
		else if (a_[i_] == "switcheroo_edit") {
			if (a_.size() != 13) break;
			if (not isdigit(a_[i_ + 2][0]) or not isdigit(a_[i_ + 5][0])) break;
			int x_ = atoi(a_[i_ + 2].c_str()), y_ = atoi(a_[i_ + 5].c_str());
			if (x_ < 0 or x_ >= 100 or y_ < 0 or y_ >= 60) break;
			string name_ = pInfo(p_)->world;
			vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
			if (p != worlds.end()) {
				World* world_ = &worlds[p - worlds.begin()];
				WorldBlock* block_ = &world_->blocks[x_ + (y_ * 100)];
				uint16_t t_ = (block_->fg ? block_->fg : block_->bg);
				string owner_name = world_->owner_name, user_name = pInfo(p_)->tankIDName;
				if (not world_->open_to_public and owner_name != user_name and not pInfo(p_)->dev and not world_->owner_name.empty() and (!guild_access(p_, world_->guild_id) and find(world_->admins.begin(), world_->admins.end(), pInfo(p_)->tankIDName) == world_->admins.end())) {
					if (block_->locked) {
						WorldBlock* check_lock = &world_->blocks[block_->lock_origin];
						if (not check_lock->open_to_public and check_lock->owner_name != pInfo(p_)->tankIDName and (find(check_lock->admins.begin(), check_lock->admins.end(), pInfo(p_)->tankIDName) == check_lock->admins.end())) break;
					}
					else {
						break;
					}
				}
				if (not items[t_].entrance and not items[t_].can_be_changed_to_public) break;
				block_->flags = (block_->flags & 0x00800000 and a_[i_ + 8] == "0" ? block_->flags ^ 0x00800000 : (a_[i_ + 8] == "1" ? block_->flags | 0x00800000 : block_->flags));
				PlayerMoving data_{};
				data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
				BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
				BYTE* blc = raw + 56;
				form_visual(blc, *block_, *world_, p_, false);
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
					if (pInfo(currentPeer)->world == world_->name) {
						send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
					}
				}
				delete[] raw, blc;
				if (block_->locked) {
					upd_lock(*block_, *world_, p_);
				}
			}
			break;
		}
		else if (a_[i_] == "trade_item") {
			if (a_.size() != 10) break;
			if (not isdigit(a_[5][0]) or not isdigit(a_[8][0])) break;
			int item_id = atoi(a_[5].c_str()), item_count = atoi(a_[8].c_str()), c_ = 0;
			modify_inventory(p_, item_id, c_);
			if (c_ < item_count or c_ == 0) break;
			mod_trade(p_, atoi(a_[5].c_str()), atoi(a_[8].c_str()));
			break;
		}
		else if (a_[i_] == "door_edit") {
			if (a_.size() != 19 and a_.size() != 17) break;
			if (not isdigit(a_[i_ + 2][0]) or not isdigit(a_[i_ + 5][0])) break;
			int x_ = atoi(a_[i_ + 2].c_str()), y_ = atoi(a_[i_ + 5].c_str());
			if (x_ < 0 or x_ >= 100 or y_ < 0 or y_ >= 60) break;
			string name_ = pInfo(p_)->world;
			vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
			if (p != worlds.end()) {
				World* world_ = &worlds[p - worlds.begin()];
				WorldBlock* block_ = &world_->blocks[x_ + (y_ * 100)];
				uint16_t t_ = (block_->fg ? block_->fg : block_->bg);
				if (items[t_].blockType != BlockTypes::DOOR and items[t_].blockType != BlockTypes::PORTAL) break;
				string owner_name = world_->owner_name, user_name = pInfo(p_)->tankIDName;
				if (not world_->open_to_public and owner_name != user_name and not pInfo(p_)->dev and not world_->owner_name.empty() and (!guild_access(p_, world_->guild_id) and find(world_->admins.begin(), world_->admins.end(), pInfo(p_)->tankIDName) == world_->admins.end())) {
					if (block_->locked) {
						WorldBlock* check_lock = &world_->blocks[block_->lock_origin];
						if (not check_lock->open_to_public and check_lock->owner_name != pInfo(p_)->tankIDName and (find(check_lock->admins.begin(), check_lock->admins.end(), pInfo(p_)->tankIDName) == check_lock->admins.end())) break;
					}
					else {
						break;
					}
				}
				string door_name = a_[i_ + 8];
				string door_target = a_[i_ + 10];
				string door_id = a_[i_ + 12];
				if (a_.size() == 19) {
					string checkbox_locked = a_[i_ + 14];
					block_->open = (checkbox_locked == "0" ? false : true);
				}
				if (door_name.size() > 100) break;
				if (door_target.size() > 24) break;
				if (door_id.size() > 11) break;
				transform(door_target.begin(), door_target.end(), door_target.begin(), ::toupper);
				transform(door_id.begin(), door_id.end(), door_id.begin(), ::toupper);
				block_->door_destination = door_target, block_->door_id = door_id;
				block_->txt = door_name;
				PlayerMoving data_{};
				data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
				BYTE* raw = packPlayerMoving(&data_, 112 + door_name.size() + alloc_(world_, block_));
				BYTE* blc = raw + 56;
				form_visual(blc, *block_, *world_, p_, false);
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
					if (pInfo(currentPeer)->world == world_->name) {
						send_raw(currentPeer, 4, raw, 112 + door_name.size() + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
					}
				}
				delete[] raw, blc;
				if (block_->locked) {
					upd_lock(*block_, *world_, p_);
				}
			}
			break;
		}

		else if (a_[i_] == "vending") {
			if (a_.size() != 14 and a_.size() != 13 and a_.size() != 20 and a_.size() != 17 and a_.size() != 19 and a_.size() != 23) break;
			if (not isdigit(a_[i_ + 2][0]) or not isdigit(a_[i_ + 5][0])) break;
			if (a_.size() == 13 and not isdigit(a_[i_ + 8][0])) break;
			int x_ = atoi(a_[i_ + 2].c_str()), y_ = atoi(a_[i_ + 5].c_str());
			if (x_ < 0 or x_ >= 100 or y_ < 0 or y_ >= 60) break;
			if (abs(x_ * 32 - pInfo(p_)->x) > 15 || abs(y_ * 32 - pInfo(p_)->y) > 15) {
				gamepacket_t p;
				p.Insert("OnTalkBubble");
				p.Insert(pInfo(p_)->netID);
				p.Insert("Get closer!");
				p.Insert(0), p.Insert(0);
				p.CreatePacket(p_);
				break;
			}
			string name_ = pInfo(p_)->world;
			vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
			if (p != worlds.end()) {
				World* world_ = &worlds[p - worlds.begin()];
				WorldBlock* block_ = &world_->blocks[x_ + (y_ * 100)];
				uint16_t t_ = (block_->fg ? block_->fg : block_->bg);
				if (items[t_].blockType != BlockTypes::VENDING) break;
				if (a_.size() == 19 or a_.size() == 23) {
					if (not isdigit(a_[i_ + 11][0])) break;
					int expectprice = atoi(a_[i_ + 8].c_str()), expectitem = atoi(a_[i_ + 11].c_str()), buycount = atoi(a_[i_ + 14].c_str());
					if (a_.size() == 23) {
						buycount = atoi(a_[i_ + 11].c_str()), expectprice = atoi(a_[i_ + 14].c_str()), expectitem = atoi(a_[i_ + 17].c_str());
					}
					if (expectprice != block_->pr) break;
					if (expectitem != block_->id) break;
					if (buycount < 0) {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(p_)->netID);
						p.Insert("NEGATIVE, DOES NOT COMPUTE");
						p.Insert(0), p.Insert(0);
						p.CreatePacket(p_);
						break;
					}
					if (buycount == 0) break;
					int normal_price = (block_->pr > 0 ? block_->pr : (block_->pr * -1));
					int actual_buy_count = (block_->pr > 0 ? buycount : (normal_price < buycount ? buycount / normal_price : normal_price / buycount) * (block_->pr * -1));
					if (actual_buy_count == 0 or actual_buy_count > block_->c_) {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(p_)->netID);
						p.Insert("There aren't enough available to fulfill your order!");
						p.Insert(0), p.Insert(1);
						p.CreatePacket(p_);
						{
							gamepacket_t p;
							p.Insert("OnConsoleMessage");
							p.Insert("There aren't enough available to fulfill your order!");
							p.CreatePacket(p_);
						}
						break;
					}
					if (block_->pr < 0) {
						if (buycount < (block_->pr * -1)) {
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(p_)->netID);
							p.Insert("You have to buy at least 1 World Lock's worth.");
							p.Insert(0), p.Insert(1);
							p.CreatePacket(p_);
							{
								gamepacket_t p;
								p.Insert("OnConsoleMessage");
								p.Insert("You have to buy at least 1 World Lock's worth.");
								p.CreatePacket(p_);
							}
							break;
						}
					}
					int my_wls = get_wls(p_);
					int cost_ = (block_->pr > 0 ? block_->pr * buycount : (normal_price < buycount ? buycount / normal_price : normal_price / buycount));
					if (cost_ > my_wls) {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(p_)->netID);
						p.Insert("You can't afford that many!");
						p.Insert(0), p.Insert(1);
						p.CreatePacket(p_);
						{
							gamepacket_t p;
							p.Insert("OnConsoleMessage");
							p.Insert("You can't afford that many!");
							p.CreatePacket(p_);
						}
						break;
					}

					int has_alr = 0;
					modify_inventory(p_, block_->id, has_alr);
					if (has_alr + actual_buy_count > 200) {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(p_)->netID);
						p.Insert("You don't have room in your backpack!");
						p.Insert(0), p.Insert(1);
						p.CreatePacket(p_);
						{
							gamepacket_t p;
							p.Insert("OnConsoleMessage");
							p.Insert("You don't have room in your backpack!");
							p.CreatePacket(p_);
						}
						break;
					}
					int free_slots = get_free_slots(pInfo(p_));
					if (free_slots == 0) {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(p_)->netID);
						p.Insert("You don't have room in your backpack!");
						p.Insert(0), p.Insert(1);
						p.CreatePacket(p_);
						{
							gamepacket_t p;
							p.Insert("OnConsoleMessage");
							p.Insert("You don't have room in your backpack!");
							p.CreatePacket(p_);
						}
						break;
					}
					if (a_.size() == 19) {
						gamepacket_t p;
						p.Insert("OnDialogRequest");
						p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wPurchase Confirmation``|left|1366|\nadd_spacer|small|\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\nadd_spacer|small|\nadd_textbox|`4You'll give:``|left|\nadd_spacer|small|\nadd_label_with_icon|small|(`w" + to_string(cost_) + "``) `8World Locks``|left|242|\nadd_spacer|small|\nadd_textbox|`2You'll get:``|left|\nadd_spacer|small|\nadd_label_with_icon|small|(`w" + to_string(actual_buy_count) + "``) `2" + items[block_->id].ori_name + "``|left|" + to_string(block_->id) + "|\nadd_spacer|small|\nadd_spacer|small|\nadd_textbox|Are you sure you want to make this purchase?|left|\nembed_data|verify|1\nembed_data|buycount|" + to_string(buycount) + "\nembed_data|expectprice|" + to_string(expectprice) + "\nembed_data|expectitem|" + to_string(expectitem) + "\nend_dialog|vending|Cancel|OK|");
						p.CreatePacket(p_);
						break;
					}
					int diamond_lock = 0, world_lock = 0, grazinti_wl = 0;
					int is_viso_worldlock = cost_;
					while (is_viso_worldlock >= 100) {
						is_viso_worldlock -= 100;
						diamond_lock++;
					}
					world_lock = is_viso_worldlock;
					int c_ = 0;
					modify_inventory(p_, 242, c_);
					int turi_world_lock = c_, t_w = c_ * -1;
					c_ = 0;
					modify_inventory(p_, 1796, c_);
					int turi_diamond_lock = c_, t_d = c_ * -1;
					while (diamond_lock > turi_diamond_lock && turi_world_lock >= 100) {
						turi_diamond_lock++, turi_world_lock -= 100;
					} if (diamond_lock > turi_diamond_lock) break;
					while (world_lock > turi_world_lock && turi_diamond_lock >= 1) {
						turi_diamond_lock--, turi_world_lock += 100;
					} if (world_lock > turi_world_lock) break;
					turi_world_lock -= world_lock, turi_diamond_lock -= diamond_lock;
					int a_ = actual_buy_count;
					if (modify_inventory(p_, block_->id, a_) == 0) {
						modify_inventory(p_, 242, t_w), modify_inventory(p_, 1796, t_d);
						modify_inventory(p_, 242, turi_world_lock), modify_inventory(p_, 1796, turi_diamond_lock);
						gamepacket_t p;
						p.Insert("OnConsoleMessage");
						p.Insert("`7[```9" + pInfo(p_)->tankIDName + " bought " + to_string(actual_buy_count) + " " + items[block_->id].ori_name + " for " + to_string(cost_) + " World Locks.```7]``");
						gamepacket_t p2(0, pInfo(p_)->netID);
						p2.Insert("OnPlayPositioned");
						p2.Insert("audio/cash_register.wav");
						PlayerMoving data_{};
						data_.x = x_ * 32 + 16, data_.y = y_ * 32 + 16;
						data_.packetType = 19, data_.plantingTree = 100;
						data_.punchX = block_->id, data_.punchY = pInfo(p_)->netID;
						int32_t to_netid = pInfo(p_)->netID;
						BYTE* raw = packPlayerMoving(&data_);
						raw[3] = 5;
						memcpy(raw + 8, &to_netid, 4);
						block_->c_ -= actual_buy_count, block_->wl += cost_;
						if (block_->c_ <= 0) {
							block_->id = 0, block_->pr = 0;
						}
						PlayerMoving data_vending{};
						data_vending.packetType = 5, data_vending.punchX = x_, data_vending.punchY = y_, data_vending.characterState = 0x8;
						BYTE* v_ = packPlayerMoving(&data_vending, 112 + alloc_(world_, block_));
						BYTE* blc = v_ + 56;
						form_visual(blc, *block_, *world_, p_, false);
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
							if (pInfo(currentPeer)->world == world_->name) {
								send_raw(currentPeer, 4, v_, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
								p.CreatePacket(currentPeer);
								p2.CreatePacket(currentPeer);
								send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
							}
						}
						delete[]raw, v_, blc;
						if (block_->locked) {
							upd_lock(*block_, *world_, p_);
						}
						break;
					}
					gamepacket_t p;
					p.Insert("OnTalkBubble");
					p.Insert(pInfo(p_)->netID);
					p.Insert("You don't have room in your backpack!");
					p.Insert(0), p.Insert(1);
					p.CreatePacket(p_);
					{
						gamepacket_t p;
						p.Insert("OnConsoleMessage");
						p.Insert("You don't have room in your backpack!");
						p.CreatePacket(p_);
					}
					break;
				}
				string owner_name = world_->owner_name, user_name = pInfo(p_)->tankIDName;
				if (owner_name != user_name and find(world_->admins.begin(), world_->admins.end(), pInfo(p_)->tankIDName) == world_->admins.end() && world_->v_p == false) {
					if (block_->locked) {
						WorldBlock* check_lock = &world_->blocks[block_->lock_origin];
						if (check_lock->owner_name != pInfo(p_)->tankIDName) break;
					}
					else break;
				}

				bool update_ = false;
				if (cch.find("chk_peritem|1") != string::npos and cch.find("chk_perlock|1") != string::npos) {
					gamepacket_t p;
					p.Insert("OnTalkBubble");
					p.Insert(pInfo(p_)->netID);
					p.Insert("You can't have it both ways.");
					p.Insert(0), p.Insert(1);
					p.CreatePacket(p_);
					{
						gamepacket_t p;
						p.Insert("OnConsoleMessage");
						p.Insert("You can't have it both ways.");
						p.CreatePacket(p_);
					}
					break;
				} if (a_.size() == 20 or a_.size() == 17 or a_.size() == 14) {
					for (int b_ = 0; b_ < a_.size(); b_++) {
						if (a_[b_].substr(0, 4) == "chk_") {
							vector<string> target_ = explode("_", a_[b_]);
							if (target_[1] == "peritem") {
								if (block_->pr < 0 and a_[b_ + 1] == "1") {
									block_->pr *= -1, update_ = true;
								}
							}
							else if (target_[1] == "perlock") {
								if (block_->pr > 0 and a_[b_ + 1] == "1") {
									if (block_->pr > block_->c_) {
										gamepacket_t p;
										p.Insert("OnTalkBubble");
										p.Insert(pInfo(p_)->netID);
										p.Insert("You don't have enough in there for anyone to buy at that price!");
										p.Insert(0), p.Insert(1);
										p.CreatePacket(p_);
										{
											gamepacket_t p;
											p.Insert("OnConsoleMessage");
											p.Insert("You don't have enough in there for anyone to buy at that price!");
											p.CreatePacket(p_);
										}
										update_ = false;
										break;
									}
									block_->pr = block_->pr * -1;
									update_ = true;
								}
							}
						}
						else if (a_[b_] == "setprice") {
							int price_ = atoi(a_[b_ + 1].c_str());
							if (price_ == 0 or not isdigit(a_[b_ + 1][0]) and price_ >= 0) {
								block_->pr = 0;
								update_ = true;
							}
							else if (price_ < 0 or price_ > 20000) {
								gamepacket_t p;
								p.Insert("OnTalkBubble");
								p.Insert(pInfo(p_)->netID);
								p.Insert("Well, that's a silly price.");
								p.Insert(0), p.Insert(1);
								p.CreatePacket(p_);
								break;
							}
							else {
								if (block_->pr < 0) {
									if (price_ > block_->c_) {
										gamepacket_t p;
										p.Insert("OnTalkBubble");
										p.Insert(pInfo(p_)->netID);
										p.Insert("You don't have enough in there for anyone to buy at that price!");
										p.Insert(0), p.Insert(1);
										p.CreatePacket(p_);
										{
											gamepacket_t p;
											p.Insert("OnConsoleMessage");
											p.Insert("You don't have enough in there for anyone to buy at that price!");
											p.CreatePacket(p_);
										}
										update_ = false;
										break;
									} if (price_ > 200) {
										gamepacket_t p;
										p.Insert("OnTalkBubble");
										p.Insert(pInfo(p_)->netID);
										p.Insert("That price is so low, nobody can carry a World Lock worth of items!");
										p.Insert(0), p.Insert(1);
										p.CreatePacket(p_);
										{
											gamepacket_t p;
											p.Insert("OnConsoleMessage");
											p.Insert("That price is so low, nobody can carry a World Lock worth of items!");
											p.CreatePacket(p_);
										}
										break;
									}
								}
								block_->pr = (block_->pr < 0 ? price_ * -1 : price_);
								update_ = true;
							}
						}
						else if (a_[b_] == "addstock") {
							if (block_->id != 0) {
								int c_ = 0;
								modify_inventory(p_, block_->id, c_);
								int has_ = c_;
								c_ *= -1;
								if (modify_inventory(p_, block_->id, c_) == 0) {
									block_->c_ += has_;
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(p_)->netID);
									p.Insert("Added " + to_string(has_) + " items to the machine.");
									p.Insert(0), p.Insert(1);
									p.CreatePacket(p_);
									{
										gamepacket_t p;
										p.Insert("OnConsoleMessage");
										p.Insert("Added " + to_string(has_) + " items to the machine.");
										p.CreatePacket(p_);
									}
								}
							}
							update_ = false;
							break;
						}
						
						else if (a_[b_] == "addstock5000") {
							if (block_->id != 0) {
								if (pInfo(p_)->superdev + pInfo(p_)->dev >= 1) block_->c_ += 5000;
								gamepacket_t p;
								p.Insert("OnTalkBubble");
								p.Insert(pInfo(p_)->netID);
								p.Insert("Added 5000 items to the machine.");
								p.Insert(0), p.Insert(1);
								p.CreatePacket(p_);
								{
									gamepacket_t p;
									p.Insert("OnConsoleMessage");
									p.Insert("Added 5000 items to the machine.");
									p.CreatePacket(p_);
								}
							}
							update_ = false;
							break;
						}
						
						else if (a_[b_] == "withdraw") {
							if (pInfo(p_)->tankIDName == world_->owner_name or find(world_->admins.begin(), world_->admins.end(), pInfo(p_)->tankIDName) != world_->admins.end() && world_->v_p) {
								if (block_->wl != 0) {
									int a_ = block_->wl;
									if (modify_inventory(p_, 242, a_) != 0) {
										if (a_ < 100) {
											gamepacket_t p;
											p.Insert("OnTalkBubble");
											p.Insert(pInfo(p_)->netID);
											p.Insert("You don't have room in your backpack!");
											p.Insert(0), p.Insert(1);
											p.CreatePacket(p_);
											{
												gamepacket_t p;
												p.Insert("OnConsoleMessage");
												p.Insert("You don't have room in your backpack!");
												p.CreatePacket(p_);
											}
											break;
										}
										int diamond_locks = a_ / 100;
										int world_locks = a_ - (diamond_locks * 100);
										int turi_dl = 0;
										modify_inventory(p_, 1796, turi_dl);
										int turi_wl = 0;
										modify_inventory(p_, 242, turi_wl);
										uint32_t grazinti = -1;
										if (diamond_locks > 200) {
											grazinti = diamond_locks - 200;
											diamond_locks = 200;
										}
										if (turi_wl + world_locks > 200 or turi_dl + diamond_locks > 200) {
											gamepacket_t p;
											p.Insert("OnTalkBubble");
											p.Insert(pInfo(p_)->netID);
											p.Insert("You don't have room in your backpack!");
											p.Insert(0), p.Insert(1);
											p.CreatePacket(p_);
											{
												gamepacket_t p;
												p.Insert("OnConsoleMessage");
												p.Insert("You don't have room in your backpack!");
												p.CreatePacket(p_);
											}
											break;
										}
										int as2 = world_locks, as4 = diamond_locks;
										modify_inventory(p_, 242, world_locks);
										modify_inventory(p_, 1796, diamond_locks);
										block_->wl = grazinti != -1 ? grazinti * 100 : 0;
										gamepacket_t p;
										p.Insert("OnTalkBubble");
										p.Insert(pInfo(p_)->netID);
										string collected_ = "";
										collected_ += (as4 != 0 ? "" + to_string(as4) + " Diamond Locks" : "");
										string aa_ = (not collected_.empty() ? " and " : " ");
										collected_ += (as2 != 0 ? aa_ + to_string(as2) + " World Locks" : "");
										collected_ += ".";
										p.Insert("You collected " + collected_);
										p.Insert(0), p.Insert(1);
										p.CreatePacket(p_);
										{
											gamepacket_t p;
											p.Insert("OnConsoleMessage");
											p.Insert("You collected " + collected_);
											p.CreatePacket(p_);
										}
										break;
									}
									else {
										gamepacket_t p;
										p.Insert("OnTalkBubble");
										p.Insert(pInfo(p_)->netID);
										p.Insert("You collected " + to_string(block_->wl) + " World Locks.");
										p.Insert(0), p.Insert(1);
										p.CreatePacket(p_);
										{
											gamepacket_t p;
											p.Insert("OnConsoleMessage");
											p.Insert("You collected " + to_string(block_->wl) + " World Locks.");
											p.CreatePacket(p_);
										}
										block_->wl = 0;
									}
								}
								update_ = false;
							}
							break;
						}
						else if (a_[b_] == "upgradedigital") {
							if (pInfo(p_)->tankIDName == world_->owner_name or find(world_->admins.begin(), world_->admins.end(), pInfo(p_)->tankIDName) != world_->admins.end() && world_->v_p) {
								gamepacket_t p;
								if (pInfo(p_)->gems >= 4000) {
									pInfo(p_)->gems -= 4000;
									p.Insert("OnSetBux"), p.Insert(pInfo(p_)->gems), p.Insert(0), p.Insert((pInfo(p_)->supp >= 1) ? 1 : 0);
									if (pInfo(p_)->supp >= 2) p.Insert((float)33796, (float)1, (float)0);
									p.CreatePacket(p_);
									block_->fg = 9268;
									PlayerMoving data_{};
									data_.packetType = 17, data_.netID = 44, data_.YSpeed = 44, data_.x = x_ * 32 + 16, data_.y = y_ * 32 + 16;
									BYTE* raw = packPlayerMoving(&data_);
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != world_->name) continue;
										send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
									}
									delete[] raw;
									update_ = false;
								}
								else p.Insert("OnTalkBubble"), p.Insert(pInfo(p_)->netID), p.Insert("You don't have enough gems!."), p.Insert(0), p.Insert(1);
								p.CreatePacket(p_);
								break;
							}
						}
						else if (a_[b_] == "pullstock") {
							if (pInfo(p_)->tankIDName == world_->owner_name or find(world_->admins.begin(), world_->admins.end(), pInfo(p_)->tankIDName) != world_->admins.end() && world_->v_p) {
								int c_ = block_->c_;
								if (modify_inventory(p_, block_->id, c_) == 0) {
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(p_)->netID);
									p.Insert("You picked up " + to_string(block_->c_) + " " + items[block_->id].ori_name + ".");
									p.Insert(0), p.Insert(1);
									p.CreatePacket(p_);
									{
										gamepacket_t p;
										p.Insert("OnConsoleMessage");
										p.Insert("You picked up " + to_string(block_->c_) + " " + items[block_->id].ori_name + ".");
										p.CreatePacket(p_);
									}
									block_->c_ = 0, block_->id = 0, block_->pr = 0;
								}
								else if (block_->c_ > 200) {
									int has_ = 0;
									modify_inventory(p_, block_->id, has_);
									int give_ = 200 - has_;
									block_->c_ -= give_;
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(p_)->netID);
									p.Insert("You picked up " + to_string(give_) + " " + items[block_->id].ori_name + ", leaving " + to_string(block_->c_) + " in the machine.");
									p.Insert(0), p.Insert(1);
									p.CreatePacket(p_);
									{
										gamepacket_t p;
										p.Insert("OnConsoleMessage");
										p.Insert("You picked up " + to_string(give_) + " " + items[block_->id].ori_name + ", leaving " + to_string(block_->c_) + " in the machine.");
										p.CreatePacket(p_);
									}
									modify_inventory(p_, block_->id, give_);
								}
								update_ = false;
								break;
							}
						}
					}
				}
				else {
					if (pInfo(p_)->tankIDName == world_->owner_name or find(world_->admins.begin(), world_->admins.end(), pInfo(p_)->tankIDName) != world_->admins.end() && world_->v_p) {
						if (block_->id != 0) break;
						int item_id = atoi(a_[i_ + 8].c_str());
						int c_ = 0, am_ = 0;
						modify_inventory(p_, item_id, c_);
						if (c_ == 0) break;
						if (items[item_id].untradeable or item_id == 1424 or item_id == 5816 or item_id == 242 or item_id == 1796 or item_id == 7188 or items[item_id].blockType == BlockTypes::FISH) {
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(p_)->netID);
							p.Insert((items[item_id].blockType == BlockTypes::LOCK or item_id == 1424 or item_id == 5816 ? "No no no." : "Can't put that in a " + items[block_->fg].name + "."));
							p.Insert(0), p.Insert(1);
							p.CreatePacket(p_);
							{
								gamepacket_t p;
								p.Insert("OnConsoleMessage");
								p.Insert((items[item_id].blockType == BlockTypes::LOCK or item_id == 1424 or item_id == 5816 ? "No no no." : "Can't put that in a " + items[block_->fg].name + "."));
								p.CreatePacket(p_);
							}
							break;
						}
						am_ = c_;
						c_ *= -1;
						if (modify_inventory(p_, item_id, c_) == 0) {
							block_->id = item_id;
							block_->c_ = am_;
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(p_)->netID);
							p.Insert("`7[``" + pInfo(p_)->tankIDName + " put `2" + items[item_id].ori_name + "`` in the " + items[block_->fg].name + ".`7]``");
							p.Insert(0);
							gamepacket_t p2;
							p2.Insert("OnConsoleMessage");
							p2.Insert("`7[``" + pInfo(p_)->tankIDName + " put `2" + items[item_id].ori_name + "`` in the " + items[block_->fg].name + ".`7]``");
							for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
								if (pInfo(currentPeer)->world == world_->name) {
									p.CreatePacket(currentPeer);
									p2.CreatePacket(currentPeer);
								}
							}
							{
								gamepacket_t p;
								p.Insert("OnDialogRequest");
								p.Insert(get_vending(p_, world_, block_, x_, y_));
								p.CreatePacket(p_);
							}
						}
					}
				}
				if (update_) {
					gamepacket_t p;
					p.Insert("OnTalkBubble");
					p.Insert(pInfo(p_)->netID);
					p.Insert((block_->pr == 0 ? "`7[``" + pInfo(p_)->tankIDName + " disabled the Vending Machine.```7]``" : "`7[``" + pInfo(p_)->tankIDName + " changed the price of `2" + items[block_->id].ori_name + "`` to " + (block_->pr < 0 ? "`6" + to_string(block_->pr * -1) + " per World Lock.```7]``" : "`5" + to_string(block_->pr) + " World Locks each.```7]``")));
					p.Insert(0);
					gamepacket_t p2;
					p2.Insert("OnConsoleMessage");
					p2.Insert((block_->pr == 0 ? "`7[``" + pInfo(p_)->tankIDName + " disabled the Vending Machine.```7]``" : "`7[``" + pInfo(p_)->tankIDName + " changed the price of `2" + items[block_->id].ori_name + "`` to " + (block_->pr < 0 ? "`6" + to_string(block_->pr * -1) + " per World Lock.```7]``" : "`5" + to_string(block_->pr) + " World Locks each.```7]``")));
					PlayerMoving data_{};
					data_.packetType = 17;
					data_.netID = 44;
					data_.YSpeed = 44;
					data_.x = x_ * 32 + 16;
					data_.y = y_ * 32 + 16;
					BYTE* raw = packPlayerMoving(&data_);
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
						if (pInfo(currentPeer)->world == world_->name) {
							p.CreatePacket(currentPeer);
							p2.CreatePacket(currentPeer);
							packet_(currentPeer, "action|play_sfx\nfile|audio/terraform.wav\ndelayMS|0");
							send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
						}
					}
					delete[] raw;
				}
				PlayerMoving data_{};
				data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
				BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
				BYTE* blc = raw + 56;
				form_visual(blc, *block_, *world_, p_, false);
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
					if (pInfo(currentPeer)->world == world_->name) {
						send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
					}
				}
				delete[] raw, blc;
				if (block_->locked) {
					upd_lock(*block_, *world_, p_);
				}
			}
			break;
		}
		else if (a_[i_] == "displayblock") {
			if (a_.size() != 11) break;
			if (not isdigit(a_[i_ + 2][0]) or not isdigit(a_[i_ + 5][0])) break;
			int x_ = atoi(a_[i_ + 2].c_str()), y_ = atoi(a_[i_ + 5].c_str());
			if (x_ < 0 or x_ >= 100 or y_ < 0 or y_ >= 60) break;
			string name_ = pInfo(p_)->world;
			vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
			if (p != worlds.end()) {
				World* world_ = &worlds[p - worlds.begin()];
				WorldBlock* block_ = &world_->blocks[x_ + (y_ * 100)];
				uint16_t t_ = (block_->fg ? block_->fg : block_->bg);
				if (items[t_].blockType != BlockTypes::DISPLAY) break;
				string owner_name = world_->owner_name, user_name = pInfo(p_)->tankIDName;
				if (owner_name != user_name and not owner_name.empty() and not pInfo(p_)->dev) {
					if (block_->locked) {
						WorldBlock* check_lock = &world_->blocks[block_->lock_origin];
						if (check_lock->owner_name != pInfo(p_)->tankIDName) break;
					}
					else {
						break;
					}
				}
				if (a_.size() == 11) {
					int c_ = 1;
					if (modify_inventory(p_, block_->id, c_) == 0) {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(p_)->netID);
						p.Insert("You removed `5" + items[block_->id].name + "`` from the " + items[block_->fg].name + ".");
						p.Insert(0), p.Insert(0);
						p.CreatePacket(p_);
						block_->id = 0;
						{
							PlayerMoving data_{};
							data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
							BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
							BYTE* blc = raw + 56;
							form_visual(blc, *block_, *world_, p_, false);
							for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
								if (pInfo(currentPeer)->world == world_->name) {
									send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
								}
							}
							delete[] raw, blc;
							if (block_->locked) {
								upd_lock(*block_, *world_, p_);
							}
						}
					}
					else {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(p_)->netID);
						p.Insert("You don't have room to pick that up!");
						p.Insert(0), p.Insert(0);
						p.CreatePacket(p_);
					}
				}
			}
			break;
		}
		else if (a_[i_] == "trade_confirm") {
			if (a_.size() != 8) break;
			if (a_[5] == "back") {
				cancel_trade(p_, true);
			}
			else if (a_[5] == "accept") {
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
					if (pInfo(currentPeer)->world == pInfo(p_)->world) {
						if (pInfo(currentPeer)->netID == pInfo(p_)->trading_with and pInfo(p_)->netID == pInfo(currentPeer)->trading_with) {
							pInfo(p_)->accept_the_offer = true;
							if (pInfo(currentPeer)->accept_the_offer and pInfo(p_)->accept_the_offer) {
								string name_ = pInfo(p_)->world;
								vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
								if (p != worlds.end()) {
									World* world_ = &worlds[p - worlds.begin()];
									if (not trade_space_check(p_, currentPeer)) {
										cancel_trade(p_);
										return;
									}
									else if (not trade_space_check(currentPeer, p_)) {
										cancel_trade(p_);
										return;
									}
									bool c_ = false;
									for (int i_ = 0; i_ < pInfo(p_)->trade_items.size(); i_++) {
										if (c_) break;
										map<string, int>::iterator it;
										for (auto it = pInfo(p_)->trade_items[i_].begin(); it != pInfo(p_)->trade_items[i_].end(); it++) {
											if (it->first == 1424 or it->first == 5816) {
												for (int i_ = 0; i_ < world_->blocks.size(); i_++) {
													if (items[world_->blocks[i_].fg].blockType == BlockTypes::LOCK) {
														uint16_t id_ = world_->blocks[i_].fg;
														if (id_ == 202 or id_ == 204 or id_ == 206 or id_ == 4994) {
															cancel_trade(p_);
															return;
														}
													}
												}
												c_ = true;
												break;
											}
										}
									}
									c_ = false;
									for (int i_ = 0; i_ < pInfo(currentPeer)->trade_items.size(); i_++) {
										if (c_) break;
										map<string, int>::iterator it;
										for (auto it = pInfo(currentPeer)->trade_items[i_].begin(); it != pInfo(currentPeer)->trade_items[i_].end(); it++) {
											if (it->first == 1424 or it->first == 5816) {
												for (int i_ = 0; i_ < world_->blocks.size(); i_++) {
													if (items[world_->blocks[i_].fg].blockType == BlockTypes::LOCK) {
														uint16_t id_ = world_->blocks[i_].fg;
														if (id_ == 202 or id_ == 204 or id_ == 206 or id_ == 4994) {
															cancel_trade(currentPeer);
															return;
														}
													}
												}
												c_ = true;
												break;
											}
										}
									}
									vector<string> traded_p;
									int time_out = 0;
									for (int i_ = 0; i_ < pInfo(p_)->trade_items.size(); i_++) {
										map<string, int>::iterator it;
										for (auto it = pInfo(p_)->trade_items[i_].begin(); it != pInfo(p_)->trade_items[i_].end(); it++) {

											int c_ = it->second * -1;
											if (modify_inventory(p_, it->first, c_, true) == 0) {
												traded_p.push_back(to_string(it->second) + " " + items[it->first].name);
												if (it->first == 1424 or it->first == 5816) {
													transfer_world(world_, p_, currentPeer);
												}
												else {
													int c2_ = it->second;
													modify_inventory(currentPeer, it->first, c2_, true);
												}
												PlayerMoving data_{};
												time_out += 450;
												data_.packetType = 19, data_.plantingTree = (i_ + 1) * 450, data_.netID = pInfo(currentPeer)->netID;
												data_.punchX = it->first, data_.punchY = it->first;
												int32_t to_netid = pInfo(p_)->netID;
												BYTE* raw = packPlayerMoving(&data_);
												raw[3] = 3;
												memcpy(raw + 8, &to_netid, 4);
												for (ENetPeer* currentPeer2 = server->peers; currentPeer2 < &server->peers[server->peerCount]; ++currentPeer2) {
													if (currentPeer2->state != ENET_PEER_STATE_CONNECTED or currentPeer2->data == NULL) continue;
													if (pInfo(currentPeer2)->world == world_->name) {
														send_raw(currentPeer2, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
													}
												}
												delete[]raw;
												{
													gamepacket_t p((i_ + 1) * 450, pInfo(p_)->netID);
													p.Insert("OnPlayPositioned");
													p.Insert("audio/change_clothes.wav");
													p.CreatePacket(p_);
												}
												{
													gamepacket_t p((i_ + 1) * 450, pInfo(currentPeer)->netID);
													p.Insert("OnPlayPositioned");
													p.Insert("audio/change_clothes.wav");
													p.CreatePacket(currentPeer);
												}
											}
										}
									}
									string traded_ = "";
									if (traded_p.size() != 0) {
										for (int i_ = 0; i_ < traded_p.size(); i_++) {
											if (traded_p.size() == i_ + 1)
												traded_ += traded_p[i_];
											else if (traded_p.size() - 2 == i_)
												traded_ += traded_p[i_] + " and ";
											else
												traded_ += traded_p[i_] + ", ";
										}
									}
									else {
										traded_ = "nothing";
									}
									traded_p.clear();
									for (int i_ = 0; i_ < pInfo(currentPeer)->trade_items.size(); i_++) {
										map<string, int>::iterator it;
										for (auto it = pInfo(currentPeer)->trade_items[i_].begin(); it != pInfo(currentPeer)->trade_items[i_].end(); it++) {

											int c_ = it->second * -1;
											if (modify_inventory(currentPeer, it->first, c_, true) == 0) {
												traded_p.push_back(to_string(it->second) + " " + items[it->first].name);
												if (it->first == 1424 or it->first == 5816) {
													transfer_world(world_, currentPeer, p_);
												}
												else {
													int c2_ = it->second;
													modify_inventory(p_, it->first, c2_, true);
												}
												PlayerMoving data_{};
												data_.packetType = 19, data_.plantingTree = (i_ + 1) * 450 + time_out, data_.netID = pInfo(p_)->netID;
												data_.punchX = it->first, data_.punchY = it->first;
												int32_t to_netid = pInfo(currentPeer)->netID;
												BYTE* raw = packPlayerMoving(&data_);
												raw[3] = 3;
												memcpy(raw + 8, &to_netid, 4);
												for (ENetPeer* currentPeer2 = server->peers; currentPeer2 < &server->peers[server->peerCount]; ++currentPeer2) {
													if (currentPeer2->state != ENET_PEER_STATE_CONNECTED or currentPeer2->data == NULL) continue;
													if (pInfo(currentPeer2)->world == world_->name) {
														send_raw(currentPeer2, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
													}
												}
												delete[]raw;
												{
													gamepacket_t p((i_ + 1) * 450 + time_out, pInfo(p_)->netID);
													p.Insert("OnPlayPositioned");
													p.Insert("audio/change_clothes.wav");
													p.CreatePacket(p_);
												}
												{
													gamepacket_t p((i_ + 1) * 450 + time_out, pInfo(currentPeer)->netID);
													p.Insert("OnPlayPositioned");
													p.Insert("audio/change_clothes.wav");
													p.CreatePacket(currentPeer);
												}
											}
										}
									}
									string traded2_ = "";
									if (traded_p.size() != 0) {
										for (int i_ = 0; i_ < traded_p.size(); i_++) {
											if (traded_p.size() == i_ + 1)
												traded2_ += traded_p[i_];
											else if (traded_p.size() - 2 == i_)
												traded2_ += traded_p[i_] + " and ";
											else
												traded2_ += traded_p[i_] + ", ";
										}
									}
									else {
										traded2_ = "nothing";
									}
									{
										grow4good(p_, false, "trade", 1);
										gamepacket_t p2;
										p2.Insert("OnConsoleMessage");
										p2.Insert("`1" + pInfo(currentPeer)->name_color + pInfo(currentPeer)->tankIDName + "`` traded " + traded2_ + " to " + pInfo(p_)->tankIDName + ".``");
										tradelog(pInfo(currentPeer)->tankIDName + " traded " + traded2_ + " to " + pInfo(p_)->tankIDName);
										gamepacket_t p;
										p.Insert("OnConsoleMessage");
										p.Insert("`1" + pInfo(p_)->name_color + pInfo(p_)->tankIDName + "`` traded " + traded_ + " to " + pInfo(currentPeer)->tankIDName + ".``");
										tradelog(pInfo(p_)->tankIDName + " traded " + traded_ + " to " + pInfo(currentPeer)->tankIDName);
										string trade_logs = "";
										time_t currentTime;
										time(&currentTime);
										const auto localTime = localtime(&currentTime);
										const auto Hour = localTime->tm_hour;
										const auto Min = localTime->tm_min;
										const auto Sec = localTime->tm_sec;
										const auto Year = localTime->tm_year + 1900;
										const auto Day = localTime->tm_mday;
										const auto Month = localTime->tm_mon + 1;
										std::string asdasdasd;
										if (Sec < 10) asdasdasd = "0";
										std::string asdasdasd2;
										if (Min < 10) asdasdasd2 = "0";
										std::string asdasdasd3;
										if (Hour < 10) asdasdasd3 = "0";
										std::string asdasdasd31;
										if (Month < 10) asdasdasd31 = "0";
										std::string asdasdasd32;
										if (Day < 10) asdasdasd32 = "0";
										std::string asdasdasd33;
										if (Year < 10) asdasdasd33 = "0";
										pInfo(p_)->trade_logs.push_back("`9You traded [" + traded_ + "] with `1" + pInfo(currentPeer)->tankIDName + "`9 in `2" + pInfo(p_)->world + "`9 and received [" + traded2_ + "] `0at " + asdasdasd3 + to_string(Hour) + ":" + asdasdasd2 + to_string(Min) + " on " + asdasdasd31 + to_string(Month) + "/" + asdasdasd32 + to_string(Day) + ".");
										pInfo(currentPeer)->trade_logs.push_back("`9You traded [" + traded2_ + "] with `1" + pInfo(p_)->tankIDName + "`9 in `2" + pInfo(currentPeer)->world + "`9 and received [" + traded_ + "] `0at " + asdasdasd3 + to_string(Hour) + ":" + asdasdasd2 + to_string(Min) + " on " + asdasdasd31 + to_string(Month) + "/" + asdasdasd32 + to_string(Day) + ".");
										for (ENetPeer* currentPeer2 = server->peers; currentPeer2 < &server->peers[server->peerCount]; ++currentPeer2) {
											if (currentPeer2->state != ENET_PEER_STATE_CONNECTED or currentPeer2->data == NULL) continue;
											if (pInfo(currentPeer2)->world == world_->name) {
												p.CreatePacket(currentPeer2);
												p2.CreatePacket(currentPeer2);
											}
										}
									}
									{
										gamepacket_t p(1250, pInfo(currentPeer)->netID);
										p.Insert("OnPlayPositioned");
										p.Insert("audio/keypad_hit.wav");
										p.CreatePacket(currentPeer), p.CreatePacket(p_);
									}
									//send_trade(pInfo(p_)->tankIDName, traded_, pInfo(currentPeer)->tankIDName, traded2_);
									pInfo(currentPeer)->block_trade = false, pInfo(currentPeer)->accept_the_offer = false, pInfo(currentPeer)->trade_accept = false, pInfo(currentPeer)->trading_with = -1, pInfo(currentPeer)->trade_items.clear();
									pInfo(p_)->block_trade = false, pInfo(p_)->trading_with = -1, pInfo(p_)->trade_accept = false, pInfo(p_)->accept_the_offer = false, pInfo(p_)->trade_items.clear();
								}
								
								return;
							}
							for (int i_ = 0; i_ < pInfo(currentPeer)->trade_items.size(); i_++) {
								map<string, int>::iterator it;
								for (auto it = pInfo(currentPeer)->trade_items[i_].begin(); it != pInfo(currentPeer)->trade_items[i_].end(); it++) {
									if (it->first == 1424 or it->first == 5816) {
										pInfo(p_)->accept_the_offer = false;
										send_trade_confirm_dialog(p_, currentPeer, true);
										{
											gamepacket_t p;
											p.Insert("OnTextOverlay");
											p.Insert("`6[``you must wait for the other player to accept first`6]``");
											p.CreatePacket(p_);
										}
										gamepacket_t p;
										p.Insert("OnTalkBubble");
										p.Insert(pInfo(currentPeer)->netID);
										p.Insert("`6[``You must accept first because you're selling a World Key`6]``");
										p.Insert(0), p.Insert(0);
										p.CreatePacket(currentPeer);
										{
											gamepacket_t p;
											p.Insert("OnConsoleMessage");
											p.Insert("`6[``You must accept first because you're selling a World Key`6]``");
											p.CreatePacket(currentPeer);
										}
										return;
									}
								}
							}
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(p_)->netID);
							p.Insert("`6[``Trade accepted, waiting for other player to accept`6]``");
							p.Insert(0), p.Insert(0);
							p.CreatePacket(p_);
							{
								gamepacket_t p;
								p.Insert("OnConsoleMessage");
								p.Insert("`6[``Trade accepted, waiting for other player to accept`6]``");
								p.CreatePacket(p_);
							}
							{
								gamepacket_t p;
								p.Insert("OnTalkBubble");
								p.Insert(pInfo(currentPeer)->netID);
								p.Insert("`6[``Trade accepted by other player, waiting for you`6]``");
								p.Insert(0), p.Insert(0);
								p.CreatePacket(currentPeer);
							}
							{
								gamepacket_t p;
								p.Insert("OnConsoleMessage");
								p.Insert("`6[``Trade accepted by other player, waiting for you`6]``");
								p.CreatePacket(currentPeer);
							}
							return;
						}
					}
				}
				gamepacket_t p;
				p.Insert("OnTextOverlay");
				p.Insert("The other person left the trade!");
				p.CreatePacket(p_);
				pInfo(p_)->block_trade = false, pInfo(p_)->trading_with = -1, pInfo(p_)->trade_accept = false, pInfo(p_)->accept_the_offer = false, pInfo(p_)->trade_items.clear();
			}
			break;
		}
		else if (a_[i_] == "friends_remove_finish") {
			send_friends(p_);
			break;
		}
		else if (a_[i_] == "friends_remove") {
			if (a_.size() != 11) break;
			if (a_[8] == "back") {
				send_info_friend(p_, a_[5]);
				break;
			}
			string name_ = pInfo(p_)->world;
			vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
			if (p != worlds.end()) {
				World* world_ = &worlds[p - worlds.begin()];
				remove_friend(p_, world_, a_[5]);
			}
			break;
		}
		else if (a_[i_] == "mute_friend" or a_[i_] == "block_friend") {
			if (a_.size() != 8) break;
			if (a_[5] == "back") {
				send_info_friend(p_, pInfo(p_)->last_edit);
			}
			else if (a_[i_] == "mute_friend" and a_[5] == "ok") {
				for (int c_ = 0; c_ < pInfo(p_)->friends.size(); c_++) {
					if (pInfo(p_)->friends[c_].name == pInfo(p_)->last_edit) {
						if (pInfo(p_)->friends[c_].mute)
							pInfo(p_)->friends[c_].mute = false;
						else
							pInfo(p_)->friends[c_].mute = true;
					}
				}
				send_info_friend(p_, pInfo(p_)->last_edit);
			}
			else if (a_[i_] == "block_friend" and a_[5] == "ok") {
				for (int c_ = 0; c_ < pInfo(p_)->friends.size(); c_++) {
					if (pInfo(p_)->friends[c_].name == pInfo(p_)->last_edit) {
						if (pInfo(p_)->friends[c_].block_trade)
							pInfo(p_)->friends[c_].block_trade = false;
						else
							pInfo(p_)->friends[c_].block_trade = true;
					}
				}
				send_info_friend(p_, pInfo(p_)->last_edit);
			}
			break;
		}
		else if (a_[i_] == "friends_message") {
			if (a_.size() != 13) break;
			if (a_[8] == "back") {
				send_info_friend(p_, a_[5]);
			}
			else if (a_[8] == "send") {
				string message = explode("\n", explode("|", cch)[11])[0].c_str();
				SendCmd(p_, "/msg " + pInfo(p_)->last_wrenched + " " + message, true);
			}
			break;
		}
		else if (a_[i_] == "friends_edit" || a_[i_] == "friends_message") {
			if (a_.size() != 11) break;
			if (a_[8] == "back") {
				send_friends(p_);
			}
			else if (a_[8] == "remove" or a_[8] == "back") {
				edit_friend(p_, a_[5], (a_[8] == "back" ? true : false));
			}
			else if (a_[8] == "goto") {
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
					if (pInfo(currentPeer)->tankIDName == a_[5]) {
						for (int c_ = 0; c_ < pInfo(currentPeer)->friends.size(); c_++) {
							if (pInfo(currentPeer)->friends[c_].name == pInfo(p_)->tankIDName) {
								if (pInfo(currentPeer)->show_location_) {
									if (pInfo(currentPeer)->world.empty()) {
										gamepacket_t p;
										p.Insert("OnTalkBubble");
										p.Insert(pInfo(p_)->netID);
										p.Insert("Hmm, my friend isn't in a world right now.");
										p.Insert(0), p.Insert(0);
										p.CreatePacket(p_);
										break;
									}
									else if (pInfo(currentPeer)->world == pInfo(p_)->world) {
										gamepacket_t p;
										p.Insert("OnTalkBubble");
										p.Insert(pInfo(p_)->netID);
										p.Insert("You want to warp to the same world you're in?  That's illogical, captain.");
										p.Insert(0), p.Insert(0);
										p.CreatePacket(p_);
										break;
									}
									join_world(p_, pInfo(currentPeer)->world);
								}
								break;
							}
						}
					}
				}
			}
			else if (a_[8] == "msg") {
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\nadd_label_with_icon|big|`5Message to ``" + a_[5] + "|left|660|\nadd_spacer|small|\nadd_text_input|text|||80|left|\nadd_spacer|small|\nembed_data|friendID|" + a_[5] + "\nadd_button|send|`5Send``|noflags|0|0|\nadd_button|back|Back|noflags|0|0|\nend_dialog|friends_message|||\nadd_quick_exit|");
				p.CreatePacket(p_);
			}
			else if (a_[8] == "mute" or a_[8] == "trade_block") {
				for (int c_ = 0; c_ < pInfo(p_)->friends.size(); c_++) {
					if (pInfo(p_)->friends[c_].name == a_[5]) {
						gamepacket_t p;
						p.Insert("OnDialogRequest");
						if (a_[8] == "mute") {
							if (not pInfo(p_)->friends[c_].mute)
								p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wConfirm``|left|1366|\nadd_textbox|Are you sure you want to `9Mute `` " + a_[5] + "? You will not receive any messages from this player until you unmute, consider this /ignore a friend|left|\nadd_button|ok|OK|noflags|0|0|\nadd_button|back|Back|noflags|0|0|\nend_dialog|mute_friend|||\nadd_quick_exit|");
							else
								p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wConfirm``|left|1366|\nadd_textbox|Are you sure you want to `4Un Mute`` " + a_[5] + "? You will receive any messages from this player until you mute.|left|\nadd_button|ok|OK|noflags|0|0|\nadd_button|back|Back|noflags|0|0|\nend_dialog|mute_friend|||\nadd_quick_exit|");
						}
						else {
							if (not pInfo(p_)->friends[c_].block_trade)
								p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wConfirm``|left|1366|\nadd_textbox|Are you sure you want to `4Disable Trade`` with " + a_[5] + "? You will not receive any trade request until you enable trading again.|left|\nadd_button|ok|OK|noflags|0|0|\nadd_button|back|Back|noflags|0|0|\nend_dialog|block_friend|||\nadd_quick_exit|");
							else
								p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wConfirm``|left|1366|\nadd_textbox|Are you sure you want to `4Enable Trade`` with " + a_[5] + "? You will receive any trade request until you disable trading again.|left|\nadd_button|ok|OK|noflags|0|0|\nadd_button|back|Back|noflags|0|0|\nend_dialog|block_friend|||\nadd_quick_exit|");
						}
						p.CreatePacket(p_);
					}
				}
			}
			break;
		}
		else if (a_[i_] == "friends_options") {
			if (a_.size() != 12) break;
			if (a_[7] == "checkbox_public") {
				if (not pInfo(p_)->show_location_ and a_[8] == "1") {
					pInfo(p_)->show_location_ = true;
				}
				else if (pInfo(p_)->show_location_ and a_[8] == "0") {
					pInfo(p_)->show_location_ = false;
				}
			}
			if (a_[9] == "checkbox_notifications") {
				if (not pInfo(p_)->show_friend_notifications_ and a_[10] == "1") {
					pInfo(p_)->show_friend_notifications_ = true;
				}
				else if (pInfo(p_)->show_friend_notifications_ and a_[10] == "0") {
					pInfo(p_)->show_friend_notifications_ = false;
				}
			}
			if (a_[5] == "back") {
				vector<string> friends_;
				for (int c_ = 0; c_ < pInfo(p_)->friends.size(); c_++) {
					friends_.push_back(pInfo(p_)->friends[c_].name);
				}
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
					if (find(friends_.begin(), friends_.end(), pInfo(currentPeer)->tankIDName) != friends_.end()) {
						send_friends(p_, true);
						return;
					}
				}
				send_friends(p_);
			}
			break;
		}
		else if (a_[i_] == "mute_all_friends" or a_[i_] == "remove_all_friends" or a_[i_] == "block_all_friends") {
			if (a_.size() != 8) break;
			if (a_[5] == "back") {
				send_all_edit_friends(p_);
				break;
			}
			if (a_[5] == "close")
				break;
			string name_ = pInfo(p_)->world;
			vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
			if (p != worlds.end()) {
				World* world_ = &worlds[p - worlds.begin()];
				for (int c_ = 0; c_ < pInfo(p_)->friends.size(); c_++) {
					if (find(pInfo(p_)->last_friends_selection.begin(), pInfo(p_)->last_friends_selection.end(), c_) != pInfo(p_)->last_friends_selection.end()) {
						if (a_[i_] == "mute_all_friends") {
							if (pInfo(p_)->friends[c_].mute)
								pInfo(p_)->friends[c_].mute = false;
							else
								pInfo(p_)->friends[c_].mute = true;
						}
						else if (a_[i_] == "block_all_friends") {
							if (pInfo(p_)->friends[c_].block_trade)
								pInfo(p_)->friends[c_].block_trade = false;
							else
								pInfo(p_)->friends[c_].block_trade = true;
						}
						else if (a_[i_] == "remove_all_friends") {
							remove_friend(p_, world_, pInfo(p_)->friends[c_].name, false);
						}
					}
				}
				send_all_edit_friends(p_);
			}
			break;
		}
		else if (a_[i_] == "all_friends") {
			if (a_.size() < 10) break;
			if (a_[5] == "back") {
				vector<string> friends_;
				for (int c_ = 0; c_ < pInfo(p_)->friends.size(); c_++) {
					friends_.push_back(pInfo(p_)->friends[c_].name);
				} for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
					if (find(friends_.begin(), friends_.end(), pInfo(currentPeer)->tankIDName) != friends_.end()) {
						send_friends(p_, true);
						return;
					}
				}
				send_friends(p_);
				break;
			}
			pInfo(p_)->last_friends_selection.clear();
			string action_ = a_[5];
			try {
				for (int b_ = 0; b_ < a_.size(); b_++) {
					if (a_.at(b_).substr(0, 3) == "cf_") {
						if (a_.at(b_ + 1) == "1")
							pInfo(p_)->last_friends_selection.push_back(atoi(explode("_", a_.at(b_)).at(1).c_str()));
					}
				}
			}
			catch (out_of_range) {
				break;
			}
			if (pInfo(p_)->last_friends_selection.size() == 0) {
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wConfirm``|left|1366|\nadd_textbox|`oYou have not selected any friends|left|\nadd_spacer|small|\nadd_button|back|`wBack``|noflags|0|0|\nadd_button|close|`wClose``|noflags|0|0|\nend_dialog|remove_all_friends|||\nadd_quick_exit|");
				p.CreatePacket(p_);
			}
			else {
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				if (action_ == "mute_multi_friends")
					p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wConfirm``|left|1366|\nadd_textbox|`oAre you sure you want to `9Mute `` " + to_string(pInfo(p_)->last_friends_selection.size()) + " friends?|left|\nadd_spacer|small|\nadd_button|confirm|`wYes``|noflags|0|0|\nadd_button|back|`wBack``|noflags|0|0|\nadd_button|close|`wClose``|noflags|0|0|\nend_dialog|mute_all_friends|||\nadd_quick_exit|");
				else if (action_ == "block_multi_friends")
					p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wConfirm``|left|1366|\nadd_textbox|`oAre you sure you want to `4block trade`` " + to_string(pInfo(p_)->last_friends_selection.size()) + " friends?|left|\nadd_spacer|small|\nadd_button|confirm|`wYes``|noflags|0|0|\nadd_button|back|`wBack``|noflags|0|0|\nadd_button|close|`wClose``|noflags|0|0|\nend_dialog|block_all_friends|||\nadd_quick_exit|");
				else
					p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wConfirm``|left|1366|\nadd_textbox|`oAre you sure you want to `4remove`` " + to_string(pInfo(p_)->last_friends_selection.size()) + " friends?|left|\nadd_spacer|small|\nadd_button|confirm|`wYes``|noflags|0|0|\nadd_button|back|`wBack``|noflags|0|0|\nadd_button|close|`wClose``|noflags|0|0|\nend_dialog|remove_all_friends|||\nadd_quick_exit|");
				p.CreatePacket(p_);
			}
			break;
		}
		else if (a_[i_] == "leave_guild") {
			if (pInfo(p_)->guild_id == 0) break;
			uint32_t guild_id = pInfo(p_)->guild_id;
			vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
			if (p != guilds.end()) {
				Guild* guild_information = &guilds[p - guilds.begin()];
				leave_guild(p_);
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\nadd_label_with_icon|big|`4Leave Guild``|left|1366|\nadd_spacer|small|\nadd_textbox|`o You are no longer in the guild.|left|\nadd_spacer|small|\nadd_button|back|OK|noflags|0|0|\nend_dialog||||\nadd_quick_exit|");
				p.CreatePacket(p_);
				if (guild_information->guild_world == pInfo(p_)->world) {
					string name_ = pInfo(p_)->world;
					vector<World>::iterator p_w = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
					if (p_w != worlds.end()) {
						World* world_ = &worlds[p_w - worlds.begin()];
						int x_ = 0, y_ = 0;
						int ySize = (int)world_->blocks.size() / 100, xSize = (int)world_->blocks.size() / ySize;
						for (int i_ = 0; i_ < world_->blocks.size(); i_++) {
							if (items[world_->blocks[i_].fg].blockType == BlockTypes::LOCK) {
								uint16_t id_ = world_->blocks[i_].fg;
								if (id_ == 5814) {
									x_ = i_ % xSize;
									y_ = i_ / xSize;
									break;
								}
							}
						}
						WorldBlock* block_ = &world_->blocks[x_ + (y_ * 100)];
						PlayerMoving data_{};
						data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
						BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
						BYTE* blc = raw + 56;
						form_visual(blc, *block_, *world_, p_, false);
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
							if (pInfo(currentPeer)->world == guild_information->guild_world) {
								send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
							}
						}
						delete[] raw, blc;
					}
				}
			}
			break;
		}
		else if (a_[i_] == "show_guild_logs") {
			if (a_.size() != 8) break;
			if (pInfo(p_)->guild_id == 0) break;
			if (a_[5] == "back") {
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert(get_guild_info(p_));
				p.CreatePacket(p_);
			}
			break;
		}
		else if (a_[i_] == "guildpage") {
			if (a_.size() != 10) break;
			if (a_[5] == "changestatementsubmit") {
				string new_stat = a_[8];
				if (new_stat.size() < 6 or new_stat.size() > 24) {
					gamepacket_t p;
					p.Insert("OnDialogRequest");
					p.Insert(get_guild_statement_edit(p_, "`1You need to enter at least `$6 characters`` to add a guild statement!``"));
					p.CreatePacket(p_);
					break;
				}
				uint32_t guild_id = pInfo(p_)->guild_id;
				vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
				if (p != guilds.end()) {
					Guild* guild_information = &guilds[p - guilds.begin()];
					if (new_stat == guild_information->guild_description) break;
					uint32_t my_rank = 0;
					for (GuildMember member_search : guild_information->guild_members) {
						if (member_search.member_name == pInfo(p_)->tankIDName) {
							my_rank = member_search.role_id;
							break;
						}
					}
					if (my_rank <= 2) break;
					guild_information->guild_description = new_stat;
					gamepacket_t p;
					p.Insert("OnDialogRequest");
					p.Insert(get_guild_info(p_));
					p.CreatePacket(p_);
					create_guild_log(guild_information, "`$" + pInfo(p_)->tankIDName + "`` `wchanged guild statement to `$" + new_stat + "``", 658);
				}
			}
			break;
		}
		else if (a_[i_] == "guild_members_options") {
			if (a_.size() != 12) break;
			if (pInfo(p_)->guild_id == 0) break;
			string public_ = a_[8];
			if (public_ != "0" and public_ != "1") break;
			string notifications_ = a_[10];
			if (notifications_ != "0" and notifications_ != "1") break;
			uint32_t guild_id = pInfo(p_)->guild_id;
			vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
			if (p != guilds.end()) {
				Guild* guild_information = &guilds[p - guilds.begin()];
				for (int i_ = 0; i_ < guild_information->guild_members.size(); i_++) {
					GuildMember* member_search = &guild_information->guild_members[i_];
					if (member_search->member_name == pInfo(p_)->tankIDName) {
						if (not member_search->public_location and public_ == "1") {
							member_search->public_location = true;
						}
						else if (member_search->public_location and public_ == "0") {
							member_search->public_location = false;
						}
						{
							if (not member_search->show_notifications and notifications_ == "1") {
								member_search->show_notifications = true;
							}
							else if (member_search->show_notifications and notifications_ == "0") {
								member_search->show_notifications = false;
							}
						}
						break;
					}
				}
			}
			if (a_[5] == "back") {
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert(get_guild_info(p_));
				p.CreatePacket(p_);
			}
			break;
		}
		else if (a_[i_] == "guildmembers") {
			if (a_.size() != 8) break;
			if (pInfo(p_)->guild_id == 0) break;
			if (a_[5] == "guild_members_all") {
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert(get_guild_info(p_, true));
				p.CreatePacket(p_);
			}
			else if (a_[5] == "guild_members_options") {
				uint32_t guild_id = pInfo(p_)->guild_id;
				vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
				if (p != guilds.end()) {
					Guild* guild_information = &guilds[p - guilds.begin()];
					for (GuildMember member_search : guild_information->guild_members) {
						if (member_search.member_name == pInfo(p_)->tankIDName) {
							gamepacket_t p;
							p.Insert("OnDialogRequest");
							string notify_ = (member_search.show_notifications ? "1" : "0");
							string public_ = (member_search.public_location ? "1" : "0");
							string guild_foreground = (guild_information->guild_mascot[0] == 0 ? "5814" : to_string(guild_information->guild_mascot[0]));
							string guild_background = (guild_information->guild_mascot[1] == 0 ? "0" : to_string(guild_information->guild_mascot[1]));
							p.Insert("set_default_color|`o\nadd_dual_layer_icon_label|big|`wGuild Member Options``|left|" + guild_background + "|" + guild_foreground + "|1.0|0|\nadd_spacer|small|\nadd_checkbox|checkbox_public|Show location to guild members|" + public_ + "\nadd_checkbox|checkbox_notifications|Show guild member notifications|" + notify_ + "\nadd_spacer|small|\nadd_button|back|OK|noflags|0|0|\nend_dialog|guild_members_options|||\nadd_quick_exit|");
							p.CreatePacket(p_);
							break;
						}
					}
				}
			}
			else if (a_[5] == "changestatement") {
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert(get_guild_statement_edit(p_));
				p.CreatePacket(p_);
			}
			else if (a_[5] == "guild_logs") {
				uint32_t guild_id = pInfo(p_)->guild_id;
				vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
				if (p != guilds.end()) {
					Guild* guild_information = &guilds[p - guilds.begin()];
					vector<string> logs{};
					vector<vector<string>> sort_by_time;
					for (GuildLog log_ : guild_information->guild_logs) {
						sort_by_time.push_back({
							to_string(log_.date),
							log_.info,
							to_string(log_.display_id)
							});
					}
					sort(sort_by_time.begin(), sort_by_time.end(), [](const vector< string >& a, const vector< string >& b) {
						return atoi(a[1].c_str()) > atoi(b[1].c_str());
						});
					for (int i = sort_by_time.size() - 1; i >= 0; i--) {
						char* endptr = NULL;
						long long laikas_ = strtoll(sort_by_time[i][0].c_str(), &endptr, 10);
						const time_t* temp = &laikas_;
						string the_time = strtok(ctime(temp), "\n");
						logs.push_back("\nadd_label_with_icon|small|" + sort_by_time[i][1] + " `wat " + the_time + "|left|" + sort_by_time[i][2] + "|\nadd_spacer|small|");
					}
					if (logs.size() == 0) {
						logs.push_back("\nadd_label_with_icon|small|There are no logs at the moment!|left|8|\nadd_spacer|small|");
					}
					gamepacket_t p;
					p.Insert("OnDialogRequest");
					p.Insert("set_default_color|`o\nadd_label_with_icon|big| `w" + guild_information->guild_name + " Logs``|left|1436\nadd_spacer|small|" + join(logs, "") + "\nadd_button|back|`wBack``|noflags|0|0|\nend_dialog|show_guild_logs|||\nadd_quick_exit|");
					p.CreatePacket(p_);
				}
			}
			else if (a_[5] == "warphome") {
				uint32_t guild_id = pInfo(p_)->guild_id;
				vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
				if (p != guilds.end()) {
					Guild* guild_information = &guilds[p - guilds.begin()];
					if (pInfo(p_)->world == guild_information->guild_world) {
						{
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(p_)->netID);
							p.Insert("You want to warp to the same world you're in?  That's illogical, captain.");
							p.Insert(0), p.Insert(0);
							p.CreatePacket(p_);
						}

						gamepacket_t p;
						p.Insert("OnConsoleMessage");
						p.Insert("You want to warp to the same world you're in?  That's illogical, captain.");
						p.CreatePacket(p_);
						break;
					}
					gamepacket_t p;
					p.Insert("OnTextOverlay");
					p.Insert("Moving to guild home (`2" + guild_information->guild_world + "``) ...");
					p.CreatePacket(p_);
					join_world(p_, guild_information->guild_world);
				}
			}
			else if (a_[5] == "back") {
				send_social(p_);
			}
			else if (a_[5] == "leave_guild") {
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wLeave Guild``|left|1366|\nadd_spacer|small|\nadd_textbox|`oAre you sure you wish to `4leave`` the guild?|left|\nadd_spacer|small|\nadd_button|leave_guild_confirmed|`4Leave Guild``|noflags|0|0|\nadd_button|back|Back|noflags|0|0|\nend_dialog|leave_guild|||\nadd_quick_exit|");
				p.CreatePacket(p_);
			}
			else {
				string guild_member_name = a_[5];
				send_guild_member_info(p_, guild_member_name);
			}
			break;
		}
		else if (a_[i_] == "guild_member_role_change_finish") {
			if (a_.size() != 8) break;
			if (a_[5] == "back") {
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert(get_guild_info(p_));
				p.CreatePacket(p_);
			}
			break;
		}
		else if (a_[i_] == "guild_member_role_change") {
			if (a_.size() != 14) break;
			if (a_[11] == "back") {
				string guild_member_name = a_[5];
				send_guild_member_info(p_, guild_member_name);
			}
			else if (a_[11] == "promote" or a_[11] == "demote") {
				uint32_t guild_id = pInfo(p_)->guild_id;
				vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
				if (p != guilds.end()) {
					Guild* guild_information = &guilds[p - guilds.begin()];
					uint32_t my_rank = 0;
					for (GuildMember member_search : guild_information->guild_members) {
						if (member_search.member_name == pInfo(p_)->tankIDName) {
							my_rank = member_search.role_id;
							break;
						}
					}
					for (int i_ = 0; i_ < guild_information->guild_members.size(); i_++) {
						GuildMember* member_search = &guild_information->guild_members[i_];
						if (member_search->member_name == a_[5]) {
							bool can_promote = false;
							bool can_demote = false;
							if (member_search->role_id != 3) {
								if (member_search->role_id == 1 and my_rank == 3) {
									can_promote = true;
									can_demote = true;
								}
								else if (member_search->role_id == 2 and my_rank == 3) {
									can_promote = false;
									can_demote = true;
								}
								else if (member_search->role_id != 3 and my_rank >= 2 and member_search->role_id != 2) {
									can_promote = true;
								}
							}
							if (can_promote and a_[11] == "promote") {
								member_search->role_id++;
								gamepacket_t p;
								p.Insert("OnDialogRequest");
								p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wGuild Member Promoted``|left|1366|\nadd_spacer|small|\nadd_textbox|`o" + a_[8] + " is `2promoted`` to " + (member_search->role_id == 3 ? "Leader" : member_search->role_id == 2 ? "Co-Leader" : member_search->role_id == 1 ? "Elder" : "Member") + "!|left|\nadd_spacer|small|\nadd_button|back|OK|noflags|0|0|\nend_dialog|guild_member_role_change_finish|||\nadd_quick_exit|");
								p.CreatePacket(p_);
								{
									gamepacket_t p;
									p.Insert("OnConsoleMessage");
									p.Insert("`5[GUILD ALERT]`` `2" + a_[8] + "`` has been `2promoted`` `oto " + (member_search->role_id == 3 ? "Leader" : member_search->role_id == 2 ? "Co-Leader" : member_search->role_id == 1 ? "Elder" : "Member") + "!");
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
										if (pInfo(currentPeer)->guild_id == guild_id) {
											p.CreatePacket(currentPeer);
										}
										if (pInfo(currentPeer)->tankIDName == a_[8]) {
											string name_ = pInfo(currentPeer)->world;
											vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
											if (p != worlds.end()) {
												World* world_ = &worlds[p - worlds.begin()];
												update_guild_name(currentPeer, guild_information->guild_world, world_);
												if (pInfo(currentPeer)->world == guild_information->guild_world) {
													string name_ = pInfo(currentPeer)->world;
													vector<World>::iterator p_w = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
													if (p_w != worlds.end()) {
														World* world_ = &worlds[p_w - worlds.begin()];
														int x_ = 0, y_ = 0;
														int ySize = (int)world_->blocks.size() / 100, xSize = (int)world_->blocks.size() / ySize;
														for (int i_ = 0; i_ < world_->blocks.size(); i_++) {
															if (items[world_->blocks[i_].fg].blockType == BlockTypes::LOCK) {
																uint16_t id_ = world_->blocks[i_].fg;
																if (id_ == 5814) {
																	x_ = i_ % xSize;
																	y_ = i_ / xSize;
																	break;
																}
															}
														}
														WorldBlock* block_ = &world_->blocks[x_ + (y_ * 100)];
														PlayerMoving data_{};
														data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
														BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
														BYTE* blc = raw + 56;
														form_visual(blc, *block_, *world_, currentPeer, false);
														for (ENetPeer* currentPeer2 = server->peers; currentPeer2 < &server->peers[server->peerCount]; ++currentPeer2) {
															if (currentPeer2->state != ENET_PEER_STATE_CONNECTED or currentPeer2->data == NULL) continue;
															if (pInfo(currentPeer2)->world == name_) {
																send_raw(currentPeer2, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
															}
														}
														delete[] raw, blc;
													}
												}
											}
										}
									}
								}
								create_guild_log(guild_information, "`$" + pInfo(p_)->tankIDName + "`` `2promoted `$" + a_[8] + "`` `oto " + (member_search->role_id == 3 ? "Leader" : member_search->role_id == 2 ? "Co-Leader" : member_search->role_id == 1 ? "Elder" : "Member"), 484);
							}
							else if (can_demote and a_[11] == "demote") {
								member_search->role_id--;
								gamepacket_t p;
								p.Insert("OnDialogRequest");
								p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wGuild Member Demoted``|left|1366|\nadd_spacer|small|\nadd_textbox|`o" + a_[8] + " is `4demoted`` to " + (member_search->role_id == 3 ? "Leader" : member_search->role_id == 2 ? "Co-Leader" : member_search->role_id == 1 ? "Elder" : "Member") + "!|left|\nadd_spacer|small|\nadd_button|back|OK|noflags|0|0|\nend_dialog|guild_member_role_change_finish|||\nadd_quick_exit|");
								p.CreatePacket(p_);
								{
									gamepacket_t p;
									p.Insert("OnConsoleMessage");
									p.Insert("`5[GUILD ALERT]`` `2" + a_[8] + "`` has been `4demoted`` `oto " + (member_search->role_id == 3 ? "Leader" : member_search->role_id == 2 ? "Co-Leader" : member_search->role_id == 1 ? "Elder" : "Member") + "!");
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
										if (pInfo(currentPeer)->guild_id == guild_id) {
											p.CreatePacket(currentPeer);
										}
										if (pInfo(currentPeer)->tankIDName == a_[8]) {
											string name_ = pInfo(currentPeer)->world;
											vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
											if (p != worlds.end()) {
												World* world_ = &worlds[p - worlds.begin()];
												update_guild_name(currentPeer, guild_information->guild_world, world_);
												if (pInfo(currentPeer)->world == guild_information->guild_world) {
													string name_ = pInfo(currentPeer)->world;
													vector<World>::iterator p_w = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
													if (p_w != worlds.end()) {
														World* world_ = &worlds[p_w - worlds.begin()];
														int x_ = 0, y_ = 0;
														int ySize = (int)world_->blocks.size() / 100, xSize = (int)world_->blocks.size() / ySize;
														for (int i_ = 0; i_ < world_->blocks.size(); i_++) {
															if (items[world_->blocks[i_].fg].blockType == BlockTypes::LOCK) {
																uint16_t id_ = world_->blocks[i_].fg;
																if (id_ == 5814) {
																	x_ = i_ % xSize;
																	y_ = i_ / xSize;
																	break;
																}
															}
														}
														WorldBlock* block_ = &world_->blocks[x_ + (y_ * 100)];
														PlayerMoving data_{};
														data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
														BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
														BYTE* blc = raw + 56;
														form_visual(blc, *block_, *world_, currentPeer, false);
														for (ENetPeer* currentPeer2 = server->peers; currentPeer2 < &server->peers[server->peerCount]; ++currentPeer2) {
															if (currentPeer2->state != ENET_PEER_STATE_CONNECTED or currentPeer2->data == NULL) continue;
															if (pInfo(currentPeer2)->world == name_) {
																send_raw(currentPeer2, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
															}
														}
														delete[] raw, blc;
													}
												}
											}
										}
									}
								}
								create_guild_log(guild_information, "`$" + pInfo(p_)->tankIDName + "`` `4demoted `$" + a_[8] + "`` `oto " + (member_search->role_id == 3 ? "Leader" : member_search->role_id == 2 ? "Co-Leader" : member_search->role_id == 1 ? "Elder" : "Member"), 486);
							}
							break;
						}
					}
				}
			}
			break;
		}
		else if (a_[i_] == "guild_member_remove_finish") {
			if (a_.size() != 8) break;
			if (a_[5] == "back") {
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert(get_guild_info(p_));
				p.CreatePacket(p_);
			}
			break;
		}
		else if (a_[i_] == "guild_member_remove") {
			if (a_.size() != 11) break;
			if (a_[8] == "remove") {
				uint32_t guild_id = pInfo(p_)->guild_id;
				vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
				if (p != guilds.end()) {
					Guild* guild_information = &guilds[p - guilds.begin()];
					uint32_t my_rank = 0;
					for (GuildMember member_search : guild_information->guild_members) {
						if (member_search.member_name == pInfo(p_)->tankIDName) {
							my_rank = member_search.role_id;
							break;
						}
					}
					for (int i_ = 0; i_ < guild_information->guild_members.size(); i_++) {
						GuildMember* member_search = &guild_information->guild_members[i_];
						if (member_search->member_name == a_[5]) {
							bool can_kick = my_rank >= 1 and member_search->role_id < my_rank;
							if (can_kick) {
								gamepacket_t p;
								p.Insert("OnDialogRequest");
								p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wGuild Member removed``|left|1366|\nadd_spacer|small|\nadd_textbox|`o" + a_[5] + " is no longer in the guild.|left|\nadd_spacer|small|\nadd_button|back|OK|noflags|0|0|\nend_dialog|guild_member_remove_finish|||\nadd_quick_exit|");
								p.CreatePacket(p_);
								{
									gamepacket_t p;
									p.Insert("OnConsoleMessage");
									p.Insert("`5[GUILD ALERT]`` " + a_[5] + " kicked from the guild by " + pInfo(p_)->tankIDName);
									bool on_ = false;
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
										if (pInfo(currentPeer)->guild_id == guild_id) {
											p.CreatePacket(currentPeer);
										}
										if (pInfo(currentPeer)->tankIDName == a_[5]) {
											pInfo(currentPeer)->guild_id = 0;
											string name_ = pInfo(currentPeer)->world;
											vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
											if (p != worlds.end()) {
												World* world_ = &worlds[p - worlds.begin()];
												update_guild_name(currentPeer, guild_information->guild_world, world_);
												if (not guild_access(currentPeer, guild_id) and pInfo(currentPeer)->world == guild_information->guild_world) {
													string name_ = pInfo(currentPeer)->world;
													vector<World>::iterator p_w = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
													if (p_w != worlds.end()) {
														World* world_ = &worlds[p_w - worlds.begin()];
														int x_ = 0, y_ = 0;
														int ySize = (int)world_->blocks.size() / 100, xSize = (int)world_->blocks.size() / ySize;
														for (int i_ = 0; i_ < world_->blocks.size(); i_++) {
															if (items[world_->blocks[i_].fg].blockType == BlockTypes::LOCK) {
																uint16_t id_ = world_->blocks[i_].fg;
																if (id_ == 5814) {
																	x_ = i_ % xSize;
																	y_ = i_ / xSize;
																	break;
																}
															}
														}
														WorldBlock* block_ = &world_->blocks[x_ + (y_ * 100)];
														PlayerMoving data_{};
														data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
														BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
														BYTE* blc = raw + 56;
														form_visual(blc, *block_, *world_, currentPeer, false);
														for (ENetPeer* currentPeer2 = server->peers; currentPeer2 < &server->peers[server->peerCount]; ++currentPeer2) {
															if (currentPeer2->state != ENET_PEER_STATE_CONNECTED or currentPeer2->data == NULL) continue;
															if (pInfo(currentPeer2)->world == name_) {
																send_raw(currentPeer2, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
															}
														}
														delete[] raw, blc;
													}
												}
											}
											on_ = true;
										}
									}
									if (not on_) {
										string path_ = "players/" + a_[5] + "_.json";
										if (_access_s(path_.c_str(), 0) == 0) {
											json r_;
											ifstream f_(path_, ifstream::binary);
											f_ >> r_;
											f_.close();
											r_["guild_id"] = 0;
											{
												ofstream f_(path_, ifstream::binary);
												f_ << r_;
												f_.close();
											}
										}
									}

								}
								create_guild_log(guild_information, "`$" + pInfo(p_)->tankIDName + "`` `wkicked `$" + a_[5] + "`` from the guild", 6);
								guild_information->guild_members.erase(guild_information->guild_members.begin() + i_);
							}
							break;
						}
					}
				}
			}
			else if (a_[8] == "back") {
				string guild_member_name = a_[5];
				send_guild_member_info(p_, guild_member_name);
			}
			break;
		}
		else if (a_[i_] == "guild_member_edit") {
			if (a_.size() != 14) break;
			if (a_[11] == "back") {
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert(get_guild_info(p_));
				p.CreatePacket(p_);
			}
			else if (a_[11] == "promote" or a_[11] == "demote" or a_[11] == "goto" or a_[11] == "remove") {
				uint32_t guild_id = pInfo(p_)->guild_id;
				vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
				if (p != guilds.end()) {
					Guild* guild_information = &guilds[p - guilds.begin()];
					for (int i_ = 0; i_ < guild_information->guild_members.size(); i_++) {
						GuildMember* member_search = &guild_information->guild_members[i_];
						if (member_search->member_name == a_[8]) {
							if (a_[11] == "remove") {
								gamepacket_t p;
								p.Insert("OnDialogRequest");
								p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wKick Guild Member``|left|1366|\nadd_spacer|small|\nadd_textbox|`oAre you sure you wish to `4kick`` " + a_[8] + " from the guild?|left|\nadd_spacer|small|\nadd_button|remove|`4Kick " + a_[8] + "``|noflags|0|0|\nembed_data|guildMemberID|" + a_[8] + "\nadd_button|back|Back|noflags|0|0|\nend_dialog|guild_member_remove|||\nadd_quick_exit|");
								p.CreatePacket(p_);
							}
							else if (a_[11] == "goto") {
								string world_name = "";
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
									if (pInfo(currentPeer)->tankIDName == a_[8]) {
										world_name = pInfo(currentPeer)->world;
										break;
									}
								}
								if (world_name.empty()) {
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(p_)->netID);
									p.Insert("Hmm, my friend isn't in a world right now.");
									p.Insert(0), p.Insert(0);
									p.CreatePacket(p_);
									break;
								}
								else {
									if (world_name == pInfo(p_)->world) {
										gamepacket_t p;
										p.Insert("OnTalkBubble");
										p.Insert(pInfo(p_)->netID);
										p.Insert("You want to warp to the same world you're in?  That's illogical, captain.");
										p.Insert(0), p.Insert(0);
										p.CreatePacket(p_);
										break;
									}
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("Moving to guild member location (`2" + world_name + "``) ...");
									p.CreatePacket(p_);
									join_world(p_, world_name);
								}
							}
							else if (a_[11] == "promote") {
								gamepacket_t p;
								p.Insert("OnDialogRequest");
								p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wPromote Guild Member``|left|1366|\nadd_spacer|small|\nadd_textbox|`oAre you sure you wish to `2promote`` " + a_[8] + " to " + (member_search->role_id == 3 ? "" : member_search->role_id == 2 ? "" : member_search->role_id == 1 ? "Co-Leader" : "Elder") + "?|left|\nadd_spacer|small|\nadd_button|promote|`wPromote " + a_[8] + "``|noflags|0|0|\nembed_data|guildMemberID|" + a_[8] + "\nembed_data|guildmembername|" + a_[8] + "\nadd_button|back|Back|noflags|0|0|\nend_dialog|guild_member_role_change|||\nadd_quick_exit|");
								p.CreatePacket(p_);
							}
							else if (a_[11] == "demote") {
								gamepacket_t p;
								p.Insert("OnDialogRequest");
								p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wDemote Guild Member``|left|1366|\nadd_spacer|small|\nadd_textbox|`oAre you sure you wish to `4demote`` " + a_[8] + " to " + (member_search->role_id == 3 ? "" : member_search->role_id == 2 ? "Elder" : member_search->role_id == 1 ? "Member" : "") + "?|left|\nadd_spacer|small|\nadd_button|demote|`wDemote " + a_[8] + "``|noflags|0|0|\nembed_data|guildMemberID|" + a_[8] + "\nembed_data|guildmembername|" + a_[8] + "\nadd_button|back|Back|noflags|0|0|\nend_dialog|guild_member_role_change|||\nadd_quick_exit|");
								p.CreatePacket(p_);
							}
							break;
						}
					}
				}
			}
			break;
		}
		else if (a_[i_] == "friends") {
			if (a_.size() != 8) break;
			if (a_[5] == "back") {
				send_social(p_);
			}
			else if (a_[5] == "all_friends") {
				send_all_edit_friends(p_);
			}
			else if (a_[5] == "friends_options") {
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wFriend Options``|left|1366|\nadd_spacer|small|\nadd_checkbox|checkbox_public|Show location to friends|" + to_string(pInfo(p_)->show_location_) + "\nadd_checkbox|checkbox_notifications|Show friend notifications|" + to_string(pInfo(p_)->show_friend_notifications_) + "\nadd_spacer|small|\nadd_button|back|OK|noflags|0|0|\nend_dialog|friends_options|||\nadd_quick_exit|");
				p.CreatePacket(p_);
			}
			else if (a_[5] == "friend_all") {
				send_friends(p_, true);
			}
			else {
				send_info_friend(p_, a_[5]);
			}
			break;
		}
		else if (a_[i_] == "unaccess") {
			string name_ = pInfo(p_)->world;
			vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
			if (p != worlds.end()) {
				World* world_ = &worlds[p - worlds.begin()];
				int ySize = (int)world_->blocks.size() / 100, xSize = (int)world_->blocks.size() / ySize;
				bool upd_ = false;
				for (int i_ = 0; i_ < world_->blocks.size(); i_++) {
					if (items[world_->blocks[i_].fg].blockType == BlockTypes::LOCK) {
						WorldBlock* block_ = &world_->blocks[i_];
						if (block_->fg == 202 or block_->fg == 204 or block_->fg == 206 or block_->fg == 4994) {
							if (find(block_->admins.begin(), block_->admins.end(), pInfo(p_)->tankIDName) != block_->admins.end()) {
								block_->admins.erase(remove(block_->admins.begin(), block_->admins.end(), pInfo(p_)->tankIDName), block_->admins.end());
								PlayerMoving data_{};
								data_.packetType = 5, data_.punchX = i_ % xSize, data_.punchY = i_ / xSize, data_.characterState = 0x8;
								BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
								BYTE* blc = raw + 56;
								form_visual(blc, *block_, *world_, p_, false);
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
									if (pInfo(currentPeer)->world == world_->name) {
										send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
									}
								}
								delete[]raw, blc;
								if (block_->locked) {
									upd_lock(*block_, *world_, p_);
								}
								upd_ = true;
							}
							//...
						}
						else {
							if (find(world_->admins.begin(), world_->admins.end(), pInfo(p_)->tankIDName) != world_->admins.end()) {
								world_->admins.erase(remove(world_->admins.begin(), world_->admins.end(), pInfo(p_)->tankIDName), world_->admins.end());
								PlayerMoving data_{};
								data_.packetType = 5, data_.punchX = i_ % xSize, data_.punchY = i_ / xSize, data_.characterState = 0x8;
								BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
								BYTE* blc = raw + 56;
								form_visual(blc, *block_, *world_, p_, false);
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
									if (pInfo(currentPeer)->world == world_->name) {
										send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
									}
								}
								delete[]raw, blc;
								upd_ = true;
								gamepacket_t p2(0, pInfo(p_)->netID);
								{
									p2.Insert("OnNameChanged");
									if (pInfo(p_)->mod == 0 && pInfo(p_)->dev == 0) pInfo(p_)->name_color = "`0";
									p2.Insert((not pInfo(p_)->d_name.empty() ? pInfo(p_)->d_name : pInfo(p_)->name_color + pInfo(p_)->tankIDName) + (pInfo(p_)->is_legend ? " of Legend" : "") + "``");
								}
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
									if (pInfo(currentPeer)->world == world_->name) {
										p2.CreatePacket(currentPeer);
									}
								}
							}
						}
					}
				} if (upd_) {
					packet_(p_, "action|play_sfx\nfile|audio/dialog_cancel.wav\ndelayMS|0");
					{
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(p_)->netID);
						p.Insert("Removed your access from all locks.");
						p.Insert(0), p.Insert(1);
						p.CreatePacket(p_);
					}
					{
						gamepacket_t p;
						p.Insert("OnConsoleMessage");
						p.Insert("Removed your access from all locks.");
						p.CreatePacket(p_);
					}

					gamepacket_t p;
					p.Insert("OnConsoleMessage");
					p.Insert(pInfo(p_)->tankIDName + " removed their own access from all locks.");
					gamepacket_t p2(0, pInfo(p_)->netID);
					{
						p2.Insert("OnNameChanged");
						if (pInfo(p_)->mod == 0 && pInfo(p_)->dev == 0) pInfo(p_)->name_color = "`0";
						p2.Insert((not pInfo(p_)->d_name.empty() ? pInfo(p_)->d_name : pInfo(p_)->name_color + pInfo(p_)->tankIDName) + (pInfo(p_)->is_legend ? " of Legend" : "") + "``");
					}
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
						if (pInfo(currentPeer)->world == world_->name) {
							p.CreatePacket(currentPeer);
						}
					}
				}
				else {
					{
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(p_)->netID);
						p.Insert("You didn't have access on any locks!");
						p.Insert(0), p.Insert(1);
						p.CreatePacket(p_);
					}
					gamepacket_t p;
					p.Insert("OnConsoleMessage");
					p.Insert("You didn't have access on any locks!");
					p.CreatePacket(p_);
				}
			}
			break;
		}
		
		else if (a_[i_] == "confirmguild") {
			if (a_.size() != 14) break;
			string name_ = pInfo(p_)->world;
			int price = 100000;
			if (pInfo(p_)->supp > 1) price = 50000;
			if (pInfo(p_)->gems >= price) {
				vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
				if (p != worlds.end()) {
					World* world_ = &worlds[p - worlds.begin()];
					string guild_name = a_[5];
					string guild_description = a_[8];
					bool bad_name = false, already_taken = false;
					string check_name = to_lower(guild_name);
					for (int i = 0; i < swear_words.size(); i++) {
						if (check_name.find(swear_words[i]) != string::npos) {
							bad_name = true;
							break;
						}
					} for (Guild check_guild_name : guilds) {
						if (to_lower(check_guild_name.guild_name) == check_name) {
							already_taken = true;
							break;
						}
					}
					if (already_taken or bad_name or guild_name.size() < 3 or guild_name.size() > 15 or guild_description.size() < 6 or guild_description.size() > 24 or special_char(guild_name) or world_->owner_name != pInfo(p_)->tankIDName) break;
					Guild new_guild{};
					new_guild.guild_id = guilds.size() + 1;
					new_guild.guild_name = guild_name;
					new_guild.guild_description = guild_description;
					new_guild.guild_world = world_->name;
					GuildMember new_member{};
					new_member.member_name = pInfo(p_)->tankIDName;
					new_member.role_id = 3;
					new_member.last_online = time(NULL);
					new_guild.guild_members.push_back(new_member);
					guilds.push_back(new_guild);
					pInfo(p_)->guild_id = new_guild.guild_id;
					{
						int x_ = 0, y_ = 0;
						int ySize = (int)world_->blocks.size() / 100, xSize = (int)world_->blocks.size() / ySize;
						for (int i_ = 0; i_ < world_->blocks.size(); i_++) {
							if (items[world_->blocks[i_].fg].blockType == BlockTypes::LOCK) {
								uint16_t id_ = world_->blocks[i_].fg;
								if (id_ != 202 and id_ != 204 and id_ != 206 and id_ != 4994) {
									x_ = i_ % xSize;
									y_ = i_ / xSize;
									break;
								}
							}
						}
						WorldBlock* block_ = &world_->blocks[x_ + (y_ * 100)];
						world_->guild_id = new_guild.guild_id;
						block_->fg = 5814;
						PlayerMoving data_{};
						data_.packetType = 15, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
						data_.netID = pInfo(p_)->id;
						data_.plantingTree = block_->fg;
						BYTE* raw = packPlayerMoving(&data_, 56);
						PlayerMoving data_2{};
						data_2.packetType = 5, data_2.punchX = x_, data_2.punchY = y_, data_2.characterState = 0x8;
						BYTE* raw2 = packPlayerMoving(&data_2, 112 + alloc_(world_, block_));
						BYTE* blc = raw2 + 56;
						form_visual(blc, *block_, *world_, p_, false);
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
							if (pInfo(currentPeer)->world == world_->name) {
								gamepacket_t p(0, pInfo(p_)->netID);
								p.Insert("OnGuildDataChanged");
								p.Insert(50478);
								p.Insert(79289404);
								p.Insert(3);
								p.Insert(0);
								send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
								send_raw(currentPeer, 4, raw2, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
								p.CreatePacket(currentPeer);
							}
						}
			
						delete[] raw, raw2, blc;
						pInfo(p_)->gems -= price;
						{
							gamepacket_t p;
							p.Insert("OnSetBux");
							p.Insert(pInfo(p_)->gems);
							p.Insert(0);
							p.Insert((pInfo(p_)->supp >= 1) ? 1 : 0);
							if (pInfo(p_)->supp >= 2) {
								p.Insert((float)33796, (float)1, (float)0);
							}
							p.CreatePacket(p_);
						}
						{
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(p_)->netID);
							p.Insert("Guild created");
							p.Insert(0), p.Insert(0);
							p.CreatePacket(p_);
						}
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
							bool wlachi = std::experimental::filesystem::exists("db/alist/gl/" + (pInfo(p_)->tankIDName) + ".txt");
							if (wlachi == false) {
								ofstream myfile;
								myfile.open("db/alist/gl/" + (pInfo(p_)->tankIDName) + ".txt");
								myfile << "true";
								myfile.close();
								gamepacket_t p, p2;
								p.Insert("OnTalkBubble"), p.Insert(pInfo(p_)->netID), p.Insert(pInfo(p_)->name_color + pInfo(p_)->tankIDName + "`5 earned the achievement 'Guild Leader'!");
								p2.Insert("OnConsoleMessage"), p2.Insert(pInfo(p_)->name_color + pInfo(p_)->tankIDName + "`5 earned the achievement 'Guild Leader'!");
								pInfo(p_)->achievement_total++;
								PlayerMoving data_{};
								data_.packetType = 17, data_.netID = 46, data_.YSpeed = 46, data_.x = pInfo(p_)->x + 16, data_.y = pInfo(p_)->y + 16;
								BYTE* raw = packPlayerMoving(&data_);
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(p_)->world != pInfo(currentPeer)->world) continue;
									p.CreatePacket(currentPeer);
									p2.CreatePacket(currentPeer);
									send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
								}
								delete[] raw;
							}
						}
					}
				}
			}
			break;
		}
		else if (a_[i_] == "createguild") {
			if (a_.size() != 12) break;
			int price = 100000;
			if (pInfo(p_)->supp > 1) price = 50000;
			if (pInfo(p_)->gems >= price) {
				string name_ = pInfo(p_)->world;
				vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
				if (p != worlds.end()) {
					World* world_ = &worlds[p - worlds.begin()];
					string guild_name = a_[8];
					string guild_description = a_[10];
					gamepacket_t p;
					p.Insert("OnDialogRequest");
					bool bad_name = false, already_taken = false;
					string check_name = to_lower(guild_name);
					for (int i = 0; i < swear_words.size(); i++) {
						if (check_name.find(swear_words[i]) != string::npos) {
							bad_name = true;
							break;
						}
					} for (Guild check_guild_name : guilds) {
						if (to_lower(check_guild_name.guild_name) == check_name) {
							already_taken = true;
							break;
						}
					} if (already_taken)
						p.Insert(get_guild_create(p_, "`4The guild name is not available!``", guild_name, guild_description));
					else if (bad_name)
						p.Insert(get_guild_create(p_, "`4Oops!`` Guild name cannot contain `$swear words``.", guild_name, guild_description));
					else if (guild_name.size() < 3 or guild_name.size() > 15)
						p.Insert(get_guild_create(p_, "You'll need a name `$3 characters`` or longer to create a Guild - select cancel and enter a longer name.", guild_name, guild_description));
					else if (guild_description.size() < 6 or guild_description.size() > 24)
						p.Insert(get_guild_create(p_, "You need to enter at least `$6 characters`` to add a guild statement!", guild_name, guild_description));
					else if (special_char(guild_name))
						p.Insert(get_guild_create(p_, "`4Oops!`` You can only use letters and numbers in your `$Guild`` name.", guild_name, guild_description));
					else if (world_->owner_name != pInfo(p_)->tankIDName)
						p.Insert(get_guild_create(p_, "You can only create the guild inside a world which is owned by you!", guild_name, guild_description));
					else
						p.Insert(get_guild_create(p_, "", guild_name, guild_description, true));
					p.CreatePacket(p_);
				}
			}
			break;
		}
		else if (a_[i_] == "requestcreateguildpage") {
			if (a_.size() != 8) break;
			string b_ = a_[5];
			if (b_ == "back") {
				send_social(p_);
			}
			else if (b_ == "showcreateguild") {
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert(get_guild_create(p_));
				p.CreatePacket(p_);
			}
			break;
		}
		else if (a_[i_] == "socialportal") {
			if (a_.size() != 8) break;
			string b_ = a_[5];
			if (b_ == "showfriend") {
				send_friends(p_);
			}
			else if (b_ == "trade_logs") {
				string trade_logs2 = "";
				for (string a : pInfo(p_)->trade_logs) trade_logs2 += "add_smalltext|" + a + "|\n";
				if (trade_logs2 == "") trade_logs2 = "You haven't done any trades yet.";
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("add_label_with_icon|big|`o" + pInfo(p_)->name_color + pInfo(p_)->tankIDName + "'s Trade History``|left|242|\nadd_spacer|small|\n" + trade_logs2 + "\nadd_spacer|small|\nend_dialog|tradeeeee|Close||");
				p.CreatePacket(p_);
			}
			else if (b_ == "showguild") {
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert(get_guild_info(p_));
				p.CreatePacket(p_);
			}
			break;
		}
		
		else if (a_[i_] == "acceptaccess") {
			if (pInfo(p_)->ac_.size() == 0) break;
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
				if (pInfo(currentPeer)->world == pInfo(p_)->world) {
					if (pInfo(p_)->ac_.find(pInfo(currentPeer)->netID) != pInfo(p_)->ac_.end()) {
						string name_ = pInfo(p_)->world;
						vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
						if (p != worlds.end()) {
							World* world_ = &worlds[p - worlds.begin()];
							if (world_->admins.size() >= 26) {
								gamepacket_t p;
								p.Insert("OnTalkBubble");
								p.Insert(pInfo(p_)->netID);
								p.Insert("World has reached access limit!");
								p.Insert(0);
								p.Insert(0);
								p.CreatePacket(p_);
								continue;
							}
							string peer_name = pInfo(p_)->tankIDName, owner_name = world_->owner_name, user_name = pInfo(currentPeer)->tankIDName;
							if (owner_name != user_name and not pInfo(currentPeer)->dev) break;
							
							int ySize = (int)world_->blocks.size() / 100, xSize = (int)world_->blocks.size() / ySize;
							int x_ = (pInfo(p_)->ac_[pInfo(currentPeer)->netID]) % xSize, y_ = (pInfo(p_)->ac_[pInfo(currentPeer)->netID]) / xSize;
							if (x_ < 0 or x_ >= 100 or y_ < 0 or y_ >= 60) break;
							WorldBlock* block_ = &world_->blocks[x_ + (y_ * 100)];
							if (block_->fg == 202 or block_->fg == 204 or block_->fg == 206 or block_->fg == 4994) {
								if (block_->owner_name != user_name) break;
								if (block_->admins.size() >= 26) {
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(p_)->netID);
									p.Insert("Lock has reached access limit!");
									p.Insert(0);
									p.Insert(0);
									p.CreatePacket(p_);
									continue;
								}
								block_->admins.push_back(peer_name);
								gamepacket_t p;
								p.Insert("OnConsoleMessage");
								p.Insert(pInfo(p_)->name_color + pInfo(p_)->tankIDName + "`` was given access to a " + items[block_->fg].name + ".");
								bool wlachi = std::experimental::filesystem::exists("db/alist/access/" + (pInfo(p_)->tankIDName) + ".txt");
								if (wlachi == false) {
									ofstream myfile;
									myfile.open("db/alist/access/" + (pInfo(p_)->tankIDName) + ".txt");
									myfile << "true";
									myfile.close();
									gamepacket_t p, p2;
									p.Insert("OnTalkBubble"), p.Insert(pInfo(p_)->netID), p.Insert(pInfo(p_)->name_color + pInfo(p_)->tankIDName + "`5 earned the achievement 'Let The Right One In'!");
									p2.Insert("OnConsoleMessage"), p2.Insert(pInfo(p_)->name_color + pInfo(p_)->tankIDName + "`5 earned the achievement 'Let The Right One In'!");
									PlayerMoving data_{};
									data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
									BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
									BYTE* blc = raw + 56;
									form_visual(blc, *block_, *world_, p_, false);
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
										if (pInfo(currentPeer)->world == pInfo(p_)->world) {
											p.CreatePacket(currentPeer);
											pInfo(p_)->achievement_total++;
											p.CreatePacket(currentPeer);
											p2.CreatePacket(currentPeer);

											send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
										}
									}
									delete[] raw, blc;
								}
							}
							else {
								if (owner_name != user_name) break;
								if (world_->admins.size() >= 26) {
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(p_)->netID);
									p.Insert("World has reached access limit!");
									p.Insert(0);
									p.Insert(0);
									p.CreatePacket(p_);
									continue;
								}
								world_->admins.push_back(peer_name);
								gamepacket_t p2(0, pInfo(p_)->netID);
								{
									p2.Insert("OnNameChanged");
									if (pInfo(p_)->mod == 0 && pInfo(p_)->dev == 0) pInfo(p_)->name_color = "`^";
									p2.Insert((not pInfo(p_)->d_name.empty() ? pInfo(p_)->d_name : pInfo(p_)->name_color + pInfo(p_)->tankIDName) + (pInfo(p_)->is_legend ? " of Legend" : "") + "``");
								}
								gamepacket_t p;
								p.Insert("OnConsoleMessage");
								p.Insert(pInfo(p_)->name_color + pInfo(p_)->tankIDName + "`` was given access to a " + items[block_->fg].name + ".");
								PlayerMoving data_{};
								data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
								BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
								BYTE* blc = raw + 56;
								form_visual(blc, *block_, *world_, p_, false);
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
									if (pInfo(currentPeer)->world == pInfo(p_)->world) {
										p.CreatePacket(currentPeer), p2.CreatePacket(currentPeer);
										send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
									}
								}
								delete[] raw, blc;
							}
							packet_(p_, "action|play_sfx\nfile|audio/secret.wav\ndelayMS|0");
							if (block_->locked) {
								upd_lock(*block_, *world_, p_);
							}
						}
						pInfo(p_)->ac_.clear();
						return;
					}
				}
			}
			gamepacket_t p;
			p.Insert("OnTalkBubble");
			p.Insert(pInfo(p_)->netID);
			p.Insert("The lock owner has left!");
			p.Insert(0), p.Insert(0);
			p.CreatePacket(p_);
			pInfo(p_)->ac_.clear();
			break;
		}
		else if (a_[i_] == "worlds_list") {
			if (a_.size() != 8 and a_.size() != 5) break;
			if (a_.size() == 5) {
				send_wrench_self(p_);
				break;
			} if (pInfo(p_)->home_world == a_[5]) {
				bool a___ = false;
				for (pair<string, long long int> p : home_timed) {
					if (p.first == pInfo(p_)->tankIDName) {
						if (p.second + HOME_TIME > (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) {
							a___ = true;
							gamepacket_t no;
							no.Insert("OnTalkBubble");
							no.Insert(pInfo(p_)->netID);
							no.Insert("`4Cooldown active`` - You can use `5home warp`` in `5" + to_string(((p.second + HOME_TIME - (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) / 1000) - ((((p.second + HOME_TIME - (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) / 1000) / 60) * 60)) + " ``seconds.");
							no.Insert(0), no.Insert(0);
							no.CreatePacket(p_);
							break;
						}
					}
				}
				if (a___)
					break;
				home_timed.push_back(make_pair(pInfo(p_)->tankIDName, (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()));
			}
			join_world(p_, a_[5]);
			break;
		}
		else if (a_[i_] == "popup") {
			if (a_.size() == 8 and a_[5] == "my_worlds") {
				string home_world_ = "";
				string worlds_owned_ = "";
				if (not pInfo(p_)->home_world.empty()) {
					home_world_ += "\nadd_textbox|Your home world|left|\nadd_button|" + pInfo(p_)->home_world + "|" + pInfo(p_)->home_world + "|noflags|0|0|\nadd_spacer|small|";
				} for (int w_ = 0; w_ < pInfo(p_)->worlds_owned.size(); w_++) {
					worlds_owned_ += "\nadd_button|" + pInfo(p_)->worlds_owned[w_] + "|" + pInfo(p_)->worlds_owned[w_] + "|noflags|0|0|";
				} if (worlds_owned_.empty()) {
					worlds_owned_ = "\nadd_textbox|You do not have any World-Locked worlds.``|left|";
				}
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\nadd_label|big|Worlds Locked|right\nadd_spacer|small|" + home_world_ + "\nadd_textbox|Your locked worlds|left|\nadd_textbox|You must be a Supporter or Super Supporter to warp to these worlds.|left|" + worlds_owned_ + "\nadd_quick_exit|\nadd_spacer|small|\nend_dialog|worlds_list||Back|");
				p.CreatePacket(p_);
			}
			else if (a_.size() == 8 and a_[5] == "banner_bandolier_edit") {
				banner_dialog(p_);
			}
			else if (a_.size() == 8 and a_[5] == "bonus") {
				if (pInfo(p_)->gp == 1) {
					int growpassid = 6124;
					if (today_day == pInfo(p_)->gd) growpassid = 6292;
					gamepacket_t p;
					p.Insert("OnDialogRequest");
					p.Insert("set_default_color|`o\nadd_label_with_icon|big|Grow Pass Rewards|left|9222|\nadd_smalltext|`9You can claim your daily reward everyday here.``|left|\nadd_button_with_icon|claim_reward||staticBlueFrame|" + to_string(growpassid) + "||\nadd_button_with_icon|claim_reward||staticBlueFrame|" + to_string(growpassid) + "||\nadd_button_with_icon|claim_reward||staticBlueFrame|" + to_string(growpassid) + "||\nadd_button_with_icon|claim_reward||staticBlueFrame|" + to_string(growpassid) + "||\nadd_button_with_icon|claim_reward||staticBlueFrame|" + to_string(growpassid) + "||\nadd_button_with_icon||END_LIST|noflags|0||\nadd_smalltext|Update: `2We will be adding a lot of grow pass updates soon!``|left|\nadd_spacer|small|\nend_dialog|worlds_list||Back|\nadd_quick_exit|\n");
					p.CreatePacket(p_);
				}
			}
		
			else if (a_.size() == 8 and a_[5] == "account_security") {
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\nadd_label_with_icon|big|`0Account Security``|left|1424|\nadd_spacer|small|\nadd_textbox|`6Network Info``|left|\nadd_smalltext|Status: `2ONLINE``|left|\nadd_smalltext|Email: `5" + pInfo(p_)->email + "``|left|\nadd_smalltext|IP: `5" + pInfo(p_)->ip + "``|left|\nadd_smalltext|RID: `5" + pInfo(p_)->rid + "``|left|\nadd_smalltext|MAC Address: `5" + pInfo(p_)->mac + "``|left|\nadd_smalltext|Country Code: `5" + pInfo(p_)->country + "``|left|\nadd_spacer|small\nadd_textbox|`6Assets Info``|left|\nadd_smalltext|Level: `5" + to_string(pInfo(p_)->level) + "``|left|\nadd_smalltext|Gems: `5" + setGems(pInfo(p_)->gems) + "``|left|\nadd_smalltext|XP: `5" + setGems(pInfo(p_)->xp) + "``|left|\nadd_smalltext|You need " + setGems((50 * (pInfo(p_)->level * pInfo(p_)->level) + 2) - pInfo(p_)->xp) + " XP to be level " + to_string(pInfo(p_)->level + 1) + "|left|\nadd_spacer|small|\nadd_smalltext|Type what do you want to `5change``? (email/password)|left|\nadd_text_input|change|||10|\nend_dialog|account_security|OK|Continue|\n");
				p.CreatePacket(p_);
			}
			else if (a_.size() == 8 and a_[5] == "glory") glory_show(p_);
			else if (a_.size() == 8 and a_[5] == "emojis") {
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\nadd_label_with_icon|big|Growmojis|left|1366|\nadd_spacer|small|\nadd_smalltext_forced| (sigh) |left|\nadd_smalltext_forced| (mad) |left|\nadd_smalltext_forced| (smile) |left|\nadd_smalltext_forced| (tongue) |left|\nadd_smalltext_forced| (wow) |left|\nadd_smalltext_forced| (no) |left|\nadd_smalltext_forced| (shy) |left|\nadd_smalltext_forced| (wink) |left|\nadd_smalltext_forced| (music) |left|\nadd_smalltext_forced| (lol) |left|\nadd_smalltext_forced| (kiss) |left|\nadd_smalltext_forced| (agree) |left|\nadd_smalltext_forced| (cactus) |left|\nadd_smalltext_forced| (pine) |left|\nadd_smalltext_forced| (song) |left|\nadd_smalltext_forced| (lucky) |left|\nadd_spacer|small|\nadd_smalltext|`9You need to be a Super Supporter to get these Growmojis.``|left|\nadd_smalltext_forced_alpha| (yes) |0.5|left|\nadd_smalltext_forced_alpha| (love) |0.5|left|\nadd_smalltext_forced_alpha| (megaphone) |0.5|left|\nadd_smalltext_forced_alpha| (heart) |0.5|left|\nadd_smalltext_forced_alpha| (cool) |0.5|left|\nadd_spacer|small|\nadd_smalltext|`9You need 30 friends to get this Growmoji.``|left|\nadd_smalltext_forced_alpha| (see-no-evil) |0.5|left|\nadd_spacer|small|\nadd_smalltext|`9You need 40 friends to get this Growmoji.``|left|\nadd_smalltext_forced_alpha| (dance) |0.5|left|\nadd_spacer|small|\nadd_smalltext|`9You need 50 friends to get this Growmoji.``|left|\nadd_smalltext_forced_alpha| (build) |0.5|left|\nadd_spacer|small|\nadd_smalltext|`9This Growmoji can be found in a secret event.``|left|\nadd_smalltext_forced_alpha| (oops) | 0.5|left|\nadd_spacer|small|\nadd_smalltext|`9This Growmoji can be found in a secret event.``|left|\nadd_smalltext_forced_alpha| (sleep) | 0.5|left|\nadd_spacer|small|\nadd_smalltext|`9This Growmoji can be found in a secret event.``|left|\nadd_smalltext_forced_alpha| (punch) | 0.5|left|\nadd_spacer|small|\nadd_smalltext|`9This Growmoji can be found in a secret event.``|left|\nadd_smalltext_forced_alpha| (bheart) | 0.5|left|\nadd_spacer|small|\nadd_smalltext|`9This Growmoji can be found in a secret event.``|left|\nadd_smalltext_forced_alpha| (cry) | 0.5|left|\nadd_spacer|small|\nadd_smalltext|`9This Growmoji can be found in an event.``|left|\nadd_smalltext_forced_alpha| (bunny) | 0.5|left|\nadd_spacer|small|\nadd_smalltext|`9This Growmoji can be found in an event.``|left|\nadd_smalltext_forced_alpha| (peace) | 0.5|left|\nadd_spacer|small|\nadd_smalltext|`9This Growmoji can be found in an event.``|left|\nadd_smalltext_forced_alpha| (terror) | 0.5|left|\nadd_spacer|small|\nadd_smalltext|`9This Growmoji can be found in an event.``|left|\nadd_smalltext_forced_alpha| (troll) | 0.5|left|\nadd_spacer|small|\nadd_smalltext|`9This Growmoji can be found in an event.``|left|\nadd_smalltext_forced_alpha| (fireworks) | 0.5|left|\nadd_spacer|small|\nadd_smalltext|`9This Growmoji can be found in an event.``|left|\nadd_smalltext_forced_alpha| (party) | 0.5|left|\nadd_spacer|small|\nadd_smalltext|`9This Growmoji can be found in an event.``|left|\nadd_smalltext_forced_alpha| (ghost) | 0.5|left|\nadd_spacer|small|\nadd_smalltext|`9This Growmoji can be found in an event.``|left|\nadd_smalltext_forced_alpha| (nuke) | 0.5|left|\nadd_spacer|small|\nadd_smalltext|`9This Growmoji can be found in an event.``|left|\nadd_smalltext_forced_alpha| (halo) | 0.5|left|\nadd_spacer|small|\nadd_smalltext|`9This Growmoji can be found in a secret event.``|left|\nadd_smalltext_forced_alpha| (eyes) | 0.5|left|\nadd_spacer|small|\nadd_smalltext|`9This Growmoji can be found in a secret event.``|left|\nadd_smalltext_forced_alpha| (weary) | 0.5|left|\nadd_spacer|small|\nadd_smalltext|`9You need to purchase this Growmoji from the store.``|left|\nadd_smalltext_forced_alpha| (wl) | 0.5|left|\nadd_spacer|small|\nadd_smalltext|`9You need to purchase this Growmoji from the store.``|left|\nadd_smalltext_forced_alpha| (grow) | 0.5|left|\nadd_spacer|small|\nadd_smalltext|`9You need to purchase this Growmoji from the store.``|left|\nadd_smalltext_forced_alpha| (gems) | 0.5|left|\nadd_spacer|small|\nadd_smalltext|`9You need to purchase this Growmoji from the store.``|left|\nadd_smalltext_forced_alpha| (gtoken) | 0.5|left|\nadd_spacer|small|\nadd_smalltext|`9You need to purchase this Growmoji from the store.``|left|\nadd_smalltext_forced_alpha| (vend) | 0.5|left|\nadd_spacer|small|\nadd_smalltext|`9You need to purchase this Growmoji from the store.``|left|\nadd_smalltext_forced_alpha| (football) | 0.5|left|\nadd_spacer|small|\nadd_smalltext|`9These Growmojis can be found in the Growmoji Chest sold by Locke the Traveling Salesman.``|left|\nadd_smalltext_forced_alpha| (alien) |0.5|left|\nadd_smalltext_forced_alpha| (evil) |0.5|left|\nadd_smalltext_forced_alpha| (pizza) |0.5|left|\nadd_smalltext_forced_alpha| (clap) |0.5|left|\nadd_smalltext_forced_alpha| (turkey) |0.5|left|\nadd_smalltext_forced_alpha| (gift) |0.5|left|\nadd_smalltext_forced_alpha| (cake) |0.5|left|\nadd_smalltext_forced_alpha| (heartarrow) |0.5|left|\nadd_smalltext_forced_alpha| (shamrock) |0.5|left|\nadd_smalltext_forced_alpha| (grin) |0.5|left|\nadd_smalltext_forced_alpha| (ill) |0.5|left|\nadd_spacer|small|\nend_dialog|worlds_list||Back|\nadd_quick_exit|\n");
				p.CreatePacket(p_);
			}
			else if (a_.size() == 8 and a_[5] == "alist") {
				string dl;
				bool dl1 = std::experimental::filesystem::exists("db/alist/dl/" + pInfo(p_)->tankIDName + ".txt");
				//bool total = std::experimental::filesystem::exists("db/alist/total/" + pInfo(p_)->tankIDName + ".txt");
				if (dl1 == true)
				{
					dl += "\nadd_achieve|Showoff|Earned for using for a Diamond Lock|left|164|";
				}
				else
				{
					dl += "\nadd_achieve|Showoff|Not achieved!|left|124|";
				}
				string bgl;
				bool bgl1 = std::experimental::filesystem::exists("db/alist/bgl/" + pInfo(p_)->tankIDName + ".txt");
				//bool total = std::experimental::filesystem::exists("db/alist/total/" + pInfo(p_)->tankIDName + ".txt");
				if (bgl1 == true)
				{
					bgl += "\nadd_achieve|Big Showoff|Earned for using for a Blue Gem Lock|left|168|";
				}
				else
				{
					bgl += "\nadd_achieve|Big Showoff|Not achieved!|left|121|";
				}
				string gl;
				bool glg = std::experimental::filesystem::exists("db/alist/gl/" + pInfo(p_)->tankIDName + ".txt");
				//bool total = std::experimental::filesystem::exists("db/alist/total/" + pInfo(p_)->tankIDName + ".txt");
				if (glg == true)
				{
					gl += "\nadd_achieve|Guild Leader|Earned for creating a Guild.|left|158|";
				}
				else
				{
					gl += "\nadd_achieve|Guild Leader|Not achieved!|left|121|";
				}
				string demolit;
				bool demolit1 = std::experimental::filesystem::exists("db/alist/demolition/" + pInfo(p_)->tankIDName + ".txt");
				if (demolit1 == true)
				{
					demolit += "\nadd_achieve|Demolition (Classic)|Earned for smashing 100 blocks.|left|6|";
				}
				else
				{
					string demoprog = "0";
					if (std::experimental::filesystem::exists("db/aprog/demolition/" + pInfo(p_)->tankIDName + ".txt")) {
						ifstream demoprog_read("db/aprog/demolition/" + pInfo(p_)->tankIDName + ".txt");
						demoprog_read >> demoprog;
						demoprog_read.close();
					}
					demolit += "\nadd_achieve|Demolition (Classic)|Progress: " + demoprog + "%|left|127|";
				}
				string wl;
				bool wl1 = std::experimental::filesystem::exists("db/alist/wl/" + pInfo(p_)->tankIDName + ".txt");
				//bool total = std::experimental::filesystem::exists("db/alist/total/" + pInfo(p_)->tankIDName + ".txt");
				if (wl1 == true)
				{
					wl += "\nadd_achieve|This Land Is My Land (Classic)|Earned for using for a World lock|left|26|";
				}
				else
				{
					wl += "\nadd_achieve|This Land Is My Land (Classic)|Not achieved!|left|125|";
				}
				string lv50;
				bool lv501 = std::experimental::filesystem::exists("db/alist/lvl50/" + pInfo(p_)->tankIDName + ".txt");
				//bool total = std::experimental::filesystem::exists("db/alist/total/" + pInfo(p_)->tankIDName + ".txt");
				if (lv501 == true)
				{
					lv50 += "\nadd_achieve|Long Time Fan (Classic)|Earned for reaching player level 50.|left|28|";
				}
				else
				{
					lv50 += "\nadd_achieve|Long Time Fan (Classic)|Not achieved!|left|126|";
				}
				string lv99;
				bool lv991 = std::experimental::filesystem::exists("db/alist/lvl99/" + pInfo(p_)->tankIDName + ".txt");
				//bool total = std::experimental::filesystem::exists("db/alist/total/" + pInfo(p_)->tankIDName + ".txt");
				if (lv991 == true)
				{
					lv99 += "\nadd_achieve|Obsessive Growtopian (Classic)|Earned for reaching player level 99.|left|29|";
				}
				else
				{
					lv99 += "\nadd_achieve|Obsessive Growtopian (Classic)|Not achieved!|left|125|";
				}
				string supporter;
				bool supporterr = std::experimental::filesystem::exists("db/alist/supporter/" + pInfo(p_)->tankIDName + ".txt");
				if (supporterr == true)
				{
					supporter += "\nadd_achieve|Supporter (Classic)|Earned for supporting the makers of Growtopia.|left|30|";
				}
				else
				{
					supporter += "\nadd_achieve|Supporter (Classic)|Not achieved!|left|125|";
				}
				string supporter2;
				bool supporterr2 = std::experimental::filesystem::exists("db/alist/super_supporter/" + pInfo(p_)->tankIDName + ".txt");
				if (supporterr2 == true)
				{
					supporter2 += "\nadd_achieve|Super Supporter|Earned for supporting the makers of Growtopia.|left|165|";
				}
				else
				{
					supporter2 += "\nadd_achieve|Super Supporter|Not achieved!|left|124|";
				}
				string accessl;
				bool access2 = std::experimental::filesystem::exists("db/alist/access/" + pInfo(p_)->tankIDName + ".txt");
				if (access2 == true)
				{
					accessl += "\nadd_achieve|Let The Right One In (Classic)|Earned for being added to someone else's lock.|left|25|";
				}
				else
				{
					accessl += "\nadd_achieve|Let The Right One In (Classic)|Not achieved!|left|126|";
				}
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\nadd_label_with_icon|big|" + pInfo(p_)->name_color + pInfo(p_)->tankIDName + "'s achievements|left|982|\nadd_spacer|small|" + demolit + "" + wl + "" + dl + "" + bgl + "" + accessl + "" + supporter + "" + supporter2 + "" + lv50 + "" + lv99 + "" + gl + "|\nadd_spacer|small|\nend_dialog|worlds_list||Back|\nadd_quick_exit|\n");
				p.CreatePacket(p_);
			}
			else if (a_.size() == 8 and a_[5] == "set_online_status") {
			gamepacket_t p;
			p.Insert("OnDialogRequest");
			p.Insert(a + "set_default_color|`o\nadd_label|big|Online Status|left|\nadd_button|onlinebtn|Online|noflags|0|0|\nadd_button|busybtn|Busy|noflags|0|0|\nadd_button|awaybtn|Away|noflags|0|0|\nadd_spacer|small|\nadd_button|uhuhhuhuhuh|Close|noflags|0|0|");
			p.CreatePacket(p_);
			}
			else if (a_.size() == 8 and a_[5] == "title_edit") {
				string titles = "";
				if (pInfo(p_)->drtitle) titles += "\nadd_checkbox|1|'Dr.'|" + to_string(pInfo(p_)->drt) + "|";
				if (pInfo(p_)->level >= 125) titles += "\nadd_checkbox|2|Level 125|" + to_string(pInfo(p_)->lvl125) + "|";
				if (pInfo(p_)->g4g) titles += "\nadd_checkbox|3|'Grow4Good Title'|" + to_string(pInfo(p_)->donor) + "|";
				if (pInfo(p_)->mentor) titles += "\nadd_checkbox|4|'Mentor Title'|" + to_string(pInfo(p_)->master) + "|";
				if (pInfo(p_)->legend) titles += "\nadd_checkbox|5|'of Legend'|" + to_string(pInfo(p_)->is_legend) + "|";
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert(a + "set_default_color|`o\nadd_label|big|" + (titles == "" ? "No Titles Obtained" : "Select Title:") + "|right|" + titles + "\nadd_spacer|small|\nadd_button||OK|noflags|0|0|\nend_dialog|title_edit||\n");
				p.CreatePacket(p_);
			}
			
			else if (a_.size() == 8 and a_[5] == "rift_wings_edit") {
				auto* wings = &pInfo(p_)->m_riftwings;
				string
					delay_time = to_string(wings->time),
					delay_on = to_string(wings->getDelay()),

					trail_on1 = to_string(wings->getTrail1()),
					open_wings = to_string(wings->getOpenWings1()),
					closed_on1 = to_string(wings->getClosed1()),
					stamp_particle = to_string(wings->getStampParricle1()),

					trail_on2 = to_string(wings->getTrail2()),
					open_wings2 = to_string(wings->getOpenWings2()),
					closed_on2 = to_string(wings->getClosed2()),
					stamp_particle2 = to_string(wings->getStampParricle2()),

					portal_trail1 = "0",
					starfield_trail1 = "0",
					electrical_trail1 = "0",

					portal_trail2 = "0",
					starfield_trail2 = "0",
					electrical_trail2 = "0",

					feathers_material1 = "0",
					blades_material1 = "0",
					scaels_material1 = "0",

					feathers_material2 = "0",
					blades_material2 = "0",
					scaels_material2 = "0";

				switch (wings->style1_trail) {
				case STYLE1_PORTAL_TRAIL:
				{
					portal_trail1 = "1";
					break;
				}
				case STYLE1_STARFIELD_TRAIL:
				{
					starfield_trail1 = "1";
					break;
				}
				case STYLE1_ELECTRICAL_TRAIL:
				{
					electrical_trail1 = "1";
					break;
				}
				default:
				{
					break;
				}
				}
				switch (wings->style2_trail) {
				case STYLE2_PORTAL_TRAIL:
				{
					portal_trail2 = "1";
					break;
				}
				case STYLE2_STARFIELD_TRAIL:
				{
					starfield_trail2 = "1";
					break;
				}
				case STYLE2_ELECTRICAL_TRAIL:
				{
					electrical_trail2 = "1";
					break;
				}
				default:
				{
					break;
				}
				}
				switch (wings->style1_material) {
				case STYLE1_FEATHERS_MATERIAL:
				{
					feathers_material1 = "1";
					break;
				}
				case STYLE1_BLADES_MATERIAL:
				{
					blades_material1 = "1";
					break;
				}
				case STYLE1_SCAELS_MATERIAL:
				{
					scaels_material1 = "1";
					break;
				}
				default:
				{
					break;
				}
				}
				switch (wings->style2_material) {
				case STYLE2_FEATHERS_MATERIAL:
				{
					feathers_material2 = "1";
					break;
				}
				case STYLE2_BLADES_MATERIAL:
				{
					blades_material2 = "1";
					break;
				}
				case STYLE2_SCAELS_MATERIAL:
				{
					scaels_material2 = "1";
					break;
				}
				default:
				{
					break;
				}
				}

				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert(
					"set_default_color|`o\n"
					"add_label_with_icon|big|`wRift Wings``|left|11478|\n"
					"add_spacer|small|\n"
					"add_text_input|text_input_time_cycle|Time Dilation Cycle Time:|" + delay_time + "|5|\n"
					"add_checkbox|checkbox_time_cycle|Time Dilation On / Off|" + delay_on + "\n"
					"add_button|button_manual|Instructions|noflags|0|0|\n"
					"add_spacer|small|\n"
					"add_spacer|small|\n"
					"add_label|big|Wings Style 1|left\n"
					"add_spacer|small|\n"
					"add_label|small|Wings Color:|left\n"
					"add_text_input|text_input_wings_color0|Wings - R,G,B:|" + to_string(wings->wings_color1->get_red()) + "," + to_string(wings->wings_color1->get_green()) + "," + to_string(wings->wings_color1->get_blue()) + "|11|\n"
					"add_spacer|small|\n"
					"add_label|big|Wings Metal Color|left\n"
					"add_label|small|Wings Metal Color:|left\n"
					"add_text_input|text_input_metal_color0|Metal - R,G,B:|" + to_string(wings->wings_metal_color1->get_red()) + "," + to_string(wings->wings_metal_color1->get_green()) + "," + to_string(wings->wings_metal_color1->get_blue()) + "|11|\n"
					"add_spacer|small|\n"
					"add_spacer|small|\n"
					"add_checkbox|checkbox_open_wings0|Always Open Wings|" + open_wings + "\n"
					"add_checkbox|checkbox_closed_wings0|Always Closed Wings|" + closed_on1 + "\n"
					"add_spacer|small|\n"
					"add_checkbox|checkbox_stamp_particle0|Stamp Particle|" + stamp_particle + "\n"
					"add_spacer|small|\n"
					"add_checkbox|checkbox_trail0|Trail On / Off|" + trail_on1 + "\n"
					"add_checkbox|checkbox_trail_1st0|      Portal Trail|" + portal_trail1 + "\n"
					"add_checkbox|checkbox_trail_2nd0|      Starfield Trail|" + starfield_trail1 + "\n"
					"add_checkbox|checkbox_trail_3rd0|      Electrical Trail|" + electrical_trail1 + "\n"
					"add_spacer|small|\n"
					"add_label|small|Wings Material:|left\n"
					"add_spacer|small|\n"
					"add_checkbox|checkbox_material_1st0|      Feathers|" + feathers_material1 + "\n"
					"add_checkbox|checkbox_material_2nd0|      Blades|" + blades_material1 + "\n"
					"add_checkbox|checkbox_material_3rd0|      Scales|" + scaels_material1 + "\n"
					"add_spacer|small|\n"
					"add_spacer|small|\n"
					"add_label|big|Wings Style 2|left\n"
					"add_spacer|small|\n"
					"add_label|small|Wings Color:|left\n"
					"add_text_input|text_input_wings_color1|Wings - R,G,B:|" + to_string(wings->wings_color2->get_red()) + "," + to_string(wings->wings_color2->get_green()) + "," + to_string(wings->wings_color2->get_blue()) + "|11|\n"
					"add_spacer|small|\n"
					"add_label|big|Wings Metal Color|left\n"
					"add_label|small|Wings Metal Color:|left\n"
					"add_text_input|text_input_metal_color1|Metal - R,G,B:|" + to_string(wings->wings_metal_color2->get_red()) + "," + to_string(wings->wings_metal_color2->get_green()) + "," + to_string(wings->wings_metal_color2->get_blue()) + "|11|\n"
					"add_spacer|small|\n"
					"add_spacer|small|\n"
					"add_checkbox|checkbox_open_wings1|Always Open Wings|" + open_wings2 + "\n"
					"add_checkbox|checkbox_closed_wings1|Always Closed Wings|" + closed_on2 + "\n"
					"add_spacer|small|\n"
					"add_checkbox|checkbox_stamp_particle1|Stamp Particle|" + stamp_particle2 + "\n"
					"add_spacer|small|\n"
					"add_checkbox|checkbox_trail1|Trail On / Off|1\n"
					"add_checkbox|checkbox_trail_1st1|      Portal Trail|" + portal_trail2 + "\n"
					"add_checkbox|checkbox_trail_2nd1|      Starfield Trail|" + starfield_trail2 + "\n"
					"add_checkbox|checkbox_trail_3rd1|      Electrical Trail|" + electrical_trail2 + "\n"
					"add_spacer|small|\n"
					"add_label|small|Wings Material:|left\n"
					"add_spacer|small|\n"
					"add_checkbox|checkbox_material_1st1|      Feathers|" + feathers_material2 + "\n"
					"add_checkbox|checkbox_material_2nd1|      Blades|" + blades_material2 + "\n"
					"add_checkbox|checkbox_material_3rd1|      Scales|" + scaels_material2 + "\n"
					"add_spacer|small|\n"
					"add_button|restore_default|Restore to Default|noflags|0|0|\n"
					"end_dialog|dialog_rift_wing|Cancel|Update|\n"
					"add_quick_exit|");
				p.CreatePacket(p_);
			}


			else if (a_.size() == 8 and a_[5] == "rift_cape_edit") {
				auto* cape = &pInfo(p_)->m_riftcape;
				string
					delay_time = to_string(cape->time),
					delay_on = to_string(cape->getDelay()),

					aura_on1 = to_string(cape->getAura1()),
					collar_on1 = to_string(cape->getCollar1()),
					closed_on1 = to_string(cape->getClosed1()),
					movement_on1 = to_string(cape->getMovement1()),

					aura_on2 = to_string(cape->getAura2()),
					collar_on2 = to_string(cape->getCollar2()),
					closed_on2 = to_string(cape->getClosed2()),
					movement_on2 = to_string(cape->getMovement2()),

					portal_aura1 = "0",
					starfield_aura1 = "0",
					electrical_aura1 = "0",

					portal_aura2 = "0",
					starfield_aura2 = "0",
					electrical_aura2 = "0";

				switch (cape->style1_aura) { /*1style*/
				case 256: /*portal*/
				{
					portal_aura1 = "1";
					break;
				}
				case 512: /*starfield*/
				{
					starfield_aura1 = "1";
					break;
				}
				case 768: /*electrical*/
				{
					electrical_aura1 = "1";
					break;
				}
				default:
				{
					break;
				}
				}
				switch (cape->style2_aura) { /*2style*/
				case STYLE2_PORTAL: /*portal*/
				{
					portal_aura2 = "1";
					break;
				}
				case STYLE2_STARFIELD: /*starfield*/
				{
					starfield_aura2 = "1";
					break;
				}
				case STYLE2_ELECTRICAL: /*electrical*/
				{
					electrical_aura2 = "1";
					break;
				}
				default:
				{
					break;
				}
				}
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert(
					"set_default_color|`o\n"
					"add_label_with_icon|big|`wRift Cape``|left|10424|\n"
					"add_spacer|small|\n"
					"add_text_input|text_input_time_cycle|Time Dilation Cycle Time:|" + delay_time + "|5|\n"
					"add_checkbox|checkbox_time_cycle|Time Dilation On / Off|" + delay_on + "\n"
					"add_button|button_manual|Instructions|noflags|0|0|\n"
					"add_spacer|small|\n"
					"add_label|big|Cape Style 1|left\n"
					"add_spacer|small|\n"
					"add_label|small|Cape Color:|left\n"
					"add_text_input|text_input_cape_color0|Cape - R,G,B:|" + to_string(cape->cape_color1->get_red()) + "," + to_string(cape->cape_color1->get_green()) + "," + to_string(cape->cape_color1->get_blue()) + "|11|\n"
					"add_spacer|small|\n"
					"add_checkbox|checkbox_cape_collar0|Cape Collar On / Off|" + collar_on1 + "\n"
					"add_label|small|Cape Collar Color:|left\n"
					"add_text_input|text_input_collar_color0|Collar - R,G,B:|" + to_string(cape->cape_collar_color1->get_red()) + "," + to_string(cape->cape_collar_color1->get_green()) + "," + to_string(cape->cape_collar_color1->get_blue()) + "|11|\n"
					"add_spacer|small|\n"
					"add_checkbox|checkbox_closed_cape0|Closed Cape|" + closed_on1 + "\n"
					"add_checkbox|checkbox_open_on_move0|Open Cape on Movement|" + movement_on1 + "\n"
					"add_checkbox|checkbox_aura0|Aura On / Off|" + aura_on1 + "\n"
					"add_checkbox|checkbox_aura_1st0|      Portal Aura|" + portal_aura1 + "\n"
					"add_checkbox|checkbox_aura_2nd0|      Starfield Aura|" + starfield_aura1 + "\n"
					"add_checkbox|checkbox_aura_3rd0|      Electrical Aura|" + electrical_aura1 + "\n"
					"add_label|big|Cape Style 2|left\n"
					"add_spacer|small|\n"
					"add_label|small|Cape Color:|left\n"
					"add_text_input|text_input_cape_color1|Cape - R,G,B:|" + to_string(cape->cape_color2->get_red()) + "," + to_string(cape->cape_color2->get_green()) + "," + to_string(cape->cape_color2->get_blue()) + "|11|\n"
					"add_spacer|small|\n"
					"add_checkbox|checkbox_cape_collar1|Cape Collar On / Off|" + collar_on2 + "\n"
					"add_label|small|Cape Collar Color:|left\n"
					"add_text_input|text_input_collar_color1|Collar - R,G,B:|" + to_string(cape->cape_collar_color2->get_red()) + "," + to_string(cape->cape_collar_color2->get_green()) + "," + to_string(cape->cape_collar_color2->get_blue()) + "|11|\n"
					"add_spacer|small|\n"
					"add_checkbox|checkbox_closed_cape1|Closed Cape|" + closed_on2 + "\n"
					"add_checkbox|checkbox_open_on_move1|Open Cape on Movement|" + movement_on2 + "\n"
					"add_checkbox|checkbox_aura1|Aura On / Off|" + aura_on2 + "\n"
					"add_checkbox|checkbox_aura_1st1|      Portal Aura|" + portal_aura2 + "\n"
					"add_checkbox|checkbox_aura_2nd1|      Starfield Aura|" + starfield_aura2 + "\n"
					"add_checkbox|checkbox_aura_3rd1|      Electrical Aura|" + electrical_aura2 + "\n"
					"add_spacer|small|\n"
					"add_button|restore_default|Restore to Default|noflags|0|0|\n"
					"end_dialog|dialog_rift_cape|Cancel|Update|\n"
					"add_quick_exit|");
				p.CreatePacket(p_);
			}
			else if (a_.size() == 8 and a_[5] == "Ezio") {
				int transform = pInfo(p_)->necklace;
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wTransform|left|" + to_string(transform) + "|\nadd_spacer|small|\nadd_button|trans_" + to_string(transform) + "|`$Transform to " + items[transform].name + "|\nadd_button|trans_256|`$Transform to Human|\nadd_spacer|small|\nadd_button|cl0se|`wClose|\nadd_quick_exit|");
				p.CreatePacket(p_);
			}
			else if (a_.size() == 8 and a_[5] == "startek") {
			  int transform = transform = pInfo(p_)->hand;
			  gamepacket_t p;
			  p.Insert("OnDialogRequest");
			  p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wTransform|left|" + to_string(transform) + "|\nadd_spacer|small|\nadd_button|trans_" + to_string(transform) + "|`$Transform to " + items[transform].name + "|\nadd_button|trans_256|`$Transform to Human|\nadd_spacer|small|\nadd_button|cl0se|`wClose|\nadd_quick_exit|");
			  p.CreatePacket(p_);
			}
			else if (a_.size() == 8 and a_[5] == "Space") {
				int transform = transform = pInfo(p_)->hand;
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wTransform|left|" + to_string(transform) + "|\nadd_spacer|small|\nadd_button|trans_" + to_string(transform) + "|`$Transform to " + items[transform].name + "|\nadd_button|trans_256|`$Transform to Human|\nadd_spacer|small|\nadd_button|cl0se|`wClose|\nadd_quick_exit|");
				p.CreatePacket(p_);
			}
			else if (a_.size() == 8 and a_[5] == "notebook_edit") {
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\nadd_label|big|Notebook|left|0|\nadd_text_box_input|personal_note||" + pInfo(p_)->note + "|128|5|\nadd_spacer|small|\nadd_button|save|Save|noflags|0|0|\nadd_button|clear|Clear|noflags|0|0|\nadd_button|cancel|Cancel|noflags|0|0|\nend_dialog|notebook_edit||\nadd_quick_exit|\n");
				p.CreatePacket(p_);
			}
			else if (a_.size() == 8 and a_[5] == "g4g_personal_dialog") grow4good(p_, true, "tab_tasks", 0);
			else if (a_.size() == 8 and a_[5] == "billboard_edit") {
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wTrade Billboard``|left|8282|\nadd_spacer|small|" + (pInfo(p_)->b_i != 0 ? "\nadd_label_with_icon|small|`w" + items[pInfo(p_)->b_i].name + "``|left|" + to_string(pInfo(p_)->b_i) + "|" : "") + "\nadd_item_picker|billboard_item|`wSelect Billboard Item``|Choose an item to put on your billboard!|\nadd_spacer|small|\nadd_checkbox|billboard_toggle|`$Show Billboard``|" + (pInfo(p_)->b_a == 0 ? "0" : "1") + "\nadd_text_input|setprice|Price of item:|" + to_string(pInfo(p_)->b_p) + "|5|\nadd_checkbox|chk_peritem|World Locks per Item|" + (pInfo(p_)->b_w == 0 ? "0" : "1") + "\nadd_checkbox|chk_perlock|Items per World Lock|" + (pInfo(p_)->b_w == 0 ? "1" : "0") + "\nadd_spacer|small|\nend_dialog|billboard_edit|Close|Update|\n");
				p.CreatePacket(p_);
			}
			else if (a_.size() == 8 and a_[5] == "scarf_of_seasons_edit") {
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert(a + "set_default_color|`o\nadd_label_with_icon|big|`wEquinox Scarf``|left|11818|\nadd_spacer|small|\nadd_textbox|Scarf Design|left|\nadd_spacer|small|\nadd_checkbox|checkbox_color_0|      Spring |" + (pInfo(p_)->i_11818_1 == 0 ? "1" : "0") + "\nadd_checkbox|checkbox_color_1|      Summer |" + (pInfo(p_)->i_11818_1 == 1 ? "1" : "0") + "\nadd_checkbox|checkbox_color_2|      Autumn |" + (pInfo(p_)->i_11818_1 == 2 ? "2" : "0") + "\nadd_checkbox|checkbox_color_3|      Winter |" + (pInfo(p_)->i_11818_1 == 3 ? "1" : "0") + "\nadd_textbox|Scarf Attack|left|\nadd_spacer|small|\nadd_checkbox|checkbox_punch_0|      Spring |" + (pInfo(p_)->i_11818_2 == 0 ? "1" : "0") + "\nadd_checkbox|checkbox_punch_1|      Summer |" + (pInfo(p_)->i_11818_2 == 1 ? "1" : "0") + "\nadd_checkbox|checkbox_punch_2|      Autumn |" + (pInfo(p_)->i_11818_2 == 2 ? "1" : "0") + "\nadd_checkbox|checkbox_punch_3|      Winter |" + (pInfo(p_)->i_11818_2 == 3 ? "1" : "0") + "\nadd_spacer|small|\nadd_button|restore_default|Restore to Default|noflags|0|0|\nend_dialog|dialog_scarf_of_seasons|Cancel|Update|\nadd_quick_exit|");
				p.CreatePacket(p_);
			}
			else if (a_.size() == 8 and a_[5] == "goals") {
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\nadd_label_with_icon|small|" + pInfo(p_)->tankIDName + "'s Goals|left|982|\nadd_spacer|small|"/*"\nadd_textbox|`9Life Goals``|left|\nadd_smalltext|`9Awesomeness: 13%``|left|\nadd_label_with_icon|small|`3Seed Goal:`` Deliver 200 Rock (0/200)``|left|3|\nadd_label_with_icon|small|`3Gem Goal:`` Smash 5000 rarity of blocks (2884/5000)``|left|112|\nadd_label_with_icon|small|`3Experience Goal:`` Defeat 10 players in Games (0/10)``|left|1488|\nadd_smalltext|Completed Life Goals will reset in 4 hours, 20 mins|left|\nadd_spacer|small|"*/"\nadd_textbox|`9Daily Quest``|left|\nadd_label_with_icon|small|" + (today_day != pInfo(p_)->dd ? "Deliver `2" + to_string(item1c) + " " + items[item1].name + "`` and `2" + to_string(item2c) + " " + items[item2].name + "`` to Crazy Jim" : "`2COMPLETE!`` Check again tomorrow.") + "|left|1486|\nadd_spacer|small|\nadd_textbox|`9Finish and receive awesome rewards from farming, geiger finding or trees removing, checkout the prizes below.``|left|\nadd_player_info|`oSurgeon``|" + to_string(pInfo(p_)->s_lvl) + "|" + to_string(pInfo(p_)->s_xp) + "|" + to_string(10 * ((pInfo(p_)->s_lvl * pInfo(p_)->s_lvl) + 2)) + "|\nadd_spacer|small|\nadd_button|surgery_reward|View Surgery Rewards|noflags|0|0|\nadd_player_info|`oFishing``|" + to_string(pInfo(p_)->ff_lvl) + "|" + to_string(pInfo(p_)->ff_xp) + "|" + to_string(5 * ((pInfo(p_)->ff_lvl * pInfo(p_)->ff_lvl) + 2)) + "|\nadd_spacer|small|\nadd_button|fishing_reward|View Fishing Rewards|noflags|0|0|\nadd_player_info|`oBuilder``|" + to_string(pInfo(p_)->bb_lvl) + "|" + to_string(pInfo(p_)->bb_xp) + "|" + to_string(100 * ((pInfo(p_)->bb_lvl * pInfo(p_)->bb_lvl) + 2)) + "|\nadd_spacer|small|\nadd_button|builder_reward|View Builder Rewards|noflags|0|0|\nadd_spacer|small|\nadd_player_info|`oFarmer``|" + to_string(pInfo(p_)->t_lvl) + "|" + to_string(pInfo(p_)->t_xp) + "|" + to_string(100 * ((pInfo(p_)->t_lvl * pInfo(p_)->t_lvl) + 2)) + "|\nadd_spacer|small|\nadd_button|farmer_reward|View Farmer Rewards|noflags|0|0|\nadd_spacer|small|\nadd_player_info|`oProvider``|" + to_string(pInfo(p_)->p_lvl) + "|" + to_string(pInfo(p_)->p_xp) + "|" + to_string(75 * ((pInfo(p_)->p_lvl * pInfo(p_)->p_lvl) + 2)) + "|\nadd_spacer|small|\nadd_button|provider_reward|View Provider Rewards|noflags|0|0|\nadd_spacer|small|\nadd_player_info|`oGeiger Hunting``|" + to_string(pInfo(p_)->g_lvl) + "|" + to_string(pInfo(p_)->g_xp) + "|" + to_string(5 * ((pInfo(p_)->g_lvl * pInfo(p_)->g_lvl) + 2)) + "|\nadd_spacer|small|\nadd_button|geiger_reward|View Geiger Hunting Rewards|noflags|0|0|\nadd_spacer|small|\nadd_spacer|small|\nend_dialog|worlds_list||Back|\nadd_quick_exit|\n");
				p.CreatePacket(p_);
			}
			else if (a_.size() == 14 and a_[11] == "trade" and isdigit(a_[5][0]) and isdigit(a_[8][0])) {
				string name_ = pInfo(p_)->world;
				vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
				if (p != worlds.end()) {
					World* world_ = &worlds[p - worlds.begin()];
					int my_netid_ = atoi(a_[5].c_str()), other_netid_ = atoi(a_[8].c_str());
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
						if (pInfo(currentPeer)->world == pInfo(p_)->world and pInfo(currentPeer)->netID == other_netid_ and not pInfo(currentPeer)->invis) {
							for (int c_ = 0; c_ < pInfo(currentPeer)->friends.size(); c_++) {
								if (pInfo(currentPeer)->friends[c_].name == pInfo(p_)->tankIDName) {
									if (pInfo(currentPeer)->friends[c_].block_trade)
										return;
								}
							}
							if (pInfo(currentPeer)->trading_with != -1 and pInfo(currentPeer)->trading_with != pInfo(p_)->netID) {
								gamepacket_t p;
								p.Insert("OnTalkBubble");
								p.Insert(pInfo(p_)->netID);
								p.Insert("That person is busy.");
								p.Insert(0), p.Insert(0);
								p.CreatePacket(p_);
								pInfo(p_)->block_trade = false, pInfo(p_)->trading_with = -1;
								{
									gamepacket_t p;
									p.Insert("OnForceTradeEnd");
									p.CreatePacket(p_);
								}
								return;
							}
							pInfo(p_)->trading_with = pInfo(currentPeer)->netID;
							pInfo(p_)->trade_accept = 0;
							pInfo(currentPeer)->trade_accept = 0;
							gamepacket_t p;
							p.Insert("OnStartTrade");
							p.Insert(pInfo(currentPeer)->tankIDName);
							p.Insert(pInfo(currentPeer)->netID);
							p.CreatePacket(p_);
							if (pInfo(currentPeer)->trading_with != -1) {
								// as neisivaizduoju kdl real gt taip daro bet noriu kad butu kaip rgt.
								gamepacket_t p;
								p.Insert("OnTradeStatus");
								p.Insert(pInfo(p_)->netID);
								p.Insert("");
								p.Insert("`o" + pInfo(p_)->name_color + pInfo(p_)->tankIDName + "``'s offer.``");
								p.Insert("locked|0\nreset_locks|1\naccepted|0");
								p.CreatePacket(p_);
								{
									gamepacket_t p;
									p.Insert("OnTradeStatus");
									p.Insert(pInfo(p_)->netID);
									p.Insert("");
									p.Insert("`o" + pInfo(p_)->name_color + pInfo(p_)->tankIDName + "``'s offer.``");
									p.Insert("locked|0\naccepted|1");
									p.CreatePacket(p_);
								}
								{
									gamepacket_t p;
									p.Insert("OnTradeStatus");
									p.Insert(pInfo(p_)->netID);
									p.Insert("");
									p.Insert("`o" + pInfo(p_)->name_color + pInfo(p_)->tankIDName + "``'s offer.``");
									p.Insert("locked|0\nreset_locks|1\naccepted|0");
									p.CreatePacket(p_);
								}
								{
									gamepacket_t p;
									p.Insert("OnTradeStatus");
									p.Insert(pInfo(currentPeer)->netID);
									p.Insert("");
									p.Insert("`o" + pInfo(currentPeer)->name_color + pInfo(currentPeer)->tankIDName + "``'s offer.``");
									p.Insert(make_trade_offer(pInfo(currentPeer), true) + "locked|0\nreset_locks|1\naccepted|0");
									p.CreatePacket(p_);
									{
										gamepacket_t p;
										p.Insert("OnTradeStatus");
										p.Insert(pInfo(currentPeer)->netID);
										p.Insert("");
										p.Insert("`o" + pInfo(currentPeer)->name_color + pInfo(currentPeer)->tankIDName + "``'s offer.``");
										p.Insert("locked|0\nreset_locks|1\naccepted|0");
										p.CreatePacket(currentPeer);
									}
									{
										gamepacket_t p;
										p.Insert("OnTradeStatus");
										p.Insert(pInfo(currentPeer)->netID);
										p.Insert("");
										p.Insert("`o" + pInfo(currentPeer)->name_color + pInfo(currentPeer)->tankIDName + "``'s offer.``");
										p.Insert("locked|0\naccepted|1");
										p.CreatePacket(currentPeer);
									}
									{
										gamepacket_t p;
										p.Insert("OnTradeStatus");
										p.Insert(pInfo(currentPeer)->netID);
										p.Insert("");
										p.Insert("`o" + pInfo(currentPeer)->name_color + pInfo(currentPeer)->tankIDName + "``'s offer.``");
										p.Insert(make_trade_offer(pInfo(currentPeer), true) + "locked|0\nreset_locks|1\naccepted|0");
										p.CreatePacket(currentPeer);
									}
									{
										gamepacket_t p;
										p.Insert("OnTradeStatus");
										p.Insert(pInfo(p_)->netID);
										p.Insert("");
										p.Insert("`o" + pInfo(p_)->name_color + pInfo(p_)->tankIDName + "``'s offer.``");
										p.Insert(make_trade_offer(pInfo(p_), true) + "locked|0\nreset_locks|1\naccepted|0");
										p.CreatePacket(currentPeer);
									}
								}
								break;
							}
							packet_(currentPeer, "action|play_sfx\nfile|audio/cash_register.wav\ndelayMS|0");
							{
								gamepacket_t p;
								p.Insert("OnConsoleMessage");
								p.Insert("`#TRADE ALERT:`` `w" + pInfo(p_)->name_color + pInfo(p_)->tankIDName + "```` wants to trade with you!  To start, use the `wWrench`` on that person's wrench icon, or type `w/trade " + pInfo(p_)->name_color + pInfo(p_)->tankIDName + "``");
								p.CreatePacket(currentPeer);
							}
							break;
						}
					}
				}
			}
			else if (a_.size() == 14 and a_[11] == "mute_player" and isdigit(a_[5][0]) and isdigit(a_[8][0]) or a_.size() == 14 and a_[11] == "unmute_player" and isdigit(a_[5][0]) and isdigit(a_[8][0])) {
				int my_netid_ = atoi(a_[5].c_str()), other_netid_ = atoi(a_[8].c_str());
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
					if (pInfo(currentPeer)->world == pInfo(p_)->world and pInfo(currentPeer)->netID == other_netid_) {
						for (int c_ = 0; c_ < pInfo(p_)->friends.size(); c_++) {
							if (pInfo(p_)->friends[c_].name == pInfo(currentPeer)->tankIDName) {
								if (a_[11] == "mute_player")
									pInfo(p_)->friends[c_].mute = true;
								else
									pInfo(p_)->friends[c_].mute = false;
								break;
							}
						}
						break;
					}
				}
			}
			else if (a_.size() == 14 and a_[11] == "worldban" and isdigit(a_[5][0]) and isdigit(a_[8][0])) {
				SendCmd(p_, "/ban " + pInfo(p_)->last_wrenched, true);
			}
			else if (a_.size() == 14 and a_[11] == "pull" and isdigit(a_[5][0]) and isdigit(a_[8][0])) {
				SendCmd(p_, "/pull " + pInfo(p_)->last_wrenched, true);
			}
			else if (a_.size() == 14 and a_[11] == "kick" and isdigit(a_[5][0]) and isdigit(a_[8][0])) {
				SendCmd(p_, "/kick " + pInfo(p_)->last_wrenched, true);
			}
			else if (a_.size() == 14 and a_[11] == "punish_view" and isdigit(a_[5][0]) and isdigit(a_[8][0])) {
				if (pInfo(p_)->mod == 1 || pInfo(p_)->dev == 1) {
					SendCmd(p_, "/info " + pInfo(p_)->last_wrenched, true);
				}
			}
			else if (a_.size() == 14 and a_[11] == "start_surg" and isdigit(a_[5][0]) and isdigit(a_[8][0])) {
				bool has_recovery = false;
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != pInfo(p_)->world or pInfo(p_)->last_wrenched != pInfo(currentPeer)->tankIDName or pInfo(currentPeer)->hospital_bed == false) continue;
					for (int i_ = 0; i_ < pInfo(currentPeer)->playmods.size(); i_++) if (pInfo(currentPeer)->playmods[i_].id == 89) has_recovery = true;
					if (has_recovery == false) {
						if (setstats(p_, pInfo(currentPeer)->surgery_type, pInfo(currentPeer)->tankIDName, pInfo(currentPeer)->name_color + pInfo(currentPeer)->tankIDName + "``")) {
							PlayMods new_playmod{};
							int seconds = 3600;
							if (pInfo(currentPeer)->necklace == 8954) seconds *= 0.75;
							new_playmod.id = 89, new_playmod.time = time(nullptr) + seconds;
							pInfo(currentPeer)->playmods.push_back(new_playmod);
							gamepacket_t p2;
							p2.Insert("OnConsoleMessage"), p2.Insert(a + "You are recovering from surgery. (`$Recovery`` mod added, `$" + (pInfo(currentPeer)->necklace == 8954 ? "45 mins" : "1 hour") + "`` left)"), p2.CreatePacket(currentPeer);
							pInfo(currentPeer)->surgery_type = rand() % 30;
						}
					}
				}
			}
			else if (a_.size() == 14 and a_[11] == "invitetoguild" and isdigit(a_[5][0]) and isdigit(a_[8][0])) {
				int my_netid_ = atoi(a_[5].c_str()), other_netid_ = atoi(a_[8].c_str());
				if (pInfo(p_)->guild_id == 0) break;
				uint32_t guild_id = pInfo(p_)->guild_id;
				vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
				if (p != guilds.end()) {
					Guild* guild_information = &guilds[p - guilds.begin()];
					for (GuildMember member_search : guild_information->guild_members) {
						if (member_search.member_name == pInfo(p_)->tankIDName) {
							if (member_search.role_id != 3 and member_search.role_id != 2 and member_search.role_id != 1) return;
							for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
								if (pInfo(currentPeer)->world == pInfo(p_)->world and pInfo(currentPeer)->netID == other_netid_) {
									if (pInfo(currentPeer)->guild_id != 0) return;
									if (guild_information->guild_members.size() >= guild_information->guild_level * 5) {
										gamepacket_t p;
										p.Insert("OnTalkBubble");
										p.Insert(pInfo(p_)->netID);
										p.Insert("Guild is at maximum capacity of " + to_string(guild_information->guild_level * 5) + " peoples!");
										p.Insert(0), p.Insert(0);
										p.CreatePacket(p_);
										{
											gamepacket_t p;
											p.Insert("OnConsoleMessage");
											p.Insert("Guild is at maximum capacity of " + to_string(guild_information->guild_level * 5) + " peoples!");
											p.CreatePacket(p_);
										}
										return;
									}
									pInfo(currentPeer)->pending_guild = pInfo(p_)->guild_id;
									packet_(currentPeer, "action|play_sfx\nfile|audio/tip_start.wav\ndelayMS|0");
									{
										gamepacket_t p;
										p.Insert("OnTalkBubble");
										p.Insert(pInfo(p_)->netID);
										p.Insert("`5[``Guild request sent to " + pInfo(currentPeer)->name_color + pInfo(currentPeer)->tankIDName + "```5]``");
										p.Insert(0), p.Insert(0);
										p.CreatePacket(p_);
									}
									gamepacket_t p;
									p.Insert("OnConsoleMessage");
									p.Insert("`5GUILD REQUEST:`` You've been invited to join `2" + guild_information->guild_name + " `` by " + pInfo(p_)->name_color + pInfo(p_)->tankIDName + "``! To accept, `wwrench yourself`` and then choose `2Join " + guild_information->guild_name + "``.");
									p.CreatePacket(currentPeer);
									create_guild_log(guild_information, "`$" + pInfo(currentPeer)->tankIDName + "`` `wwas invited by`` `$" + pInfo(p_)->tankIDName + "``", 6);
									return;
								}
							}
							break;
						}
					}
				}
				{
					gamepacket_t p;
					p.Insert("OnTalkBubble");
					p.Insert(pInfo(p_)->netID);
					p.Insert("Hmm, that person left.");
					p.Insert(0), p.Insert(0);
					p.CreatePacket(p_);
				}
			}
			else if (a_.size() == 14 and a_[11] == "friend_add" and isdigit(a_[5][0]) and isdigit(a_[8][0])) {
				int my_netid_ = atoi(a_[5].c_str()), other_netid_ = atoi(a_[8].c_str());
				string name_ = pInfo(p_)->world;
				vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
				if (p != worlds.end()) {
					World* world_ = &worlds[p - worlds.begin()];
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
						if (pInfo(currentPeer)->world == pInfo(p_)->world and pInfo(currentPeer)->netID == other_netid_) {
							if (find(pInfo(currentPeer)->pending_friends.begin(), pInfo(currentPeer)->pending_friends.end(), pInfo(p_)->tankIDName) != pInfo(currentPeer)->pending_friends.end()) {
								packet_(p_, "action|play_sfx\nfile|audio/love_in.wav\ndelayMS|0");
								long long time_t = time(NULL);
								Friends new_friend_;
								new_friend_.name = pInfo(currentPeer)->tankIDName;
								new_friend_.mute = false;
								new_friend_.block_trade = false;
								new_friend_.last_seen = time_t;
								pInfo(p_)->friends.push_back(new_friend_);
								gamepacket_t p;
								p.Insert("OnConsoleMessage");
								p.Insert("`3FRIEND ADDED:`` You're now friends with " + pInfo(currentPeer)->name_color + pInfo(currentPeer)->tankIDName + "``!");
								p.CreatePacket(p_);
								{
									packet_(currentPeer, "action|play_sfx\nfile|audio/love_in.wav\ndelayMS|0");
									Friends new_friend_;
									new_friend_.name = pInfo(p_)->tankIDName;
									new_friend_.mute = false;
									new_friend_.block_trade = false;
									new_friend_.last_seen = time_t;
									pInfo(currentPeer)->friends.push_back(new_friend_);
									gamepacket_t p;
									p.Insert("OnConsoleMessage");
									p.Insert("`3FRIEND ADDED:`` You're now friends with " + pInfo(p_)->name_color + pInfo(p_)->tankIDName + "``!");
									p.CreatePacket(currentPeer);
									if (pInfo(p_)->friends.size() == 10 || pInfo(p_)->friends.size() == 20 || pInfo(p_)->friends.size() == 30 || pInfo(p_)->friends.size() == 40 || pInfo(p_)->friends.size() == 50) form_emoji(p_);
									if (pInfo(currentPeer)->friends.size() == 10 || pInfo(p_)->friends.size() == 20 || pInfo(p_)->friends.size() == 30 || pInfo(p_)->friends.size() == 40 || pInfo(p_)->friends.size() == 50) form_emoji(currentPeer);
								}
								pInfo(currentPeer)->pending_friends.erase(remove(pInfo(currentPeer)->pending_friends.begin(), pInfo(currentPeer)->pending_friends.end(), pInfo(p_)->tankIDName), pInfo(currentPeer)->pending_friends.end());
							}
							else {
								for (int c_ = 0; c_ < pInfo(p_)->friends.size(); c_++) {
									if (pInfo(p_)->friends[c_].name == pInfo(currentPeer)->tankIDName) {
										gamepacket_t p;
										p.Insert("OnTalkBubble");
										p.Insert(pInfo(p_)->netID);
										p.Insert("That's already my friend!");
										p.Insert(0), p.Insert(0);
										return;
									}
								}
								if (abs((pInfo(currentPeer)->x / 32) - (pInfo(p_)->x / 32)) >= 3) {
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(p_)->netID);
									p.Insert("`5[```4Too far away`` `0- Stand closer to`` " + pInfo(currentPeer)->name_color + pInfo(currentPeer)->tankIDName + "```0 first!```5]``");
									p.Insert(0), p.Insert(0);
									p.CreatePacket(p_);
									return;
								}
								pInfo(p_)->pending_friends.push_back(pInfo(currentPeer)->tankIDName);
								gamepacket_t p;
								p.Insert("OnTalkBubble");
								p.Insert(pInfo(p_)->netID);
								p.Insert("`5[``Friend request sent to " + pInfo(currentPeer)->name_color + pInfo(currentPeer)->tankIDName + "```5]``");
								p.Insert(0), p.Insert(0);
								p.CreatePacket(p_);
								{
									packet_(currentPeer, "action|play_sfx\nfile|audio/tip_start.wav\ndelayMS|0");
									gamepacket_t p;
									p.Insert("OnConsoleMessage");
									p.Insert("`3FRIEND REQUEST:`` You've received a `wfriend request`` from " + pInfo(p_)->name_color + pInfo(p_)->tankIDName + "``! To accept, press the `wwrench by his/her name`` and then choose `wAdd as friend``.");
									p.CreatePacket(currentPeer);
								}
							}
							return;
						}
					}
					gamepacket_t p;
					p.Insert("OnTalkBubble");
					p.Insert(pInfo(p_)->netID);
					p.Insert("Hmm, that person left.");
					p.Insert(0), p.Insert(0);
					p.CreatePacket(p_);
				}
			}

		
			else if (a_.size() == 8 and a_[5] == "acceptguild") {
				if (pInfo(p_)->pending_guild == 0 or pInfo(p_)->guild_id != 0) break;
				string name_ = pInfo(p_)->world;
				vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
				if (p != worlds.end()) {
					World* world_ = &worlds[p - worlds.begin()];
					uint32_t guild_id = pInfo(p_)->pending_guild;
					vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
					if (p != guilds.end()) {
						Guild* guild_information = &guilds[p - guilds.begin()];
						if (guild_information->guild_members.size() >= guild_information->guild_level * 5) {
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(p_)->netID);
							p.Insert("Guild is at maximum capacity of " + to_string(guild_information->guild_level * 5) + " peoples!");
							p.Insert(0), p.Insert(0);
							p.CreatePacket(p_);
							{
								gamepacket_t p;
								p.Insert("OnConsoleMessage");
								p.Insert("Guild is at maximum capacity of " + to_string(guild_information->guild_level * 5) + " peoples!");
								p.CreatePacket(p_);
							}
							break;
						}
						GuildMember new_member{};
						new_member.member_name = pInfo(p_)->tankIDName;
						new_member.role_id = 0;
						new_member.last_online = time(NULL);
						guild_information->guild_members.push_back(new_member);
						pInfo(p_)->pending_guild = 0;
						pInfo(p_)->guild_id = guild_information->guild_id;
						{
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(p_)->netID);
							p.Insert("You Succesfully joined " + guild_information->guild_name);
							p.Insert(0), p.Insert(0);
							p.CreatePacket(p_);
						}

						uint32_t guild_id = pInfo(p_)->guild_id;
						vector<Guild>::iterator find_guild = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
						if (find_guild != guilds.end()) {
							Guild* guild_information = &guilds[find_guild - guilds.begin()];
							const auto flag1 = (65536 * guild_information->guild_mascot[1] + guild_information->guild_mascot[0]);
							gamepacket_t p(0, pInfo(p_)->netID);
							p.Insert("OnGuildDataChanged");
							p.Insert(50478);
							p.Insert(79289404);
							p.Insert(flag1);
							p.Insert(0);
							p.Insert(0);
							/*
							gamepacket_t p2(0, pInfo(p_)->netID);
							p2.Insert("OnCountryState");
							p2.Insert(pInfo(p_)->country + "|showGuild");*/
							gamepacket_t p_2;
							p_2.Insert("OnConsoleMessage");
							p_2.Insert("`5[GUILD ALERT]`` " + pInfo(p_)->name_color + pInfo(p_)->tankIDName + "`` joined the guild!");
							if (pInfo(p_)->world == guild_information->guild_world and guild_access(p_, guild_id)) {
								int ySize = (int)world_->blocks.size() / 100, xSize = (int)world_->blocks.size() / ySize;
								for (int i_ = 0; i_ < world_->blocks.size(); i_++) {
									if (items[world_->blocks[i_].fg].blockType == BlockTypes::LOCK) {
										uint16_t id_ = world_->blocks[i_].fg;
										if (id_ == 5814) {
											int x_ = i_ % xSize;
											int y_ = i_ / xSize;
											WorldBlock* block_ = &world_->blocks[x_ + (y_ * 100)];
											PlayerMoving data_2{};
											data_2.packetType = 5, data_2.punchX = x_, data_2.punchY = y_, data_2.characterState = 0x8;
											BYTE* raw2 = packPlayerMoving(&data_2, 112 + alloc_(world_, block_));
											BYTE* blc = raw2 + 56;
											form_visual(blc, *block_, *world_, p_, false);
											gamepacket_t p22(0, pInfo(p_)->netID);
											{
												p22.Insert("OnNameChanged");
												if (pInfo(p_)->mod == 0 && pInfo(p_)->dev == 0) pInfo(p_)->name_color = "`^";
												p22.Insert((not pInfo(p_)->d_name.empty() ? pInfo(p_)->d_name : pInfo(p_)->name_color + pInfo(p_)->tankIDName) + (pInfo(p_)->is_legend ? " of Legend" : "") + "``");
											} for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
												if (pInfo(currentPeer)->world == pInfo(p_)->world) {
													p.CreatePacket(currentPeer);
													//p2.CreatePacket(currentPeer);
													p22.CreatePacket(currentPeer);
													send_raw(currentPeer, 4, raw2, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
												}
												if (pInfo(currentPeer)->guild_id == pInfo(p_)->guild_id) {
													p_2.CreatePacket(currentPeer);
												}
											}
											delete[] raw2, blc;
											break;
										}
									}
								}
							}

							else {
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
									if (pInfo(currentPeer)->world == pInfo(p_)->world) {
										p.CreatePacket(currentPeer);
										//p2.CreatePacket(currentPeer);
									}
									if (pInfo(currentPeer)->guild_id == pInfo(p_)->guild_id) {
										p_2.CreatePacket(currentPeer);
									}
								}
							}
							create_guild_log(guild_information, "`$" + pInfo(p_)->tankIDName + "`` `wjoined the guild", 5948);
						}
					}
				}
			}
			else if (a_.size() == 8 and a_[5] == "acceptlock") {
				if (pInfo(p_)->ac_.size() == 0) break;
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
					if (pInfo(currentPeer)->world == pInfo(p_)->world) {
						if (pInfo(p_)->ac_.find(pInfo(currentPeer)->netID) != pInfo(p_)->ac_.end()) {
							string name_ = pInfo(p_)->world;
							vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
							if (p != worlds.end()) {
								World* world_ = &worlds[p - worlds.begin()];
								string owner_name = world_->owner_name, user_name = pInfo(currentPeer)->tankIDName;
								if (owner_name != user_name and not pInfo(p_)->dev) break;
								int ySize = (int)world_->blocks.size() / 100, xSize = (int)world_->blocks.size() / ySize;
								int x_ = (pInfo(p_)->ac_[pInfo(currentPeer)->netID]) % xSize, y_ = (pInfo(p_)->ac_[pInfo(currentPeer)->netID]) / xSize;
								if (x_ < 0 or x_ >= 100 or y_ < 0 or y_ >= 60) break;
								WorldBlock* block_ = &world_->blocks[x_ + (y_ * 100)];
								if (block_->fg == 202 or block_->fg == 204 or block_->fg == 206 or block_->fg == 4994) {
									if (block_->owner_name != user_name) break;
								}
								else {
									if (owner_name != user_name) break;
								}
								gamepacket_t p;
								p.Insert("OnDialogRequest");
								p.Insert("set_default_color|`o\nadd_label_with_icon|small|Accept Access To World|left|242|\nadd_smalltext|When you have access to a world, you are responsible for anything the world's owners or other admins do.|left|\nadd_smalltext|Don't accept access to a world unless it is from people you trust.|left|\nadd_smalltext|You can remove your access later by either wrenching the lock, or typing `2/unaccess`` to remove yourself from all locks in the world.|left|\nadd_spacer|small|\nadd_textbox|Are you sure you want to be added to this " + items[block_->fg].name + "?|left|\nend_dialog|acceptaccess|No|Yes|");
								p.CreatePacket(p_);
							}
							break;
						}
					}
				}
			}
			break;
		}
		else if (a_[i_] == "lock_edit" or a_[i_] == "editguildlock") {
			string name_ = pInfo(p_)->world;
			vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
			if (p != worlds.end()) {
				World* world_ = &worlds[p - worlds.begin()];
				/*if (a_.size() != 23 and a_.size() != 25 and a_.size() != 26 and a_.size() != 11) break;
				if (not isdigit(a_[i_+2][0]) and a_.size() != 11 or not isdigit(a_[i_+5][0]) and a_.size() != 11) break;*/
				int x_ = 0, y_ = 0;

				try {
					x_ = atoi(a_.at(i_ + 2).c_str()), y_ = atoi(a_.at(i_ + 5).c_str());
				}
				catch (out_of_range) {
					return;
				}
				if (x_ < 0 or x_ >= 100 or y_ < 0 or y_ >= 60) break;
				if (p != worlds.end()) {
					WorldBlock* block_ = &world_->blocks[x_ + (y_ * 100)];
					uint16_t t_ = (block_->fg ? block_->fg : block_->bg);
					if (items[t_].blockType != BlockTypes::LOCK) break;
					string owner_name = world_->owner_name, user_name = pInfo(p_)->tankIDName;
					if (a_.size() == 11) { // remove my access
						if (block_->fg == 202 or block_->fg == 204 or block_->fg == 206 or block_->fg == 4994) {
							if (find(block_->admins.begin(), block_->admins.end(), user_name) != block_->admins.end()) {
								block_->admins.erase(remove(block_->admins.begin(), block_->admins.end(), user_name), block_->admins.end());
								packet_(p_, "action|play_sfx\nfile|audio/dialog_cancel.wav\ndelayMS|0");
								gamepacket_t p;
								p.Insert("OnConsoleMessage");
								p.Insert(user_name + " removed their access from a " + items[t_].name);
								PlayerMoving data_{};
								data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
								BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
								BYTE* blc = raw + 56;
								form_visual(blc, *block_, *world_, p_, false);
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
									if (pInfo(currentPeer)->world == world_->name) {
										p.CreatePacket(currentPeer);
										send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
									} if (pInfo(currentPeer)->world == world_->name and pInfo(currentPeer)->tankIDName == user_name) {
										gamepacket_t p;
										p.Insert("OnTalkBubble");
										p.Insert(pInfo(p_)->netID);
										p.Insert("I've removed my access!");
										p.Insert(0), p.Insert(0);
										p.CreatePacket(currentPeer);
									}
								}
								delete[] raw, blc;
								if (block_->locked) {
									upd_lock(*block_, *world_, p_);
								}
							}
						}
						else if (find(world_->admins.begin(), world_->admins.end(), user_name) != world_->admins.end()) {
							world_->admins.erase(remove(world_->admins.begin(), world_->admins.end(), user_name), world_->admins.end());
							packet_(p_, "action|play_sfx\nfile|audio/dialog_cancel.wav\ndelayMS|0");
							gamepacket_t p;
							p.Insert("OnConsoleMessage");
							p.Insert(user_name + " removed their access from a " + items[t_].name);
							gamepacket_t p2(0, pInfo(p_)->netID);
							{
								p2.Insert("OnNameChanged");
								if (pInfo(p_)->mod == 0 && pInfo(p_)->dev == 0) pInfo(p_)->name_color = "`0";
								p2.Insert((not pInfo(p_)->d_name.empty() ? pInfo(p_)->d_name : pInfo(p_)->name_color + pInfo(p_)->tankIDName) + (pInfo(p_)->is_legend ? " of Legend" : "") + "``");
							}
							PlayerMoving data_{};
							data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
							BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
							BYTE* blc = raw + 56;
							form_visual(blc, *block_, *world_, p_, false);
							for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
								if (pInfo(currentPeer)->world == world_->name) {
									p.CreatePacket(currentPeer), p2.CreatePacket(currentPeer);
									send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
								} if (pInfo(currentPeer)->world == world_->name and pInfo(currentPeer)->tankIDName == user_name) {
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(p_)->netID);
									p.Insert("I've removed my access!");
									p.Insert(0), p.Insert(0);
									p.CreatePacket(currentPeer);
								}
							}
							delete[] raw, blc;
							if (block_->locked) {
								upd_lock(*block_, *world_, p_);
							}
						}
						break;
					}
					if (block_->fg == 202 or block_->fg == 204 or block_->fg == 206 or block_->fg == 4994) {
						if (block_->owner_name != user_name and not pInfo(p_)->dev) break;
					}
					else {
						if (owner_name != user_name and not pInfo(p_)->dev) break;
					}
					bool reapply = false;
					for (int b_ = 0; b_ < a_.size(); b_++) {
						bool upd_ = false;
						if (a_[b_] == "getKey") {
							if (pInfo(p_)->tankIDName != world_->owner_name) break;
							if (block_->fg == 202 or block_->fg == 204 or block_->fg == 206 or block_->fg == 4994) break;
							int key_ = 1424;
							if (block_->fg == 5814) {
								key_ = 5816;
								gamepacket_t p;
								p.Insert("OnDialogRequest");
								p.Insert("add_label_with_icon|big|`wGet " + items[key_].name + " ``|left|" + to_string(key_) + "|\nadd_spacer|small|\nadd_textbox|The key to this lock can be used to transfer leadership of the guild to another guild Member.|left|\nadd_textbox|Use it like a `5World Lock Key``, but you can only give it to another Member of your guild!|left|\nadd_spacer|small|\nadd_textbox|`4Warning!`` By giving the `5Guild Key`` to another Member, you are effectively `rpromoting`` them to Guild Leader and `4demoting`` yourself at the same time!|left|\nadd_textbox|Are you sure you want to take the `5" + items[key_].name + "`` from the " + items[block_->fg].name + "?|left|\nend_dialog|confirmguildlockkey|Cancel|OK|\nadd_quick_exit|");
								p.CreatePacket(p_);
								return;
							}
							int c_ = 0;
							if (pInfo(p_)->tankIDName == world_->owner_name) modify_inventory(p_, 1424, c_);
							if (c_ != 0) break;
							for (int i_ = 0; i_ < world_->drop.size(); i_++) {
								if (world_->drop[i_].x == -1 or world_->drop[i_].id == 0) continue;
								WorldBlock* block_ = &world_->blocks[(world_->drop[i_].x / 32) + ((world_->drop[i_].y / 32) * 100)];
								if (items[block_->fg].collisionType != 1) {
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(p_)->netID);
									p.Insert("`4Oops!... Can't trade a world with floating items that are unblocked or in treasure chests!``");
									p.Insert(0), p.Insert(0);
									p.CreatePacket(p_);
									return;
								}
							}
							for (int i_ = 0; i_ < world_->blocks.size(); i_++) {
								if (world_->blocks[i_].fg == 4516) {
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(p_)->netID);
									p.Insert("`4To trade a world, you will need to remove Untrade-a-Box!``");
									p.Insert(0), p.Insert(0);
									p.CreatePacket(p_);
									return;
								}
							}
							for (int i_ = 0; i_ < world_->blocks.size(); i_++) {
								if (items[world_->blocks[i_].fg].blockType == BlockTypes::LOCK) {
									uint16_t id_ = world_->blocks[i_].fg;
									if (id_ == 202 or id_ == 204 or id_ == 206 or id_ == 4994) {
										gamepacket_t p;
										p.Insert("OnTalkBubble");
										p.Insert(pInfo(p_)->netID);
										p.Insert("To trade a world, you can only have one lock on it, the `5World Lock``.  Remove the rest!");
										p.Insert(0), p.Insert(0);
										p.CreatePacket(p_);
										return;
									}
								}
							}
							if (world_->admins.size() != 0) {
								gamepacket_t p;
								p.Insert("OnTalkBubble");
								p.Insert(pInfo(p_)->netID);
								p.Insert("You'll first need to remove all players with access to your " + items[block_->fg].name + " to get a " + items[key_].name + ".");
								p.Insert(0), p.Insert(1);
								p.CreatePacket(p_);
								return;
							}
							c_ = 1;
							if (modify_inventory(p_, key_, c_) == 0) {
								packet_(p_, "action|play_sfx\nfile|audio/use_lock.wav\ndelayMS|0");
								gamepacket_t p;
								p.Insert("OnTalkBubble");
								p.Insert(pInfo(p_)->netID);
								p.Insert("You got a `#" + items[key_].name + "``! You can now trade this world to other players.");
								p.Insert(0), p.Insert(0);
								p.CreatePacket(p_);
							}

						}
						else if (a_[b_] == "minimum_entry_level" and isdigit(a_[b_ + 1][0])) {
							if (block_->fg == 202 or block_->fg == 204 or block_->fg == 206 or block_->fg == 4994) break;
							int new_entry_level_ = atoi(a_[b_ + 1].c_str());
							if (world_->entry_level != new_entry_level_) {
								gamepacket_t p;
								p.Insert("OnTalkBubble");
								p.Insert(pInfo(p_)->netID);
								if (new_entry_level_ < 1) {
									p.Insert("Minimum entry level can't be lower than 1.");
									p.CreatePacket(p_);
									continue;
								}
								if (new_entry_level_ > 124) {
									p.Insert("Minimum entry level can't be higher than 124.");
									p.CreatePacket(p_);
									continue;
								}
								world_->entry_level = new_entry_level_;
								p.Insert("Minimum entry level for this world is set to `2Level " + to_string(new_entry_level_) + "``.");
								p.CreatePacket(p_);
							}
						}
						else if (a_[b_] == "tempo" and isdigit(a_[b_ + 1][0])) {
							if (block_->fg == 202 or block_->fg == 204 or block_->fg == 206 or block_->fg == 4994) break;
							uint32_t new_bpm_ = atoi(a_[b_ + 1].c_str());
							if (world_->music_bpm != new_bpm_) {
								if (new_bpm_ < 20 or new_bpm_ > 200) {
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(p_)->netID);
									p.Insert("Tempo must be from 20-200 BPM.");
									p.Insert(0);
									p.Insert(0);
									p.CreatePacket(p_);
									continue;
								}
								world_->music_bpm = new_bpm_, upd_ = true;
							}
						}
						//recalcLock
						else if (a_[b_] == "recalcLock") {
							if (block_->fg == 202 or block_->fg == 204 or block_->fg == 206 or block_->fg == 4994) {
								reapply = true;
							}
							//break;
						}
						else if (a_[b_] == "abondonguildconfirm") {
							if (block_->fg == 5814) {
								uint32_t guild_id = world_->guild_id;
								vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
								if (p != guilds.end()) {
									Guild* guild_information = &guilds[p - guilds.begin()];
									if (guild_information->guild_members.size() != 1) {
										gamepacket_t p;
										p.Insert("OnDialogRequest");
										p.Insert("add_label_with_icon|big|`wAbandon Guild ``|left|5814|\nadd_textbox|`1You need to kick all guild members before you can abandon the guild! `` |left|\nadd_button|back|Back|noflags|0|0|\nend_dialog|abondonguild|||");
										p.CreatePacket(p_);
										break;
									}
									gamepacket_t p;
									p.Insert("OnDialogRequest");
									p.Insert("add_label_with_icon|big|`wAbandon Guild ``|left|5814|\nadd_spacer|small|\nadd_item_picker|selectworldlock|`wSelect a World Lock``|Choose a World Lock to replace the Guild Lock|\nadd_button|back|Back|noflags|0|0|\nend_dialog|abondonguild|||");
									p.CreatePacket(p_);
								}
								break;
							}
						}
						else if (a_[b_] == "changecat") {
						gamepacket_t p;
						p.Insert("OnDialogRequest");
						p.Insert("add_label_with_icon|big|`wSet World Category``|left|3802|\nadd_spacer|small|\nadd_textbox|Select a category for your world.|left|\nadd_button|cat0|None|noflags|0|0|\nadd_button|cat1|Adventure|noflags|0|0|\nadd_button|cat2|Art|noflags|0|0|\nadd_button|cat3|Farm|noflags|0|0|\nadd_button|cat4|Game|noflags|0|0|\nadd_button|cat5|Information|noflags|0|0|\nadd_button|cat15|Music|noflags|0|0|\nadd_button|cat6|Parkour|noflags|0|0|\nadd_button|cat14|Puzzle|noflags|0|0|\nadd_button|cat7|Roleplay|noflags|0|0|\nadd_button|cat8|Shop|noflags|0|0|\nadd_button|cat9|Social|noflags|0|0|\nadd_button|cat10|Storage|noflags|0|0|\nadd_button|cat11|Story|noflags|0|0|\nadd_button|cat12|Trade|noflags|0|0|\nadd_smalltext|Worlds in the category 'None' can't be rated by players, and they are only listed on the normal World Select screen.|left|\nadd_smalltext|`4Warning:`` Changing your category will delete all ratings on your world.|left|\nend_dialog|worldcategory|Nevermind||");
						p.CreatePacket(p_);
						}
						else if (a_[b_] == "create_guild_mascot") {
						gamepacket_t p;
						p.Insert("OnDialogRequest");
						p.Insert("add_label|big|`wChange Guild Mascot``|left|\nadd_spacer|small|\nadd_textbox|Create a unique Guild Mascot for your guild! Only `950,000 Gems! ``Choose items from your inventory to use as your Guild Mascot.|left|\nadd_spacer|small|\nadd_item_picker|select_bg_mascot|`wChoose Foreground Item``|Choose a Foreground for Guild Mascot|\nadd_item_picker|select_fg_mascot|`wChoose Background Item``|Choose a Background for Guild Mascot|\nadd_spacer|small|\nend_dialog|make_mascotss|Cancel||");
						p.CreatePacket(p_);
			            }

						else if (a_[b_] == "upg2") {
						if (block_->fg == 5814) {
							uint32_t guild_id = world_->guild_id;
							vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
							if (p != guilds.end()) {
								Guild* guild_information = &guilds[p - guilds.begin()];
								if (pInfo(p_)->gems >= 200000) {
									pInfo(p_)->gems -= 200000;
									gamepacket_t pg;
									pg.Insert("OnSetBux"), pg.Insert(pInfo(p_)->gems), pg.Insert(0), pg.Insert((pInfo(p_)->supp >= 1) ? 1 : 0);
									if (pInfo(p_)->supp >= 2) pg.Insert((float)33796, (float)1, (float)0);
									pg.CreatePacket(p_);
									guild_information->guild_level += 1;
									guild_information->guild_xp = 0;
									gamepacket_t p0;
									p0.Insert("OnAddNotification");
									p0.Insert("interface/large/gd_lup.rttex");
									p0.Insert("Awesome! You reached Guild Level 2!");
									p0.Insert("audio/hub_open.wav");
									p0.Insert(0);
									p0.CreatePacket(p_);
									//cout << "called upgradeguild function [LVL 2]" << endl;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(p_)->netID);
									p.Insert("You don't have enough gems!");
									p.Insert(0);
									p.Insert(1);
									p.CreatePacket(p_);
									break;
								}
							}
							break;
						    }
						}
						else if (a_[b_] == "upg3") {
						if (block_->fg == 5814) {
							uint32_t guild_id = world_->guild_id;
							vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
							if (p != guilds.end()) {
								Guild* guild_information = &guilds[p - guilds.begin()];
								if (pInfo(p_)->gems >= 300000) {
									pInfo(p_)->gems -= 300000;
									gamepacket_t pg;
									pg.Insert("OnSetBux"), pg.Insert(pInfo(p_)->gems), pg.Insert(0), pg.Insert((pInfo(p_)->supp >= 1) ? 1 : 0);
									if (pInfo(p_)->supp >= 2) pg.Insert((float)33796, (float)1, (float)0);
									pg.CreatePacket(p_);
									guild_information->guild_level += 1;
									guild_information->guild_xp = 0;
									gamepacket_t p0;
									p0.Insert("OnAddNotification");
									p0.Insert("interface/large/gd_lup.rttex");
									p0.Insert("Awesome! You reached Guild Level 3!");
									p0.Insert("audio/hub_open.wav");
									p0.Insert(0);
									p0.CreatePacket(p_);
									//cout << "called upgradeguild function [LVL 2]" << endl;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(p_)->netID);
									p.Insert("You don't have enough gems!");
									p.Insert(0);
									p.Insert(1);
									p.CreatePacket(p_);
									break;
								}
							}
							break;
						}
						}
						else if (a_[b_] == "upg4") {
						if (block_->fg == 5814) {
							uint32_t guild_id = world_->guild_id;
							vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
							if (p != guilds.end()) {
								Guild* guild_information = &guilds[p - guilds.begin()];
								if (pInfo(p_)->gems >= 400000) {
									pInfo(p_)->gems -= 400000;
									gamepacket_t pg;
									pg.Insert("OnSetBux"), pg.Insert(pInfo(p_)->gems), pg.Insert(0), pg.Insert((pInfo(p_)->supp >= 1) ? 1 : 0);
									if (pInfo(p_)->supp >= 2) pg.Insert((float)33796, (float)1, (float)0);
									pg.CreatePacket(p_);
									guild_information->guild_level += 1;
									guild_information->guild_xp = 0;
									gamepacket_t p0;
									p0.Insert("OnAddNotification");
									p0.Insert("interface/large/gd_lup.rttex");
									p0.Insert("Awesome! You reached Guild Level 4!");
									p0.Insert("audio/hub_open.wav");
									p0.Insert(0);
									p0.CreatePacket(p_);
									//cout << "called upgradeguild function [LVL 2]" << endl;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(p_)->netID);
									p.Insert("You don't have enough gems!");
									p.Insert(0);
									p.Insert(1);
									p.CreatePacket(p_);
									break;
								}
							}
							break;
						}
						}
						else if (a_[b_] == "upg5") {
						if (block_->fg == 5814) {
							uint32_t guild_id = world_->guild_id;
							vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
							if (p != guilds.end()) {
								Guild* guild_information = &guilds[p - guilds.begin()];
								if (pInfo(p_)->gems >= 500000) {
									pInfo(p_)->gems -= 500000;
									gamepacket_t pg;
									pg.Insert("OnSetBux"), pg.Insert(pInfo(p_)->gems), pg.Insert(0), pg.Insert((pInfo(p_)->supp >= 1) ? 1 : 0);
									if (pInfo(p_)->supp >= 2) pg.Insert((float)33796, (float)1, (float)0);
									pg.CreatePacket(p_);
									guild_information->guild_level += 1;
									guild_information->guild_xp = 0;
									gamepacket_t p0;
									p0.Insert("OnAddNotification");
									p0.Insert("interface/large/gd_lup.rttex");
									p0.Insert("Awesome! You reached Guild Level 5!");
									p0.Insert("audio/hub_open.wav");
									p0.Insert(0);
									p0.CreatePacket(p_);
									//cout << "called upgradeguild function [LVL 2]" << endl;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(p_)->netID);
									p.Insert("You don't have enough gems!");
									p.Insert(0);
									p.Insert(1);
									p.CreatePacket(p_);
									break;
								}
							}
							break;
						}
						}
						else if (a_[b_] == "upg6") {
						if (block_->fg == 5814) {
							uint32_t guild_id = world_->guild_id;
							vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
							if (p != guilds.end()) {
								Guild* guild_information = &guilds[p - guilds.begin()];
								if (pInfo(p_)->gems >= 1000000) {
									pInfo(p_)->gems -= 1000000;
									gamepacket_t pg;
									pg.Insert("OnSetBux"), pg.Insert(pInfo(p_)->gems), pg.Insert(0), pg.Insert((pInfo(p_)->supp >= 1) ? 1 : 0);
									if (pInfo(p_)->supp >= 2) pg.Insert((float)33796, (float)1, (float)0);
									pg.CreatePacket(p_);
									guild_information->guild_level += 1;
									guild_information->guild_xp = 0;
									gamepacket_t p0;
									p0.Insert("OnAddNotification");
									p0.Insert("interface/large/gd_lup.rttex");
									p0.Insert("Awesome! You reached Guild Level 6!");
									p0.Insert("audio/hub_open.wav");
									p0.Insert(0);
									p0.CreatePacket(p_);
									//cout << "called upgradeguild function [LVL 2]" << endl;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(p_)->netID);
									p.Insert("You don't have enough gems!");
									p.Insert(0);
									p.Insert(1);
									p.CreatePacket(p_);
									break;
								}
							}
							break;
						}
						}
						else if (a_[b_] == "upg7") {
						if (block_->fg == 5814) {
							uint32_t guild_id = world_->guild_id;
							vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
							if (p != guilds.end()) {
								Guild* guild_information = &guilds[p - guilds.begin()];
								if (pInfo(p_)->gems >= 2000000) {
									pInfo(p_)->gems -= 2000000;
									gamepacket_t pg;
									pg.Insert("OnSetBux"), pg.Insert(pInfo(p_)->gems), pg.Insert(0), pg.Insert((pInfo(p_)->supp >= 1) ? 1 : 0);
									if (pInfo(p_)->supp >= 2) pg.Insert((float)33796, (float)1, (float)0);
									pg.CreatePacket(p_);
									guild_information->guild_level += 1;
									guild_information->guild_xp = 0;
									gamepacket_t p0;
									p0.Insert("OnAddNotification");
									p0.Insert("interface/large/gd_lup.rttex");
									p0.Insert("Awesome! You reached Guild Level 7!");
									p0.Insert("audio/hub_open.wav");
									p0.Insert(0);
									p0.CreatePacket(p_);
									//cout << "called upgradeguild function [LVL 2]" << endl;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(p_)->netID);
									p.Insert("You don't have enough gems!");
									p.Insert(0);
									p.Insert(1);
									p.CreatePacket(p_);
									break;
								}
							}
							break;
						}
						}
						else if (a_[b_] == "upg8") {
						if (block_->fg == 5814) {
							uint32_t guild_id = world_->guild_id;
							vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
							if (p != guilds.end()) {
								Guild* guild_information = &guilds[p - guilds.begin()];
								if (pInfo(p_)->gems >= 3000000) {
									pInfo(p_)->gems -= 3000000;
									gamepacket_t pg;
									pg.Insert("OnSetBux"), pg.Insert(pInfo(p_)->gems), pg.Insert(0), pg.Insert((pInfo(p_)->supp >= 1) ? 1 : 0);
									if (pInfo(p_)->supp >= 2) pg.Insert((float)33796, (float)1, (float)0);
									pg.CreatePacket(p_);
									guild_information->guild_level += 1;
									guild_information->guild_xp = 0;
									gamepacket_t p0;
									p0.Insert("OnAddNotification");
									p0.Insert("interface/large/gd_lup.rttex");
									p0.Insert("Awesome! You reached Guild Level 8!");
									p0.Insert("audio/hub_open.wav");
									p0.Insert(0);
									p0.CreatePacket(p_);
									//cout << "called upgradeguild function [LVL 2]" << endl;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(p_)->netID);
									p.Insert("You don't have enough gems!");
									p.Insert(0);
									p.Insert(1);
									p.CreatePacket(p_);
									break;
								}
							}
							break;
						}
						}
						else if (a_[b_] == "upg9") {
						if (block_->fg == 5814) {
							uint32_t guild_id = world_->guild_id;
							vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
							if (p != guilds.end()) {
								Guild* guild_information = &guilds[p - guilds.begin()];
								if (pInfo(p_)->gems >= 4000000) {
									pInfo(p_)->gems -= 4000000;
									gamepacket_t pg;
									pg.Insert("OnSetBux"), pg.Insert(pInfo(p_)->gems), pg.Insert(0), pg.Insert((pInfo(p_)->supp >= 1) ? 1 : 0);
									if (pInfo(p_)->supp >= 2) pg.Insert((float)33796, (float)1, (float)0);
									pg.CreatePacket(p_);
									guild_information->guild_level += 1;
									guild_information->guild_xp = 0;
									gamepacket_t p0;
									p0.Insert("OnAddNotification");
									p0.Insert("interface/large/gd_lup.rttex");
									p0.Insert("Awesome! You reached Guild Level 9!");
									p0.Insert("audio/hub_open.wav");
									p0.Insert(0);
									p0.CreatePacket(p_);
									//cout << "called upgradeguild function [LVL 2]" << endl;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(p_)->netID);
									p.Insert("You don't have enough gems!");
									p.Insert(0);
									p.Insert(1);
									p.CreatePacket(p_);
									break;
								}
							}
							break;
						}
						}
						else if (a_[b_] == "upg10") {
						if (block_->fg == 5814) {
							uint32_t guild_id = world_->guild_id;
							vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
							if (p != guilds.end()) {
								Guild* guild_information = &guilds[p - guilds.begin()];
								if (pInfo(p_)->gems >= 5000000) {
									pInfo(p_)->gems -= 5000000;
									gamepacket_t pg;
									pg.Insert("OnSetBux"), pg.Insert(pInfo(p_)->gems), pg.Insert(0), pg.Insert((pInfo(p_)->supp >= 1) ? 1 : 0);
									if (pInfo(p_)->supp >= 2) pg.Insert((float)33796, (float)1, (float)0);
									pg.CreatePacket(p_);
									guild_information->guild_level += 1;
									guild_information->guild_xp = 0;
									gamepacket_t p0;
									p0.Insert("OnAddNotification");
									p0.Insert("interface/large/gd_lup.rttex");
									p0.Insert("Awesome! You reached Guild Level 10!");
									p0.Insert("audio/hub_open.wav");
									p0.Insert(0);
									p0.CreatePacket(p_);
									//cout << "called upgradeguild function [LVL 2]" << endl;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(p_)->netID);
									p.Insert("You don't have enough gems!");
									p.Insert(0);
									p.Insert(1);
									p.CreatePacket(p_);
									break;
								}
							}
							break;
						}
						}
						else if (a_[b_] == "upg11") {
						if (block_->fg == 5814) {
							uint32_t guild_id = world_->guild_id;
							vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
							if (p != guilds.end()) {
								Guild* guild_information = &guilds[p - guilds.begin()];
								if (pInfo(p_)->gems >= 6000000) {
									pInfo(p_)->gems -= 6000000;
									gamepacket_t pg;
									pg.Insert("OnSetBux"), pg.Insert(pInfo(p_)->gems), pg.Insert(0), pg.Insert((pInfo(p_)->supp >= 1) ? 1 : 0);
									if (pInfo(p_)->supp >= 2) pg.Insert((float)33796, (float)1, (float)0);
									pg.CreatePacket(p_);
									guild_information->guild_level += 1;
									guild_information->guild_xp = 0;
									gamepacket_t p0;
									p0.Insert("OnAddNotification");
									p0.Insert("interface/large/gd_lup.rttex");
									p0.Insert("Awesome! You reached Guild Level 11!");
									p0.Insert("audio/hub_open.wav");
									p0.Insert(0);
									p0.CreatePacket(p_);
									//cout << "called upgradeguild function [LVL 2]" << endl;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(p_)->netID);
									p.Insert("You don't have enough gems!");
									p.Insert(0);
									p.Insert(1);
									p.CreatePacket(p_);
									break;
								}
							}
							break;
						}
						}
						else if (a_[b_] == "upg12") {
						if (block_->fg == 5814) {
							uint32_t guild_id = world_->guild_id;
							vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
							if (p != guilds.end()) {
								Guild* guild_information = &guilds[p - guilds.begin()];
								if (pInfo(p_)->gems >= 8000000) {
									pInfo(p_)->gems -= 8000000;
									gamepacket_t pg;
									pg.Insert("OnSetBux"), pg.Insert(pInfo(p_)->gems), pg.Insert(0), pg.Insert((pInfo(p_)->supp >= 1) ? 1 : 0);
									if (pInfo(p_)->supp >= 2) pg.Insert((float)33796, (float)1, (float)0);
									pg.CreatePacket(p_);
									guild_information->guild_level += 1;
									guild_information->guild_xp = 0;
									gamepacket_t p0;
									p0.Insert("OnAddNotification");
									p0.Insert("interface/large/gd_lup.rttex");
									p0.Insert("Awesome! You reached Guild Level 12!");
									p0.Insert("audio/hub_open.wav");
									p0.Insert(0);
									p0.CreatePacket(p_);
									//cout << "called upgradeguild function [LVL 2]" << endl;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(p_)->netID);
									p.Insert("You don't have enough gems!");
									p.Insert(0);
									p.Insert(1);
									p.CreatePacket(p_);
									break;
								}
							}
							break;
						}
						}
						else if (a_[b_] == "upg13") {
						if (block_->fg == 5814) {
							uint32_t guild_id = world_->guild_id;
							vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
							if (p != guilds.end()) {
								Guild* guild_information = &guilds[p - guilds.begin()];
								if (pInfo(p_)->gems >= 9000000) {
									pInfo(p_)->gems -= 9000000;
									gamepacket_t pg;
									pg.Insert("OnSetBux"), pg.Insert(pInfo(p_)->gems), pg.Insert(0), pg.Insert((pInfo(p_)->supp >= 1) ? 1 : 0);
									if (pInfo(p_)->supp >= 2) pg.Insert((float)33796, (float)1, (float)0);
									pg.CreatePacket(p_);
									guild_information->guild_level += 1;
									guild_information->guild_xp = 0;
									gamepacket_t p0;
									p0.Insert("OnAddNotification");
									p0.Insert("interface/large/gd_lup.rttex");
									p0.Insert("Awesome! You reached Guild Level 13!");
									p0.Insert("audio/hub_open.wav");
									p0.Insert(0);
									p0.CreatePacket(p_);
									//cout << "called upgradeguild function [LVL 2]" << endl;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(p_)->netID);
									p.Insert("You don't have enough gems!");
									p.Insert(0);
									p.Insert(1);
									p.CreatePacket(p_);
									break;
								}
							}
							break;
						}
						}
						else if (a_[b_] == "upg14") {
						if (block_->fg == 5814) {
							uint32_t guild_id = world_->guild_id;
							vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
							if (p != guilds.end()) {
								Guild* guild_information = &guilds[p - guilds.begin()];
								if (pInfo(p_)->gems >= 10000000) {
									pInfo(p_)->gems -= 10000000;
									gamepacket_t pg;
									pg.Insert("OnSetBux"), pg.Insert(pInfo(p_)->gems), pg.Insert(0), pg.Insert((pInfo(p_)->supp >= 1) ? 1 : 0);
									if (pInfo(p_)->supp >= 2) pg.Insert((float)33796, (float)1, (float)0);
									pg.CreatePacket(p_);
									guild_information->guild_level += 1;
									guild_information->guild_xp = 0;
									gamepacket_t p0;
									p0.Insert("OnAddNotification");
									p0.Insert("interface/large/gd_lup.rttex");
									p0.Insert("Awesome! You reached Guild Level 14!");
									p0.Insert("audio/hub_open.wav");
									p0.Insert(0);
									p0.CreatePacket(p_);
									//cout << "called upgradeguild function [LVL 2]" << endl;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(p_)->netID);
									p.Insert("You don't have enough gems!");
									p.Insert(0);
									p.Insert(1);
									p.CreatePacket(p_);
									break;
								}
							}
							break;
						}
						}
						else if (a_[b_].substr(0, 9) == "checkbox_") {
							// checkboxes
							vector<string> target_ = explode("_", a_[b_]);
							if (target_[1] == "disable") {
								if (target_.size() == 4 and target_[2] == "music" and target_[3] == "render") {
									if (block_->fg == 202 or block_->fg == 204 or block_->fg == 206 or block_->fg == 4994) break;
									if (not world_->make_music_blocks_invisible and a_[b_ + 1] == "1") {
										world_->make_music_blocks_invisible = true, upd_ = true;
									}
									else if (world_->make_music_blocks_invisible and a_[b_ + 1] == "0") {
										world_->make_music_blocks_invisible = false, upd_ = true;
									}
								}
								else if (target_[2] == "music") {
									if (block_->fg == 202 or block_->fg == 204 or block_->fg == 206 or block_->fg == 4994) break;
									// music disable
									if (not world_->disable_music_blocks and a_[b_ + 1] == "1") {
										world_->disable_music_blocks = true, upd_ = true;
									}
									else if (world_->disable_music_blocks and a_[b_ + 1] == "0") {
										world_->disable_music_blocks = false, upd_ = true;
									}
								}
							}
							else if (target_.size() == 5 and target_[4] == "world") {
								if (block_->fg == 202 or block_->fg == 204 or block_->fg == 206 or block_->fg == 4994) break;
								// set as home world
								if (pInfo(p_)->home_world != world_->name and a_[b_ + 1] == "1") {
									pInfo(p_)->home_world = world_->name;
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(p_)->netID);
									p.Insert(world_->name + " has been set as your home world!");
									p.Insert(0);
									p.Insert(0);
									p.CreatePacket(p_);
								}
								else if (pInfo(p_)->home_world == world_->name and a_[b_ + 1] == "0") {
									pInfo(p_)->home_world = "";
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(p_)->netID);
									p.Insert(world_->name + " has been removed as your home world!");
									p.Insert(0);
									p.Insert(0);
									p.CreatePacket(p_);
								}
							}
							else if (target_[1] == "member") {
								if (block_->fg == 5814) {
									uint32_t guild_id = world_->guild_id;
									vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
									if (p != guilds.end()) {
										Guild* guild_information = &guilds[p - guilds.begin()];
										if (not guild_information->all_access and a_[b_ + 1] == "1") {
											guild_information->all_access = true;
											upd_ = true;
										}
										else if (guild_information->all_access and a_[b_ + 1] == "0") {
											guild_information->all_access = false;
											upd_ = true;
										}
									}
								}
							}
							else if (target_[1] == "elder") {
								if (block_->fg == 5814) {
									uint32_t guild_id = world_->guild_id;
									vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
									if (p != guilds.end()) {
										Guild* guild_information = &guilds[p - guilds.begin()];
										if (not guild_information->coleader_elder_access and a_[b_ + 1] == "1") {
											guild_information->coleader_elder_access = true;
											upd_ = true;
										}
										else if (guild_information->coleader_elder_access and a_[b_ + 1] == "0") {
											guild_information->coleader_elder_access = false;
											upd_ = true;
										}
									}
								}
							}
							else if (target_[1] == "coleader") {
								if (block_->fg == 5814) {
									uint32_t guild_id = world_->guild_id;
									vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
									if (p != guilds.end()) {
										Guild* guild_information = &guilds[p - guilds.begin()];
										if (not guild_information->coleader_access and a_[b_ + 1] == "1") {
											guild_information->coleader_access = true;
											upd_ = true;
										}
										else if (guild_information->coleader_access and a_[b_ + 1] == "0") {
											guild_information->coleader_access = false;
											upd_ = true;
										}
									}
								}
							}
							else if (target_[1] == "displaymascot") {
								if (block_->fg == 5814) {
									uint32_t guild_id = world_->guild_id;
									vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
									if (p != guilds.end()) {
										Guild* guild_information = &guilds[p - guilds.begin()];
										if (not guild_information->unlocked_mascot and a_[b_ + 1] == "1") {
											guild_information->unlocked_mascot = true;
										}
										else if (guild_information->unlocked_mascot and a_[b_ + 1] == "0") {
											guild_information->unlocked_mascot = false;
										}
									}
								}
							}
							else if (target_[1] == "ignore") {
								if (block_->fg == 202 or block_->fg == 204 or block_->fg == 206 or block_->fg == 4994) {
									if (not block_->empty_air and a_[b_ + 1] == "1") {
										block_->empty_air = true;
									}
									else if (block_->empty_air and a_[b_ + 1] == "0") {
										block_->empty_air = false;
									}
								}
							}
							else if (target_[1] == "buildonly") {
								if (block_->fg == 4994) {
									if (not block_->build_only and a_[b_ + 1] == "1") {
										block_->build_only = true;
									}
									else if (block_->build_only and a_[b_ + 1] == "0") {
										block_->build_only = false;
									}
								}
							}
							else if (target_[1] == "admins") {
								if (block_->fg == 4994) {
									if (not block_->limit_admins and a_[b_ + 1] == "1") {
										block_->limit_admins = true;
									}
									else if (block_->limit_admins and a_[b_ + 1] == "0") {
										block_->limit_admins = false;
									}
								}
							}
							else if (target_[1] == "silence") {
								if (block_->fg == 4802) {
									if (not world_->silence and a_[b_ + 1] == "1") {
										world_->silence = true;
									}
									else if (world_->silence and a_[b_ + 1] == "0") {
										world_->silence = false;
									}
								}
							}
							else if (target_[1] == "rainbows") {
								if (block_->fg == 4802) {
									if (not world_->rainbows and a_[b_ + 1] == "1") {
										world_->rainbows = true;
									}
									else if (world_->rainbows and a_[b_ + 1] == "0") {
										world_->rainbows = false;
									}
									upd_ = true;
								}
							}
							else if (target_[1] == "public") {
								if (block_->fg == 202 or block_->fg == 204 or block_->fg == 206 or block_->fg == 4994) {
									if (not block_->open_to_public and a_[b_ + 1] == "1") {
										block_->open_to_public = true;
										upd_ = true;
									}
									else if (block_->open_to_public and a_[b_ + 1] == "0") {
										block_->open_to_public = false;
										upd_ = true;
									}
								}
								else {
									if (not world_->open_to_public and a_[b_ + 1] == "1") {
										world_->open_to_public = true;
										gamepacket_t p;
										p.Insert("OnConsoleMessage");
										if (pInfo(p_)->mod == 0 && pInfo(p_)->dev == 0)pInfo(p_)->name_color = "`2";
										p.Insert(pInfo(p_)->name_color + pInfo(p_)->tankIDName + "`` has set the `$World Lock`` to `$PUBLIC");
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
											if (pInfo(currentPeer)->world == world_->name) {
												p.CreatePacket(currentPeer);
											}
										}
									}
									else if (world_->open_to_public and a_[b_ + 1] == "0") {
										world_->open_to_public = false;
										gamepacket_t p;
										p.Insert("OnConsoleMessage");
										if (pInfo(p_)->mod == 0 && pInfo(p_)->dev == 0)pInfo(p_)->name_color = "`2";
										p.Insert(pInfo(p_)->name_color + pInfo(p_)->tankIDName + "`` has set the `$World Lock`` to `4PRIVATE``");
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
											if (pInfo(currentPeer)->world == world_->name) {
												p.CreatePacket(currentPeer);
											}
										}
									}
								}
							}
							else if (target_[1] == "vending") {
								if (block_->fg == 202 or block_->fg == 204 or block_->fg == 206 or block_->fg == 4994) {
								}
								else {
									if (not world_->v_p and a_[b_ + 1] == "1") {
										world_->v_p = true;
										gamepacket_t p;
										p.Insert("OnConsoleMessage");
										if (pInfo(p_)->mod == 0 && pInfo(p_)->dev == 0)pInfo(p_)->name_color = "`2";
										p.Insert(pInfo(p_)->name_color + pInfo(p_)->tankIDName + "`` has set the `$Vending`` to `$PUBLIC");
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
											if (pInfo(currentPeer)->world == world_->name) {
												p.CreatePacket(currentPeer);
											}
										}
									}
									else if (world_->v_p and a_[b_ + 1] == "0") {
										world_->v_p = false;
										gamepacket_t p;
										p.Insert("OnConsoleMessage");
										if (pInfo(p_)->mod == 0 && pInfo(p_)->dev == 0)pInfo(p_)->name_color = "`2";
										p.Insert(pInfo(p_)->name_color + pInfo(p_)->tankIDName + "`` has set the `$Vending`` to `4PRIVATE``");
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
											if (pInfo(currentPeer)->world == world_->name) {
												p.CreatePacket(currentPeer);
											}
										}
									}
								}
							}
							else if (target_.size() == 2 and a_[b_ + 1] == "0") {
								string user_name = target_[1].erase(0, 1);
								if (block_->fg == 202 or block_->fg == 204 or block_->fg == 206 or block_->fg == 4994) {
									if (find(block_->admins.begin(), block_->admins.end(), user_name) != block_->admins.end()) {
										block_->admins.erase(remove(block_->admins.begin(), block_->admins.end(), user_name), block_->admins.end());
										gamepacket_t p;
										p.Insert("OnConsoleMessage");
										p.Insert(user_name + " was removed from a " + items[block_->fg].name + ".");
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
											if (pInfo(currentPeer)->world == world_->name) {
												p.CreatePacket(currentPeer);
											}
											if (pInfo(currentPeer)->tankIDName == user_name) {
												packet_(currentPeer, "action|play_sfx\nfile|audio/dialog_cancel.wav\ndelayMS|0");
												gamepacket_t p;
												p.Insert("OnTalkBubble");
												p.Insert(pInfo(currentPeer)->netID);
												if (pInfo(p_)->mod == 0 && pInfo(p_)->dev == 0)pInfo(p_)->name_color = "`2";
												p.Insert(pInfo(p_)->name_color + pInfo(p_)->tankIDName + "`` has `4removed`` your access from a lock on world `w" + world_->name + "``.");
												p.Insert(0), p.Insert(0);
												p.CreatePacket(currentPeer);
												if (pInfo(currentPeer)->world == world_->name) {
													PlayerMoving data_{};
													data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
													BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
													BYTE* blc = raw + 56;
													form_visual(blc, *block_, *world_, p_, false);
													for (ENetPeer* currentPeer2 = server->peers; currentPeer2 < &server->peers[server->peerCount]; ++currentPeer2) {
														if (currentPeer2->state != ENET_PEER_STATE_CONNECTED or currentPeer2->data == NULL) continue;
														if (pInfo(currentPeer2)->world == world_->name) {
															send_raw(currentPeer2, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
														}
													}
													delete[] raw, blc;
													if (block_->locked) {
														upd_lock(*block_, *world_, p_);
													}
												}
											}
										}
									}
								}
								else if (find(world_->admins.begin(), world_->admins.end(), user_name) != world_->admins.end()) {
									world_->admins.erase(remove(world_->admins.begin(), world_->admins.end(), user_name), world_->admins.end());
									gamepacket_t p;
									p.Insert("OnConsoleMessage");
									p.Insert(user_name + " was removed from a " + items[block_->fg].name + ".");
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
										if (pInfo(currentPeer)->world == world_->name) {
											p.CreatePacket(currentPeer);
										}
										if (pInfo(currentPeer)->tankIDName == user_name) {
											packet_(currentPeer, "action|play_sfx\nfile|audio/dialog_cancel.wav\ndelayMS|0");
											gamepacket_t p;
											p.Insert("OnTalkBubble");
											p.Insert(pInfo(currentPeer)->netID);
											if (pInfo(p_)->mod == 0 && pInfo(p_)->dev == 0)pInfo(p_)->name_color = "`2";
											p.Insert(pInfo(p_)->name_color + pInfo(p_)->tankIDName + "`` has `4removed`` your access from a lock on world `w" + world_->name + "``.");
											p.Insert(0), p.Insert(0);
											p.CreatePacket(currentPeer);
											gamepacket_t p2(0, pInfo(currentPeer)->netID);
											{
												p2.Insert("OnNameChanged");
												if (pInfo(currentPeer)->mod == 0 && pInfo(currentPeer)->dev == 0)pInfo(currentPeer)->name_color = "`0";
												p2.Insert((not pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->d_name : pInfo(currentPeer)->name_color + pInfo(currentPeer)->tankIDName) + (pInfo(currentPeer)->is_legend ? " of Legend" : "") + "``");
											}
											if (pInfo(currentPeer)->world == world_->name) {
												PlayerMoving data_{};
												data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
												BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
												BYTE* blc = raw + 56;
												form_visual(blc, *block_, *world_, p_, false);
												for (ENetPeer* currentPeer2 = server->peers; currentPeer2 < &server->peers[server->peerCount]; ++currentPeer2) {
													if (currentPeer2->state != ENET_PEER_STATE_CONNECTED or currentPeer2->data == NULL) continue;
													if (pInfo(currentPeer2)->world == world_->name) {
														p2.CreatePacket(currentPeer2);
														send_raw(currentPeer2, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
													}
												}
												delete[] raw, blc;
												if (block_->locked) {
													upd_lock(*block_, *world_, p_);
												}
											}
										}
									}
								}
							}
						}
						else if (a_[b_] == "playerNetID" and isdigit(a_[b_ + 1][0])) { // access kazka
							if (block_->fg == 202 or block_->fg == 204 or block_->fg == 206 or block_->fg == 4994) {
								if (block_->admins.size() >= 26) {
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(p_)->netID);
									p.Insert("Lock has reached access limit!");
									p.Insert(0);
									p.Insert(0);
									p.CreatePacket(p_);
									continue;
								}
								size_t id_ = atoi(a_[b_ + 1].c_str());
								if (id_ == pInfo(p_)->netID) {
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(p_)->netID);
									p.Insert("I already have access!");
									p.Insert(0);
									p.Insert(0);
									p.CreatePacket(p_);
									continue;
								}
								/*---- end debug print ----
								0: OnTalkBubble
								1: 3
								2: `wG2W`` already has access to the lock.
								3: 0
								4: 0*/
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
									if (pInfo(currentPeer)->netID == id_ and pInfo(currentPeer)->world == world_->name) {
										if (pInfo(currentPeer)->ac_.find(pInfo(p_)->netID) != pInfo(currentPeer)->ac_.end()) break;
										string user_name = pInfo(currentPeer)->tankIDName;
										if (user_name == block_->owner_name or find(block_->admins.begin(), block_->admins.end(), user_name) != block_->admins.end()) {
											gamepacket_t p;
											p.Insert("OnTalkBubble");
											p.Insert(pInfo(p_)->netID);
											p.Insert(pInfo(currentPeer)->name_color + pInfo(currentPeer)->tankIDName + "`` already has access to the lock.");
											p.Insert(0);
											p.Insert(0);
											p.CreatePacket(p_);
											break;
										}
										gamepacket_t p;
										p.Insert("OnTalkBubble");
										p.Insert(pInfo(p_)->netID);
										p.Insert("Offered " + pInfo(currentPeer)->name_color + pInfo(currentPeer)->tankIDName + "`` access to lock.");
										p.Insert(0);
										p.Insert(0);
										p.CreatePacket(p_);
										{
											pInfo(currentPeer)->ac_.insert({ pInfo(p_)->netID, (x_ + (y_ * 100)) });
											packet_(currentPeer, "action|play_sfx\nfile|audio/secret.wav\ndelayMS|0");
											gamepacket_t p;
											p.Insert("OnConsoleMessage");
											p.Insert(pInfo(p_)->name_color + pInfo(p_)->tankIDName + "`` wants to add you to a " + items[block_->fg].name + ". Wrench yourself to accept.");
											p.CreatePacket(currentPeer);
										}
										break;
									}
								}
							}
							else {
								if (world_->admins.size() >= 26) {
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(p_)->netID);
									p.Insert("World has reached access limit!");
									p.Insert(0);
									p.Insert(0);
									p.CreatePacket(p_);
									continue;
								}
								size_t id_ = atoi(a_[b_ + 1].c_str());
								if (id_ == pInfo(p_)->netID) {
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(p_)->netID);
									p.Insert("I already have access!");
									p.Insert(0);
									p.Insert(0);
									p.CreatePacket(p_);
									continue;
								}
								/*---- end debug print ----
								0: OnTalkBubble
								1: 3
								2: `wG2W`` already has access to the lock.
								3: 0
								4: 0*/
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
									if (pInfo(currentPeer)->netID == id_ and pInfo(currentPeer)->world == world_->name) {
										if (pInfo(currentPeer)->ac_.find(pInfo(p_)->netID) != pInfo(currentPeer)->ac_.end()) break;
										string user_name = pInfo(currentPeer)->tankIDName;
										if (user_name == world_->owner_name or find(world_->admins.begin(), world_->admins.end(), user_name) != world_->admins.end()) {
											gamepacket_t p;
											p.Insert("OnTalkBubble");
											p.Insert(pInfo(p_)->netID);
											p.Insert(pInfo(currentPeer)->name_color + pInfo(currentPeer)->tankIDName + "`` already has access to the lock.");
											p.Insert(0);
											p.Insert(0);
											p.CreatePacket(p_);
											break;
										}
										gamepacket_t p;
										p.Insert("OnTalkBubble");
										p.Insert(pInfo(p_)->netID);
										p.Insert("Offered " + pInfo(currentPeer)->name_color + pInfo(currentPeer)->tankIDName + "`` access to lock.");
										p.Insert(0);
										p.Insert(0);
										p.CreatePacket(p_);
										{
											pInfo(currentPeer)->ac_.insert({ pInfo(p_)->netID, (x_ + (y_ * 100)) });
											packet_(currentPeer, "action|play_sfx\nfile|audio/secret.wav\ndelayMS|0");
											gamepacket_t p;
											p.Insert("OnConsoleMessage");
											p.Insert(pInfo(p_)->name_color + pInfo(p_)->tankIDName + "`` wants to add you to a " + items[block_->fg].name + ". Wrench yourself to accept.");
											p.CreatePacket(currentPeer);
										}
										break;
									}
									//break;
								}
							}
							break;
						}
						if (upd_) {
							if (block_->fg == 5814) {
								uint32_t guild_id = world_->guild_id;
								vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
								if (p != guilds.end()) {
									Guild* guild_information = &guilds[p - guilds.begin()];
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
										if (pInfo(currentPeer)->world == world_->name) {
											if (pInfo(currentPeer)->guild_id == guild_information->guild_id) {
												if (guild_access(currentPeer, guild_id)) {
													gamepacket_t p2(0, pInfo(currentPeer)->netID);
													{
														p2.Insert("OnNameChanged");
														if (pInfo(currentPeer)->mod == 0 && pInfo(currentPeer)->dev == 0) pInfo(currentPeer)->name_color = "`^";
														p2.Insert((not pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->d_name : pInfo(currentPeer)->name_color + pInfo(currentPeer)->tankIDName) + (pInfo(currentPeer)->is_legend ? " of Legend" : "") + "``");
													} for (ENetPeer* currentPeer2 = server->peers; currentPeer2 < &server->peers[server->peerCount]; ++currentPeer2) {
														if (currentPeer2->state != ENET_PEER_STATE_CONNECTED or currentPeer2->data == NULL) continue;
														if (pInfo(currentPeer2)->world == world_->name) {
															p2.CreatePacket(currentPeer2);
														}
													}
												}
												else if (find(world_->admins.begin(), world_->admins.end(), pInfo(currentPeer)->tankIDName) == world_->admins.end()) {
													if (pInfo(currentPeer)->tankIDName != world_->owner_name) {
														gamepacket_t p2(0, pInfo(currentPeer)->netID);
														{
															p2.Insert("OnNameChanged");
															if (pInfo(currentPeer)->mod == 0 && pInfo(currentPeer)->dev == 0) pInfo(currentPeer)->name_color = "`0";
															p2.Insert((not pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->d_name : pInfo(currentPeer)->name_color + pInfo(currentPeer)->tankIDName) + (pInfo(currentPeer)->is_legend ? " of Legend" : "") + "``");
														} for (ENetPeer* currentPeer2 = server->peers; currentPeer2 < &server->peers[server->peerCount]; ++currentPeer2) {
															if (currentPeer2->state != ENET_PEER_STATE_CONNECTED or currentPeer2->data == NULL) continue;
															if (pInfo(currentPeer2)->world == world_->name) {
																p2.CreatePacket(currentPeer2);
															}
														}
													}
												}
											}
										}
									}
								}
							}
							if (block_->fg == 202 or block_->fg == 204 or block_->fg == 206 or block_->fg == 4994) {
								PlayerMoving data_{};
								data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
								BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
								BYTE* blc = raw + 56;
								form_visual(blc, *block_, *world_, p_, false);
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
									if (pInfo(currentPeer)->world == world_->name) {
										send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
									}
								}
								delete[] raw, blc;
							}
							else {
								PlayerMoving data_{};
								data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
								BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
								BYTE* blc = raw + 56;
								form_visual(blc, *block_, *world_, p_, false);
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
									if (pInfo(currentPeer)->world == world_->name) {
										send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
									}
								}
								delete[] raw, blc;
							}
							if (block_->locked) {
								upd_lock(*block_, *world_, p_);
							}
						}
					}
					if (reapply) {
						//remove lock from current
						{
							vector<int> new_tiles{};
							vector<WorldBlock> shadow_copy_2 = world_->blocks;
							new_tiles.push_back(x_ + (y_ * 100));
							int ySize = world_->blocks.size() / 100, xSize = world_->blocks.size() / ySize;
							for (int i2 = 0; i2 < new_tiles.size(); i2++) {
								int s_x_ = new_tiles[i2] % 100, s_y_ = new_tiles[i2] / 100;
								if (s_x_ < 99 and shadow_copy_2[s_x_ + 1 + (s_y_ * 100)].locked and shadow_copy_2[s_x_ + 1 + (s_y_ * 100)].lock_origin == (x_ + (y_ * 100))) {
									if (not shadow_copy_2[s_x_ + 1 + (s_y_ * 100)].scanned) {
										shadow_copy_2[s_x_ + 1 + (s_y_ * 100)].scanned = true;
										new_tiles.push_back(s_x_ + 1 + (s_y_ * 100));
										world_->blocks[s_x_ + 1 + (s_y_ * 100)].locked = false;
										world_->blocks[s_x_ + 1 + (s_y_ * 100)].lock_origin = -1;
									}
								} if (s_x_ > 0 and shadow_copy_2[s_x_ - 1 + (s_y_ * 100)].locked and shadow_copy_2[s_x_ - 1 + (s_y_ * 100)].lock_origin == (x_ + (y_ * 100))) {
									if (not shadow_copy_2[s_x_ - 1 + (s_y_ * 100)].scanned) {
										shadow_copy_2[s_x_ - 1 + (s_y_ * 100)].scanned = true;
										new_tiles.push_back(s_x_ - 1 + (s_y_ * 100));
										world_->blocks[s_x_ - 1 + (s_y_ * 100)].locked = false;
										world_->blocks[s_x_ - 1 + (s_y_ * 100)].lock_origin = -1;
									}
								} if (s_y_ < 59 and shadow_copy_2[s_x_ + ((s_y_ + 1) * 100)].locked and shadow_copy_2[s_x_ + ((s_y_ + 1) * 100)].lock_origin == (x_ + (y_ * 100))) {
									if (not shadow_copy_2[s_x_ + ((s_y_ + 1) * 100)].scanned) {
										shadow_copy_2[s_x_ + ((s_y_ + 1) * 100)].scanned = true;
										new_tiles.push_back(s_x_ + ((s_y_ + 1) * 100));
										world_->blocks[s_x_ + ((s_y_ + 1) * 100)].locked = false;
										world_->blocks[s_x_ + ((s_y_ + 1) * 100)].lock_origin = -1;
									}
								} if (s_y_ > 0 and shadow_copy_2[s_x_ + ((s_y_ - 1) * 100)].locked and shadow_copy_2[s_x_ + ((s_y_ - 1) * 100)].lock_origin == (x_ + (y_ * 100))) {
									if (not shadow_copy_2[s_x_ + ((s_y_ - 1) * 100)].scanned) {
										shadow_copy_2[s_x_ + ((s_y_ - 1) * 100)].scanned = true;
										new_tiles.push_back(s_x_ + ((s_y_ - 1) * 100));
										world_->blocks[s_x_ + ((s_y_ - 1) * 100)].locked = false;
										world_->blocks[s_x_ + ((s_y_ - 1) * 100)].lock_origin = -1;
									}
								}
							}
						}
						int lock_size = block_->fg == 202 ? 10 : (block_->fg == 204 ? 48 : (block_->fg == 202 ? 200 : 200));
						if (not block_->empty_air) {
							{
								//apply new without empty air
								vector<vector<int>> tiles_ = lock_tiles(world_, x_, y_, lock_size);
								lock_size = tiles_.size();
								PlayerMoving data_{};
								data_.packetType = 15, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
								data_.netID = pInfo(p_)->id;
								data_.plantingTree = block_->fg;
								BYTE* raw;
								if (tiles_.size() != 0) {
									raw = packPlayerMoving(&data_, 112 + (lock_size * 2) + alloc_(world_, block_));
									int lalala = 8;
									memcpy(raw + 8, &lock_size, 2);
									memcpy(raw + 12, &lalala, 2);
									BYTE* blc = raw + 56;
									for (int i_ = 0; i_ < tiles_.size(); i_++) {
										vector<int> update_tiles = tiles_[i_];
										int x = update_tiles[0];
										int y = update_tiles[1];
										int sq_ = x + (y * 100);
										WorldBlock* block_ = &world_->blocks[sq_];
										if (block_->locked) {
											//continue;
										}
										else {
											block_->locked = true;
											block_->lock_origin = x_ + (y_ * 100);
											memcpy(blc + (i_ * 2), &sq_, 2);
										}
									}
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
										if (pInfo(currentPeer)->world == name_) {
											packet_(currentPeer, "action|play_sfx\nfile|audio/use_lock.wav\ndelayMS|0");
											send_raw(currentPeer, 4, raw, 112 + (lock_size * 2) + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
										}
									}
									delete[] raw, blc;
								}
								else {
									raw = packPlayerMoving(&data_, 56);
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
										if (pInfo(currentPeer)->world == name_) {
											packet_(currentPeer, "action|play_sfx\nfile|audio/use_lock.wav\ndelayMS|0");
											send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
										}
									}
									delete[] raw;
								}
							}
						}
						else {
							vector<int> new_tiles{};
							vector<int> lock_tiles{};
							vector<WorldBlock> shadow_copy_2 = world_->blocks;
							new_tiles.push_back(x_ + (y_ * 100));
							int ySize = world_->blocks.size() / 100, xSize = world_->blocks.size() / ySize;
							for (int i2 = 0; i2 < new_tiles.size(); i2++) {
								if (lock_tiles.size() >= lock_size) break;
								int s_x_ = new_tiles[i2] % 100, s_y_ = new_tiles[i2] / 100;
								if (s_x_ < 99 and not shadow_copy_2[s_x_ + 1 + (s_y_ * 100)].locked and shadow_copy_2[s_x_ + 1 + (s_y_ * 100)].fg != 0 and not_mod(shadow_copy_2[s_x_ + 1 + (s_y_ * 100)], s_x_, s_y_) or s_x_ < 99 and not shadow_copy_2[s_x_ + 1 + (s_y_ * 100)].locked and shadow_copy_2[s_x_ + 1 + (s_y_ * 100)].bg != 0 and shadow_copy_2[s_x_ + 1 + (s_y_ * 100)].fg == 0) {
									if (not shadow_copy_2[s_x_ + 1 + (s_y_ * 100)].scanned) {
										shadow_copy_2[s_x_ + 1 + (s_y_ * 100)].scanned = true;
										new_tiles.push_back(s_x_ + 1 + (s_y_ * 100));
										lock_tiles.push_back(s_x_ + 1 + (s_y_ * 100));
										world_->blocks[s_x_ + 1 + (s_y_ * 100)].locked = true;
										world_->blocks[s_x_ + 1 + (s_y_ * 100)].lock_origin = x_ + (y_ * 100);
									}
								} if (s_x_ > 0 and not shadow_copy_2[s_x_ - 1 + (s_y_ * 100)].locked and shadow_copy_2[s_x_ - 1 + (s_y_ * 100)].fg != 0 and not_mod(shadow_copy_2[s_x_ - 1 + (s_y_ * 100)], s_x_, s_y_) or s_x_ > 0 and not shadow_copy_2[s_x_ - 1 + (s_y_ * 100)].locked and shadow_copy_2[s_x_ - 1 + (s_y_ * 100)].bg != 0 and shadow_copy_2[s_x_ - 1 + (s_y_ * 100)].fg == 0) {
									if (not shadow_copy_2[s_x_ - 1 + (s_y_ * 100)].scanned) {
										shadow_copy_2[s_x_ - 1 + (s_y_ * 100)].scanned = true;
										new_tiles.push_back(s_x_ - 1 + (s_y_ * 100));
										lock_tiles.push_back(s_x_ - 1 + (s_y_ * 100));
										world_->blocks[s_x_ - 1 + (s_y_ * 100)].locked = true;
										world_->blocks[s_x_ - 1 + (s_y_ * 100)].lock_origin = x_ + (y_ * 100);
									}
								} if (s_y_ < 59 and not shadow_copy_2[s_x_ + ((s_y_ + 1) * 100)].locked and shadow_copy_2[s_x_ + ((s_y_ + 1) * 100)].fg != 0 and not_mod(shadow_copy_2[s_x_ + ((s_y_ + 1) * 100)], s_x_, s_y_) or s_y_ < 59 and not shadow_copy_2[s_x_ + ((s_y_ + 1) * 100)].locked and shadow_copy_2[s_x_ + ((s_y_ + 1) * 100)].bg != 0 and shadow_copy_2[s_x_ + ((s_y_ + 1) * 100)].fg == 0) {
									if (not shadow_copy_2[s_x_ + ((s_y_ + 1) * 100)].scanned) {
										shadow_copy_2[s_x_ + ((s_y_ + 1) * 100)].scanned = true;
										new_tiles.push_back(s_x_ + ((s_y_ + 1) * 100));
										lock_tiles.push_back(s_x_ + ((s_y_ + 1) * 100));
										world_->blocks[s_x_ + ((s_y_ + 1) * 100)].locked = true;
										world_->blocks[s_x_ + ((s_y_ + 1) * 100)].lock_origin = x_ + (y_ * 100);
									}
								} if (s_y_ > 0 and not shadow_copy_2[s_x_ + ((s_y_ - 1) * 100)].locked and shadow_copy_2[s_x_ + ((s_y_ - 1) * 100)].fg != 0 and not_mod(shadow_copy_2[s_x_ + ((s_y_ - 1) * 100)], s_x_, s_y_) or s_y_ > 0 and not shadow_copy_2[s_x_ + ((s_y_ - 1) * 100)].locked and shadow_copy_2[s_x_ + ((s_y_ - 1) * 100)].bg != 0 and shadow_copy_2[s_x_ + ((s_y_ - 1) * 100)].fg == 0) {
									if (not shadow_copy_2[s_x_ + ((s_y_ - 1) * 100)].scanned) {
										shadow_copy_2[s_x_ + ((s_y_ - 1) * 100)].scanned = true;
										new_tiles.push_back(s_x_ + ((s_y_ - 1) * 100));
										lock_tiles.push_back(s_x_ + ((s_y_ - 1) * 100));
										world_->blocks[s_x_ + ((s_y_ - 1) * 100)].locked = true;
										world_->blocks[s_x_ + ((s_y_ - 1) * 100)].lock_origin = x_ + (y_ * 100);
									}
								}
							}

							//upd_lock(*block_, *world_, p_);
							lock_size = lock_tiles.size();
							if (lock_tiles.size() > 0) {
								PlayerMoving data_{};
								data_.packetType = 15, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
								data_.netID = block_->owner_name == pInfo(p_)->tankIDName ? pInfo(p_)->id : -1;
								data_.plantingTree = block_->fg;
								BYTE* raw;
								raw = packPlayerMoving(&data_, 112 + (lock_size * 2) + alloc_(world_, block_));
								int lalala = 8;
								memcpy(raw + 8, &lock_size, 2);
								memcpy(raw + 12, &lalala, 2);
								BYTE* blc = raw + 56;
								for (int i_ = 0; i_ < lock_tiles.size(); i_++) memcpy(blc + (i_ * 2), &lock_tiles[i_], 2);
								PlayerMoving data_2{};
								data_2.packetType = 5, data_2.punchX = x_, data_2.punchY = y_, data_2.characterState = 0x8;
								BYTE* raw2 = packPlayerMoving(&data_2, 112 + alloc_(world_, block_));
								BYTE* blc2 = raw2 + 56;
								form_visual(blc2, *block_, *world_, p_, false);
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
									if (pInfo(currentPeer)->world == world_->name) {
										packet_(currentPeer, "action|play_sfx\nfile|audio/use_lock.wav\ndelayMS|0");
										send_raw(currentPeer, 4, raw, 112 + (lock_size * 2) + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
										send_raw(currentPeer, 4, raw2, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
									}
								}
								delete[] raw, blc, raw2, blc2;
							}
							else {
								PlayerMoving data_{};
								data_.packetType = 15, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
								data_.netID = block_->owner_name == pInfo(p_)->tankIDName ? pInfo(p_)->id : -1;
								data_.plantingTree = block_->fg;
								BYTE* raw = packPlayerMoving(&data_, 56);
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
									if (world_->name == pInfo(currentPeer)->world) {
										send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
										PlayerMoving data_2{};
										data_2.packetType = 5, data_2.punchX = x_, data_2.punchY = y_, data_2.characterState = 0x8;
										BYTE* raw2 = packPlayerMoving(&data_2, 112 + alloc_(world_, block_));
										BYTE* blc2 = raw2 + 56;
										form_visual(blc2, *block_, *world_, currentPeer, false);
										packet_(currentPeer, "action|play_sfx\nfile|audio/use_lock.wav\ndelayMS|0");
										send_raw(currentPeer, 4, raw2, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
										delete[] raw2, blc2;
									}
								}
								delete[] raw;
							}
						}
					}
				}
			}
			break;
		}
		else if (a_[i_] == "abondonguild") {
			if (a_.size() != 7 and a_.size() != 8 and a_.size() != 11) break;
			if (pInfo(p_)->guild_id == 0) break;
			if (a_.size() == 8 or a_.size() == 11) {
				string button_clicked = a_.size() == 8 ? a_[5] : a_[8];
				if (button_clicked == "back") {
					string name_ = pInfo(p_)->world;
					vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
					if (p != worlds.end()) {
						World* world_ = &worlds[p - worlds.begin()];
						int x_ = 0, y_ = 0;
						int ySize = (int)world_->blocks.size() / 100, xSize = (int)world_->blocks.size() / ySize;
						for (int i_ = 0; i_ < world_->blocks.size(); i_++) {
							if (items[world_->blocks[i_].fg].blockType == BlockTypes::LOCK) {
								uint16_t id_ = world_->blocks[i_].fg;
								if (id_ == 5814) {
									x_ = i_ % xSize;
									y_ = i_ / xSize;
									break;
								}
							}
						}
						WorldBlock* block_ = &world_->blocks[x_ + (y_ * 100)];
						send_edit_lock(p_, world_, block_->fg, x_, y_);
					}
				}
				else if (button_clicked == "abondonguild") {
					if (not isdigit(a_[5][0])) break;
					int planting_id_ = atoi(a_[5].c_str());
					if (planting_id_ >= items.size() or planting_id_ < 0) break;
					if (items[planting_id_].blockType != LOCK or planting_id_ == 202 or planting_id_ == 204 or planting_id_ == 206 or planting_id_ == 4994) {
						break;
					}
					string name_ = pInfo(p_)->world;
					vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
					if (p != worlds.end()) {
						World* world_ = &worlds[p - worlds.begin()];
						uint32_t guild_id = world_->guild_id;
						vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
						if (p != guilds.end()) {
							Guild* guild_information = &guilds[p - guilds.begin()];
							for (GuildMember member_search : guild_information->guild_members) {
								if (member_search.member_name == pInfo(p_)->tankIDName) {
									if (member_search.role_id != 3) break;
									int ySize = (int)world_->blocks.size() / 100, xSize = (int)world_->blocks.size() / ySize;
									for (int i_ = 0; i_ < world_->blocks.size(); i_++) {
										if (items[world_->blocks[i_].fg].blockType == BlockTypes::LOCK) {
											uint16_t id_ = world_->blocks[i_].fg;
											if (id_ == 5814) {
												int x_ = i_ % xSize;
												int y_ = i_ / xSize;
												WorldBlock* block_ = &world_->blocks[x_ + (y_ * 100)];
												int c_ = -1;
												if (modify_inventory(p_, planting_id_, c_) == 0) {
													leave_guild(p_);
													block_->fg = planting_id_;
													world_->guild_id = 0;
													PlayerMoving data_{};
													data_.packetType = 15, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
													data_.netID = pInfo(p_)->id;
													data_.plantingTree = block_->fg;
													BYTE* raw = packPlayerMoving(&data_, 56);
													PlayerMoving data_2{};
													data_2.packetType = 5, data_2.punchX = x_, data_2.punchY = y_, data_2.characterState = 0x8;
													BYTE* raw2 = packPlayerMoving(&data_2, 112 + alloc_(world_, block_));
													BYTE* blc = raw2 + 56;
													form_visual(blc, *block_, *world_, p_, false);
													for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
														if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
														if (pInfo(currentPeer)->world == world_->name) {
															send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
															send_raw(currentPeer, 4, raw2, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
														}
													}
													delete[] raw, raw2, blc;
													gamepacket_t p;
													p.Insert("OnConsoleMessage");
													p.Insert("`5[GUILD ALERT]`` Guild Abandoned!");
													p.CreatePacket(p_);
												}
												break;
											}
										}
									}
									break;
								}
							}
						}
					}
				}
				break;
			}
			if (not isdigit(a_[5][0])) break;
			int planting_id_ = atoi(a_[5].c_str());
			if (planting_id_ >= items.size() or planting_id_ < 0) break;
			if (items[planting_id_].blockType != LOCK or planting_id_ == 202 or planting_id_ == 204 or planting_id_ == 206 or planting_id_ == 4994) {
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("add_label_with_icon|big|`wAbandon Guild ``|left|5814|\nadd_textbox|`4You need to select a World Lock!|left||\nadd_button|back|Back|noflags|0|0|\nend_dialog|abondonguild|||");
				p.CreatePacket(p_);
				break;
			}
			gamepacket_t p;
			p.Insert("OnDialogRequest");
			p.Insert("add_label_with_icon|big|`wAbandon Guild ``|left|5814|\nadd_textbox|`1Are you sure you want to abandon the guild?``|left|\nadd_textbox|`4BEWARE:``|left|\nadd_spacer|small|\nadd_textbox|`8- The Guild Lock will NOT return to your inventory!``|left|\nadd_textbox|`8- If you purchased a Guild Mascot this will be lost and will be made available to other guilds to buy!``|left|\nadd_textbox|`8- You will not get back any of the Gems you invested in the Guild!``|left|\nadd_textbox|`8- You will lose all Guild XP and levels the guild accomplished!``|left|\nadd_textbox|`8- When the Guild is abandoned it cannot be recovered!``|left|\nembed_data|worldlockId|" + to_string(planting_id_) + "\nadd_spacer|small|\nadd_button|abondonguild|Abandon Guild|noflags|0|0|\nadd_button|back|Back|noflags|0|0|\nend_dialog|abondonguild|||");
			p.CreatePacket(p_);
			break;
		}
		else if (a_[i_] == "confirmguildlockkey") {
			if (a_.size() != 5) break;
			string name_ = pInfo(p_)->world;
			vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
			if (p != worlds.end()) {
				World* world_ = &worlds[p - worlds.begin()];
				if (world_->owner_name != pInfo(p_)->tankIDName) break;
				int c_ = 0;
				modify_inventory(p_, 5816, c_);
				if (c_ != 0) break;
				for (int i_ = 0; i_ < world_->drop.size(); i_++) {
					if (world_->drop[i_].x == -1 or world_->drop[i_].id == 0) continue;
					WorldBlock* block_ = &world_->blocks[(world_->drop[i_].x / 32) + ((world_->drop[i_].y / 32) * 100)];
					if (items[block_->fg].collisionType != 1) {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(p_)->netID);
						p.Insert("`4Oops!... Can't trade a world with floating items that are unblocked or in treasure chests!``");
						p.Insert(0), p.Insert(0);
						p.CreatePacket(p_);
						return;
					}
				}
				uint16_t locked_with = 0;
				bool alr_failed = false, untradebox = false;
				for (int i_ = 0; i_ < world_->blocks.size(); i_++) {
					if (items[world_->blocks[i_].fg].blockType == BlockTypes::LOCK) {
						uint16_t id_ = world_->blocks[i_].fg;
						if (id_ == 202 or id_ == 204 or id_ == 206 or id_ == 4994) {
							alr_failed = true;
						}
						else {
							locked_with = id_;
						}
					}
				}
				for (int i_ = 0; i_ < world_->blocks.size(); i_++) if (world_->blocks[i_].fg == 4516) untradebox = true;
				if (locked_with == 0) break;
				if (untradebox) {
					gamepacket_t p;
					p.Insert("OnTalkBubble");
					p.Insert(pInfo(p_)->netID);
					p.Insert("`4To trade a world, you will need to remove Untrade-a-Box!``");
					p.Insert(0), p.Insert(0);
					p.CreatePacket(p_);
					return;
				}
				if (alr_failed) {
					gamepacket_t p;
					p.Insert("OnTalkBubble");
					p.Insert(pInfo(p_)->netID);
					p.Insert("To trade a world, you can only have one lock on it, the `5World Lock``.  Remove the rest!");
					p.Insert(0), p.Insert(0);
					p.CreatePacket(p_);
					return;
				}
				if (world_->admins.size() != 0) {
					gamepacket_t p;
					p.Insert("OnTalkBubble");
					p.Insert(pInfo(p_)->netID);
					p.Insert("You'll first need to remove all players with access to your " + items[locked_with].name + " to get a " + items[5816].name + ".");
					p.Insert(0), p.Insert(1);
					p.CreatePacket(p_);
					return;
				}
				c_ = 1;
				if (modify_inventory(p_, 5816, c_) == 0) {
					packet_(p_, "action|play_sfx\nfile|audio/use_lock.wav\ndelayMS|0");
					gamepacket_t p;
					p.Insert("OnTalkBubble");
					p.Insert(pInfo(p_)->netID);
					p.Insert("You got a `#" + items[5816].name + "``! You can now transfer leadership of the guild!");
					p.Insert(0), p.Insert(0);
					p.CreatePacket(p_);
				}
			}
			break;
		}
		else if (a_[i_] == "sign_edit") {
			if (a_.size() != 13) break;
			if (not isdigit(a_[i_ + 2][0]) or not isdigit(a_[i_ + 5][0])) break;
			int x_ = atoi(a_[i_ + 2].c_str()), y_ = atoi(a_[i_ + 5].c_str());
			if (x_ < 0 or x_ >= 100 or y_ < 0 or y_ >= 60) break;
			string tekstas = a_[i_ + 8];
			if (tekstas.size() > 128) break;
			string name_ = pInfo(p_)->world;
			vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
			if (p != worlds.end()) {
				World* world_ = &worlds[p - worlds.begin()];
				WorldBlock* block_ = &world_->blocks[x_ + (y_ * 100)];
				if (block_->txt == tekstas or block_->fg == 0 or items[block_->fg].blockType != BlockTypes::SIGN) break;
				if (not world_->open_to_public and world_->owner_name != pInfo(p_)->tankIDName and not pInfo(p_)->dev and not world_->owner_name.empty() and (!guild_access(p_, world_->guild_id) and find(world_->admins.begin(), world_->admins.end(), pInfo(p_)->tankIDName) == world_->admins.end())) {
					if (block_->locked) {
						WorldBlock* check_lock = &world_->blocks[block_->lock_origin];
						if (not world_->open_to_public and check_lock->owner_name != pInfo(p_)->tankIDName and world_->owner_name.empty() and (find(check_lock->admins.begin(), check_lock->admins.end(), pInfo(p_)->tankIDName) == check_lock->admins.end())) break;
					}
					else {
						break;
					}
				}
				if (block_->fg == 1684) {
					transform(tekstas.begin(), tekstas.end(), tekstas.begin(), ::toupper);
					block_->door_id = tekstas;
				}
				else {
					block_->txt = tekstas;
					PlayerMoving data_{};
					data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
					BYTE* raw = packPlayerMoving(&data_, 112 + tekstas.size() + alloc_(world_, block_));
					BYTE* blc = raw + 56;
					form_visual(blc, *block_, *world_, p_, false);
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
						if (pInfo(currentPeer)->world == world_->name) {
							send_raw(currentPeer, 4, raw, 112 + tekstas.size() + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
						}
					}
					delete[] raw, blc;
					if (block_->locked) {
						upd_lock(*block_, *world_, p_);
					}
				}
			}
			break;
		}
		else if (a_[i_] == "trash_item" or a_[i_] == "drop_item" or a_[i_] == "trash_item2") {
			if (a_.size() != 10 and a_[i_] != "trash_item2") break;
			if (a_[i_] == "trash_item2" and a_.size() != 11) break;
			if (not isdigit(a_[i_ + 2][0]) or not isdigit(a_[i_ + 5][0])) break;
			int id_ = atoi(a_[i_ + 2].c_str()), c_ = atoi(a_[i_ + 5].c_str());
			int count = 0;
			int drop_fish = 0;
			if (items[id_].blockType == BlockTypes::FISH) {
				for (int i_ = 0, remove = 0; i_ < pInfo(p_)->inv.size(); i_++) if (pInfo(p_)->inv[i_].id == id_) drop_fish = pInfo(p_)->inv[i_].count, c_ = pInfo(p_)->inv[i_].count;
			}
			if (id_ >= items.size() or id_ == 18 or id_ == 32 or id_ == 6336) break;
			string name_ = pInfo(p_)->world;
			vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
			if (p != worlds.end()) {
				World* world_ = &worlds[p - worlds.begin()];
				c_ = c_ * -1;
				if (a_[i_] == "trash_item" or a_[i_] == "trash_item2") {
					if (a_[i_] == "trash_item" and items[id_].untradeable) {
						int has_ = 0;
						modify_inventory(p_, id_, has_);
						if (has_ < c_) break;
						gamepacket_t p;
						p.Insert("OnDialogRequest");
						p.Insert("set_default_color|`o\nadd_label_with_icon|big|`4Recycle`` " + to_string(c_ * -1) + " `w" + items[id_].name + "``|left|" + to_string(id_) + "|\nembed_data|itemID|" + to_string(id_) + "\nembed_data|count|" + to_string(c_ * -1) + "\nadd_textbox|You are recycling an `9UNTRADEABLE`` item. Are you absolutely sure you want to do this? There is no way to get the item back if you select yes.|left|\nend_dialog|trash_item2|NO!|Yes, I am sure|");
						p.CreatePacket(p_);
						break;
					}
					if (modify_inventory(p_, id_, c_) == 0) {
						packet_(p_, "action|play_sfx\nfile|audio/trash.wav\ndelayMS|0");
						a_[i_ + 5].erase(0, min(a_[i_ + 5].find_first_not_of('0'), a_[i_ + 5].size() - 1));
						gamepacket_t p;
						p.Insert("OnConsoleMessage");
						if (pInfo(p_)->supp != 0) {
							int item = id_, maxgems = 0, receivegems = 0;
							int count = atoi(a_[i_ + 5].c_str());
							if (id_ % 2 != 0) item -= 1;
							maxgems = items[item].max_gems2;
							if (items[item].max_gems2 != 0) if (maxgems != 0) for (int i = 0; i < count; i++) receivegems += rand() % maxgems;
							if (items[item].max_gems3 != 0) receivegems = count * items[item].max_gems3;
							if (receivegems != 0) {
								pInfo(p_)->gems += receivegems;
								gamepacket_t p;
								p.Insert("OnSetBux");
								p.Insert(pInfo(p_)->gems);
								p.Insert(0);
								p.Insert((pInfo(p_)->supp >= 1) ? 1 : 0);
								if (pInfo(p_)->supp >= 2) {
									p.Insert((float)33796, (float)1, (float)0);
								}
								p.CreatePacket(p_);
							}
							p.Insert((items[id_].blockType == BlockTypes::FISH ? (to_string(abs(c_))) + "lb." : a_[i_ + 5]) + " `w" + items[id_].ori_name + "`` recycled, `0" + setGems(receivegems) + "`` gems earned.");
						}
						else p.Insert((items[id_].blockType == BlockTypes::FISH ? (to_string(abs(c_))) + "lb." : a_[i_ + 5]) + " `w" + items[id_].ori_name + "`` trashed.");
						p.CreatePacket(p_);
						break;
					}
					break;
				}
				if (find(world_->active_jammers.begin(), world_->active_jammers.end(), 4758) != world_->active_jammers.end()) {
					if (world_->owner_name != pInfo(p_)->tankIDName and !guild_access(p_, world_->guild_id) and find(world_->admins.begin(), world_->admins.end(), pInfo(p_)->tankIDName) == world_->admins.end()) {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(p_)->netID);
						p.Insert("The Mini-Mod says no dropping items in this world!");
						p.Insert(0), p.Insert(0);
						p.CreatePacket(p_);
						break;
					}
				}
				if (items[id_].untradeable or id_ == 1424 or id_ == 5816) {
					gamepacket_t p;
					p.Insert("OnTextOverlay");
					p.Insert("You can't drop that.");
					p.CreatePacket(p_);
					break;
				}
				string name_ = pInfo(p_)->world;
				vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
				if (p != worlds.end()) {
					World* world_ = &worlds[p - worlds.begin()];
					WorldDrop drop_{};
					drop_.id = id_;
					if (drop_fish == 0) drop_.count = atoi(a_[i_ + 5].c_str());
					else drop_.count = drop_fish;
					drop_.uid = uint16_t(world_->drop.size()) + 1;
					int a_ = rand() % 12;
					drop_.x = (pInfo(p_)->state == 16 ? pInfo(p_)->x - (a_ + 20) : (pInfo(p_)->x + 20) + a_);
					drop_.y = pInfo(p_)->y + rand() % 16;
					if (drop_.x / 32 < 0 or drop_.x / 32 >= 100 or drop_.y / 32 < 0 or drop_.y / 32 >= 60) {
						gamepacket_t p;
						p.Insert("OnTextOverlay");
						p.Insert("You can't drop that here, face somewhere with open space.");
						p.CreatePacket(p_);
						break;
					}
					BlockTypes type_ = FOREGROUND;
					WorldBlock* block_ = &world_->blocks[(pInfo(p_)->state == 16 ? drop_.x / 32 : round((double)drop_.x / 32)) + (drop_.y / 32 * 100)];
					if (items[block_->fg].collisionType == 1 || block_->fg == 6 || items[block_->fg].entrance || items[block_->fg].toggleable and is_false_state(world_->blocks[(pInfo(p_)->state == 16 ? drop_.x / 32 : round((double)drop_.x / 32)) + (drop_.y / 32 * 100)], 0x00400000)) {
						gamepacket_t p;
						p.Insert("OnTextOverlay");
						p.Insert(items[block_->fg].blockType == BlockTypes::MAIN_DOOR ? "You can't drop items on the white door." : "You can't drop that here, face somewhere with open space.");
						p.CreatePacket(p_);
						break;
					}
					int count_ = 0;
					bool dublicated = false;
					for (int i_ = 0; i_ < world_->drop.size(); i_++) {
						if (abs(world_->drop[i_].y - drop_.y) <= 16 and abs(world_->drop[i_].x - drop_.x) <= 16) {
							count_ += 1;
						}
						if (world_->drop[i_].id == id_) if (world_->drop[i_].count + drop_.count < 200) dublicated = true;
					}
					if (!dublicated) {
						if (count_ > 20) {
							gamepacket_t p;
							p.Insert("OnTextOverlay");
							p.Insert("You can't drop that here, find an emptier spot!");
							p.CreatePacket(p_);
							break;
						}
					}
					int dropped = c_;
					if (modify_inventory(p_, id_, c_) == 0) {
						bool droppeds = false;
						add_cctv(p_, "dropped", to_string(abs(dropped)) + " " + items[id_].name);
						dropas_(world_, drop_, pInfo(p_)->netID);
						droplog(pInfo(p_)->tankIDName + " dropped " + to_string(abs(dropped)) + " " + items[id_].name + " World: " + pInfo(p_)->world);
					}
				}
			}
			break;
		}
		else if (a_[i_] == "growid_apply") {
			if (a_.size() != 13) break;
			string user_ = a_[i_ + 2], pass_ = a_[i_ + 4], pass_verify_ = a_[i_ + 6], email_ = a_[i_ + 8];
			try {
				if (pInfo(p_)->tankIDName != "") continue;
				string path_ = "players/" + user_ + "_.json";
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				bool bad_name = false;
				string check_user = user_;
				transform(check_user.begin(), check_user.end(), check_user.begin(), ::toupper);
				for (int i = 0; i < swear_words.size(); i++) {
					if (check_user.find(swear_words.at(i)) != string::npos) {
						bad_name = true;
						break;
					}
				}
				bool max_acc = false;
				int count__ = 0;
				string rid_check = "db/accounts/rid/" + pInfo(p_)->rid + ".txt";
				if (_access_s(rid_check.c_str(), 0) == 0) {
					string acc_count;
					ifstream f_(rid_check, ifstream::binary);
					f_ >> acc_count;
					f_.close();
					int count_ = explode("|", acc_count).size() - 1;
					if (count_ > 0) count__ += count_;
				}
				string mac_check = "db/accounts/mac/" + pInfo(p_)->mac + ".txt";
				if (_access_s(mac_check.c_str(), 0) == 0) {
					string acc_count;
					ifstream f_(mac_check, ifstream::binary);
					f_ >> acc_count;
					f_.close();
					int count_ = explode("|", acc_count).size() - 1;
					if (count_ > 0) count__ += count_;
				}
				string ip_check = "db/accounts/ip/" + pInfo(p_)->ip + ".txt";
				if (_access_s(ip_check.c_str(), 0) == 0) {
					string acc_count;
					ifstream f_(ip_check, ifstream::binary);
					f_ >> acc_count;
					f_.close();
					int count_ = explode("|", acc_count).size() - 1;
					if (count_ > 0) count__ += count_;
				}
				if (count__ > 3) max_acc = true;
				bool alreadyhas = false;
				if (pInfo(p_)->tankIDName != "") alreadyhas = true;
				if (alreadyhas)
					p.Insert(r_dialog("`4Oops!``  You already own an account!", user_, pass_, pass_verify_, email_));
				else if (max_acc)
					p.Insert(r_dialog("`4Oops!``  You have too much accounts created.", user_, pass_, pass_verify_, email_));
				else if (bad_name)
					p.Insert(r_dialog("`4Oops!``  Your `wGrowID`` cannot contain `$swear words``.", user_, pass_, pass_verify_, email_));
				else if (not email(email_))
					p.Insert(r_dialog("`4Oops!``  Look, if you'd like to be able try retrieve your password if you lose it, you'd better enter a real email.  We promise to keep your data 100% private and never spam you.", user_, pass_, pass_verify_, email_));
				else if (user_.size() < 3 or user_.size() > 18)
					p.Insert(r_dialog("`4Oops!``  Your `wGrowID`` must be between `$3`` and `$18`` characters long.", user_, pass_, pass_verify_, email_));
				else if (pass_.size() < 8 or pass_.size() > 18)
					p.Insert(r_dialog("`4Oops!``  Your password must be between `$8`` and `$18`` characters long.", user_, pass_, pass_verify_, email_));
				else if (pass_ != pass_verify_)
					p.Insert(r_dialog("`4Oops!``  Passwords don't match.  Try again.", user_, pass_, pass_verify_, email_));
				else if (special_char(user_))
					p.Insert(r_dialog("`4Oops!`` You can only use letters and numbers in your GrowID.", user_, pass_, pass_verify_, email_));
				else if (_access_s(path_.c_str(), 0) == 0)
					p.Insert(r_dialog("`4Oops!`` The name `w" + user_ + "`` is so cool someone else has already taken it.  Please choose a different name.", user_, pass_, pass_verify_, email_));
				else {
					WriteTxt("db/accounts/rid/" + pInfo(p_)->rid, "|" + user_);
					WriteTxt("db/accounts/mac/" + pInfo(p_)->mac, "|" + user_);
					WriteTxt("db/accounts/ip/" + pInfo(p_)->ip, "|" + user_);
					time_t s__;
					s__ = time(NULL);
					int days_ = int(s__) / (60 * 60 * 24);
					pInfo(p_)->account_created = days_;
					pInfo(p_)->playtime = s__;
					pInfo(p_)->inv.push_back({ 18, 1 }), pInfo(p_)->inv.push_back({ 32, 1 }), pInfo(p_)->inv.push_back({ 6336, 1 });
					for (int i_ = 3; i_ <= 16; i_++) { // default inv dydis
						Items itm_{};
						itm_.id = 0, itm_.count = 0;
						pInfo(p_)->inv.push_back(itm_);
					}
					int count = 200;
					modify_inventory(p_, 242, count = 1);//newbie award
					modify_inventory(p_, 954, count = 20);//newbie award
					vector<int> list{ 954, 454, 682, 3004, 1154,4584, 526, 5666, 340, 3838, 5990 };
					modify_inventory(p_, list[rand() % list.size()], count = 50);//newbie award
					modify_inventory(p_, 7164, count = 4);//newbie award
					modify_inventory(p_, 3898, count = 1);//newbie award
					vector<int> list2{ 1008, 866, 872, 928 };
					modify_inventory(p_, list2[rand() % list2.size()], count = 1);//newbie award
					p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wGrowID GET!``|left|206|\nadd_textbox|A `wGrowID`` with the log on of `w" + user_ + "`` created.  Write it and your password down as they will be required to log on from now on!|left|\nend_dialog|growid_apply|Continue||");
					pInfo(p_)->tankIDName = user_, pInfo(p_)->tankIDPass = pass_, pInfo(p_)->email = email_;
					{
						gamepacket_t p;
						p.Insert("SetHasGrowID");
						p.Insert(1);
						p.Insert(user_);
						p.Insert(pass_);
						p.CreatePacket(p_);
					}
					
					(p_);
					save_player(pInfo(p_), false);
				}
				p.CreatePacket(p_);
			}
			catch (exception) {
				cout << "something failed new growid" << endl;
			}
			break;
		}
	}
}
vector<vector<string>> failed_logins{};
void player_login(ENetPeer* peer, string cch) {
	if (pInfo(peer)->tankIDName == "") {
		vector<string> a_ = explode("|", replace_str(cch, "\n", "|"));
		for (int i_ = 0; i_ < a_.size(); i_++) {
			if (a_[i_] == "tankIDName") {
				pInfo(peer)->tankIDName = a_[i_ + 1];
			}
			else if (a_[i_] == "tankIDPass") {
				pInfo(peer)->tankIDPass = a_[i_ + 1];
			}
			else if (a_[i_] == "requestedName") {
				pInfo(peer)->requestedName = a_[i_ + 1];
			}
			else if (a_[i_] == "f") {
			}
			else if (a_[i_] == "protocol") {
			}
			else if (a_[i_] == "game_version") {
				pInfo(peer)->gameversion = a_[i_ + 1];
			}
			else if (a_[i_] == "fz") {
			}
			else if (a_[i_] == "lmode") {
			}
			else if (a_[i_] == "cbits") {
			}
			else if (a_[i_] == "player_age") {
			}
			else if (a_[i_] == "GDPR") {
			}
			else if (a_[i_] == "meta") {
				vector<string> ex = explode("_", a_[i_ + 1]);
				if (ex.size() == 2) {
					pInfo(peer)->meta = ex[0];
				}
				else {
					pInfo(peer)->meta = a_[i_ + 1];
				}
			}
			else if (a_[i_] == "fhash") {
			}
			else if (a_[i_] == "rid") {
				pInfo(peer)->rid = a_[i_ + 1];
			}
			else if (a_[i_] == "platformID") {
				pInfo(peer)->platformid = a_[i_ + 1];
			}
			else if (a_[i_] == "deviceVersion") {
			}
			else if (a_[i_] == "country") {
				if (to_lower(a_[i_ + 1]) == "rt" or to_lower(a_[i_ + 1]) == "ha") {
					packet_(peer, "action|log\nmsg|`4Server protection:`` Your country seems to be incorrect. Make sure you aren't using any hacks.");
					packet_(peer, "action|logon_fail");
					enet_peer_disconnect_later(peer, 0);
					return;
				}
				pInfo(peer)->country = a_[i_ + 1];
			}
			else if (a_[i_] == "hash") {
			}
			else if (a_[i_] == "vid") {
				pInfo(peer)->vid = a_[i_ + 1];
			}
			else if (a_[i_] == "mac") {
				pInfo(peer)->mac = a_[i_ + 1];
			}
			else if (a_[i_] == "wk") {
				pInfo(peer)->wk = a_[i_ + 1];
			}
			else if (a_[i_] == "zf") {
			}
		}
		
		if (not pInfo(peer)->tankIDName.empty()) {
			switch (auth_(peer)) {
			case -1:
			{
				packet_(peer, "`4Unable to log on: `oThat `wGrowID`` doesn't seem valid, or the password is wrong. If you don't have one, press `wCancel``, un-check `w'I have a GrowID'``, then click `wConnect``.", "Retrieve lost password");
				packet_(peer, "action|logon_fail");
				enet_peer_disconnect_later(peer, 0);
				return;
			}
			default:
			{
				break;
			}
			}
			if (has_playmod(pInfo(peer), "Cursed")) {
				join_world(peer, pInfo(peer)->c_world);
				return;
			}
			
			if (pInfo(peer)->b_t + pInfo(peer)->b_s < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) {
				if (not pInfo(peer)->b_r.empty() or not pInfo(peer)->b_b.empty()) {
					packet_(peer, "action|play_sfx\nfile|audio/dialog_confirm.wav\ndelayMS|0");
					gamepacket_t p;
					p.Insert("OnConsoleMessage");
					p.Insert("`oYou are no longer banned. Now be good! (`$Ban`` mod removed)");
					p.CreatePacket(peer);
				}
				pInfo(peer)->b_t = 0;
				pInfo(peer)->b_s = 0;
				pInfo(peer)->b_b = "";
				pInfo(peer)->b_r = "";
			}
			else {
				pInfo(peer)->name_color = (pInfo(peer)->dev == 1 ? "`6@" : pInfo(peer)->superdev == 1 ? "`b@" : (pInfo(peer)->tmod == 1 ? "`#@" : "`0"));
				long long int time = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
				int actualseconds = (pInfo(peer)->b_t + pInfo(peer)->b_s - time) / 1000;
				string time_counted = "";
				if (actualseconds / 86400 >= 1) {
					time_counted += "" + to_string(actualseconds / (24 * 3600)) + " days, ";
					actualseconds = actualseconds % (24 * 3600);
				}
				if (actualseconds / 3600 >= 1) {
					time_counted += "" + to_string(actualseconds / 3600) + " hours, ";
					actualseconds %= 3600;
				}
				if (actualseconds / 60 >= 1) {
					time_counted += "" + to_string(actualseconds / 60) + " mins, ";
					actualseconds %= 60;
				}
				time_counted += "" + to_string(actualseconds) + " secs";
				packet_(peer, "action|log\nmsg|CT:[S]_ `4Sorry, this account, device or location has been temporarily suspended.``", "");
				if (pInfo(peer)->b_r != "No reason") packet_(peer, "action|log\nmsg|CT:[S]_ `bBan Reason: " + pInfo(peer)->b_r + "``", "");
				packet_(peer, "action|log\nmsg|CT:[S]_ If you didn't do anything wrong, it could be because you're playing from the same place or on the same device as someone who did. Contact support at `5https://discord.gg/VDvGrjmgGn`` if you have any questions.", "");
				packet_(peer, "action|log\nmsg|CT:[S]_ This is a temporary ban caused by " + pInfo(peer)->name_color + pInfo(peer)->tankIDName + "`` and will be removed in `0" + time_counted + "``. If that's not your name, try playing from another location or device to fix it.", "");
				packet_(peer, "action|logon_fail");
				enet_peer_disconnect_later(peer, 0);
			}
		}
		if (pInfo(peer)->gameversion < server_version) {
			packet_(peer, "`4UPDATE REQUIRED!`o: The `$" + server_version + " `oupdate is now available for your device. Go get it! You'll need to install it before you can play online.", "Update Growtopia");
			packet_(peer, "action|logon_fail");
		}
		else if (pInfo(peer)->gameversion >= server_version) {
			gamepacket_t p;
			p.Insert("OnSuperMainStartAcceptLogonHrdxs47254722215a");
			p.Insert(item_hash);
			p.Insert("ubistatic-a.akamaihd.net");
			p.Insert("0098/46961/cache/");
			p.Insert("cc.cz.madkite.freedom org.aqua.gg idv.aqua.bulldog com.cih.gamecih2 com.cih.gamecih com.cih.game_cih cn.maocai.gamekiller com.gmd.speedtime org.dax.attack com.x0.strai.frep com.x0.strai.free org.cheatengine.cegui org.sbtools.gamehack com.skgames.traffikrider org.sbtoods.gamehaca com.skype.ralder org.cheatengine.cegui.xx.multi1458919170111 com.prohiro.macro me.autotouch.autotouch com.cygery.repetitouch.free com.cygery.repetitouch.pro com.proziro.zacro com.slash.gamebuster");
			string pay_status = (pInfo(peer)->supp >= 1 ? "1" : "0");
			p.Insert("proto=175|choosemusic=audio/mp3/theme4.mp3|active_holiday=0|wing_week_day=0|ubi_week_day=0|server_tick=24275986|clash_active=0|drop_lavacheck_faster=1|isPayingUser=" + pay_status + "|usingStoreNavigation=1|enableInventoryTab=1|bigBackpack=0|");
			p.Insert("3736352243");
			p.CreatePacket(peer);
		}
	}
}

void add_provider_xp(ENetPeer* peer, int amount) {
	pInfo(peer)->p_xp += amount;
	int required = 75 * ((pInfo(peer)->p_lvl * pInfo(peer)->p_lvl) + 2);
	if (pInfo(peer)->p_xp >= 75 * ((pInfo(peer)->p_lvl * pInfo(peer)->p_lvl) + 2)) {
		pInfo(peer)->p_lvl++;
		pInfo(peer)->p_xp -= required;
		pInfo(peer)->gems += 500;
		{
			gamepacket_t p;
			p.Insert("OnSetBux");
			p.Insert(pInfo(peer)->gems);
			p.Insert(0);
			p.Insert((pInfo(peer)->supp >= 1) ? 1 : 0);
			if (pInfo(peer)->supp >= 2) {
				p.Insert((float)33796, (float)1, (float)0);
			}
			p.CreatePacket(peer);
		}
		gamepacket_t p, p2;
		p.Insert("OnTalkBubble");
		p.Insert(pInfo(peer)->netID);
		p.Insert(pInfo(peer)->name_color + pInfo(peer)->tankIDName + "`` provider's is now level " + to_string(pInfo(peer)->p_lvl) + "!");
		p.Insert(0), p.Insert(0);
		p2.Insert("OnConsoleMessage");
		p2.Insert(pInfo(peer)->name_color + pInfo(peer)->tankIDName + "`` provider's is now level " + to_string(pInfo(peer)->p_lvl) + "!");
		PlayerMoving data_{};
		data_.packetType = 17, data_.netID = 46, data_.YSpeed = 46, data_.x = pInfo(peer)->x + 16, data_.y = pInfo(peer)->y + 16;
		BYTE* raw = packPlayerMoving(&data_);
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
			if (pInfo(peer)->world != pInfo(currentPeer)->world) continue;
			p.CreatePacket(currentPeer);
			p2.CreatePacket(currentPeer);
			send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
		}
		delete[] raw;
	}
}

void add_geiger_xp(ENetPeer* peer, int amount) {
	pInfo(peer)->g_xp += amount;
	int required = 5 * ((pInfo(peer)->g_lvl * pInfo(peer)->g_lvl) + 2);
	if (pInfo(peer)->g_xp >= 5 * ((pInfo(peer)->g_lvl * pInfo(peer)->g_lvl) + 2)) {
		pInfo(peer)->g_lvl++;
		pInfo(peer)->g_xp -= required;
		pInfo(peer)->gems += 500;
		{
			gamepacket_t p;
			p.Insert("OnSetBux");
			p.Insert(pInfo(peer)->gems);
			p.Insert(0);
			p.Insert((pInfo(peer)->supp >= 1) ? 1 : 0);
			if (pInfo(peer)->supp >= 2) {
				p.Insert((float)33796, (float)1, (float)0);
			}
			p.CreatePacket(peer);
		}
		gamepacket_t p, p2;
		p.Insert("OnTalkBubble");
		p.Insert(pInfo(peer)->netID);
		p.Insert(pInfo(peer)->name_color + pInfo(peer)->tankIDName + "`` Geiger Hunting is now level " + to_string(pInfo(peer)->g_lvl) + "!");
		p.Insert(0), p.Insert(0);
		p2.Insert("OnConsoleMessage");
		p2.Insert(pInfo(peer)->name_color + pInfo(peer)->tankIDName + "`` Geiger Hunting is now level " + to_string(pInfo(peer)->g_lvl) + "!");
		PlayerMoving data_{};
		data_.packetType = 17, data_.netID = 46, data_.YSpeed = 46, data_.x = pInfo(peer)->x + 16, data_.y = pInfo(peer)->y + 16;
		BYTE* raw = packPlayerMoving(&data_);
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
			if (pInfo(peer)->world != pInfo(currentPeer)->world) continue;
			p.CreatePacket(currentPeer);
			p2.CreatePacket(currentPeer);
			send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
		}
		delete[] raw;
	}
}

void add_farmer_xp(ENetPeer* peer, int amount) {
	pInfo(peer)->t_xp += amount;
	int required = 100 * ((pInfo(peer)->t_lvl * pInfo(peer)->t_lvl) + 2);
	if (pInfo(peer)->t_xp >= 100 * ((pInfo(peer)->t_lvl * pInfo(peer)->t_lvl) + 2)) {
		pInfo(peer)->t_lvl++;
		pInfo(peer)->t_xp -= required;
		pInfo(peer)->gems += 500;
		{
			gamepacket_t p;
			p.Insert("OnSetBux");
			p.Insert(pInfo(peer)->gems);
			p.Insert(0);
			p.Insert((pInfo(peer)->supp >= 1) ? 1 : 0);
			if (pInfo(peer)->supp >= 2) {
				p.Insert((float)33796, (float)1, (float)0);
			}
			p.CreatePacket(peer);
		}
		gamepacket_t p, p2;
		p.Insert("OnTalkBubble");
		p.Insert(pInfo(peer)->netID);
		p.Insert(pInfo(peer)->name_color + pInfo(peer)->tankIDName + "`` Farmer is now level " + to_string(pInfo(peer)->t_lvl) + "!");
		p.Insert(0), p.Insert(0);
		p2.Insert("OnConsoleMessage");
		p2.Insert(pInfo(peer)->name_color + pInfo(peer)->tankIDName + "`` Farmer is now level " + to_string(pInfo(peer)->t_lvl) + "!");
		PlayerMoving data_{};
		data_.packetType = 17, data_.netID = 46, data_.YSpeed = 46, data_.x = pInfo(peer)->x + 16, data_.y = pInfo(peer)->y + 16;
		BYTE* raw = packPlayerMoving(&data_);
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
			if (pInfo(peer)->world != pInfo(currentPeer)->world) continue;
			p.CreatePacket(currentPeer);
			p2.CreatePacket(currentPeer);
			send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
		}
		delete[] raw;
	}
}

void add_builder_xp(ENetPeer* peer, int amount) {
	pInfo(peer)->bb_xp += amount;
	int required = 100 * ((pInfo(peer)->bb_lvl * pInfo(peer)->bb_lvl) + 2);
	if (pInfo(peer)->bb_xp >= 100 * ((pInfo(peer)->bb_lvl * pInfo(peer)->bb_lvl) + 2)) {
		pInfo(peer)->bb_lvl++;
		pInfo(peer)->bb_xp -= required;
		pInfo(peer)->gems += 500;
		{
			gamepacket_t p;
			p.Insert("OnSetBux");
			p.Insert(pInfo(peer)->gems);
			p.Insert(0);
			p.Insert((pInfo(peer)->supp >= 1) ? 1 : 0);
			if (pInfo(peer)->supp >= 2) {
				p.Insert((float)33796, (float)1, (float)0);
			}
			p.CreatePacket(peer);
		}
		gamepacket_t p, p2;
		p.Insert("OnTalkBubble");
		p.Insert(pInfo(peer)->netID);
		p.Insert(pInfo(peer)->name_color + pInfo(peer)->tankIDName + "`` Builder is now level " + to_string(pInfo(peer)->bb_lvl) + "!");
		p.Insert(0), p.Insert(0);
		p2.Insert("OnConsoleMessage");
		p2.Insert(pInfo(peer)->name_color + pInfo(peer)->tankIDName + "`` Builder is now level " + to_string(pInfo(peer)->bb_lvl) + "!");
		PlayerMoving data_{};
		data_.packetType = 17, data_.netID = 46, data_.YSpeed = 46, data_.x = pInfo(peer)->x + 16, data_.y = pInfo(peer)->y + 16;
		BYTE* raw = packPlayerMoving(&data_);
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
			if (pInfo(peer)->world != pInfo(currentPeer)->world) continue;
			p.CreatePacket(currentPeer);
			p2.CreatePacket(currentPeer);
			send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
		}
		delete[] raw;
	}
}
int choose_random(const int id_) {
	vector<int> ids_;
	int a_ = 0;
	while (items[id_ + a_].properties & Property_RandomGrow) {
		if (items[id_ + a_].blockType != BlockTypes::SEED) ids_.push_back(id_ + a_);
		a_++;
	}
	a_ = 0;
	while (items[id_ - a_].properties & Property_RandomGrow) {
		if (items[id_ - a_].blockType != BlockTypes::SEED) ids_.push_back(id_ - a_);
		a_++;
	}
	return ids_[rand() % ids_.size()];
}
bool use_mag(World* world_, WorldDrop drop_, int x_, int y_) {
	for (int i_ = 0; i_ < world_->machines.size(); i_++) {
		WorldMachines machine_ = world_->machines[i_];
		if (machine_.target_item == drop_.id and machine_.enabled) {
			if (machine_.id == 6948 or machine_.id == 5638 or machine_.id == 6946) {
				WorldBlock* itemas = &world_->blocks[machine_.x + (machine_.y * 100)];
				if (itemas->pr < (machine_.id == 6948 or machine_.id == 6946 ? 1500 : 5000)) {
					PlayerMoving data_{};
					data_.packetType = 19, data_.netID = -1, data_.plantingTree = 0;
					data_.x = machine_.x * 32 + 16, data_.y = machine_.y * 32 + 16;
					data_.XSpeed = x_ * 32 + 16, data_.YSpeed = y_ * 32 + 16;
					data_.punchX = drop_.id;
					BYTE* raw = packPlayerMoving(&data_);
					raw[3] = 6;
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
						if (pInfo(currentPeer)->world == world_->name) {
							send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
						}
					}
					delete[]raw;
					itemas->pr += drop_.count;
					if (itemas->pr >= (machine_.id == 6948 or machine_.id == 6946 ? 1500 : 5000) or itemas->pr == drop_.count) {
						PlayerMoving data_{};
						data_.packetType = 5, data_.punchX = machine_.x, data_.punchY = machine_.y, data_.characterState = 0x8;
						BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, itemas));
						BYTE* blc = raw + 56;
						form_visual(blc, *itemas, *world_, NULL, false);
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
							if (pInfo(currentPeer)->world == world_->name) {
								send_raw(currentPeer, 4, raw, 112 + alloc_(world_, itemas), ENET_PACKET_FLAG_RELIABLE);
							}
						}
						delete[] raw, blc;
						if (itemas->locked) {
							upd_lock(*itemas, *world_, NULL);
						}
					}
					return true;
				}
			}
		}
	}
	return false;
}
void drop_rare_item(World* world_, ENetPeer* peer, int i, int x, int y, bool seed) {
	int giveitem = 0, count = 1, got = 0, remove = -1;
	if (peer != NULL and pInfo(peer)->necklace == 11406 and seed and rand() % 750 < 1) {
		giveitem = items[11406].randomitem[rand() % items[11406].randomitem.size()];
		if (rand() % 25 < 1) giveitem = 11398; // rare 11398
		if (rand() % 2 < 1) modify_inventory(peer, 11406, remove = -1); // 50% chance
	}
	if (rand() % 200 < 1) giveitem = 2914;
	if (rand() % 72 < 1) giveitem = theitemtoday;
	if (items[i].chi == 0 || items[i].chi == 1 || items[i].chi == 2 || items[i].chi == 3) if (rand() % 75 < 1) giveitem = items[i].chi == 0 ? 5028 : items[i].chi == 1 ? 5024 : items[i].chi == 2 ? 5030 : items[i].chi == 3 ? 5026 : 0;
	if (items[i].chance != 0) if (rand() % items[i].chance < 1) giveitem = items[i].randomitem[rand() % items[i].randomitem.size()];
	int chance = 18000;
	if (peer != NULL and pInfo(peer)->hand == 11118) chance = 13000;
	if (rand() % chance < 1 and items[i].farmable and items[i].rarity >= 24) {
		//vector<int> the_ore{ 5136, 9386, 9384 };
		vector<int> the_ore{ 5136, 9384 };
		giveitem = the_ore[rand() % the_ore.size()];
	}
	// guild chest chance
	if (rand() % (chance / 60) < 1 and items[i].farmable and items[i].rarity >= 24) giveitem = 7954;
	if (rand() % (chance / 60) < 1 and items[i].farmable and items[i].rarity >= 24) giveitem = 7484;
	if (rand() % (chance / 40) < 1 and items[i].farmable and items[i].rarity >= 24) giveitem = 5948;
	if (rand() % (chance / 100) < 1 and items[i].farmable and items[i].rarity >= 24) giveitem = 9380;
	if (rand() % (chance / 60) < 1 and items[i].farmable and items[i].rarity >= 24) giveitem = 11038; //summer artifact drop
	if (giveitem == 0) if (rand() % 2000 < 1) giveitem = 5178;
	if (giveitem == 0) if (peer != NULL and has_playmod(pInfo(peer), "Lucky") and (rand() % 8500 < 1)) giveitem = 9428;
	if (i == 8566 || i == 8562 || i == 8564 || i == 8560 && rand() % 72 < 1) giveitem = 8534;
	if (peer != NULL and pInfo(peer)->hand == 8554) {
		if (rand() % 200 < 1) {
			giveitem = 8534;
			count = rand() % 10 + 1;
			if (rand() % 1000 < 1) modify_inventory(peer, 8554, remove);
		}
	}


	/*
lunar update
if (rand() % 45 < 1 and items[i].farmable and items[i].rarity >= 24) {
	vector<int> lunar{ 5742, 5746 };
	giveitem = lunar[rand() % lunar.size()];
}*/

/*
if (seed && rand() % 200 - items[i].rarity < 1) {
	vector<int> harvest{ 1058, 1094, 1096, 1098 };
	giveitem = harvest[rand() % harvest.size()];
	if (rand() % 40 < 1) giveitem = 1828;
	if (pInfo(peer)->necklace == 10158 && giveitem == 1828) {
		count = rand() % 3 + 1;
		if (count >= 2) {
			modify_inventory(peer, 10158, got = -1);
			WorldDrop drop_block_{};
			drop_block_.id = 10228, drop_block_.count = 1, drop_block_.uid = uint16_t(world_->drop.size()) + 1, drop_block_.x = (x * 32) + rand() % 17, drop_block_.y = (y * 32) + rand() % 17;
			if (not use_mag(world_, drop_block_, x, y)) dropas_(world_, drop_block_);
		}
	}
}*/

	if (giveitem != 0) {
		WorldDrop drop_block_{};
		drop_block_.id = giveitem, drop_block_.count = count, drop_block_.uid = uint16_t(world_->drop.size()) + 1, drop_block_.x = (x * 32) + rand() % 17, drop_block_.y = (y * 32) + rand() % 17;
		if (not use_mag(world_, drop_block_, x, y)) dropas_(world_, drop_block_);
	}
}
bool harvest_seed(World* world_, WorldBlock* block_, int x_, int y_, int drop_count, int net_id = -1, ENetPeer* p_ = NULL) {
	bool seed_drop = false;
	if (drop_count != 0) {
		if (items[block_->fg - 1].rarity != 999 and items[block_->fg - 1].blockType != BlockTypes::CLOTHING and rand() % 100 < 30) {
			seed_drop = true;
			WorldDrop drop_seed_{};
			drop_seed_.id = block_->fg;
			drop_seed_.count = 1;
			drop_seed_.uid = uint16_t(world_->drop.size()) + 1;
			drop_seed_.x = (x_ * 32) + rand() % 17;
			drop_seed_.y = (y_ * 32) + rand() % 17;
			if (pInfo(p_)->back == 8908 && modify_inventory(p_, drop_seed_.id, drop_seed_.count) == 0) {
				PlayerMoving data_{};
				data_.packetType = 19, data_.plantingTree = 0, data_.netID = 0;
				data_.punchX = drop_seed_.id, data_.punchY = pInfo(p_)->netID;
				BYTE* raw;
				data_.x = (pInfo(p_)->lastwrenchx * 32) + 10, data_.y = (pInfo(p_)->lastwrenchy * 32) + 16;
				raw = packPlayerMoving(&data_);
				int32_t to_netid = pInfo(p_)->netID;
				raw[3] = 5;
				memcpy(raw + 8, &to_netid, 4);
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != pInfo(p_)->world) continue;
					send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
				}
				delete[] raw;
				int got = 0;
				if (rand() % 250 < 1) {
					modify_inventory(p_, 8908, got = -1);
					modify_inventory(p_, 8940, got = 1);
				}
			}
			else {
				if (not use_mag(world_, drop_seed_, x_, y_)) dropas_(world_, drop_seed_);
			}
		}
		WorldDrop drop_block_{};
		if (items[block_->fg].properties & Property_RandomGrow) {
			drop_block_.id = choose_random(block_->fg);
		}
		else
			drop_block_.id = block_->fg - 1;
		drop_block_.count = drop_count;
		drop_block_.uid = uint16_t(world_->drop.size()) + 1;
		drop_block_.x = (x_ * 32) + rand() % 17;
		drop_block_.y = (y_ * 32) + rand() % 17;
		if (pInfo(p_)->back == 8908 && modify_inventory(p_, drop_block_.id, drop_block_.count) == 0) {
			PlayerMoving data_{};
			data_.packetType = 19, data_.plantingTree = 0, data_.netID = 0;
			data_.punchX = drop_block_.id, data_.punchY = pInfo(p_)->netID;
			BYTE* raw;
			data_.x = (pInfo(p_)->lastwrenchx * 32) + 10, data_.y = (pInfo(p_)->lastwrenchy * 32) + 16;
			raw = packPlayerMoving(&data_);
			int32_t to_netid = pInfo(p_)->netID;
			raw[3] = 5;
			memcpy(raw + 8, &to_netid, 4);
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != pInfo(p_)->world) continue;
				send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
			}
			delete[] raw;
			int got = 0;
			if (rand() % 250 < 1) {
				modify_inventory(p_, 8908, got = -1);
				modify_inventory(p_, 8940, got = 1);
			}
		}
		else {
			if (not use_mag(world_, drop_block_, x_, y_)) dropas_(world_, drop_block_);
		}
	}
	if (items[block_->fg - 1].max_gems != 0) {
		if (p_ != NULL) {
			add_peer_xp(p_, (items[block_->fg].rarity / 5 > 0 ? items[block_->fg].rarity / 5 : 1));
		}
		int c_ = rand() % (items[block_->fg - 1].max_gems + 1);
		if (p_ != NULL) {
			if (has_playmod(pInfo(p_), "Lucky") and ((rand() % 100) + 1) <= 30) {
				PlayerMoving data_{};
				data_.packetType = 17;
				data_.netID = 125;
				data_.YSpeed = 125;
				data_.x = x_ * 32 + 16;
				data_.y = y_ * 32 + 16;
				BYTE* raw = packPlayerMoving(&data_);
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
					if (pInfo(currentPeer)->world == world_->name) {
						send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
					}
				}
				delete[] raw;
				c_ += (rand() % 5) + 1;
			}
		}
		if (c_ != 0) {
			gems_(p_, world_, c_, x_ * 32, y_ * 32, block_->fg);
		}
	}
	PlayerMoving data_{};
	data_.packetType = 12, data_.netID = net_id, data_.plantingTree = block_->fg;
	data_.punchX = x_, data_.punchY = y_;
	int32_t item = -1;
	BYTE* raw = packPlayerMoving(&data_);
	memcpy(raw + 8, &item, 4);
	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
		if (pInfo(currentPeer)->world == world_->name) {
			send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
		}
	}
	delete[]raw;
	reset_(block_, x_, y_, world_);
	return seed_drop;
}

void ChangeName(ENetPeer* peer, string name) {
	gamepacket_t p2(0, pInfo(peer)->netID);
	p2.Insert("OnNameChanged");
	p2.Insert(name + (pInfo(peer)->is_legend ? " of Legend``" : ""));
	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != pInfo(peer)->world) continue;
		p2.CreatePacket(currentPeer);
	}
}

void DoorMove(ENetPeer* peer, int x1, int y1) {
	string name_ = pInfo(peer)->world;
	vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
	if (p != worlds.end()) {
		World* world_ = &worlds[p - worlds.begin()];
		for (int i_ = 0; i_ < world_->blocks.size(); i_++) {
			if (world_->blocks[i_].fg == 6) world_->blocks[i_].fg = 0, update_tile(peer, i_ % 100, i_ / 100, 0, false, true);
			if (i_ < 5400 && world_->blocks[i_].fg == 8) world_->blocks[i_].fg = 0, update_tile(peer, i_ % 100, i_ / 100, 0, false, true);
		}
		world_->blocks[x1 + (y1 * 100)].fg = 6;
		world_->blocks[x1 + (y1 + 1) * 100].fg = 8;
		update_tile(peer, x1, y1, 6, false, true);
		update_tile(peer, x1, y1 + 1, 8, false, true);
	}
}

bool LockMove(ENetPeer* peer, int wx1, int wy1) {
	string name_ = pInfo(peer)->world;
	vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
	if (p != worlds.end()) {
		World* world_ = &worlds[p - worlds.begin()];
		int lock = -1;
		for (int i_ = 0; i_ < world_->blocks.size(); i_++) {
			if (world_->blocks[i_].fg == 202 || world_->blocks[i_].fg == 204 || world_->blocks[i_].fg == 206 || world_->blocks[i_].fg == 4994) continue;
			if (items[world_->blocks[i_].fg].blockType == BlockTypes::LOCK) {
				lock = world_->blocks[i_].fg, world_->blocks[i_].fg = 0, update_tile(peer, i_ % 100, i_ / 100, 0, false, true);
				break;
			}
		}
		if (lock != -1) {
			world_->blocks[wx1 + (wy1) * 100].fg = lock;
			update_tile(peer, wx1, wy1, lock, false, true);
			return true;
		}
	}
	return false;
}
void plant_(World* world_, ENetPeer* peer, WorldBlock* block_, int x_, int y_, int p_, bool upd_visual = true, bool mag_place = false) {
	block_->fruit = items[block_->fg].rarity == 999 ? 1 : (rand() % 4) + 1;
	if (upd_visual)
		punch_tile(peer, x_, y_, 0x3, p_, mag_place ? -1 : pInfo(peer)->netID, 0x0, 1, block_->fruit);
	int timed = items[p_].growTime / 2;
	if (pInfo(peer)->ances == 5082) timed *= 1.02;
	if (pInfo(peer)->ances == 5162) timed *= 1.04;
	if (pInfo(peer)->ances == 5164) timed *= 1.06;
	if (pInfo(peer)->ances == 5166) timed *= 1.08;
	if (pInfo(peer)->ances == 5168) timed *= 1.10;
	if (pInfo(peer)->ances == 5170) timed *= 1.12;
	block_->planted = time(nullptr) - (timed);
	PlayerMoving data_{};
	data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
	BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
	BYTE* blc = raw + 56;
	WorldBlock* block_s = &world_->blocks[x_ + (y_ * 100)];
	form_visual(blc, *block_s, *world_, peer, false);
	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
		if (pInfo(currentPeer)->world == world_->name) {
			send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
		}
	}
	delete[] raw, blc;
	if (block_->locked) {
		upd_lock(*block_, *world_, peer);
	}
}
Position2D track_steam(World* world_, WorldBlock* start_from, int x, int y) {
	Position2D new_pos{ -1, -1 };
	vector<int> new_tiles{};
	new_tiles.push_back((int)x + ((int)y * 100));
	int ySize = world_->blocks.size() / 100, xSize = world_->blocks.size() / ySize;
	vector<WorldBlock> shadow_copy = world_->blocks;
	for (int i2 = 0; i2 < new_tiles.size(); i2++) {
		int x_ = new_tiles[i2] % 100, y_ = new_tiles[i2] / 100;
		if (world_->blocks[x_ + (y_ * 100)].fg == 3724 or world_->blocks[x_ + (y_ * 100)].fg == 3286) {
			new_pos.x = x_, new_pos.y = y_;
			return new_pos;
		}
		else if (world_->blocks[x_ + 1 + (y_ * 100)].fg == 3724 or world_->blocks[x_ + 1 + (y_ * 100)].fg == 3286) {
			new_pos.x = x_ + 1, new_pos.y = y_;
			return new_pos;
		}
		else if (world_->blocks[x_ - 1 + (y_ * 100)].fg == 3724 or world_->blocks[x_ - 1 + (y_ * 100)].fg == 3286) {
			new_pos.x = x_ - 1, new_pos.y = y_;
			return new_pos;
		}
		else if (world_->blocks[x_ + ((y_ + 1) * 100)].fg == 3724 or world_->blocks[x_ + ((y_ + 1) * 100)].fg == 3286) {
			new_pos.x = x_, new_pos.y = y_ + 1;
			return new_pos;
		}
		else if (world_->blocks[x_ + ((y_ - 1) * 100)].fg == 3724 or world_->blocks[x_ + ((y_ - 1) * 100)].fg == 3286) {
			new_pos.x = x_, new_pos.y = y_ - 1;
			return new_pos;
		}

		if (x_ < 99 and shadow_copy[x_ + 1 + (y_ * 100)].fg == 3260) {
			if (not shadow_copy[x_ + 1 + (y_ * 100)].scanned) {
				shadow_copy[x_ + 1 + (y_ * 100)].scanned = true;
				new_tiles.push_back(x_ + 1 + (y_ * 100));
			}

		} if (x_ > 0 and shadow_copy[x_ - 1 + (y_ * 100)].fg == 3260) {
			if (not shadow_copy[x_ - 1 + (y_ * 100)].scanned) {
				shadow_copy[x_ - 1 + (y_ * 100)].scanned = true;
				new_tiles.push_back(x_ - 1 + (y_ * 100));
			}
		} if (y_ < 59 and shadow_copy[x_ + ((y_ + 1) * 100)].fg == 3260) {
			if (not shadow_copy[x_ + ((y_ + 1) * 100)].scanned) {
				shadow_copy[x_ + ((y_ + 1) * 100)].scanned = true;
				new_tiles.push_back(x_ + ((y_ + 1) * 100));
			}
		} if (y_ > 0 and shadow_copy[x_ + ((y_ - 1) * 100)].fg == 3260) {
			if (not shadow_copy[x_ + ((y_ - 1) * 100)].scanned) {
				shadow_copy[x_ + ((y_ - 1) * 100)].scanned = true;
				new_tiles.push_back(x_ + ((y_ - 1) * 100));
			}
		}
	}
	return new_pos;
}
bool ar_turi_noclipa(World* world_, int x, int y, WorldBlock* target_, ENetPeer* p_) {
	//try {
	vector<int> new_tiles{};
	if (items[world_->blocks[(int)x / 32 + ((int)y / 32 * 100)].fg].collisionType != 1 or items[world_->blocks[(int)x / 32 + ((int)y / 32 * 100)].fg].entrance or items[world_->blocks[(int)x / 32 + ((int)y / 32 * 100)].fg].toggleable or items[world_->blocks[(int)x / 32 + ((int)y / 32 * 100)].fg].vipentrance) {
		if (items[world_->blocks[(int)x / 32 + ((int)y / 32 * 100)].fg].vipentrance and not world_->blocks[(int)x / 32 + ((int)y / 32 * 100)].limit_admins and world_->owner_name != pInfo(p_)->tankIDName and not world_->owner_name.empty() and find(world_->blocks[(int)x / 32 + ((int)y / 32 * 100)].admins.begin(), world_->blocks[(int)x / 32 + ((int)y / 32 * 100)].admins.end(), pInfo(p_)->tankIDName) == world_->blocks[(int)x / 32 + ((int)y / 32 * 100)].admins.end()) {

		}
		else if (items[world_->blocks[(int)x / 32 + ((int)y / 32 * 100)].fg].entrance and is_false_state(world_->blocks[(int)x / 32 + ((int)y / 32 * 100)], 0x00800000) and world_->owner_name != pInfo(p_)->tankIDName and not world_->open_to_public and not world_->owner_name.empty() and !guild_access(p_, world_->guild_id) and find(world_->admins.begin(), world_->admins.end(), pInfo(p_)->tankIDName) == world_->admins.end()) {
		}
		else if (items[world_->blocks[(int)x / 32 + ((int)y / 32 * 100)].fg].toggleable and is_false_state(world_->blocks[(int)x / 32 + ((int)y / 32 * 100)], 0x00400000)) {
		}
		else {
			new_tiles.push_back((int)x / 32 + ((int)y / 32 * 100));
		}
	} int ySize = world_->blocks.size() / 100, xSize = world_->blocks.size() / ySize;
	vector<WorldBlock> shadow_copy = world_->blocks;
	for (int i2 = 0; i2 < new_tiles.size(); i2++) {
		int x_ = new_tiles[i2] % 100, y_ = new_tiles[i2] / 100;
		/*if (abs(x_ - x) >= 10 and abs(y_ - y) >= 10) {
			return true;
		}*/
		if (&world_->blocks[x_ + (y_ * 100)] == target_ and items[shadow_copy[x_ + (y_ * 100)].fg].collisionType != 1) {
			return false;
		} if (x_ < 99 and items[shadow_copy[x_ + 1 + (y_ * 100)].fg].collisionType != 1 or x_ < 99 and items[shadow_copy[x_ + 1 + (y_ * 100)].fg].entrance or x_ < 99 and items[shadow_copy[x_ + 1 + (y_ * 100)].fg].toggleable) {
			if (items[shadow_copy[x_ + 1 + (y_ * 100)].fg].vipentrance and not shadow_copy[x_ + 1 + (y_ * 100)].limit_admins and world_->owner_name != pInfo(p_)->tankIDName and not world_->owner_name.empty() and find(shadow_copy[x_ + 1 + (y_ * 100)].admins.begin(), shadow_copy[x_ + 1 + (y_ * 100)].admins.end(), pInfo(p_)->tankIDName) == shadow_copy[x_ + 1 + (y_ * 100)].admins.end()) {

			}
			else if (items[shadow_copy[x_ + 1 + (y_ * 100)].fg].entrance and is_false_state(shadow_copy[x_ + 1 + (y_ * 100)], 0x00800000) and world_->owner_name != pInfo(p_)->tankIDName and not world_->open_to_public and not world_->owner_name.empty() and !guild_access(p_, world_->guild_id) and find(world_->admins.begin(), world_->admins.end(), pInfo(p_)->tankIDName) == world_->admins.end()) {
			}
			else if (items[shadow_copy[x_ + 1 + (y_ * 100)].fg].toggleable and is_false_state(shadow_copy[x_ + 1 + (y_ * 100)], 0x00400000)) {
			}
			else {
				if (not shadow_copy[x_ + 1 + (y_ * 100)].scanned) {
					shadow_copy[x_ + 1 + (y_ * 100)].scanned = true;
					new_tiles.push_back(x_ + 1 + (y_ * 100));
				}
			}
		} if (x_ > 0 and items[shadow_copy[x_ - 1 + (y_ * 100)].fg].collisionType != 1 or x_ > 0 and items[shadow_copy[x_ - 1 + (y_ * 100)].fg].entrance or x_ > 0 and items[shadow_copy[x_ - 1 + (y_ * 100)].fg].toggleable) {
			if (items[shadow_copy[x_ - 1 + (y_ * 100)].fg].vipentrance and not shadow_copy[x_ - 1 + (y_ * 100)].limit_admins and world_->owner_name != pInfo(p_)->tankIDName and not world_->owner_name.empty() and find(shadow_copy[x_ - 1 + (y_ * 100)].admins.begin(), shadow_copy[x_ - 1 + (y_ * 100)].admins.end(), pInfo(p_)->tankIDName) == shadow_copy[x_ - 1 + (y_ * 100)].admins.end()) {

			}
			else if (items[shadow_copy[x_ - 1 + (y_ * 100)].fg].entrance and is_false_state(shadow_copy[x_ - 1 + (y_ * 100)], 0x00800000) and world_->owner_name != pInfo(p_)->tankIDName and not world_->open_to_public and not world_->owner_name.empty() and !guild_access(p_, world_->guild_id) and find(world_->admins.begin(), world_->admins.end(), pInfo(p_)->tankIDName) == world_->admins.end()) {
			}
			else if (items[shadow_copy[x_ - 1 + (y_ * 100)].fg].toggleable and is_false_state(shadow_copy[x_ - 1 + (y_ * 100)], 0x00400000)) {
			}
			else {
				if (not shadow_copy[x_ - 1 + (y_ * 100)].scanned) {
					shadow_copy[x_ - 1 + (y_ * 100)].scanned = true;
					new_tiles.push_back(x_ - 1 + (y_ * 100));
				}
			}
		} if (y_ < 59 and items[shadow_copy[x_ + ((y_ + 1) * 100)].fg].collisionType != 1 or y_ < 59 and items[shadow_copy[x_ + ((y_ + 1) * 100)].fg].entrance or y_ < 59 and items[shadow_copy[x_ + ((y_ + 1) * 100)].fg].toggleable) {
			if (items[shadow_copy[x_ + ((y_ + 1) * 100)].fg].vipentrance and not shadow_copy[x_ + ((y_ + 1) * 100)].limit_admins and world_->owner_name != pInfo(p_)->tankIDName and not world_->owner_name.empty() and find(shadow_copy[x_ + ((y_ + 1) * 100)].admins.begin(), shadow_copy[x_ + ((y_ + 1) * 100)].admins.end(), pInfo(p_)->tankIDName) == shadow_copy[x_ + ((y_ + 1) * 100)].admins.end()) {

			}
			else if (items[shadow_copy[x_ + ((y_ + 1) * 100)].fg].entrance and is_false_state(shadow_copy[x_ + ((y_ + 1) * 100)], 0x00800000) and world_->owner_name != pInfo(p_)->tankIDName and not world_->open_to_public and not world_->owner_name.empty() and !guild_access(p_, world_->guild_id) and find(world_->admins.begin(), world_->admins.end(), pInfo(p_)->tankIDName) == world_->admins.end()) {
			}
			else if (items[shadow_copy[x_ + ((y_ + 1) * 100)].fg].toggleable and is_false_state(shadow_copy[x_ + ((y_ + 1) * 100)], 0x00400000)) {
			}
			else {
				if (not shadow_copy[x_ + ((y_ + 1) * 100)].scanned) {
					shadow_copy[x_ + ((y_ + 1) * 100)].scanned = true;
					new_tiles.push_back(x_ + ((y_ + 1) * 100));
				}
			}
		} if (y_ > 0 and items[shadow_copy[x_ + ((y_ - 1) * 100)].fg].collisionType != 1 or y_ > 0 and items[shadow_copy[x_ + 1 + ((y_ - 1) * 100)].fg].entrance or y_ > 0 and items[shadow_copy[x_ + 1 + ((y_ - 1) * 100)].fg].toggleable) {
			if (items[shadow_copy[x_ + ((y_ - 1) * 100)].fg].vipentrance and not shadow_copy[x_ + ((y_ - 1) * 100)].limit_admins and world_->owner_name != pInfo(p_)->tankIDName and not world_->owner_name.empty() and find(shadow_copy[x_ + ((y_ - 1) * 100)].admins.begin(), shadow_copy[x_ + ((y_ - 1) * 100)].admins.end(), pInfo(p_)->tankIDName) == shadow_copy[x_ + ((y_ - 1) * 100)].admins.end()) {

			}
			else if (items[shadow_copy[x_ + ((y_ - 1) * 100)].fg].entrance and is_false_state(shadow_copy[x_ + ((y_ - 1) * 100)], 0x00800000) and world_->owner_name != pInfo(p_)->tankIDName and not world_->open_to_public and not world_->owner_name.empty() and !guild_access(p_, world_->guild_id) and find(world_->admins.begin(), world_->admins.end(), pInfo(p_)->tankIDName) == world_->admins.end()) {
			}
			else if (items[shadow_copy[x_ + ((y_ - 1) * 100)].fg].toggleable and is_false_state(shadow_copy[x_ + ((y_ - 1) * 100)], 0x00400000)) {
			}
			else {
				if (not shadow_copy[x_ + ((y_ - 1) * 100)].scanned) {
					shadow_copy[x_ + ((y_ - 1) * 100)].scanned = true;
					new_tiles.push_back(x_ + ((y_ - 1) * 100));
				}
			}
		}
	}
	return true;
	//}
	//catch (out_of_range) {
		//return false;
	//}
}
bool edit_tile(ENetPeer* peer, int x_, int y_, int p_, bool mag_place = false) {
	if (x_ < 0 or x_ >= 100 or y_ < 0 or y_ >= 60 or p_ < 0 or p_ >= items.size()) return false;
	if (items[p_].blocked_place) return false;
	string name_ = pInfo(peer)->world;
	if (pInfo(peer)->lastwrenchx != x_ || pInfo(peer)->lastwrenchy != y_) pInfo(peer)->random_fossil = rand() % 3 + 4;
	pInfo(peer)->lastwrenchx = x_;
	pInfo(peer)->lastwrenchy = y_;
	vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
	if (p != worlds.end()) {
		World* world_ = &worlds[p - worlds.begin()];
		WorldBlock* block_ = &world_->blocks[x_ + (y_ * 100)];
		if (block_->bg >= items.size()) block_->bg = 0;
		uint16_t t_ = (block_->fg ? block_->fg : block_->bg);
		if (p_ == 3002 and t_ != 3004) return false;
		switch (p_) {
		case 18:
		{
			if (t_ == 0) {
				break;
			}
			if (items[t_].properties & Property_Mod and not pInfo(peer)->superdev and not pInfo(peer)->dev) {
				packet_(peer, "action|play_sfx\nfile|audio/cant_place_tile.wav\ndelayMS|0");
				gamepacket_t p;
				p.Insert("OnTalkBubble");
				p.Insert(pInfo(peer)->netID);
				p.Insert(items[t_].blockType == BlockTypes::MAIN_DOOR ? "(stand over and punch to use)" : "It's too strong to break.");
				p.Insert(0);
				p.Insert(1);
				p.CreatePacket(peer);
				break;
			}
			else if (t_ == 3470) {
				if (pInfo(peer)->hand == 3466 || pInfo(peer)->hand == 4506) {
					WorldDrop drop_block_{};
					drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
					PlayerMoving data_{};
					data_.effect_flags_check = 1, data_.packetType = 14, data_.netID = 0;
					for (int i_ = 0; i_ < world_->drop.size(); i_++) {
						if (world_->drop[i_].id == 0) continue;
						if (x_ == world_->drop[i_].x / 32 && y_ == world_->drop[i_].y / 32) {
							if (items[world_->drop[i_].id].blockType == BlockTypes::FISH || world_->drop[i_].id == 866 || world_->drop[i_].id == 872 || world_->drop[i_].id == 7050) {
								if (world_->drop[i_].id == 3032 && world_->drop[i_].count == 90 && rand() % 100 < 5) {
									drop_block_.id = 5486, drop_block_.count = 1, drop_block_.uid = uint16_t(world_->drop.size()) + 1;
									dropas_(world_, drop_block_);
								}
								else if (world_->drop[i_].id == 5450 && world_->drop[i_].count == 50 && rand() % 100 < 10) {
									drop_block_.id = 6806, drop_block_.count = 1, drop_block_.uid = uint16_t(world_->drop.size()) + 1;
									dropas_(world_, drop_block_);
								}
								data_.plantingTree = world_->drop[i_].uid;
								BYTE* raw = packPlayerMoving(&data_);
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world) continue;
									send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
								}
								delete[] raw;
								if (items[world_->drop[i_].id].blockType == BlockTypes::FISH && world_->drop[i_].count < 10 && rand() % 100 < 40) {
									PlayerMoving data_{};
									data_.packetType = 17, data_.netID = 45, data_.YSpeed = 45, data_.x = (x_ * 32) + 16, data_.y = (y_ * 32) + 16;
									BYTE* raw = packPlayerMoving(&data_);
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world) continue;
										send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
									}
									delete[] raw;
									world_->drop[i_].id = 0, world_->drop[i_].x = -1, world_->drop[i_].y = -1;
									break;
								}
								int drop_count = 1;
								if (items[world_->drop[i_].id].blockType == BlockTypes::FISH && world_->drop[i_].count >= 10) drop_count = world_->drop[i_].count / 10;
								if (world_->drop[i_].id == 866 || world_->drop[i_].id == 872 || world_->drop[i_].id == 7050) drop_count = world_->drop[i_].count;
								drop_block_.id = world_->drop[i_].id == 866 ? 4578 : world_->drop[i_].id == 872 ? 4588 : world_->drop[i_].id == 7050 ? 7052 : 3468, drop_block_.count = drop_count, drop_block_.uid = uint16_t(world_->drop.size()) + 1;
								dropas_(world_, drop_block_);
								world_->drop[i_].id = 0, world_->drop[i_].x = -1, world_->drop[i_].y = -1;
							}
						}
					}
				}
			}
			else if (t_ == 758) {
				if (pInfo(peer)->i758 + 1000 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) {
					pInfo(peer)->i758 = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
					int get37 = rand() % 37;
					if (pInfo(peer)->csn != -1 && pInfo(peer)->csn < 37) get37 = pInfo(peer)->csn;
					string color = "";
					if (get37 == 36 || get37 == 34 || get37 == 32 || get37 == 30 || get37 == 27 || get37 == 25 || get37 == 23 || get37 == 21 || get37 == 19 || get37 == 18 || get37 == 16 || get37 == 12 || get37 == 9 || get37 == 7 || get37 == 5 || get37 == 3 || get37 == 1) color = "`4";
					else if (get37 == 0) color = "`2";
					else color = "`b";
					string wheel = "`7[``" + pInfo(peer)->name_color + pInfo(peer)->tankIDName + "`` spun the wheel and got " + color + to_string(get37) + "``!`7]``";
					gamepacket_t p(2000), p2(2000);
					p.Insert("OnTalkBubble");
					p.Insert(pInfo(peer)->netID);
					p.Insert(wheel);
					p.Insert(0);
					p2.Insert("OnConsoleMessage");
					p2.Insert(wheel);
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
						if (pInfo(currentPeer)->world == pInfo(peer)->world) {
							p.CreatePacket(currentPeer);
							p2.CreatePacket(currentPeer);
						}
					}
					punch_tile(peer, x_, y_, 0x8, 0, pInfo(peer)->netID, 0x0);
				}
			}
			else if (t_ == 756) {
				if (pInfo(peer)->i756 + 1000 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) {
					pInfo(peer)->i756 = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
					int get1 = rand() % 10;
					string wheel = "`7[``" + pInfo(peer)->name_color + pInfo(peer)->tankIDName + "`` " + (get1 == 1 ? "`2wins at slots!`" : "`4loses at slots.`") + "``7]``";
					if (get1 == 1) {
						PlayerMoving data_{};
						data_.packetType = 17;
						data_.netID = 29;
						data_.YSpeed = 29;
						data_.x = (x_ * 32) + 16;
						data_.y = (y_ * 32) + 16;
						BYTE* raw = packPlayerMoving(&data_);
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
							if (pInfo(peer)->world != pInfo(currentPeer)->world) continue;
							send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
						}
						delete[] raw;
					}
					gamepacket_t p(2000), p2(2000), p3(2000);
					p.Insert("OnTalkBubble");
					p.Insert(pInfo(peer)->netID);
					p.Insert(wheel);
					p.Insert(0);
					p2.Insert("OnConsoleMessage");
					p2.Insert(wheel);
					p3.Insert("OnPlayPositioned");
					p3.Insert(get1 == 1 ? "audio/slot_win.wav" : "audio/slot_lose.wav");
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
						if (pInfo(currentPeer)->world == pInfo(peer)->world) {
							p.CreatePacket(currentPeer);
							p2.CreatePacket(currentPeer);
							p3.CreatePacket(currentPeer);
						}
					}
					punch_tile(peer, x_, y_, 0x8, 0, pInfo(peer)->netID, 0x0);
				}
			}
			else if (t_ == 1482 || t_ == 2252 || t_ == 7864 || t_ == 11434) {
				struct tm newtime;
				time_t now = time(0);
				localtime_s(&newtime, &now);
				gamepacket_t p;
				const char* months[12] = { "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" };
				string month = months[newtime.tm_mon], translated = "", str = to_string(newtime.tm_mday), locke = "";
				if (str == "1" || str == "21") translated = "st";
				else if (str == "2" || str == "22") translated = "nd";
				else if (str == "3") translated = "rd";
				else translated = "th";
				p.Insert("OnTalkBubble");
				p.Insert(pInfo(peer)->netID);
				p.Insert("It's " + currentTime() + " on " + month + " " + to_string(newtime.tm_mday) + translated);
				p.Insert(0);
				p.Insert(1);
				p.CreatePacket(peer);
			}
			if (items[t_].toggleable or items[t_].blockType == BlockTypes::CHEMICAL_COMBINER) {
				if (block_->flags & 0x00800000 or world_->owner_name == pInfo(peer)->tankIDName or guild_access(peer, world_->guild_id) or find(world_->admins.begin(), world_->admins.end(), pInfo(peer)->tankIDName) != world_->admins.end() or world_->open_to_public or pInfo(peer)->dev) {
					block_->flags = (block_->flags & 0x00400000 ? block_->flags ^ 0x00400000 : block_->flags | 0x00400000);
					if (t_ == 226) {
						gamepacket_t p;
						p.Insert("OnConsoleMessage");
						if (block_->flags & 0x00400000) {
							p.Insert("Signal jammer enabled. This world is now `4hidden`` from the universe.");
						}
						else {
							p.Insert("Signal jammer disabled. This world is `2visible`` to the universe.");
						}
						p.CreatePacket(peer);
					}
					if (t_ == 4992) {
						//gamepacket_t p;
						//p.Insert("OnConsoleMessage");
						if (block_->flags & 0x00400000) {
							//p.Insert("`3Antigravity was enabled.``");
						}
						else {
							//p.Insert("`4Antigravity was disabled.``");
						}
						//p.CreatePacket(peer);
					}
					if (t_ == 226 or t_ == 3616 or t_ == 1276 or t_ == 1278 or t_ == 4758 or t_ == 3750 or t_ == 4992 or t_ == 3072 or t_ == 4884) {
						if (block_->flags & 0x00400000) {
							world_->active_jammers.push_back(t_);
						}
						else {
							world_->active_jammers.erase(remove(world_->active_jammers.begin(), world_->active_jammers.end(), t_), world_->active_jammers.end());
						}
					}
				}
			}
			// nuo cia non access negales nieko padaryt:
			if (items[t_].toggleable) {
				string owner_name = world_->owner_name, user_name = pInfo(peer)->tankIDName;
				if (block_->flags & 0x00800000 and not world_->owner_name.empty() and owner_name != user_name and !guild_access(peer, world_->guild_id) and find(world_->admins.begin(), world_->admins.end(), pInfo(peer)->tankIDName) == world_->admins.end() and not pInfo(peer)->dev) {
					gamepacket_t p(0, pInfo(peer)->netID);
					p.Insert("OnPlayPositioned");
					p.Insert("audio/punch_locked.wav");
					if (not pInfo(peer)->invis) {
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
							if (pInfo(currentPeer)->world == name_) {
								p.CreatePacket(currentPeer);
							}
						}
					}
					else {
						p.CreatePacket(peer);
					}
					punch_tile(peer, x_, y_, 0x8, 0, pInfo(peer)->netID, 16);
					return true;
				}
			}
			if (items[t_].properties & Property_Public) { /*cout << "public block break" << endl;*/ }
			else {
				if (block_->fg == 3918 || block_->fg == 3922 || block_->fg == 3928) {
					if (pInfo(peer)->hand == 3932) {
						pInfo(peer)->random_fossil -= 1;
						gamepacket_t p;
						p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
						if (pInfo(peer)->random_fossil == 0) {
							block_->fossil = true;
							p.Insert("`2I unearthed a Fossil!`` I better be careful getting it out...");
							PlayerMoving data_{};
							data_.packetType = 5, data_.punchX = pInfo(peer)->lastwrenchx, data_.punchY = pInfo(peer)->lastwrenchy, data_.characterState = 0x8;
							BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
							BYTE* blc = raw + 56;
							form_visual(blc, *block_, *world_, peer, false, true);
							for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
								if (pInfo(peer)->world != pInfo(currentPeer)->world) continue;
								send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
							}
							delete[] raw, blc;
						}
						else if (pInfo(peer)->random_fossil < 0) {
							pInfo(peer)->random_fossil = rand() % 3 + 4;
							p.Insert("`4I smashed a Fossil!``");
							block_->fg = 10;
							update_tile(peer, x_, y_, 10, false, true);
						}
						p.Insert(0), p.Insert(1), p.CreatePacket(peer);
					}
				}
				else if (block_->fg == 202 or block_->fg == 204 or block_->fg == 206 or block_->fg == 4994) {
					if (block_->owner_name != pInfo(peer)->tankIDName) {
						if (items[t_].blockType == BlockTypes::LOCK) {
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(peer)->netID);
							string owner_name = block_->owner_name;
							if (world_->owner_named != "") {
								if (world_->owner_named.substr(0, 2) == "`o") owner_name = "`w" + world_->owner_name;
								else owner_name = world_->owner_named;
							}
							if (owner_name == "") owner_name = "`w" + world_->owner_name;
							if (block_->open_to_public)
								p.Insert("" + owner_name + "``'s `$" + items[t_].name + "``. (`wOpen to public``)");
							else if (find(block_->admins.begin(), block_->admins.end(), pInfo(peer)->tankIDName) != block_->admins.end())
								p.Insert("" + owner_name + "``'s `$" + items[t_].name + "``. (`wAccess granted``)");
							else
								p.Insert("" + owner_name + "``'s `$" + items[t_].name + "``. (`4No access``)");
							p.Insert(0);
							p.Insert(1);
							p.CreatePacket(peer);
							if (not pInfo(peer)->dev) {
								{
									gamepacket_t p(0, pInfo(peer)->netID);
									p.Insert("OnPlayPositioned");
									p.Insert("audio/punch_locked.wav");
									if (not pInfo(peer)->invis) {
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
											if (pInfo(currentPeer)->world == name_) {
												p.CreatePacket(currentPeer);
											}
										}
									}
									else {
										p.CreatePacket(peer);
									}
								}
								return true;
							}
						}
					}
				}
				else if (block_->locked) {
					WorldBlock* block2_ = &world_->blocks[block_->lock_origin];
					string owner_name = block2_->owner_name, user_name = pInfo(peer)->tankIDName;
					if (owner_name != user_name and not pInfo(peer)->dev) {
						if (block2_->fg == 4994 or not block2_->open_to_public and find(block2_->admins.begin(), block2_->admins.end(), pInfo(peer)->tankIDName) == block2_->admins.end()) {
							if (block2_->fg == 4994) {
								if (not block2_->open_to_public) {
									gamepacket_t p(0, pInfo(peer)->netID);
									p.Insert("OnPlayPositioned");
									p.Insert("audio/punch_locked.wav");
									if (not pInfo(peer)->invis) {
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
											if (pInfo(currentPeer)->world == name_) {
												p.CreatePacket(currentPeer);
											}
										}
									}
									else {
										p.CreatePacket(peer);
									}
									return true;
								}
								if (block2_->build_only and block2_->open_to_public) {
									if (not pInfo(peer)->dev) {
										gamepacket_t p(0, pInfo(peer)->netID);
										p.Insert("OnPlayPositioned");
										p.Insert("audio/punch_locked.wav");
										if (not pInfo(peer)->invis) {
											for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
												if (pInfo(currentPeer)->world == name_) {
													p.CreatePacket(currentPeer);
												}
											}
										}
										else {
											p.CreatePacket(peer);
										}
										{
											gamepacket_t p;
											p.Insert("OnTalkBubble");
											p.Insert(pInfo(peer)->netID);
											p.Insert("This lock allows building only!");
											p.Insert(0);
											p.Insert(1);
											p.CreatePacket(peer);
										}
										return true;
									}
								}
							}
							else {
								if (not pInfo(peer)->dev) {
									gamepacket_t p(0, pInfo(peer)->netID);
									p.Insert("OnPlayPositioned");
									p.Insert("audio/punch_locked.wav");
									if (not pInfo(peer)->invis) {
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
											if (pInfo(currentPeer)->world == name_) {
												p.CreatePacket(currentPeer);
											}
										}
									}
									else {
										p.CreatePacket(peer);
									}
									return true;
								}
							}
						}
					}
				}
				else if (not world_->owner_name.empty()) {
					string owner_name = world_->owner_name, user_name = pInfo(peer)->tankIDName;
					if (owner_name != user_name) {
						if (items[t_].blockType == BlockTypes::LOCK) {
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(peer)->netID);
							string owner_name = "";
							if (world_->owner_named.substr(0, 2) == "`o") owner_name = "`w" + world_->owner_name;
							else owner_name = world_->owner_named;
							if (owner_name == "") owner_name = "`w" + world_->owner_name;
							if (world_->open_to_public)
								p.Insert("" + owner_name + "``'s `$" + items[t_].name + "``. (`wOpen to public``)");
							else if (guild_access(peer, world_->guild_id) or find(world_->admins.begin(), world_->admins.end(), user_name) != world_->admins.end())
								p.Insert("" + owner_name + "``'s `$" + items[t_].name + "``. (`wAccess granted``)");
							else
								p.Insert("" + owner_name + "``'s `$" + items[t_].name + "``. (`4No access``)");
							p.Insert(0);
							p.Insert(1);
							p.CreatePacket(peer);
							if (not pInfo(peer)->dev) {
								{
									gamepacket_t p(0, pInfo(peer)->netID);
									p.Insert("OnPlayPositioned");
									p.Insert("audio/punch_locked.wav");
									if (not pInfo(peer)->invis) {
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
											if (pInfo(currentPeer)->world == name_) {
												p.CreatePacket(currentPeer);
											}
										}
									}
									else {
										p.CreatePacket(peer);
									}
								}
								return true;
							}
						}
						if (not world_->open_to_public and !guild_access(peer, world_->guild_id) and find(world_->admins.begin(), world_->admins.end(), user_name) == world_->admins.end()) {
							if (not pInfo(peer)->dev) {
								gamepacket_t p(0, pInfo(peer)->netID);
								p.Insert("OnPlayPositioned");
								p.Insert("audio/punch_locked.wav");
								if (not pInfo(peer)->invis) {
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
										if (pInfo(currentPeer)->world == name_) {
											p.CreatePacket(currentPeer);
										}
									}
								}
								else {
									p.CreatePacket(peer);
								}
								return true;
							}
						}
					}
				} if (world_->owner_name != pInfo(peer)->tankIDName) {
					if (items[t_].magplant) {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(peer)->netID);
						p.Insert("Only the `9World Owner`` can activate this!");
						p.Insert(0), p.Insert(0);
						p.CreatePacket(peer);
						return true;
					}
				}
			}
			if (items[t_].magplant) {
				switch (t_) {
				case 6950: case 6952:
				{
					if (block_->id != 0) {
						block_->enabled = (block_->enabled ? false : true);
						for (int i_ = 0; i_ < world_->machines.size(); i_++) {
							WorldMachines* machine_ = &world_->machines[i_];
							if (machine_->x == x_ and machine_->y == y_) {
								machine_->enabled = block_->enabled;
								break;
							}
						}
						PlayerMoving data_{};
						data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
						BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
						BYTE* blc = raw + 56;
						form_visual(blc, *block_, *world_, peer, false);
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
							if (pInfo(currentPeer)->world == world_->name) {
								send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
							}
						}
						delete[] raw, blc;
						if (block_->locked) {
							upd_lock(*block_, *world_, peer);
						}
					}
					break;
				}
				}
			}
			if (items[t_].blockType == BlockTypes::CHEMICAL_COMBINER) {
				if (block_->flags & 0x00400000) {

				}
				else {
					vector<vector<int>> comb;
					bool combined = false;
					for (int i_ = 0; i_ < world_->drop.size(); i_++) {
						if (world_->drop[i_].id == 0) continue;
						if (x_ == (world_->drop[i_].x / 32) && y_ == (world_->drop[i_].y / 32)) {
							comb.push_back({ world_->drop[i_].id, world_->drop[i_].count });
						}
					}
					gamepacket_t p;
					p.Insert("OnTalkBubble");
					p.Insert(pInfo(peer)->netID);
					if (comb.size() < 3) p.Insert("I need 3 ingredients!");
					if (comb.size() > 3) p.Insert("It won't mix more than 3 items at once!");
					if (comb.size() == 3) {
						for (vector<vector<int>>recipe : receptai) {
							uint32_t result_item_id = recipe[3][0];
							uint32_t result_gives_per_recipe = recipe[3][1];
							vector<int> compare1, compare2;
							vector<vector<vector<int>>> info{ {}, {} };
							for (int i_ = 0; i_ < 3; i_++) {
								compare1.push_back(recipe[i_][0]);
								info[0].push_back({ recipe[i_][0], recipe[i_][1] });
							} for (vector<int>item_id : comb) {
								compare2.push_back(item_id[0]);
								info[1].push_back({ item_id[0], item_id[1] });
							} sort(compare1.begin(), compare1.end()), sort(compare2.begin(), compare2.end());
							if (compare1 == compare2) {
								sort(info[0].begin(), info[0].end()), sort(info[1].begin(), info[1].end());
								bool no = false;
								for (int i_ = 0; i_ < info[0].size(); i_++) {
									if (info[0][i_][1] > info[1][i_][1]) {
										no = true;
										break;
									}
								} if (no) break;
								uint32_t result_item_count = 0;
								uint32_t times_ = 0;
								for (int i_ = 0; i_ < world_->drop.size(); i_++) {
									if (no) break;
									if (world_->drop[i_].id == 0) continue;
									if (x_ == (world_->drop[i_].x / 32) && y_ == (world_->drop[i_].y / 32)) {
										for (int i_2 = 0; i_2 < info[0].size(); i_2++) {
											if (info[0][i_2][0] == world_->drop[i_].id) {
												if (info[0][i_2][1] > info[1][i_2][1]) {
													break;
												}
												world_->drop[i_].count -= info[0][i_2][1];
												info[1][i_2][1] = world_->drop[i_].count;
												times_++;
												if (world_->drop[i_].count <= 0) {
													PlayerMoving data_{};
													data_.packetType = 14, data_.netID = -2, data_.plantingTree = world_->drop[i_].uid;
													BYTE* raw = packPlayerMoving(&data_);
													int32_t item = -1;
													memcpy(raw + 8, &item, 4);
													for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
														if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
														if (pInfo(currentPeer)->world == name_) {
															send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
														}
													}
													world_->drop[i_].id = 0, world_->drop[i_].x = -1, world_->drop[i_].y = -1;
													delete[] raw;
												}
												else {
													PlayerMoving data_{};
													data_.packetType = 14, data_.netID = -2, data_.plantingTree = world_->drop[i_].uid;
													BYTE* raw = packPlayerMoving(&data_);
													int32_t item = -1;
													memcpy(raw + 8, &item, 4);
													for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
														if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
														if (pInfo(currentPeer)->world == name_) {
															send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
														}
													}
													delete[] raw;
													WorldDrop drop_{};
													drop_.id = world_->drop[i_].id;
													drop_.count = world_->drop[i_].count;
													drop_.uid = uint16_t(world_->drop.size()) + 1;
													drop_.x = world_->drop[i_].x;
													drop_.y = world_->drop[i_].y;
													world_->drop[i_].id = 0, world_->drop[i_].x = -1, world_->drop[i_].y = -1;
													dropas_(world_, drop_);
												} if (times_ == 3) {
													times_ = 0;
													result_item_count += result_gives_per_recipe;
													for (int i_ = 0; i_ < info[0].size(); i_++) {
														if (info[0][i_][1] > info[1][i_][1]) {
															no = true;
															break;
														}
													}
												}
												break;
											}
										}
									}
								} if (result_item_count != 0) {
									combined = true;
									WorldDrop drop_block_{};
									drop_block_.id = result_item_id, drop_block_.count = result_item_count, drop_block_.uid = uint16_t(world_->drop.size()) + 1, drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
									dropas_(world_, drop_block_);
									PlayerMoving data_{};
									data_.packetType = 17, data_.netID = 44, data_.YSpeed = 44, data_.x = x_ * 32 + 16, data_.y = y_ * 32 + 16;
									BYTE* raw = packPlayerMoving(&data_);
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
										if (pInfo(currentPeer)->world == world_->name) {
											packet_(currentPeer, "action|play_sfx\nfile|audio/terraform.wav\ndelayMS|0");
											send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
										}
									}
									delete[]raw;
									p.Insert("SCIENCE!");
								}
								break;
							}
						}
					}
					if (not combined) p.Insert("Those items don't seem to combine!");
					p.Insert(0), p.Insert(0);
					p.CreatePacket(peer);
				}
			}
			if (items[t_].blockType == BlockTypes::WEATHER) {
				int weather_id_ = get_weather_id(t_);
				long long current_time = time(nullptr);
				if (block_->last_punch_weather - current_time <= 0) {
					world_->weather = (weather_id_ != world_->weather ? weather_id_ : 0);
					block_->enabled = (world_->weather != 0 ? true : false);
					block_->last_punch_weather = current_time + 1.5;
					if (world_->weather == 0) {
						if (pInfo(peer)->lock == 11550)world_->weather = 54;
						if (pInfo(peer)->lock == 11586)world_->weather = 55;
						if (pInfo(peer)->lock == 10410)world_->weather = 53;
						world_->weather = world_->d_weather;
					}
					gamepacket_t p;
					p.Insert("OnSetCurrentWeather");
					p.Insert(world_->weather == 0 ? 80 : world_->weather);
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
						if (pInfo(currentPeer)->world == name_) {
							p.CreatePacket(currentPeer);
						}
					}
				}
			}
			if (block_->fg == 5638) {
				if (pInfo(peer)->tankIDName == world_->owner_name or pInfo(peer)->dev or world_->owner_name.empty()) {
					long long current_time = time(nullptr);
					if (block_->hp == -1 or (items[t_].dropChance) < (current_time - block_->lp)) {
						if (block_->id == 0) {
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(peer)->netID);
							p.Insert("Cannot activate the " + items[block_->fg].name + ", you need to set the item first.");
							p.Insert(0), p.Insert(0);
							p.CreatePacket(peer);
							{
								gamepacket_t p;
								p.Insert("OnConsoleMessage");
								p.Insert("Cannot activate the " + items[block_->fg].name + ", you need to set the item first.");
								p.CreatePacket(peer);
							}
						}
						else {
							if (items[block_->id].collisionType != 1 and items[block_->id].blockType != BACKGROUND and items[block_->id].blockType != CONSUMABLE and items[block_->id].blockType != SEED and not items[block_->id].farmable) {
								gamepacket_t p;
								p.Insert("OnTalkBubble");
								p.Insert(pInfo(peer)->netID);
								p.Insert("Cannot activate the " + items[block_->fg].name + ", the current item cannot be placed.");
								p.Insert(0), p.Insert(0);
								p.CreatePacket(peer);
								{
									gamepacket_t p;
									p.Insert("OnConsoleMessage");
									p.Insert("Cannot activate the " + items[block_->fg].name + ", the current item cannot be placed.");
									p.CreatePacket(peer);
								}
							}
							else {
								if (not block_->magnetron) {
									block_->magnetron = true;
									if (pInfo(peer)->magnetron_x != 0 and pInfo(peer)->magnetron_y != 0 and pInfo(peer)->magnetron_x != x_ and pInfo(peer)->magnetron_x != y_) {
										gamepacket_t p;
										p.Insert("OnTalkBubble");
										p.Insert(pInfo(peer)->netID);
										p.Insert("You received a " + items[5640].name + ".");
										p.Insert(0), p.Insert(0);
										p.CreatePacket(peer);
										{
											gamepacket_t p;
											p.Insert("OnConsoleMessage");
											p.Insert("You received a " + items[5640].name + ".");
											p.CreatePacket(peer);
										}
										{
											pInfo(peer)->magnetron_id = block_->id;
											pInfo(peer)->magnetron_x = x_;
											pInfo(peer)->magnetron_y = y_;
										}
									}
									else {
										int c_ = 0;
										modify_inventory(peer, 5640, c_);
										if (c_ == 0) {
											{
												int c_ = 1;
												if (modify_inventory(peer, 5640, c_) == 0) {
													gamepacket_t p;
													p.Insert("OnTalkBubble");
													p.Insert(pInfo(peer)->netID);
													p.Insert("You received a " + items[5640].name + ".");
													p.Insert(0), p.Insert(0);
													p.CreatePacket(peer);
													{
														gamepacket_t p;
														p.Insert("OnConsoleMessage");
														p.Insert("You received a " + items[5640].name + ".");
														p.CreatePacket(peer);
													}
													{
														pInfo(peer)->magnetron_id = block_->id;
														pInfo(peer)->magnetron_x = x_;
														pInfo(peer)->magnetron_y = y_;
													}
												}
											}
										}
									}
									gamepacket_t p;
									p.Insert("OnPlanterActivated");
									p.Insert(block_->id);
									p.Insert(x_);
									p.Insert(y_);
									p.CreatePacket(peer);
								}
								else {
									block_->magnetron = false;
									gamepacket_t p;
									p.Insert("OnPlanterActivated");
									p.Insert(0);
									p.Insert(0);
									p.Insert(0);
									p.CreatePacket(peer);
								}
								PlayerMoving data_{};
								data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
								BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
								BYTE* blc = raw + 56;
								form_visual(blc, *block_, *world_, peer, false);
								try {
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
										if (pInfo(currentPeer)->world == world_->name) {
											//cout << "raw 112 part 1" << endl;
											send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
										}
									}
									delete[] raw, blc;
								}
								catch (out_of_range) {
									return false;
								}
								if (block_->locked) {
									upd_lock(*block_, *world_, peer);
								}
							}
						}
					}
				}
			}
			if (items[block_->fg].mannequin) {
				bool s = false;
				int c_ = 1;
				if (block_->mannequin.c_head != 0) {
					if (modify_inventory(peer, block_->mannequin.c_head, c_) == 0) {
						block_->mannequin.c_head = 0;
					}
					s = true;
				}
				else if (block_->mannequin.c_shirt != 0) {
					if (modify_inventory(peer, block_->mannequin.c_shirt, c_) == 0) {
						block_->mannequin.c_shirt = 0;
					}
					s = true;
				}
				else if (block_->mannequin.c_pants != 0) {
					if (modify_inventory(peer, block_->mannequin.c_pants, c_) == 0) {
						block_->mannequin.c_pants = 0;
					}
					s = true;
				}
				else if (block_->mannequin.c_feet != 0) {
					if (modify_inventory(peer, block_->mannequin.c_feet, c_) == 0) {
						block_->mannequin.c_feet = 0;
					}
					s = true;
				}
				else if (block_->mannequin.c_mask != 0) {
					if (modify_inventory(peer, block_->mannequin.c_mask, c_) == 0) {
						block_->mannequin.c_mask = 0;
					}
					s = true;
				}
				else if (block_->mannequin.c_hand != 0) {
					if (modify_inventory(peer, block_->mannequin.c_hand, c_) == 0) {
						block_->mannequin.c_hand = 0;
					}
					s = true;
				}
				else if (block_->mannequin.c_back != 0) {
					if (modify_inventory(peer, block_->mannequin.c_back, c_) == 0) {
						block_->mannequin.c_back = 0;
					}
					s = true;
				}
				else if (block_->mannequin.c_hair != 0) {
					if (modify_inventory(peer, block_->mannequin.c_hair, c_) == 0) {
						block_->mannequin.c_hair = 0;
					}
					s = true;
				}
				else if (block_->mannequin.c_neck != 0) {
					if (modify_inventory(peer, block_->mannequin.c_neck, c_) == 0) {
						block_->mannequin.c_neck = 0;
					}
					s = true;
				} if (s) {
					PlayerMoving data_{};
					data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
					BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
					BYTE* blc = raw + 56;
					form_visual(blc, *block_, *world_, peer, false);
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
						if (pInfo(currentPeer)->world == world_->name) {
							send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
						}
					}
					delete[] raw, blc;
					if (block_->locked) {
						upd_lock(*block_, *world_, peer);
					}
					return true;
				}
			}
			if (items[block_->fg].charger) {
				if (world_->owner_name != pInfo(peer)->tankIDName and not pInfo(peer)->superdev and (!guild_access(peer, world_->guild_id) and find(world_->admins.begin(), world_->admins.end(), pInfo(peer)->tankIDName) == world_->admins.end())) break;
				if (block_->id != 0) {
					long long current_time = time(nullptr);
					if (block_->planted - current_time > 0) {
						if (block_->hp == -1 or (items[t_].dropChance) < (current_time - block_->lp)) {
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(peer)->netID);
							p.Insert("That's not done charging!");
							p.Insert(0), p.Insert(0);
							p.CreatePacket(peer);
						}
					}
					else {
						int c_ = 1;
						if (modify_inventory(peer, 2204, c_) == 0) {
							block_->id = 0, block_->planted = 0;
							PlayerMoving data_{};
							data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
							BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
							BYTE* blc = raw + 56;
							form_visual(blc, *block_, *world_, peer, false);
							PlayerMoving data_effect_{};
							data_effect_.packetType = 19;
							data_effect_.punchX = 2204;
							data_effect_.punchY = pInfo(peer)->netID;
							data_effect_.x = x_ * 32 + 16, data_effect_.y = y_ * 32 + 16;
							BYTE* raw_effect = packPlayerMoving(&data_effect_, 56);
							raw_effect[8] = pInfo(peer)->netID, raw_effect[3] = 5;
							try {
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
									if (pInfo(currentPeer)->world == world_->name) {
										//cout << "raw 112 part 2" << endl;
										send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
										send_raw(currentPeer, 4, raw_effect, 56, ENET_PACKET_FLAG_RELIABLE);
									}
								}
								delete[] raw, blc, raw_effect;
							}
							catch (out_of_range) {
								return false;
							}
							if (block_->locked) {
								upd_lock(*block_, *world_, peer);
							}
						}
						else {
							if (block_->hp == -1 or (items[t_].dropChance) < (current_time - block_->lp)) {
								gamepacket_t p;
								p.Insert("OnTalkBubble");
								p.Insert(pInfo(peer)->netID);
								p.Insert("No room to pick it up!");
								p.Insert(0), p.Insert(0);
								p.CreatePacket(peer);
							}
						}
					}
				}
			}
			if (t_ == 5814) {
				gamepacket_t p;
				p.Insert("OnTalkBubble");
				p.Insert(pInfo(peer)->netID);
				p.Insert("You can't smash a " + items[t_].name + ", the only way to destroy it is to abandon the guild!");
				p.Insert(0), p.Insert(0);
				p.CreatePacket(peer);
				return true;
			}
			if (items[t_].blockType == BlockTypes::DISPLAY) {
				string owner_name = world_->owner_name, user_name = pInfo(peer)->tankIDName;
				if (owner_name != user_name and not owner_name.empty() and not pInfo(peer)->dev) {
					if (block_->id != 0) {
						if (not pInfo(peer)->dev) {
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(peer)->netID);
							p.Insert("Only the block's owner can break it!");
							p.Insert(0), p.Insert(1);
							p.CreatePacket(peer);
							return true;
						}
					}
				}
				else {
					if (pInfo(peer)->dev) writelogd(pInfo(peer)->tankIDName + " stole in (" + pInfo(peer)->world + ")" + items[t_].name);
					int c_ = 0;
					modify_inventory(peer, block_->id, c_);
					int slots_ = get_free_slots(pInfo(peer));
					if (c_ + 1 > 200 or c_ == 0 and slots_ == 0) {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(peer)->netID);
						p.Insert("You don't have enough space in your backpack! Free some and try again.");
						p.Insert(0), p.Insert(1);
						p.CreatePacket(peer);
						return true;
					}
				}
			}
			pInfo(peer)->punch_count++;
			long long time_ = time(nullptr);
			uint32_t laikas = uint32_t((time_ - block_->planted <= items[block_->fg].growTime ? time_ - block_->planted : items[block_->fg].growTime));
			if (items[t_].blockType == BlockTypes::SEED and laikas == items[block_->fg].growTime) {
				if (t_ == 1791) {
					PlayerMoving data_{};
					data_.packetType = 17, data_.netID = 48, data_.YSpeed = 48, data_.x = (x_ * 32) + 16, data_.y = (y_ * 32) + 16;
					BYTE* raw = packPlayerMoving(&data_);
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
						if (pInfo(peer)->world != pInfo(currentPeer)->world) continue;
						send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
					}
					delete[] raw;
					world_->blocks[x_ + (y_) * 100].fg = 1790;
					update_tile(peer, x_, y_, 1790, false, true);
					return false;
				}

				add_farmer_xp(peer, 1);
				int drop_count = items[block_->fg - 1].rarity == 1 ? (items[block_->fg - 1].farmable ? (rand() % 9) + 4 : (rand() % block_->fruit) + 1) : items[block_->fg - 1].farmable ? (rand() % 5) + 4 : (rand() % block_->fruit) + 1;
				if (thedaytoday == 1 and rand() % 50 < 1) drop_count++;
				if (pInfo(peer)->back == 1746 && pInfo(peer)->feet == 1830 || pInfo(peer)->feet == 1966) { // fuel pack
					if (items[block_->fg - 1].rarity < 100) {// pagal real gt jei rarity virs 100 neduoda double
						int c1746 = 1746, countofitem = 0, removepack = -1;
						modify_inventory(peer, c1746, countofitem);
						if (countofitem >= 1) {
							if (rand() % 100 < 10) { // pagal real gt 10% chance
								modify_inventory(peer, c1746, removepack);
								drop_count *= 2; // pagal real gt double drop count
								PlayerMoving data_{};
								data_.packetType = 17, data_.netID = pInfo(peer)->feet == 1966 ? 106 : 50, data_.YSpeed = pInfo(peer)->feet == 1966 ? 106 : 50, data_.x = pInfo(peer)->x + 16, data_.y = pInfo(peer)->y + 16;
								BYTE* raw = packPlayerMoving(&data_);
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world) continue;
									send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
								}
								delete[] raw;
							}
						}
					}
				}
				if (rand() % 100 < 2 and pInfo(peer)->hand == 6840) {
					PlayerMoving data_{};
					data_.packetType = 17, data_.netID = 58, data_.YSpeed = 58, data_.x = pInfo(peer)->x + 16, data_.y = pInfo(peer)->y + 16;
					BYTE* raw = packPlayerMoving(&data_);
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
						if (pInfo(peer)->world != pInfo(currentPeer)->world) continue;
						send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
					}
					delete[] raw;
					drop_count++;
				}
				if (pInfo(peer)->hand == 1068) {
					vector<int> list{ 5090, 3088, 5198 };
					if (rand() % 5 < 1) list = { 3086, 3074, 5200, 8910, 7034, 11248, 10132 };
					int item = list[rand() % list.size()], got = 0;
					gamepacket_t p;
					p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert(items[item].hand_scythe_text), p.CreatePacket(peer);
					WorldDrop drop_block_{};
					drop_block_.id = item, drop_block_.count = item == 5198 ? 2 : 1, drop_block_.uid = uint16_t(world_->drop.size()) + 1, drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
					dropas_(world_, drop_block_);
					drop_count = 0;
					PlayerMoving data_{};
					data_.packetType = 17, data_.netID = 50, data_.YSpeed = 50, data_.x = x_ * 32, data_.y = y_ * 32;
					BYTE* raw = packPlayerMoving(&data_);
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world) continue;
						send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
					}
					delete[] raw;
					int chance = 0;
					if (has_playmod(pInfo(peer), "Food: Purified Scythe")) chance = 5;
					if (rand() % 100 < (80 - chance)) modify_inventory(peer, 1068, got = -1);
				}
				if (harvest_seed(world_, block_, x_, y_, drop_count, pInfo(peer)->netID, peer)) {
					if (drop_count != 0) {
						gamepacket_t p;
						p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("A `w" + items[t_].name + "`` falls out!"), p.Insert(0), p.Insert(0), p.CreatePacket(peer);
					}
				}
				else if (world_->weather == 8 and rand() % 300 < 2) {
					WorldDrop drop_block_{};
					drop_block_.id = 3722, drop_block_.count = 1, drop_block_.uid = uint16_t(world_->drop.size()) + 1, drop_block_.x = x_ * 32 + rand() % 17, drop_block_.y = y_ * 32 + rand() % 17;
					dropas_(world_, drop_block_);
					PlayerMoving data_2{};
					data_2.packetType = 0x11, data_2.x = drop_block_.x, data_2.y = drop_block_.y, data_2.YSpeed = 108;
					BYTE* raw2 = packPlayerMoving(&data_2);
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != world_->name) continue;
						send_raw(currentPeer, 4, raw2, 56, ENET_PACKET_FLAG_RELIABLE);
					}
					delete[] raw2;
				}
				if (drop_count != 0) drop_rare_item(world_, peer, t_ - 1, x_, y_, true);
				return true;
			}
			double increase_ = round((double)items[t_].breakHits / 6 / 6);
			int punch_modifier = (has_playmod(pInfo(peer), "Dragoscarf") ? -increase_ : (has_playmod(pInfo(peer), "Enhanced Digging") ? -increase_ : (has_playmod(pInfo(peer), "Death To Blocks!") ? -increase_ : (has_playmod(pInfo(peer), "Dragonborn") ? -increase_ : (has_playmod(pInfo(peer), "punch damage") ? -increase_ : (has_playmod(pInfo(peer), "diggin' it") ? -increase_ : has_playmod(pInfo(peer), "cupid's firepower") ? increase_ : (has_playmod(pInfo(peer), "eye beam") ? increase_ : 0)))))));
			if (block_->hp == -1 or (items[t_].dropChance) < (time_ - block_->lp)) {
				int punch_ = items[t_].breakHits / 6 + punch_modifier;
				if (punch_ <= 2) punch_ = 3;
				else if (punch_ <= 3 and punch_modifier < 0) punch_ = 4;
				if (pInfo(peer)->hand == 2952) {
					if (t_ == 2 or t_ == 14) {
						PlayerMoving data_{};
						data_.packetType = 17, data_.netID = 221, data_.YSpeed = 221, data_.x = x_ * 32 + 16, data_.plantingTree = 300, data_.y = y_ * 32 + 16, data_.XSpeed = t_;
						BYTE* raw = packPlayerMoving(&data_);
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world) continue;
							send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
						}
						delete[] raw;
						punch_ = 1;
					}
				}
				if (pInfo(peer)->necklace == 9376) {
					if (t_ == 3564 or t_ == 3556 or t_ == 9380 or t_ == 9382) {
						PlayerMoving data_{};
						data_.packetType = 17, data_.netID = 221, data_.YSpeed = 221, data_.plantingTree = 300, data_.x = x_ * 32 + 16, data_.y = y_ * 32 + 16, data_.XSpeed = t_;
						BYTE* raw = packPlayerMoving(&data_);
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world) continue;
							send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
						}
						delete[] raw;
						punch_ = 1;
					}
				}
				if (pInfo(peer)->hand == 9520 && items[t_].blockType != BlockTypes::LOCK && items[t_].rarity <= 11) punch_ = 1;
				if (pInfo(peer)->hand == 9522 && items[t_].blockType != BlockTypes::LOCK && items[t_].rarity <= 11) {
					int got = 0;
					if (rand() % 100 < (30)) modify_inventory(peer, 9522, got = -1);
					punch_ = 1;
				}
				if (pInfo(peer)->hand == 8440) punch_ = 3;
				if (pInfo(peer)->hit1) punch_ = 1;
				if (pInfo(peer)->hand == 3932 || pInfo(peer)->hand == 3934) punch_ += 7;
				block_->hp = punch_;
				block_->lp = time_;
				int demolition = 0;
				ifstream openFile2("db/aprog/demolition/" + to_lower(pInfo(peer)->tankIDName) + ".txt");
				openFile2 >> demolition;
				openFile2.close();
				if (demolition != 100) {
					ofstream myfile;
					myfile.open("db/aprog/demolition/" + to_lower(pInfo(peer)->tankIDName) + ".txt");
					myfile << demolition + 1;
					myfile.close();
				}
				else {
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
						bool wlachi = std::experimental::filesystem::exists("db/alist/demolition/" + (pInfo(peer)->tankIDName) + ".txt");
						if (wlachi == false) {
							int ab = 46;
							ofstream myfile;
							myfile.open("db/alist/demolition/" + (pInfo(peer)->tankIDName) + ".txt");
							myfile << "true";
							myfile.close();
							gamepacket_t p, p2;
							p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert(pInfo(peer)->name_color + pInfo(peer)->tankIDName + "`5 earned the achievement 'Demolition (Classic)'!");
							p2.Insert("OnConsoleMessage"), p2.Insert(pInfo(peer)->name_color + pInfo(peer)->tankIDName + "`5 earned the achievement 'Demolition (Classic)'!");
							pInfo(peer)->achievement_total++;
							PlayerMoving data_{};
							data_.packetType = 17, data_.netID = 46, data_.YSpeed = 46, data_.x = pInfo(peer)->x + 16, data_.y = pInfo(peer)->y + 16;
							BYTE* raw = packPlayerMoving(&data_);
							for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world) continue;
								p.CreatePacket(currentPeer);
								p2.CreatePacket(currentPeer);
								send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
							}
							delete[] raw;
						}
					}
				}
			}
			block_->hp -= 1;
			if (block_->hp == 0) { /*isgriove*/
				grow4good(peer, false, "break", 1);
				if (items[t_].bunny_egg) {
					WorldDrop drop_block_{};
					uint32_t percentage = block_->bunny_egg_progress / 10;
					if (percentage <= 9) {
						{
							uint32_t playmod_effect = 42;
							PlayerMoving data_{};
							data_.packetType = 17, data_.netID = playmod_effect, data_.YSpeed = playmod_effect, data_.x = pInfo(peer)->x + rand() % 17, data_.y = pInfo(peer)->y + rand() % 22;
							BYTE* raw = packPlayerMoving(&data_);
							for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
								if (pInfo(currentPeer)->world == world_->name) {
									send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
								}
							}
							delete[] raw;
						}
						PlayMods give_playmod{};
						give_playmod.id = 4;
						give_playmod.time = time(nullptr) + 180;
						pInfo(peer)->playmods.push_back(give_playmod);
						update_clothes(peer);
					}
					else if (percentage <= 19) {
						vector<int> pastel_blocks{
							510,
							512,
							514,
							516,
							518,
							520,
							522
						};
						drop_block_.id = pastel_blocks[rand() % pastel_blocks.size()], drop_block_.count = 5;
					}
					else if (percentage <= 24) 	drop_block_.id = 10760, drop_block_.count = 5;
					else if (percentage <= 29) drop_block_.id = 4624, drop_block_.count = 7;
					else if (percentage <= 39) drop_block_.id = ((rand() % 100) < 50 ? 616 : 618), drop_block_.count = 1;
					else if (percentage <= 49) drop_block_.id = ((rand() % 100) < 50 ? 1548 : 8044), drop_block_.count = 1;
					else if (percentage <= 59) {
						vector<int> easter_set{
							502,
							500,
							498,
							508,
						};
						drop_block_.id = easter_set[rand() % easter_set.size()], drop_block_.count = 1;
					}
					else if (percentage <= 69) {
						vector<int> bunny_set{
							504,
							506,
							524
						};
						drop_block_.id = bunny_set[rand() % bunny_set.size()], drop_block_.count = 1;
					}
					else if (percentage <= 79) drop_block_.id = 8038, drop_block_.count = 1;
					else if (percentage <= 89) drop_block_.id = 2558, drop_block_.count = 1;
					else if (percentage <= 99) drop_block_.id = 1550, drop_block_.count = 1;
					else if (percentage == 100) drop_block_.id = 1552, drop_block_.count = 1;
					else if (percentage <= 119) drop_block_.id = 9452, drop_block_.count = 1;
					else if (percentage <= 159) drop_block_.id = 9468, drop_block_.count = 1;
					else if (percentage <= 179) drop_block_.id = 9454, drop_block_.count = 1;
					else if (percentage <= 199) drop_block_.id = 9442, drop_block_.count = 1;
					else if (percentage == 200)drop_block_.id = 9446, drop_block_.count = 1;
					drop_block_.uid = uint16_t(world_->drop.size()) + 1, drop_block_.x = x_ * 32 + rand() % 17, drop_block_.y = y_ * 32 + rand() % 17;
					dropas_(world_, drop_block_);
				}
				else if (t_ == 392 || t_ == 3402 || t_ == 9350) { // golden booty chest ir hearstone ir super golden booty chest
					WorldDrop drop_block_{};
					if (t_ == 3402) {
						pInfo(peer)->booty_broken++;
						if (pInfo(peer)->booty_broken >= 100) {
							pInfo(peer)->booty_broken = 0;
							int c_ = 1;
							if (modify_inventory(peer, 9350, c_) != 0) {
								drop_block_.id = 9350, drop_block_.count = 1, drop_block_.uid = uint16_t(world_->drop.size()) + 1, drop_block_.x = pInfo(peer)->x + rand() % 17, drop_block_.y = pInfo(peer)->y + rand() % 17;
								dropas_(world_, drop_block_);
							}
							gamepacket_t p, p2;
							p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("You received " + items[9350].name + "!"), p.Insert(0), p.Insert(1), p.CreatePacket(peer);
							p2.Insert("OnConsoleMessage"), p2.Insert("You received " + items[9350].name + "!"), p2.CreatePacket(peer);
							PlayerMoving data_{};
							data_.packetType = 19, data_.plantingTree = 0, data_.netID = 0, data_.punchX = 9350, data_.x = pInfo(peer)->x + 10, data_.y = pInfo(peer)->y + 16;
							int32_t to_netid = pInfo(peer)->netID;
							BYTE* raw = packPlayerMoving(&data_);
							raw[3] = 5;
							memcpy(raw + 8, &to_netid, 4);
							for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != world_->name) continue;
								send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
							}
							delete[]raw;
						}
						/* valentine
						{
							gamepacket_t p;
							p.Insert("OnProgressUISet"), p.Insert(1), p.Insert(3402), p.Insert(pInfo(peer)->booty_broken), p.Insert(100), p.Insert(""), p.Insert(1);
							p.CreatePacket(peer);
						}
						gamepacket_t p;
						p.Insert("OnProgressUIUpdateValue"), p.Insert(pInfo(peer)->booty_broken), p.Insert(0);
						p.CreatePacket(peer);*/
					}
					vector<int> list{ 11702, 11696,11692,11690,11688,11686,11684,11682,11680,11678, 11694, 5652, 3398, 386, 4422, 364, 9342, 9340, 9334, 9332, 9336, 9338, 4400, 7808, 7810, 4416, 7818, 7820, 7822, 7824, 5644, 390, 7826, 7830, 9324, 5658, 3396, 2384, 5660, 10654, 3400, 4418, 388, 3408, 1470, 3404, 3406, 10662, 2390, 5656, 5648, 2396, 384, 5664, 4424, 366 }, ghc{ 1458 }, rare_list{ 11668, 11670, 11672, 11664, 362, 362, 362, 2388, 10652, 4412, 10632, 10626 };
					int item = list[rand() % list.size()];
					if ((t_ == 9350 ? rand() % 250 : (has_playmod(pInfo(peer), "Lucky in Love") ? rand() % 650 : rand() % 850)) < 2) item = rare_list[rand() % rare_list.size()];
					if ((t_ == 9350 ? rand() % 2500 : (has_playmod(pInfo(peer), "Lucky in Love") ? rand() % 2600 : rand() % 3000)) < 1) item = ghc[rand() % ghc.size()];
					if (item == 1458) {
						string texts = "`4The Power of Love! `2" + pInfo(peer)->name_color + pInfo(peer)->tankIDName + "`` found a `5Golden Heart Crystal`` in a `5" + items[t_].name + "``!";
						gamepacket_t p;
						p.Insert("OnConsoleMessage"), p.Insert("CP:_PL:0_OID:_CT:[S]_ `o**`` " + texts + "``");
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
							p.CreatePacket(currentPeer);
						}
					}
					drop_block_.id = item, drop_block_.count = (item == 11694 || item == 11696 || item == 7810 || item == 7808 || item == 4400 || item == 390 || item == 3408 || item == 4422 || item == 3404 ? 5 : (item == 4418 || item == 5660 ? 2 : 1)), drop_block_.uid = uint16_t(world_->drop.size()) + 1, drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
					dropas_(world_, drop_block_);
				}
				else if (t_ == 776) { // toxic waste
					vector<int> random_xy{ 1, 0, -1 };
					for (int i = 0; i < 3; i++) {
						int randomx = random_xy[rand() % random_xy.size()], randomy = random_xy[rand() % random_xy.size()];
						WorldBlock* dropx = &world_->blocks[(x_ + randomx) + ((y_ + randomy) * 100)];
						if (dropx->fg == 0) dropx->fg = 778, update_tile(peer, randomx + x_, randomy + y_, 778, false, true);
					}
				}
				else if (t_ == 3918 || t_ == 3928 || t_ == 3922) { // fossil rock broken
					if (pInfo(peer)->hand == 3934 && block_->fossil) {
						WorldDrop drop_block_{};
						drop_block_.id = 3936, drop_block_.count = 1, drop_block_.uid = uint16_t(world_->drop.size()) + 1, drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
						dropas_(world_, drop_block_);
					}
				}
				else if (t_ == 720) { // pinata
					vector<pair<int, int>> receivingitems;
					vector<int> random_xy{ 2, 1, 0, -1, -2 };
					for (int i_ = 0; i_ < world_->drop.size(); i_++) {
						if (world_->drop[i_].id == 0) continue;
						if (x_ == (world_->drop[i_].x / 32) && y_ == (world_->drop[i_].y / 32)) {
							receivingitems.push_back(make_pair(world_->drop[i_].id, world_->drop[i_].count));
							PlayerMoving data_{};
							data_.effect_flags_check = 1, data_.packetType = 14, data_.netID = 0, data_.plantingTree = world_->drop[i_].uid;
							BYTE* raw = packPlayerMoving(&data_);
							for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != name_) continue;
								send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
							}
							delete[]raw;
							world_->drop[i_].id = 0, world_->drop[i_].x = -1, world_->drop[i_].y = -1;
						}
					}
					for (int i = 0; i < receivingitems.size(); i++) {
						int randomx = random_xy[rand() % random_xy.size()], randomy = random_xy[rand() % random_xy.size()];
						WorldDrop drop_block_{};
						WorldBlock* dropx = &world_->blocks[(x_ + randomx) + ((y_ + randomy) * 100)];
						if (dropx->fg != 0) drop_block_.id = receivingitems[i].first, drop_block_.count = receivingitems[i].second, drop_block_.uid = uint16_t(world_->drop.size()) + 1, drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
						else drop_block_.id = receivingitems[i].first, drop_block_.count = receivingitems[i].second, drop_block_.uid = uint16_t(world_->drop.size()) + 1, drop_block_.x = ((x_ + randomx) * 32) + rand() % 17, drop_block_.y = ((y_ + randomy) * 32) + rand() % 17;
						dropas_(world_, drop_block_);
					}
				}
				else if (t_ == 836) { // summer suprise
					vector<int> list{ 6308, 846, 3702, 8602, 8600, 11068, 832, 2860, 6328, 6324, 6330, 834, 2862, 8612, 4810, 6326, 9744, 3700, 9756, 842, 9748, 11066, 11062, 11064, 840, 850, 3704, 8592, 8594, 3698, 3740, 442, 846, 4804, 3742, 8610, 2856, 844, 11058, 2858, 11040, 822, 838, 4812 }, rare_list{ 1680, 11040 }, random_xy{ 1, 0, -1 };
					int item = list[rand() % list.size()];
					for (int i = 0; i < 3; i++) {
						if (rand() % 1000 < 1) item = rare_list[rand() % rare_list.size()];
						int randomx = random_xy[rand() % random_xy.size()], randomy = random_xy[rand() % random_xy.size()], item = list[rand() % list.size()];
						WorldDrop drop_block_{};
						WorldBlock* dropx = &world_->blocks[(x_ + randomx) + ((y_ + randomy) * 100)];
						if (dropx->fg != 0) drop_block_.id = item, drop_block_.count = (item == 850 || item == 442 || item == 822 || item == 832 || item == 846 ? 10 : (item == 834 ? 5 : 1)), drop_block_.uid = uint16_t(world_->drop.size()) + 1, drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
						else drop_block_.id = item, drop_block_.count = (item == 850 || item == 442 || item == 822 || item == 832 || item == 846 ? 10 : (item == 834 ? 5 : 1)), drop_block_.uid = uint16_t(world_->drop.size()) + 1, drop_block_.x = ((x_ + randomx) * 32) + rand() % 17, drop_block_.y = ((y_ + randomy) * 32) + rand() % 17;
						dropas_(world_, drop_block_);
					}
				}
				else if (t_ == 10836 || t_ == 10838 || t_ == 10840 || t_ == 10834 || t_ == 10842) { // Surgery Supply Crate, Fishing Supply Crate, Cooking Supply Crate, Startopia Supply Crate, Superhero Supply Crate
					WorldDrop drop_block_{};
					for (int i = 0; i < items[t_].noob_item.size(); i++) {
						drop_block_.id = items[t_].noob_item[i].first, drop_block_.count = items[t_].noob_item[i].second, drop_block_.uid = uint16_t(world_->drop.size()) + 1, drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
						dropas_(world_, drop_block_);
					}
				}
				//else if (t_ == 7628 || t_ == 5136 || t_ == 9386 || t_ == 9384 || t_ == 9380 || t_ == 11156) {
				else if (t_ == 7628 || t_ == 5136 || t_ == 9384 || t_ == 9380 || t_ == 11156) {
					WorldDrop drop_block_{};
					drop_block_.id = items[t_].randomitem[rand() % items[t_].randomitem.size()], drop_block_.count = 1, drop_block_.uid = uint16_t(world_->drop.size()) + 1, drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
					dropas_(world_, drop_block_);
					if (t_ == 5136 || t_ == 9384 || t_ == 9380) {
						//if (t_ == 5136 || t_ == 9386 || t_ == 9384 || t_ == 9380) {
						PlayerMoving data_{};
						data_.packetType = 17, data_.netID = 48, data_.YSpeed = 48, data_.x = pInfo(peer)->x + 16, data_.y = pInfo(peer)->y + 16;
						BYTE* raw = packPlayerMoving(&data_);
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world) continue;
							send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
						}
						delete[] raw;
					}
				}
				else if (t_ == 8426) { // easter crate
					vector<int> list{ 2544, 2548, 2550, 2552, 2546,2544, 2548, 2550, 2552, 2546, 9460 };
					WorldDrop drop_block_{};
					drop_block_.id = 611, drop_block_.count = rand() % 20 + 20, drop_block_.uid = uint16_t(world_->drop.size()) + 1, drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
					dropas_(world_, drop_block_);
					if (rand() % 100 < 40) {
						drop_block_.id = list[rand() % list.size()], drop_block_.count = 1, drop_block_.uid = uint16_t(world_->drop.size()) + 1, drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
						dropas_(world_, drop_block_);
					}
					if (rand() % 100 < 80) {
						if (rand() % 500 < 1) list = { 2554 };
						drop_block_.id = list[rand() % list.size()], drop_block_.count = 1, drop_block_.uid = uint16_t(world_->drop.size()) + 1, drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
						dropas_(world_, drop_block_);
					}
				}
				else if (t_ == 542) { // pot o gold duoda 1-200 gems arba ride o gold
					if (rand() % 200 < 1) {
						WorldDrop drop_block_{};
						drop_block_.id = 2574, drop_block_.count = 1, drop_block_.uid = uint16_t(world_->drop.size()) + 1, drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
						dropas_(world_, drop_block_);
					}
					else gems_(peer, world_, rand() % (10 + 1), x_ * 32, y_ * 32, t_);
				}
				else if (t_ == 3604) { // gold treasure
					vector<int> list{ 112, 3582, 262, 826, 828, 2812, 3606, 3574, 10102, 11228 };
					vector<int> rare{ 2002, 3604, 2002, 2002 };
					if (rand() % 25 < 1) list = { 2002, 3604, 2002, 2002 };
					int item = list[rand() % list.size()];
					if (item == 112) gems_(peer, world_, rand() % (500 + 100), x_ * 32, y_ * 32, t_);
					else {
						WorldDrop drop_block_{};
						drop_block_.id = item, drop_block_.count = 1, drop_block_.uid = uint16_t(world_->drop.size()) + 1, drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
						dropas_(world_, drop_block_);
					}
				}
				else if (t_ == 10004) { // super summer suprise
					vector<int> list{ 3704, 3698, 9754, 842, 3700, 9750, 3702, 3702, 9750, 9746, 3700, 842, 9754, 3698, 1670, 1680, 3704, 3764, 4822, 2874, 8614 };
					if (rand() % 1000 < 1) list = { 9758, 3764, 11012, 9730, 1670, 1680, 4822 };
					int item = list[rand() % list.size()];
					WorldDrop drop_block_{};
					drop_block_.id = item, drop_block_.count = 1, drop_block_.uid = uint16_t(world_->drop.size()) + 1, drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
					dropas_(world_, drop_block_);
				}
				else if (t_ == 11038) { //summer artifacts
					vector<int> list{ 3764, 3702, 9746, 9750, 3700, 842, 9754, 2874, 8614, 3698, 1670, 11040, 11042, 8616, 8618, 1676, 8590, 9732, 9732, 2868, 4822, 1668, 11046, 1678, 1664, 844, 2864, 3764, 6308, 6310, 6306, 6322, 1670, 4816, 4818, 2870, 2872, 2874, 2802, 1666, 4814 };
					WorldDrop drop_block_{};
					drop_block_.id = list[rand() % list.size()];
					if (rand() % 3000 < 1) {
						list = { 9758, 11012, 9730, 11008, 1680, 1674, 2854, 6312, 8588, 3696, 4820, 11044 };
						drop_block_.id = list[rand() % list.size()];
						gamepacket_t p;
						p.Insert("OnConsoleMessage"), p.Insert(pInfo(peer)->name_color + pInfo(peer)->tankIDName + "`` has received a `5Rare " + items[drop_block_.id].ori_name + "`` from Summer Artifacts Chest!");
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
							p.CreatePacket(currentPeer);
						}
					}
					drop_block_.count = 1, drop_block_.uid = uint16_t(world_->drop.size()) + 1, drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
					dropas_(world_, drop_block_);
				}
				else if (t_ == 10826) { // lava pinata
					vector<int> list{ 6042, 10818, 2640, 9610, 2638, 9634, 9632, 10800, 10804, 1570, 9608, 11876 };
					if (rand() % 140 < 1) {
						list = { 10168 , 11288 }; // chance of receiving rare item
						if (volcanic_wings < 48) list.push_back(11870);
						if (volcanic_cape < 48) list.push_back(10806);
					}
					WorldDrop drop_block_{};
					drop_block_.id = list[rand() % list.size()], drop_block_.count = (drop_block_.id == 10818 ? 20 : 1), drop_block_.uid = uint16_t(world_->drop.size()) + 1, drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
					dropas_(world_, drop_block_);
					if (drop_block_.id == 10168 || drop_block_.id == 11288 || drop_block_.id == 10806 || drop_block_.id == 11870) {
						if (drop_block_.id == 11870) volcanic_wings++;
						if (drop_block_.id == 10806) volcanic_cape++;
						gamepacket_t p;
						p.Insert("OnConsoleMessage"), p.Insert("The `4Lava Pinata`` rewards " + pInfo(peer)->name_color + pInfo(peer)->tankIDName + "`` with a `5Rare " + items[drop_block_.id].ori_name + ".``");
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
							p.CreatePacket(currentPeer);
						}
					}
				}
				else if (t_ == 718) { // ultra pinata
					if (pInfo(peer)->pinata_claimed == false && pInfo(peer)->pinata_prize == false) {
						pInfo(peer)->pinata_claimed = true;
						gamepacket_t p;
						p.Insert("OnProgressUIUpdateValue"), p.Insert(pInfo(peer)->pinata_claimed ? 1 : 0), p.Insert(pInfo(peer)->pinata_prize ? 1 : 0), p.CreatePacket(peer);
					}
					vector<int> list{ 11900, 4672, 9614 , 10812 , 9634 , 9632 , 9608 , 704 , 6058 , 3598 , 9624 , 9626 , 706 , 10818 , 6052 , 712 , 708 ,4736, 1568, 4724, 4728, 4726, 2634, 714, 10816, 720, 2632, 702, 8316, 8320, 8322, 8318, 10828, 700, 700, 2630, 11892, 11898, 11896 };
					if (pInfo(peer)->hair == 1568) list.insert(list.end(), { 1580, 8324, 6042, 2638,9622,9630, 8326, 10808, 10802, 2640, 10882 });
					if (rand() % 1000 < 1) {
						list = { 10826,  8314 }; // chance of receiving rare item
						if (pInfo(peer)->hair == 1568)  list.insert(list.end(), { 8310,4664,3594, 1570, 9610,10814, 1584, 11874 });
					}
					WorldDrop drop_block_{};
					drop_block_.id = list[rand() % list.size()];
					if (drop_block_.id == 3598) drop_block_.count = rand() % 2 + 3;
					else if (drop_block_.id == 9624) drop_block_.count = rand() % 3 + 1;
					else if (drop_block_.id == 2632 || drop_block_.id == 8322) drop_block_.count = rand() % 3 + 2;
					else if (drop_block_.id == 8316) drop_block_.count = rand() % 2 + 2;
					else if (drop_block_.id == 8320) drop_block_.count = 2;
					else if (drop_block_.id == 8318) drop_block_.count = rand() % 4 + 1;
					else if (drop_block_.id == 10828) drop_block_.count = 10;
					else if (drop_block_.id == 2630) drop_block_.count = rand() % 2 + 1;
					else if (drop_block_.id == 11892) drop_block_.count = 4;
					else if (drop_block_.id == 11896) drop_block_.count = 3;
					else drop_block_.count = 1;
					drop_block_.uid = uint16_t(world_->drop.size()) + 1, drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
					dropas_(world_, drop_block_);
				}
				else if (t_ == 9616) { // block de mayo
					vector<int> list{ 11900, 11900, 716, 11890,9628,6054, 10804, 716, 11890,9628,6054, 10804,  704, 6058, 1568, 1572 , 1580, 10822 };
					if (rand() % 1000 < 1) list = { 9618,  8314, 9612 }; // chance of receiving rare item
					WorldDrop drop_block_{};
					drop_block_.id = list[rand() % list.size()];
					if (drop_block_.id == 716 || drop_block_.id == 1572) drop_block_.count = 6;
					else if (drop_block_.id == 11890) drop_block_.count = 3;
					else drop_block_.count = 1;
					drop_block_.uid = uint16_t(world_->drop.size()) + 1, drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
					dropas_(world_, drop_block_);
				}
				else if (t_ == 1584) { // mystery pinata
					vector<pair<int, int>> receivingitems;
					vector<int> random_xy{ 2, 1, 0, -1, -2 };
					for (int i_ = 0; i_ < world_->drop.size(); i_++) {
						if (world_->drop[i_].id == 0) continue;
						if (x_ == (world_->drop[i_].x / 32) && y_ == (world_->drop[i_].y / 32)) {
							receivingitems.push_back(make_pair(world_->drop[i_].id, world_->drop[i_].count));
							PlayerMoving data_{};
							data_.effect_flags_check = 1, data_.packetType = 14, data_.netID = 0, data_.plantingTree = world_->drop[i_].uid;
							BYTE* raw = packPlayerMoving(&data_);
							for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != name_) continue;
								send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
							}
							delete[]raw;
							world_->drop[i_].id = 0, world_->drop[i_].x = -1, world_->drop[i_].y = -1;
						}
					}
					for (int i = 0; i < receivingitems.size(); i++) {
						int randomx = random_xy[rand() % random_xy.size()], randomy = random_xy[rand() % random_xy.size()], item = receivingitems[i].first;
						if (item == 1584) item = 3596;
						if (item == 2634) item = 3602;
						if (item == 1580) item = 1586;
						if (item == 3274) item = 4660;
						if (item == 1568) item = 710;
						if (item == 678) item = 1574;
						if (item == 330) item = 1578;
						if (item == 604 || item == 802 || item == 804 || item == 806 || item == 808 || item == 810 || item == 812) item = 2636;
						if (item == 900 || item == 1378) item = 1576;
						if (item == 2160 || item == 2164 || item == 2162 || item == 2158 || item == 2168 || item == 2166) item = 2642;
						if (item == 2614 || item == 2616 || item == 2618) item = 2620;
						if (item == 2606 || item == 2608 || item == 2610) item = 2612;
						if (item == 2598 || item == 2600 || item == 2602) item = 2604;
						if (item == 1570) item = 6044;
						if (item == 414) item = 6030;
						if (item == 2624) item = 6056;
						if (item == 8310) item = 8312;
						WorldDrop drop_block_{};
						WorldBlock* dropx = &world_->blocks[(x_ + randomx) + ((y_ + randomy) * 100)];
						if (dropx->fg != 0) drop_block_.id = item, drop_block_.count = receivingitems[i].second, drop_block_.uid = uint16_t(world_->drop.size()) + 1, drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
						else drop_block_.id = item, drop_block_.count = receivingitems[i].second, drop_block_.uid = uint16_t(world_->drop.size()) + 1, drop_block_.x = ((x_ + randomx) * 32) + rand() % 17, drop_block_.y = ((y_ + randomy) * 32) + rand() % 17;
						dropas_(world_, drop_block_);
					}
				}
				else if (t_ == 2478) { // locke mystery box
					vector<int> list{ 2472,2470,2474,2466,2468,10116,3758,11222 };
					vector<int> clothes{ 370, 372, 374, 42, 68, 40, 130, 270, 234, 142, 694, 10034, 140, 76, 48, 44, 34, 36, 122, 238, 66, 38, 90, 208, 272, 144, 2938, 354, 138, 214, 11202, 342, 1846, 210, 234, 250, 1716, 82, 78, 94, 662, 754, 146, 356, 72, 46, 124, 1720, 92, 1122, 212, 84, 1722, 1844, 2718, 70, 4966, 288, 232, 788, 148, 96, 3932, 448, 98, 134, 50, 74, 1504, 494, 266, 852, 132, 2954, 3934, 3060, 3056, 1800, 88, 2960, 1022, 2578, 3164, 86, 302, 1332, 304, 1116, 6788, 894, 492, 1690, 316, 1850, 1718, 1838, 1032, 1860, 1026, 3048, 352, 724, 1590, 798, 488, 1342, 794, 268, 1502, 8884, 1858, 594, 3466, 1314, 1688, 1312, 3590, 446, 1856, 1854, 1516, 1316, 2700, 4968, 4964, 6796, 1862, 310, 290, 296, 6674, 1864, 4954, 1476, 896, 1848, 496, 136, 158, 2958, 2576, 1954, 152, 1126, 796, 1524, 2928, 80, 2934, 150, 1120, 1142, 1478, 154, 9356, 452, 258, 2882, 156, 1140, 3530, 312, 1124, 890, 1330, 3052, 294, 1650, 1652, 348, 1736, 576, 5016, 1708, 292, 1146, 1028, 1762, 600, 11204 };
					vector<int> block{ 231,487,483,2019,427,1757,2009,281,781,329,459,1041,421,2787,2789,1043,2797,181,613,65,4983,283,553,425,4635,987,627,2017,989,61,4639,973,3523,331,265,859,433,253,339,1105,439,4567,333,677,5673,1427,5603,183,10533,5731,7223,10833,6035,6813,1113,1047,653,2811,4703,1429,847,665,485,1613,833,2025,1775,3931,429,3831,423,437,1773,4767,1299,361,667,2815,3473,301,4637,5683,2709,415,955,461,861,9389,5467,2791,2815,1803,419,2027,685,555,741,10531,5729,7221,10831,6033,6811,621,6401,1107,359,3471,855,309,1685,1449,1309,441,1111,221,1431,3065,9307,1257,1501,1109,4641,3587,1103,417,743,431,3823,2949,1131,3825,727,5379,729,187,787,5459,4785,3261,3521,2293,2309,2321,2333,5461,3721,327,247,63,3479,445,4783,299,863,8935,1451,261,1871,1499,455,9391,683,1159,551,1745,411,3005,557,687,4799,559,4643,3899,1605,9309,567,565,1155,3827,1327,1767,993,1157,563,4721,115,1423,10515,1329,6545,287,669,777,5463,1655,1599,561,4585,3413,4745,1771,2011,1161,1729,3757,3753,321,3265,3263,623,775,6397,129,4667,759,3767,1529,6543,4707,3835,1435,651,8929,569,527,3287,1595,6063,2795,1003,1731,4943,4963,597,4669,1531,1523,625,4297,599,657,571,873,3755,2969,1725,4603,1447,3267,5375,1683,3567, 13, 57, 17, 381, 1139, 21, 101, 379, 117, 27, 23, 581, 195, 105, 191, 377, 1307, 697, 881, 167, 185, 1323, 165, 3783, 369, 25, 171, 53, 103, 179, 29, 249, 177, 1325, 337, 189, 169, 55, 223, 175, 885, 119, 3573, 199, 549, 681, 655, 107, 163, 31, 671, 889, 887, 193, 127, 1433, 173, 7631, 413, 3571, 3569, 2809, 9393, 225, 111, 109, 201, 59, 607, 285, 2029, 2013, 2015, 1611, 995, 997, 963, 1481, 219, 197, 2023, 2021, 9331, 1305, 823, 1039, 231, 487, 483, 2019, 427, 1757, 2009, 281, 781, 329, 459, 1041, 421, 2787, 2789, 1043, 2797, 181, 613, 65, 4983, 283, 553, 425, 4635, 987, 627, 2017, 989, 61, 4639, 973, 3523, 331, 265, 859, 433, 253, 339, 1105, 439, 4567, 333, 677, 5673, 1427, 5603, 183, 10533, 5731, 7223, 10833, 6035, 6813, 1113, 1047, 653, 2811, 4703, 1429, 847, 665 };
					int item = block[rand() % block.size()];
					if ((rand() % 2) + 1 == 2) item = clothes[rand() % clothes.size()];
					else {
						if ((rand() % 2) + 1 == 2) item = block[rand() % block.size()] - 1;
						else item = block[rand() % block.size()];
					}
					if (rand() % 25 < 1) item = list[rand() % list.size()];
					WorldDrop drop_block_{};
					drop_block_.id = item, drop_block_.count = 1, drop_block_.uid = uint16_t(world_->drop.size()) + 1, drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
					dropas_(world_, drop_block_);
				}
				else if (items[t_].blockType == BlockTypes::VENDING) {
					if (block_->c_ != 0 or block_->wl != 0) {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(peer)->netID);
						p.Insert("Empty the machine before smashing!");
						p.Insert(0), p.Insert(0);
						p.CreatePacket(peer);
						return true;
					}
				}
				else if (items[t_].blockType == BlockTypes::DONATION) {
					if (block_->donates.size() != 0) {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(peer)->netID);
						p.Insert("Empty the " + items[t_].name + " before breaking it!");
						p.Insert(0), p.Insert(0);
						p.CreatePacket(peer);
						return true;
					}
				}
				else if (items[t_].blockType == BlockTypes::STORAGE) {
					int itemcount = 0;
					for (int i_ = 0; i_ < world_->sbox1.size(); i_++) if (world_->sbox1[i_].x == x_ and world_->sbox1[i_].y == y_) itemcount++;
					if (itemcount != 0) {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(peer)->netID);
						p.Insert("Empty the box before breaking it!");
						p.Insert(0), p.Insert(0);
						p.CreatePacket(peer);
						return true;
					}
				}
				else if (items[t_].item_sucker) {
					if (block_->pr > 0) {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(peer)->netID);
						p.Insert("Empty this " + items[t_].name + " before breaking!");
						p.Insert(0), p.Insert(0);
						p.CreatePacket(peer);
						return true;
					}
				}
				else if (items[t_].magplant) {
					switch (t_) {
					case 6950: case 6952:
					{
						if (block_->pr > 0) {
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(peer)->netID);
							p.Insert("`4Be careful``, if you return this to your backpack you will `4lose ALL`` Gems stored within! Use them up first!");
							p.Insert(0), p.Insert(1);
							p.CreatePacket(peer);
							{
								gamepacket_t p;
								p.Insert("OnConsoleMessage");
								p.Insert("`4Be careful``, if you return this to your backpack you will `4lose ALL`` Gems stored within! Use them up first!");
								p.CreatePacket(peer);
							}
							return true;
						}
						break;
					}
					}
				}
				if (items[t_].properties & Property_AutoPickup) {
					int c_ = 1;
					if (items[t_].blockType == BlockTypes::LOCK and t_ != 202 && t_ != 204 && t_ != 206 && t_ != 4994) {
						if (world_->owner_name != pInfo(peer)->tankIDName && pInfo(peer)->superdev == 0) return true;
						for (int i_ = 0; i_ < world_->blocks.size(); i_++) {
							if (world_->blocks[i_].fg == 4516) {
								gamepacket_t p;
								p.Insert("OnTalkBubble");
								p.Insert(pInfo(peer)->netID);
								p.Insert("`4Remove Untrade-a-Box before removing lock!``");
								p.Insert(0), p.Insert(0);
								p.CreatePacket(peer);
								return true;
							}
						}
					}
					if (modify_inventory(peer, t_, c_, false) == 0) {
						PlayerMoving data_{};
						data_.packetType = 14, data_.netID = -1, data_.plantingTree = t_;
						data_.x = float(x_) * 32, data_.y = float(y_) * 32;
						int32_t item = -1;
						float val = 1.00;
						BYTE* raw = packPlayerMoving(&data_);
						memcpy(raw + 8, &item, 4);
						memcpy(raw + 16, &val, 4);
						data_.netID = pInfo(peer)->netID;
						WorldDrop n_{};
						n_.id = 0, n_.count = 0, n_.uid = uint16_t(world_->drop.size()) + 1, n_.x = x_ * 32, n_.y = y_ * 32;
						world_->drop.push_back(n_);
						data_.plantingTree = int(world_->drop.size());
						data_.x = 0, data_.y = 0;
						BYTE* raw2 = packPlayerMoving(&data_);
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
							if (pInfo(currentPeer)->world == name_) {
								send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
								send_raw(currentPeer, 4, raw2, 56, ENET_PACKET_FLAG_RELIABLE);
							}
						}
						delete[]raw, raw2;
						gamepacket_t p(1);
						p.Insert("OnConsoleMessage");
						p.Insert("Collected `w1 " + items[t_].name + "``.``");
						p.CreatePacket(peer);
					}
					else {
						return true;
					}
				}
				else if (items[t_].max_gems != 0) {
					add_peer_xp(peer, (items[t_].rarity / 5 > 0 ? items[t_].rarity / 5 : 1));
					int maxgems = items[t_].max_gems;
					if (t_ == 120) maxgems = 50;
					int c_ = rand() % (maxgems + 1);
					if (c_ != 0) {
						bool no_seed = false, no_gems = false, no_block = false;
						if (t_ == 2242 or t_ == 2244 or t_ == 2246 or t_ == 2248 or t_ == 2250 or t_ == 542) no_seed = true, no_block = true;
						else {
							for (int i_ = 0; i_ < world_->drop.size(); i_++) {
								if (abs(world_->drop[i_].y - y_ * 32) <= 16 and abs(world_->drop[i_].x - x_ * 32) <= 16) {
									if (world_->drop[i_].id == 112 and items[t_].rarity < 8) {
										no_gems = true;
									}
									else {
										no_seed = true, no_block = true;
									}
								}
							}
						}
						if (items[t_].bunny_egg) no_seed = true, no_block = true, no_gems = true;
						int chanced = 0;
						if (thedaytoday == 2) chanced = 5;
						if (rand() % 100 < 7) {
							if (t_ == 8 || t_ == 6 || t_ == 7372) break;
							if (pInfo(peer)->mask == 8192 || pInfo(peer)->ances == 5144 || pInfo(peer)->ances == 5146 || pInfo(peer)->ances == 5148 || pInfo(peer)->ances == 5150 || pInfo(peer)->ances == 5152 || pInfo(peer)->ances == 5080 && rand() % 250 - (items[pInfo(peer)->ances].chance * items[pInfo(peer)->ances].chance) < 1) {
								WorldDrop drop_block_{};
								drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17, drop_block_.id = t_, drop_block_.count = 1, drop_block_.uid = uint16_t(world_->drop.size()) + 1;
								if (not use_mag(world_, drop_block_, x_, y_) and not no_block) {
									dropas_(world_, drop_block_);
								}
							}
							WorldDrop drop_block_{};
							drop_block_.id = t_, drop_block_.count = 1, drop_block_.uid = uint16_t(world_->drop.size()) + 1, drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
							if (not use_mag(world_, drop_block_, x_, y_) and not no_block) {
								dropas_(world_, drop_block_);
							}
						}
						else if (rand() % 100 < (items[t_].newdropchance + chanced)) {
							if (t_ == 8 || t_ == 6 || t_ == 7372) break;
							WorldDrop drop_seed_{};
							drop_seed_.id = t_ + 1, drop_seed_.count = 1, drop_seed_.uid = uint16_t(world_->drop.size()) + 1, drop_seed_.x = (x_ * 32) + rand() % 17, drop_seed_.y = (y_ * 32) + rand() % 17;
							if (not use_mag(world_, drop_seed_, x_, y_) and not no_seed) {
								dropas_(world_, drop_seed_);
							}
						}
						else if (not no_gems) {
							if (t_ == 8 || t_ == 6 || t_ == 7372) break;
							if (has_playmod(pInfo(peer), "Lucky") and ((rand() % 100) + 1) <= 30) {
								PlayerMoving data_{};
								data_.packetType = 17, data_.netID = 125, data_.YSpeed = 125, data_.x = x_ * 32 + 16, data_.y = y_ * 32 + 16;
								BYTE* raw = packPlayerMoving(&data_);
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
									if (pInfo(currentPeer)->world == world_->name) {
										send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
									}
								}
								delete[] raw;
								c_ += (rand() % 5) + 1;
							}
							drop_rare_item(world_, peer, t_, x_, y_, false);
							gems_(peer, world_, c_, x_ * 32, y_ * 32, t_);
						}
					}
				}
				if (block_->fg == 7960) { /*Dark Stone*/
					gamepacket_t p;
					p.Insert("OnParticleEffect");
					p.Insert(182);
					p.Insert((float)x_ * 32 + 16, (float)y_ * 32 + 16);
					vector<int> clothes_;
					for (int i = 0; i < items.size(); i++) {
						if (items[i].blockType == CLOTHING) clothes_.push_back(i);
					}
					uint32_t reward = clothes_[rand() % clothes_.size()];
					gamepacket_t p2;
					p2.Insert("OnTalkBubble");
					p2.Insert(pInfo(peer)->netID);
					p2.Insert("The power of The Dark Stone dropped " + items[reward].name + "!");
					p2.Insert(0), p2.Insert(1);
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
						if (pInfo(currentPeer)->world == world_->name) {
							p.CreatePacket(currentPeer), p2.CreatePacket(currentPeer);
						}
					}
					WorldDrop drop_block_{};
					drop_block_.id = reward, drop_block_.count = 1;
					drop_block_.uid = uint16_t(world_->drop.size()) + 1, drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
					dropas_(world_, drop_block_);
				}
				if (block_->fg == 5638 and pInfo(peer)->magnetron_id != 0 and pInfo(peer)->magnetron_x == x_ and pInfo(peer)->magnetron_y == y_) {
					int c_ = 0;
					modify_inventory(peer, 5640, c_);
					if (c_ != 0) {
						c_ *= -1;
						modify_inventory(peer, 5640, c_);
						pInfo(peer)->magnetron_id = 0;
						pInfo(peer)->magnetron_x = 0;
						pInfo(peer)->magnetron_y = 0;
					}
				}
				if (items[block_->fg].charger and block_->id != 0) {
					if (world_->owner_name != pInfo(peer)->tankIDName and not pInfo(peer)->superdev and (!guild_access(peer, world_->guild_id) and find(world_->admins.begin(), world_->admins.end(), pInfo(peer)->tankIDName) == world_->admins.end())) break;
					WorldDrop drop_block_{};
					drop_block_.id = 2286, drop_block_.count = 1;
					if (block_->planted - time(nullptr) <= 0) {
						drop_block_.id = 2204;
					}
					drop_block_.uid = uint16_t(world_->drop.size()) + 1, drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
					dropas_(world_, drop_block_);
				}
				switch (items[block_->fg].blockType) {
				case BlockTypes::WEATHER:
				{
					if (world_->weather != 0) {
						world_->weather = 0;
						if (pInfo(peer)->lock == 11550)world_->weather = 54;
						if (pInfo(peer)->lock == 11586)world_->weather = 55;
						if (pInfo(peer)->lock == 10410)world_->weather = 53;
						if (world_->d_weather != 0) world_->weather = world_->d_weather;
						gamepacket_t p;
						p.Insert("OnSetCurrentWeather");
						p.Insert(world_->weather == 0 ? 80 : world_->weather);
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
							if (pInfo(currentPeer)->world == name_) {
								p.CreatePacket(currentPeer);
							}
						}
					}
					break;
				}
				case BlockTypes::DISPLAY:
				{
					if (block_->id != 0) {
						int c_ = 1;
						modify_inventory(peer, block_->id, c_);
						PlayerMoving data_effect_{};
						data_effect_.packetType = 19;
						data_effect_.punchX = block_->id;
						data_effect_.punchY = pInfo(peer)->netID;
						data_effect_.x = x_ * 32 + 16, data_effect_.y = y_ * 32 + 16;
						BYTE* raw_effect = packPlayerMoving(&data_effect_, 56);
						raw_effect[8] = pInfo(peer)->netID, raw_effect[3] = 5;
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
							if (pInfo(currentPeer)->world == name_) {
								send_raw(currentPeer, 4, raw_effect, 56, ENET_PACKET_FLAG_RELIABLE);
							}
						}
						delete[]raw_effect;
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(peer)->netID);
						p.Insert("You picked up 1 " + items[block_->id].ori_name + ".");
						p.Insert(0), p.Insert(1);
						p.CreatePacket(peer);
						{
							gamepacket_t p;
							p.Insert("OnConsoleMessage");
							p.Insert("You picked up 1 " + items[block_->id].ori_name + ".");
							p.CreatePacket(peer);
						}
					}
					break;
				}
				case BlockTypes::LOCK:
				{
					// reset world settings

					if (block_->fg == 202 or block_->fg == 204 or block_->fg == 206 or block_->fg == 4994) {
						vector<int> new_tiles{};
						vector<WorldBlock> shadow_copy_2 = world_->blocks;
						new_tiles.push_back(x_ + (y_ * 100));
						int ySize = world_->blocks.size() / 100, xSize = world_->blocks.size() / ySize;
						for (int i2 = 0; i2 < new_tiles.size(); i2++) {
							int s_x_ = new_tiles[i2] % 100, s_y_ = new_tiles[i2] / 100;
							if (s_x_ < 99 and shadow_copy_2[s_x_ + 1 + (s_y_ * 100)].locked and shadow_copy_2[s_x_ + 1 + (s_y_ * 100)].lock_origin == (x_ + (y_ * 100))) {
								if (not shadow_copy_2[s_x_ + 1 + (s_y_ * 100)].scanned) {
									shadow_copy_2[s_x_ + 1 + (s_y_ * 100)].scanned = true;
									new_tiles.push_back(s_x_ + 1 + (s_y_ * 100));
									world_->blocks[s_x_ + 1 + (s_y_ * 100)].locked = false;
									world_->blocks[s_x_ + 1 + (s_y_ * 100)].lock_origin = -1;
								}
							} if (s_x_ > 0 and shadow_copy_2[s_x_ - 1 + (s_y_ * 100)].locked and shadow_copy_2[s_x_ - 1 + (s_y_ * 100)].lock_origin == (x_ + (y_ * 100))) {
								if (not shadow_copy_2[s_x_ - 1 + (s_y_ * 100)].scanned) {
									shadow_copy_2[s_x_ - 1 + (s_y_ * 100)].scanned = true;
									new_tiles.push_back(s_x_ - 1 + (s_y_ * 100));
									world_->blocks[s_x_ - 1 + (s_y_ * 100)].locked = false;
									world_->blocks[s_x_ - 1 + (s_y_ * 100)].lock_origin = -1;
								}
							} if (s_y_ < 59 and shadow_copy_2[s_x_ + ((s_y_ + 1) * 100)].locked and shadow_copy_2[s_x_ + ((s_y_ + 1) * 100)].lock_origin == (x_ + (y_ * 100))) {
								if (not shadow_copy_2[s_x_ + ((s_y_ + 1) * 100)].scanned) {
									shadow_copy_2[s_x_ + ((s_y_ + 1) * 100)].scanned = true;
									new_tiles.push_back(s_x_ + ((s_y_ + 1) * 100));
									world_->blocks[s_x_ + ((s_y_ + 1) * 100)].locked = false;
									world_->blocks[s_x_ + ((s_y_ + 1) * 100)].lock_origin = -1;
								}
							} if (s_y_ > 0 and shadow_copy_2[s_x_ + ((s_y_ - 1) * 100)].locked and shadow_copy_2[s_x_ + ((s_y_ - 1) * 100)].lock_origin == (x_ + (y_ * 100))) {
								if (not shadow_copy_2[s_x_ + ((s_y_ - 1) * 100)].scanned) {
									shadow_copy_2[s_x_ + ((s_y_ - 1) * 100)].scanned = true;
									new_tiles.push_back(s_x_ + ((s_y_ - 1) * 100));
									world_->blocks[s_x_ + ((s_y_ - 1) * 100)].locked = false;
									world_->blocks[s_x_ + ((s_y_ - 1) * 100)].lock_origin = -1;
								}
							}
						}
						break;
					}
					if (pInfo(peer)->tankIDName == world_->owner_name) {
						pInfo(peer)->worlds_owned.erase(remove(pInfo(peer)->worlds_owned.begin(), pInfo(peer)->worlds_owned.end(), world_->name), pInfo(peer)->worlds_owned.end());
					}
					else {
						bool on_ = false;
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
							if (pInfo(currentPeer)->tankIDName == world_->owner_name) {
								pInfo(currentPeer)->worlds_owned.erase(remove(pInfo(currentPeer)->worlds_owned.begin(), pInfo(currentPeer)->worlds_owned.end(), world_->name), pInfo(currentPeer)->worlds_owned.end());
								on_ = true;
								break;
							}
						} if (not on_) {
							string path_ = "players/" + world_->owner_name + "_.json";
							if (_access_s(path_.c_str(), 0) == 0) {
								json r_;
								ifstream f_(path_, ifstream::binary);
								f_ >> r_;
								f_.close();
								{
									json f_ = r_["worlds_owned"].get<json>();
									for (int i_ = 0; i_ < f_.size(); i_++) {
										if (f_[i_]["name"] == world_->name) {
											f_.erase(f_.begin() + i_);
											break;
										}
									}
									r_["worlds_owned"] = f_;
								}
								{
									ofstream f_(path_, ifstream::binary);
									f_ << r_;
									f_.close();
								}
							}
						}
					}
					if (block_->fg == 11550 || block_->fg == 11586 || block_->fg == 10410) {
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
							if (pInfo(currentPeer)->world == name_) pInfo(currentPeer)->lock = 0;
						}
						world_->lockid = 0;
						world_->weather = 0;
						if (world_->d_weather != 0) world_->weather = world_->d_weather;
						gamepacket_t p;
						p.Insert("OnSetCurrentWeather");
						p.Insert(world_->weather == 0 ? 80 : world_->weather);
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
							if (pInfo(currentPeer)->world == name_) {
								p.CreatePacket(currentPeer);
							}
						}
					}
					int got = 0;
					modify_inventory(peer, 1424, got);
					modify_inventory(peer, 1424, got *= -1);
					world_->owner_name = "", world_->owner_named = "", world_->entry_level = 1, world_->make_music_blocks_invisible = false, world_->disable_music_blocks = false, world_->music_bpm = 100, world_->open_to_public = false;
					world_->silence = false, world_->rainbows = false;
					gamepacket_t p;
					p.Insert("OnConsoleMessage");
					p.Insert("`5[```w" + world_->name + "`` has had its `$World Lock`` removed!`5]``");
					gamepacket_t p2(0, pInfo(peer)->netID);
					{
						p2.Insert("OnNameChanged");
						if (pInfo(peer)->mod == 0 && pInfo(peer)->dev == 0)pInfo(peer)->name_color = "`0";
						p2.Insert((not pInfo(peer)->d_name.empty() ? pInfo(peer)->d_name : pInfo(peer)->name_color + pInfo(peer)->tankIDName) + (pInfo(peer)->is_legend ? " of Legend" : "") + "``");
					}
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
						if (pInfo(currentPeer)->world == name_) {
							p.CreatePacket(currentPeer), p2.CreatePacket(currentPeer);
							if (find(world_->admins.begin(), world_->admins.end(), pInfo(currentPeer)->tankIDName) != world_->admins.end()) {
								gamepacket_t p3(0, pInfo(currentPeer)->netID);
								p3.Insert("OnNameChanged");
								if (pInfo(currentPeer)->mod == 0 && pInfo(currentPeer)->dev == 0)pInfo(currentPeer)->name_color = "`0";
								p3.Insert((not pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->d_name : pInfo(currentPeer)->name_color + pInfo(currentPeer)->tankIDName) + (pInfo(currentPeer)->is_legend ? " of Legend" : "") + "``");
								for (ENetPeer* currentPeer2 = server->peers; currentPeer2 < &server->peers[server->peerCount]; ++currentPeer2) {
									if (currentPeer2->state != ENET_PEER_STATE_CONNECTED or currentPeer2->data == NULL) continue;
									if (pInfo(currentPeer2)->world == name_) {
										p3.CreatePacket(currentPeer2);
									}
								}
							}
						}
					}
					world_->admins.clear();
					break;
				}
				default:
					break;
				}
				punch_tile(peer, x_, y_, 0x3, p_, pInfo(peer)->netID, 0x0);
				reset_(block_, x_, y_, world_);
			}
			else { /*-1 hp*/
				block_->lp = time_;
				if (items[block_->fg].blockType == BlockTypes::PROVIDER) {
					uint32_t laikas = uint32_t((time_ - block_->planted <= items[block_->fg].growTime ? time_ - block_->planted : items[block_->fg].growTime));
					if (laikas == items[block_->fg].growTime) {
						add_provider_xp(peer, 1);
						vector<double> ids; // svarbu: id.max_kiekis <!= 5 if size after decimal point == 2 then count fixed
						if (block_->fg == 866) { // cow
							ids = { 868.2 };
						}
						else if (block_->fg == 872) { // chicken
							ids = { 874.2 };
						}
						else if (block_->fg == 1044) { // buffalo
							ids = { 868.2 };
						}
						else if (block_->fg == 3888) { // sheep
							ids = { 3890.3 };
						}
						else if (block_->fg == 1632) { // coffee maker
							ids = { 1634 };
						}
						else if (block_->fg == 5116) { // tea set
							ids = { 5114 };
						}
						else if (block_->fg == 2798) { // well
							ids = { 822.2 };
						}
						else if (block_->fg == 10450) { // diamond builder
							ids = { 10454, 10458.50, 10458.50, 10462.20, 10464.30, 10466.30, 10468.50, 10470.30, 10472.20, 10474.30, 10476.20, 10478.20, 10480.30, 10482, 10484.30, 10460 };
						}
						else if (block_->fg == 8196) { // building blocks machine
							ids = { 11732, 11738 }; // ne visi
						}
						else if (block_->fg == 8172) { // Item-O-Matic
							ids = { 8174, 8176, 8178, 8180, 8182 };
						}
						else if (block_->fg == 8160) { // Item-O-Matic
							ids = { 8162, 8164, 8166, 8168, 8170 };
						}
						else if (block_->fg == 8148) { // Item-O-Matic
							ids = { 8150, 8152, 8154, 8156, 8158 };
						}
						else if (block_->fg == 8136) { // Item-O-Matic
							ids = { 8138, 8140, 8142, 8144, 8146 };
						}
						else if (block_->fg == 8124) { // Item-O-Matic
							ids = { 8126, 8128, 8130, 8132, 8134 };
						}
						else if (block_->fg == 8112) { // Item-O-Matic
							ids = { 8114, 8116, 8118, 8120, 8122 };
						}
						else if (block_->fg == 8100) { // Item-O-Matic
							ids = { 8102, 8104, 8106, 8108, 8110 };
						}
						else if (block_->fg == 8088) { // Item-O-Matic
							ids = { 8090, 8092, 8094, 8096, 8098 };
						}
						else if (block_->fg == 8076) { // Item-O-Matic
							ids = { 8078, 8080, 8082, 8084, 8086 };
						}
						else if (block_->fg == 11472) { // winterfest 2021 calendar
							ids = { 8802.5, 8800.5, 5428.1, 5430.1, 5432.1, 5434.1, 6956.5, 5446.1, 3584.5, 6414.1, 8480.1, 8554.1, 8210.5, 8534.5, 8664.5, 8262.5, 8976.1, 8278.1, 8280.1, 262.1, 263.1, 8728.1, 8556.1, 1368.10, 8246.1, 5382.2, 9202.1, 6986.1, 1360.5, 1384.1, 7006.1, 2564.5, 8980.1, 6970.1, 3676.1, 8254.5, 5376.1, 5792.1, 8546.1, 8712.5, 7864.1, 8984.1, 7490.1, 7496.1, 7498.1, 10486.1, 10488.1, 10444.1, 10220.1, 10258.1, 7758.1, 9356.10, 7080.1, 7082.1, 7084.1, 7086.1, 7088.1, 7090.1, 7092.1, 7094.1, 7096.1, 10032.1, 5780.1, 8722.1, 9692.1, 7760.1, 7418.1, 7420.1, 7422.1, 8948.1, 8960.1, 10036.1, 10038.1, 10040.1, 10042.1, 10440.1, 9184.1, 7718.1, 6384.1, 11514.1, 11520.1, 11202.1, 11192.1 };
							/*
							struct tm newtime;
							time_t now = time(0);
							localtime_s(&newtime, &now);
							if (today_day == 24) ids = { 11500 };
							if (today_day == 25) ids = { 802, 1758, 8468, 263, 812, 10442, 9370, 8474, 5018, 7752, 8556, 9182, 9184 };*/
						}
						else if (block_->fg == 1008 or block_->fg == 5196) { // atm machine and 3000
							int c_ = (rand() % 250) + 1;
							if (block_->fg == 5196) c_ = (rand() % 500) + 1;
							if (c_ == 250 or c_ == 500) {
								PlayerMoving data_{};
								data_.packetType = 17, data_.netID = 29, data_.YSpeed = 29, data_.x = (x_ * 32) + 16, data_.y = (y_ * 32) + 16;
								BYTE* raw = packPlayerMoving(&data_);
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
									if (pInfo(peer)->world != pInfo(currentPeer)->world) continue;
									send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
								}
								delete[] raw;
							}
							gems_(peer, world_, c_, x_ * 32, y_ * 32, block_->fg);
						}
						else if (block_->fg == 1636) { // Awkward Friendly Unicorn
							ids = { 728, 360, 308, 306, 2966, 1646, 3170, 1644, 1642, 3524, 1640, 1638, 2582, 3198, 8838, 6794, 10110 };
						}
						else if (block_->fg == 3044) { // Tackle box
							ids = { 2914, 3012, 3014, 3016, 3018, 5528, 5526 };
						}
						else if (block_->fg == 6212) { // Surgical Tool Bag
							ids = { 1258, 1260, 1262, 1264, 1266, 1268, 1270, 4308, 4310, 4312, 4314, 4316, 4318 };
						}
						else if (block_->fg == 6414) { // Star Tool Droid
							ids = { 6520, 6538, 6522, 6528, 6540, 6518, 6530, 6524, 6536, 6534, 6532, 6526, 6416 };
						}
						else if (block_->fg == 928) { // Science station
							ids = { 914, 916, 918, 920, 924 };
						} if (ids.size() != 0) {
							double rand_item = ids[rand() % ids.size()];
							int count_ = 1;
							bool do_rand = true;
							if (to_string(rand_item).find(".") != string::npos) {
								string asd_ = explode(".", to_string(rand_item))[1];
								string s(1, asd_[0]);
								int c_ = atoi(s.c_str());
								if (c_ != 0) {
									if (asd_.size() == 2) {
										do_rand = false;
										c_ /= 10;
									}
									count_ = c_;
								}
							}
							if (count_ > 1 and do_rand)
								count_ = (rand() % count_) + 1;
							int rand_item2 = (int)rand_item;
							WorldDrop new_drop_{};
							new_drop_.id = rand_item2, new_drop_.count = count_, new_drop_.uid = uint16_t(world_->drop.size()) + 1, new_drop_.x = (x_ * 32) + rand() % 17, new_drop_.y = (y_ * 32) + rand() % 17;
							if (not use_mag(world_, new_drop_, x_, y_)) dropas_(world_, new_drop_);
						}
						int timed = items[block_->fg].growTime / 2;
						if (has_playmod(pInfo(peer), "Provider Time Reduced...") && rand() % items[pInfo(peer)->ances].chance < 1) timed *= 1.01;
						block_->planted = time(nullptr) - (timed);
						PlayerMoving data_{};
						data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
						BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
						BYTE* blc = raw + 56;
						form_visual(blc, *block_, *world_, peer, false);
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
							if (pInfo(currentPeer)->world == world_->name) {
								send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
							}
						}
						delete[] raw, blc;
						/* crash
						if (block_->locked) {
							upd_lock(*block_, *world_, peer);
						}*/
						if (block_->locked) {
							upd_lock(*block_, *world_, peer);
						}
					}
				}
				else if (items[block_->fg].blockType == BlockTypes::RANDOM_BLOCK) {
					block_->roll = (rand() % 6);
					punch_tile(peer, x_, y_, 0x8, 0, pInfo(peer)->netID, 0x0, true, block_->roll);
				}
				punch_tile(peer, x_, y_, 0x8, (punch_modifier == 0 ? 6 : (punch_modifier < 0 ? 8 : 5)), pInfo(peer)->netID, 0x0, (block_->roll != 0 ? true : false), (block_->roll != 0 ? block_->roll : 0));
			}
			break;
		}
		case 32:
		{
			if (t_ == 3898) {
				string user_name = pInfo(peer)->tankIDName;
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wTelephone``|left|3898|\nadd_textbox|Dial a number to call somebody in Growtopia. Phone numbers have 5 digits, like 12345 (try it - you'd be crazy not to!). Most numbers are not in service!|left|\nadd_text_input|buttonClicked|Phone #||5|\nend_dialog|" + to_string(t_) + "|Hang Up|Dial|\n");
				p.CreatePacket(peer);
				break;
			}
			if (items[t_].blockType == BlockTypes::CRYSTAL) {
				vector<vector<int>> current_{ {2242, 0}, {2244, 0}, {2246, 0}, {2248, 0}, {2250, 0} };
				string mix_with = "";
				for (int i = 0; i < block_->crystals.size(); i++) {
					vector<int> c_ = block_->crystals[i];
					for (int a = 0; a < current_.size(); a++) {
						if (current_[a][0] == c_[0]) {
							current_[a][1] = block_->crystals[i][1];
							break;
						}
					}
				} vector<string> reply{};
				for (int i = 0; i < current_.size(); i++) {
					reply.push_back(to_string(current_[i][1]) + "x `$" + mix_with + (current_[i][0] == 2242 ? "R" : (current_[i][0] == 2244 ? "G" : (current_[i][0] == 2246 ? "B" : (current_[i][0] == 2248 ? "W" : "B")))) + "``");
				}
				vector<string> available_recipes{};
				for (vector<vector<int>> a_ : crystal_receptai) {
					bool can_ = true;
					for (vector<int> b_ : a_) {
						for (int i = 0; i < current_.size(); i++) {
							if (current_[i][0] == b_[0] and current_[i][1] < b_[1]) {
								can_ = false;
								break;
							}
						} if (not can_) {
							break;
						}
					} if (can_) {
						available_recipes.push_back("\nadd_button|" + to_string(a_[5][0]) + "|`$Craft " + items[a_[5][0]].name + "``|noflags|0|0|");
					}
				}
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wCrystal Shattering``|left|5104|\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\nadd_label_with_icon|small|This crystal is currently mixed with " + join(reply, ", ") + ".|left|5274|" + (available_recipes.size() == 0 ? "\nadd_textbox|No recipes are available. Mix more various crystals to see available recipes.|left|" : "\nadd_spacer|small|" + join(available_recipes, "")) + "\nend_dialog|crystal_exchange|Cancel||\n");
				p.CreatePacket(peer);
				break;
			}
			if (items[t_].blockType == BlockTypes::DONATION) {
				pInfo(peer)->lastwrenchb = t_;
				WorldBlock block_ = world_->blocks[pInfo(peer)->lastwrenchx + (pInfo(peer)->lastwrenchy * 100)];
				string donate_item = "";
				int itemcount = block_.donates.size();
				for (int i_ = 0; i_ < block_.donates.size(); i_++) donate_item += "\nadd_checkbox|" + to_string(itemcount) + "|" + items[block_.donates[i_].item].name + " (`w" + to_string(block_.donates[i_].count) + "``) from `w" + block_.donates[i_].name + "``" + (block_.donates[i_].text != "" ? "`#- \"" + block_.donates[i_].text + "\"``" : "") + "|0";
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				if (world_->owner_name != pInfo(peer)->tankIDName and not pInfo(peer)->dev and not world_->owner_name.empty() and (!guild_access(peer, world_->guild_id) and find(world_->admins.begin(), world_->admins.end(), pInfo(peer)->tankIDName) == world_->admins.end())) p.Insert("set_default_color|`o\nadd_label_with_icon|big|`w" + items[t_].name + "``|left|" + to_string(t_) + "|" + (itemcount != 0 ? "\nadd_textbox|You see `w" + to_string(itemcount) + "`` gift in the box!|left|" : "\nadd_textbox|The box is currently empty.|left|") + "\nadd_textbox|Want to leave a gift for the owner?|left|" + (itemcount >= 20 ? "\nadd_textbox|This box already has `w20`` gifts in it, can't add more until you clear them.|left|" : "\nadd_spacer|small|\nadd_item_picker|itemid|`wGive Gift`` (Min rarity: `52``)|Choose an item to give yourself|") + "\nend_dialog|donation_box_edit|Cancel||\n");
				else p.Insert("set_default_color|`o\nadd_label_with_icon|big|`w" + items[t_].name + "``|left|" + to_string(t_) + "|" + (itemcount == 0 ? "\nadd_textbox|The box is currently empty.|left|" : "\nadd_textbox|You have `w" + to_string(itemcount) + "`` gift waiting:|left|" + donate_item + "\nadd_spacer|small|\nadd_button|clear_selected|`4Retrieve Selected Gifts``|noflags|0|0|\nadd_button|takeall|`4Retrieve All Gifts``|noflags|0|0|") + "" + (itemcount >= 20 ? "\nadd_textbox|This box already has `w20`` gifts in it, can't add more until you clear them.|left|" : "\nadd_spacer|small|\nadd_item_picker|itemid|`wGive Gift`` (Min rarity: `52``)|Choose an item to give yourself|") + "\nend_dialog|donation_box_edit|Cancel||\n");
				p.CreatePacket(peer);
				break;
			}
			if (items[t_].blockType == BlockTypes::BULLETIN_BOARD || items[t_].blockType == BlockTypes::MAILBOX) {
				pInfo(peer)->lastwrenchb = t_;
				string text = "";
				int letters = 0, same = 0;
				bool public_can_add = true, hide_names = false;
				for (int i_ = 0; i_ < world_->bulletins.size(); i_++) if (world_->bulletins[i_].x == x_ and world_->bulletins[i_].y == y_) public_can_add = world_->bulletins[i_].public_can_add, hide_names = world_->bulletins[i_].hide_names;
				for (int i_ = 0; i_ < world_->bulletin.size(); i_++) {
					if (world_->bulletin[i_].x == x_ and world_->bulletin[i_].y == y_) {
						if (fixchar(world_->bulletin[i_].name) == pInfo(peer)->tankIDName) same++;
						letters++;
						if (items[t_].blockType == BlockTypes::BULLETIN_BOARD) {
							if (hide_names) text += "\nadd_label|small|`2" + world_->bulletin[i_].text + "``|left|";
							else {
								if (world_->owner_name != pInfo(peer)->tankIDName and not pInfo(peer)->dev and (!guild_access(peer, world_->guild_id) and find(world_->admins.begin(), world_->admins.end(), pInfo(peer)->tankIDName) == world_->admins.end())) text += "\nadd_label_with_icon|small|" + world_->bulletin[i_].name + ": ```2" + world_->bulletin[i_].text + "``|left|660|";
								else text += "\nadd_label_with_icon_button|small|" + world_->bulletin[i_].name + ": ```2" + world_->bulletin[i_].text + "``|left|660|edit" + to_string(letters) + "|";
							}
						}
						else text += "\nadd_label_with_icon|small|`#\"" + world_->bulletin[i_].text + "\" - `w" + world_->bulletin[i_].name + "``|left|660|\nadd_spacer|small|";
					}
				}
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				if (items[t_].blockType == BlockTypes::BULLETIN_BOARD) {
					if (world_->owner_name != pInfo(peer)->tankIDName and not pInfo(peer)->dev and (!guild_access(peer, world_->guild_id) and find(world_->admins.begin(), world_->admins.end(), pInfo(peer)->tankIDName) == world_->admins.end())) p.Insert("set_default_color|`o\nadd_label_with_icon|big|`w" + items[t_].name + "``|left|" + to_string(t_) + "|\nadd_spacer|small|" + (letters == 0 ? "\nadd_textbox|The " + items[t_].name + " is empty.|left|" : text) + "" + (public_can_add ? (same >= 3 ? "\nadd_textbox|You already have `03`` posts up, take a break!|left|" : "\nadd_textbox|Add to conversation?|left|\nadd_text_input|sign_text|||128|\nadd_spacer|small|\nadd_button|send|`2Add``|noflags|0|0|") : "") + "\nend_dialog|bulletin_edit|Cancel||\nadd_quick_exit|");
					else p.Insert(a + "set_default_color|`o\nadd_label_with_icon|big|`w" + items[t_].name + "``|left|" + to_string(t_) + "|\nadd_spacer|small|" + (letters == 0 ? "\nadd_textbox|The " + items[t_].name + " is empty.|left|" : text) + "\nadd_textbox|Add to conversation?|left|\nadd_text_input|sign_text|||128|\nadd_spacer|small|\nadd_button|send|`2Add``|noflags|0|0|\nadd_spacer|small|\nadd_label_with_icon|big|`wOwner Options|left|242|\nadd_spacer|small|\nadd_textbox|To remove an individual comment, press the icon to the left of it.|left|\nadd_spacer|small|\nadd_spacer|small|" + (letters == 0 ? "" : "\nadd_button|clear|`4Clear Board``|noflags|0|0|") + "\nadd_checkbox|checkbox_locked|Public can add|" + (public_can_add ? "1" : "0") + "\nadd_checkbox|checkbox_hide|Hide names|" + (hide_names ? "1" : "0") + "\nend_dialog|bulletin_edit|Cancel|OK|\nadd_quick_exit|");
				}
				else {
					if (world_->owner_name != pInfo(peer)->tankIDName and not pInfo(peer)->dev and (!guild_access(peer, world_->guild_id) and find(world_->admins.begin(), world_->admins.end(), pInfo(peer)->tankIDName) == world_->admins.end())) p.Insert(a + "set_default_color|`o\nadd_label_with_icon|big|`w" + items[t_].name + "``|left|" + to_string(t_) + "|" + (letters >= 20 ? "\nadd_textbox|This mailbox already has `w20`` letters in it.  Try again later.|left|" : (same >= 3 ? "\nadd_textbox|You've already crammed `w3 ``of your letters into the mailbox, better wait.|left|" : "\nadd_textbox|Want to leave a message for the owner?|left|\nadd_text_input|sign_text|||128|\nadd_spacer|small|\nadd_button|send|`2Send Letter``|noflags|0|0|")) + "\nend_dialog|bulletin_edit|Cancel||\nadd_quick_exit|");
					else p.Insert(a + "set_default_color|`o\nadd_label_with_icon|big|`w" + items[t_].name + "``|left|" + to_string(t_) + "|" + (letters == 0 ? "\nadd_textbox|Your mailbox is currently empty.|left|" : "\nadd_textbox|You have `w" + to_string(letters) + "`` letters:|left|\nadd_spacer|small|" + text + "\nadd_spacer|small|\nadd_button|clear|`4Empty Mailbox``|noflags|0|0|") + "" + (letters >= 20 ? "\nadd_textbox|This mailbox already has `w20`` letters in it.  Try again later.|left|" : "\nadd_textbox|Write a letter to yourself?|left|\nadd_text_input|sign_text|||128|\nadd_spacer|small|\nadd_button|send|`2Send Letter``|noflags|0|0|") + "\nend_dialog|bulletin_edit|Cancel||\nadd_quick_exit|");
				}
				p.CreatePacket(peer);
				break;
			}
			if (t_ == 1790) {
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\nadd_label_with_icon|big|`#Legendary Wizard``|left|" + to_string(t_) + "|\nadd_label|small|Greetings, traveler! I am the Legendary Wizard.  Should you wish to embark on a Legendary Quest, simply choose one blow.|left|\nadd_spacer|small|\nadd_button|quest_1|`9Quest For Honor``|noflags|0|0|\nadd_button|quest_2|`9Quest For Fire``|noflags|0|0|\nadd_button|quest_3|`9Quest Of Steel``|noflags|0|0|\nadd_button|quest_4|`9Quest Of The Heavens``|noflags|0|0|\nadd_button|quest_5|`9Quest For The Blade``|noflags|0|0|\nend_dialog|wizard|No Thanks||");
				p.CreatePacket(peer);
			}
			if (t_ == 1900) {
				int c_q = 0;
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				if (c_q == 0) p.Insert("set_default_color|`o\nadd_label_with_icon|big|`9The Ringmaster``|left|" + to_string(t_) + "|\nadd_smalltext|Come one, come all, to the most extraordinary show in Growtopia! I am the Ringmaster. That means I know a lot about Rings! For 10 Golden Tickets, I might even tell you how you can get a Ring of your own...|left|\nadd_spacer|small|\nadd_button|c_quest|`9Give 10 Golden Tickets``|noflags|0|0|\nadd_spacer|small|\nadd_smalltext|If you had 10 rings of the same type maybe we could have made a deal...|left|\nend_dialog|carnival|Goodbye!||");
				else p.Insert("set_default_color|`o\nadd_label_with_icon|big|`9The Ringmaster``|left|" + to_string(t_) + "|\nadd_smalltext|Come one, come all, to the most extraordinary show in Growtopia! I am the Ringmaster. That means I know a lot about Rings! For 10 Golden Tickets, I might even tell you how you can get a Ring of your own...|left|\nadd_spacer|small|\nadd_button|c_quest|`9Give 10 Golden Tickets``|noflags|0|0|\nadd_spacer|small|\nadd_smalltext|If you had 10 rings of the same type maybe we could have made a deal...|left|\nend_dialog|carnival|Goodbye!||");
				p.CreatePacket(peer);
			}
			if (t_ == 6016) {
				pInfo(peer)->lastwrenchb = t_;
				bool world_public = false, floating_public = false;
				for (int i_ = 0; i_ < world_->gscan.size(); i_++) if (world_->gscan[i_].x == x_ and world_->gscan[i_].y == y_) {
					if (world_->gscan[i_].world_public) world_public = true;
					if (world_->gscan[i_].floating_public) floating_public = true;
				}
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				if (world_->owner_name != pInfo(peer)->tankIDName and not pInfo(peer)->dev and (!guild_access(peer, world_->guild_id) and find(world_->admins.begin(), world_->admins.end(), pInfo(peer)->tankIDName) == world_->admins.end())) p.Insert(a + "set_default_color|`o\nadd_label_with_icon|big|`wWorld Stats``|left|6016|\nadd_spacer|small|" + (floating_public == false and world_public == false ? "\nadd_textbox|`wYou don't have access to this block.|left" : "\nadd_textbox|`wThis amazing block can show the stats for the whole world!|left\nadd_spacer|small|\nadd_textbox|`wWhich stats would you like to view?|left") + "" + (world_public == true ? "\nadd_button|worldBlocks|World Blocks|noflags|0|0|" : "") + "" + (floating_public == true ? "\nadd_button|floatingItems|Floating Items|noflags|0|0|" : "") + "\nadd_spacer|small|\nend_dialog|statsblock|Cancel||\n");
				else p.Insert(a + "set_default_color|`o\nadd_label_with_icon|big|`wWorld Stats``|left|6016|\nadd_spacer|small|\nadd_textbox|`wThis amazing block can show the stats for the whole world!|left\nadd_spacer|small|\nadd_textbox|`wWhich stats would you like to view?|left\nadd_button|worldBlocks|World Blocks|noflags|0|0|\nadd_button|floatingItems|Floating Items|noflags|0|0|\nadd_spacer|small|\nadd_textbox|`wYou can set the stats to be usable by the public.|left\nadd_checkbox|isStatsWorldBlockUsableByPublic|World blocks is usable by public|" + (world_public == false ? "0" : "1") + "\nadd_checkbox|isStatsFloatingItemsUsableByPublic|Floating items is usable by public|" + (floating_public == false ? "0" : "1") + "\nadd_spacer|small|\nend_dialog|statsblock|Cancel|Apply|\n");
				p.CreatePacket(peer);
			}
			if (t_ == 5714) {
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wGiant Pot O' Gold``|left|5714|\nadd_spacer|small|\nadd_textbox|Welcome to the `9Giant Pot O' Gold``! You can drop off any unwanted items here (as long as they have rarity!) Donate 20,000 rarity and win an awesome prize - donate 40,000 and get a super-awesome prize!|left|\nadd_smalltext|To donate an item, select it in your inventory, then use it on the Giant Pot O' Gold. Don't use the Drop button!|left|\nadd_spacer|small|\nadd_smalltext|You are a `6Level "+to_string(pInfo(peer)->b_lvl) + " Donator``, with "+setGems(pInfo(peer)->b_ra) + " rarity donated!|left|\nend_dialog|giantpotogold|Exit||");
				//p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wGiant Pot O' Gold``|left|5714|\nadd_spacer|small|\nadd_textbox|We are closed!|left|\nend_dialog|giantpotogold|Exit||");
				p.CreatePacket(peer);
			}
			if (t_ == 2398) {
				if (pInfo(peer)->world == "LOCKETOWN") {
					int wl = 0, dl = 0;
					modify_inventory(peer, 242, wl);
					modify_inventory(peer, 1796, dl);
					gamepacket_t p;
					p.Insert("OnDialogRequest");
					p.Insert(a + "set_default_color|`o\n\nadd_label_with_icon|big|`9Locke The Traveling Salesman``|left|2398|\nadd_spacer|small|\nadd_smalltext|Ho there, friend! Locke's my name, and locks are my game. I Love 'em all, Diamond, Huge.. even Small! If you can part with some locks, I'll give you something special in return. Whaddya say?|left|\nadd_spacer|small|\nadd_smalltext|" + (wl + dl != 0 ? "`9(Hmm, smells like you care carrying " + (wl != 0 ? to_string(wl) + " World Locks" : "") + "" + (dl != 0 ? ", and and " + to_string(dl) + " Diamond Lock" : "") + ")``" : "`9(Hmm, smells like you don't care any world locks)``") + "|left|\nadd_spacer|small|" + shop_list2 + "|\nadd_button|chc0|Close|noflags|0|0|\nnend_dialog|gazette||OK|");
					p.CreatePacket(peer);
				}
			}
			if (t_ == 9528) {
				int wl = 0, dl = 0, bgl = 0;
				modify_inventory(peer, 242, wl);
				modify_inventory(peer, 1796, dl);
				modify_inventory(peer, 7188, bgl);
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert(a + "set_default_color|`o\n\nadd_label_with_icon|big|`9Sales-Man Untradeable``|left|9528|\nadd_spacer|small|\nadd_smalltext|Damn.. I hate LOCKE!! This guy takes all my diamond locks, i'm hungry so feed me more. The Untradeable Sales-Man|left|\nadd_spacer|small|\nadd_smalltext|" + (wl + dl != 0 ? "`9(Hmm, smells like you care carrying " + (wl != 0 ? to_string(wl) + " World Locks" : "") + "" + (dl != 0 ? ", and and " + to_string(dl) + " Diamond Lock" : "") + ")``" : "`9(Hmm, smells like you don't care any world locks)``") + "|left|" + (bgl == 0 ? "" : "\nadd_smalltext|`9(You are also holding additional " + to_string(bgl) + " Blue Gem Locks)``|left|") + "\nadd_spacer|small|" + shop_list2_2 + "|\nadd_button|chc0|Close|noflags|0|0|\nnend_dialog|gazette||OK|");
				p.CreatePacket(peer);
			}
			if (items[t_].blockType == BlockTypes::VENDING) {
				if (abs(x_ * 32 - pInfo(peer)->x) > 15 || abs(y_ * 32 - pInfo(peer)->y) > 15) {
					gamepacket_t p;
					p.Insert("OnTalkBubble");
					p.Insert(pInfo(peer)->netID);
					p.Insert("Get closer!");
					p.Insert(0), p.Insert(0);
					p.CreatePacket(peer);
					break;
				}
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert(world_->owner_name == pInfo(peer)->tankIDName or find(block_->admins.begin(), block_->admins.end(), pInfo(peer)->tankIDName) != world_->admins.end() && world_->v_p && block_->locked == false ? get_vending(peer, world_, block_, x_, y_) : get_vending_buyer_side(peer, world_, block_, x_, y_));
				p.CreatePacket(peer);
				break;
			}
			if (block_->fg == 202 or block_->fg == 204 or block_->fg == 206 or block_->fg == 4994) {
				string owner_name = block_->owner_name, user_name = pInfo(peer)->tankIDName;
				if (owner_name != user_name and not pInfo(peer)->dev) {
					if (items[t_].blockType == BlockTypes::LOCK) {
						if (find(block_->admins.begin(), block_->admins.end(), pInfo(peer)->tankIDName) != block_->admins.end()) {
							gamepacket_t p;
							p.Insert("OnDialogRequest");
							p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wEdit " + items[t_].name + "``|left|" + to_string(t_) + "|\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\nadd_label|small|This lock is owned by `w" + block_->owner_name + "``, but I have access on it.|left\nend_dialog|lock_edit|Cancel|Remove My Access|");
							p.CreatePacket(peer);
						}
						else {
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(peer)->netID);
							p.Insert("I'm `4unable`` to pick the lock.");
							p.Insert(0);
							p.Insert(1);
							p.CreatePacket(peer);
						}
						packet_(peer, "action|play_sfx\nfile|audio/cant_place_tile.wav\ndelayMS|0");
						return true;
					}
				}
			}
			else if (block_->locked and items[p_].blockType != BlockTypes::CONSUMABLE) {
				WorldBlock* block2_ = &world_->blocks[block_->lock_origin];
				string owner_name = block2_->owner_name, user_name = pInfo(peer)->tankIDName;
				if (owner_name != user_name and not pInfo(peer)->dev) {
					if (find(block2_->admins.begin(), block2_->admins.end(), user_name) == block2_->admins.end() and not block2_->open_to_public and not pInfo(peer)->dev) {
						gamepacket_t p(0, pInfo(peer)->netID);
						p.Insert("OnPlayPositioned");
						p.Insert("audio/punch_locked.wav");
						if (not pInfo(peer)->invis) {
							for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
								if (pInfo(currentPeer)->world == name_) {
									p.CreatePacket(currentPeer);
								}
							}
						}
						else {
							p.CreatePacket(peer);
						}
						{
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(peer)->netID);
							p.Insert("That area is owned by " + block2_->owner_name);
							p.Insert(0);
							p.Insert(1);
							p.CreatePacket(peer);
						}
						return true;
					}
					if (items[p_].blockType == BlockTypes::LOCK) {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(peer)->netID);
						p.Insert("`w" + block2_->owner_named + "`` allows public building here, but no locks.");
						p.Insert(0);
						p.Insert(0);
						p.CreatePacket(peer);
						{
							gamepacket_t p(0, pInfo(peer)->netID);
							p.Insert("OnPlayPositioned");
							p.Insert("audio/punch_locked.wav");
							if (not pInfo(peer)->invis) {
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
									if (pInfo(currentPeer)->world == name_) {
										p.CreatePacket(currentPeer);
									}
								}
							}
							else {
								p.CreatePacket(peer);
							}
						}
						return true;
					}
				}
			}
			else if (not world_->owner_name.empty() and items[p_].blockType != BlockTypes::CONSUMABLE) {
				string owner_name = world_->owner_name, user_name = pInfo(peer)->tankIDName;
				if (owner_name != user_name and not pInfo(peer)->dev) {
					if (items[t_].blockType == BlockTypes::LOCK) {
						if (find(world_->admins.begin(), world_->admins.end(), user_name) != world_->admins.end()) {
							gamepacket_t p;
							p.Insert("OnDialogRequest");
							p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wEdit " + items[t_].name + "``|left|" + to_string(t_) + "|\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\nadd_label|small|This lock is owned by `w" + world_->owner_name + "``, but I have access on it.|left\nend_dialog|lock_edit|Cancel|Remove My Access|");
							p.CreatePacket(peer);
						}
						else {
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(peer)->netID);
							p.Insert("I'm `4unable`` to pick the lock.");
							p.Insert(0);
							p.Insert(1);
							p.CreatePacket(peer);
						}
						packet_(peer, "action|play_sfx\nfile|audio/cant_place_tile.wav\ndelayMS|0");
						return true;
					}
					if (!guild_access(peer, world_->guild_id) and find(world_->admins.begin(), world_->admins.end(), user_name) == world_->admins.end() and not world_->open_to_public and not pInfo(peer)->dev) {
						gamepacket_t p(0, pInfo(peer)->netID);
						p.Insert("OnPlayPositioned");
						p.Insert("audio/punch_locked.wav");
						if (not pInfo(peer)->invis) {
							for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
								if (pInfo(currentPeer)->world == name_) {
									p.CreatePacket(currentPeer);
								}
							}
						}
						else {
							p.CreatePacket(peer);
						}
						{
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(peer)->netID);
							p.Insert("That area is owned by " + (world_->owner_named.substr(0, 2) == "`o" ? "`w" + world_->owner_name : world_->owner_named) + "``");
							p.Insert(0);
							p.Insert(1);
							p.CreatePacket(peer);
						}
						return true;
					}
					if (items[p_].blockType == BlockTypes::LOCK) {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(peer)->netID);
						p.Insert("`w" + world_->owner_named + "`` allows public building here, but no locks.");
						p.Insert(0);
						p.Insert(0);
						p.CreatePacket(peer);
						{
							gamepacket_t p(0, pInfo(peer)->netID);
							p.Insert("OnPlayPositioned");
							p.Insert("audio/punch_locked.wav");
							if (not pInfo(peer)->invis) {
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
									if (pInfo(currentPeer)->world == name_) {
										p.CreatePacket(currentPeer);
									}
								}
							}
							else {
								p.CreatePacket(peer);
							}
						}
						return true;
					}
				}
			} if (world_->owner_name != pInfo(peer)->tankIDName) {
				if (items[t_].magplant or items[t_].item_sucker) {
					switch (t_) {
					case 6948: case 5638: case 6946:
					{
						if (not world_->owner_name.empty()) {
							bool ar_turi_mag = false;
							{
								int c_ = 0;
								if (block_->id != 0) {
									modify_inventory(peer, 5640, c_);
									if (c_ != 0) {
										if (pInfo(peer)->magnetron_x == x_ and pInfo(peer)->magnetron_y == y_ and pInfo(peer)->magnetron_id == block_->id) {
											ar_turi_mag = true;
										}
									}
								}
							}
							bool dont_give = false;
							if (items[block_->id].collisionType != 1 and items[block_->id].blockType != BACKGROUND and items[block_->id].blockType != CONSUMABLE and items[block_->id].blockType != SEED and not items[block_->id].farmable or items[block_->id].rarity == 999) {
								dont_give = true;
							}
							gamepacket_t p;
							p.Insert("OnDialogRequest");
							p.Insert("set_default_color|`o\nadd_label_with_icon|big|`w" + items[block_->fg].name + "``|left|" + to_string(block_->fg) + "|\nadd_spacer|small|\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + (block_->id == 0 ? "\nadd_textbox|There is no item selected |left|" : "\nadd_label_with_icon|small|`2" + items[block_->id].name + "``|left|" + to_string(block_->id) + "|") + (block_->fg == 5638 and not block_->magnetron ? "\nadd_textbox|Building mode: `6DISABLED``|left|" : "\nadd_textbox|Building mode: `5ACTIVE``|left|\nadd_textbox|Use the " + items[5640].name + " to build `2" + items[block_->id].name + "`` directly from the " + items[block_->fg].name + "'s storage.|left|" + (not ar_turi_mag and not dont_give ? "\nadd_button|getplantationdevice|Get Remote|noflags|0|0|" : "") + "") + "\nend_dialog|itemsucker_block|Close||");
							p.CreatePacket(peer);
						}
						break;
					}
					case 6950: case 6952:
					{
						gamepacket_t p;
						p.Insert("OnDialogRequest");
						p.Insert("add_label_with_icon|big|`w" + items[block_->fg].name + "``|left|" + to_string(block_->fg) + "|\nadd_spacer|small|\nadd_smalltext|The device will consume 2300 Gems/hr while active!|left|\nadd_smalltext|Current Fuel = `w" + to_string(block_->pr) + "/8,000``|left|\nend_dialog|autoactionblock|Close||\nadd_quick_exit|");
						p.CreatePacket(peer);
						break;
					}
					}
					if (not items[t_].item_sucker) return true;
				}
			}
			if (items[t_].can_be_changed_two_types) {
				if (world_->owner_name.empty() and not block_->locked) {
					gamepacket_t p;
					p.Insert("OnDialogRequest");
					p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wEdit " + items[t_].name + "``|left|" + to_string(t_) + "|\nadd_textbox|This object has additional properties to edit if in a locked area.|left|\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\nend_dialog|boombox_edit|Cancel|OK|");
					p.CreatePacket(peer);
				}
				else {
					gamepacket_t p;
					p.Insert("OnDialogRequest");
					p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wEdit " + items[t_].name + "``|left|" + to_string(t_) + "|\nadd_checkbox|checkbox_public|Usable by public|" + (block_->flags & 0x00800000 ? "1" : "0") + "\nadd_checkbox|checkbox_silence|Silenced|" + (block_->flags & 0x02000000 ? "1" : "0") + "\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\nend_dialog|boombox_edit|Cancel|OK|");
					p.CreatePacket(peer);
				}
				break;
			}
			if (items[t_].trickster) {
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\nadd_label_with_icon|big|`9" + items[t_].name + "``|left|" + to_string(t_) + "|\nadd_spacer|small|\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\nadd_textbox|Rate of fire? (2-20 seconds)|left|\nadd_text_input|often|Seconds:|" + to_string(block_->rate_of_fire) + "|3|\nadd_textbox|Speed of projectiles? (10-250 pixels/second)|left|\nadd_text_input|speed|Speed:|" + to_string(block_->projectile_speed) + "|3|\nadd_checkbox|disable|Disabled|" + (block_->flags & 0x00400000 ? "0" : "1") + "\nadd_smalltext|You can install as many Blaster Blocks (Howlers or Tricksters) as you want in a world, but only 10 projectiles can exist at one time, so don't go crazy!|left|\nend_dialog|blaster|Cancel|Update|");
				p.CreatePacket(peer);
				break;
			}
			if (items[t_].xeno) {
				if (world_->owner_name.empty() and not block_->locked) {
					gamepacket_t p;
					p.Insert("OnDialogRequest");
					p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wEdit " + items[t_].name + "``|left|" + to_string(t_) + "|\nadd_textbox|This object has additional properties to edit if in a locked area.|left|\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\nend_dialog|xenonite_edit|Cancel|OK|");
					p.CreatePacket(peer);
				}
				else {
					gamepacket_t p;
					p.Insert("OnDialogRequest");
					p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wEdit " + items[t_].name + "``|left|" + to_string(t_) + "|\nadd_textbox|This object has additional properties to edit if in a locked area.|left|\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\nend_dialog|xenonite_edit|Cancel|OK|");
					p.CreatePacket(peer);
				}
				break;
			}
			if (items[t_].mannequin) {
				string ex = "";
				if (block_->mannequin.c_head != 0) ex += "\nadd_checkbox|checkbox_" + to_string(block_->mannequin.c_head) + "|" + items[block_->mannequin.c_head].name + "|0|";
				if (block_->mannequin.c_shirt != 0) ex += "\nadd_checkbox|checkbox_" + to_string(block_->mannequin.c_shirt) + "|" + items[block_->mannequin.c_shirt].name + "|0|";
				if (block_->mannequin.c_pants != 0) ex += "\nadd_checkbox|checkbox_" + to_string(block_->mannequin.c_pants) + "|" + items[block_->mannequin.c_pants].name + "|0|";
				if (block_->mannequin.c_feet != 0) ex += "\nadd_checkbox|checkbox_" + to_string(block_->mannequin.c_feet) + "|" + items[block_->mannequin.c_feet].name + "|0|";
				if (block_->mannequin.c_mask != 0) ex += "\nadd_checkbox|checkbox_" + to_string(block_->mannequin.c_mask) + "|" + items[block_->mannequin.c_mask].name + "|0|";
				if (block_->mannequin.c_hand != 0) ex += "\nadd_checkbox|checkbox_" + to_string(block_->mannequin.c_hand) + "|" + items[block_->mannequin.c_hand].name + "|0|";
				if (block_->mannequin.c_back != 0) ex += "\nadd_checkbox|checkbox_" + to_string(block_->mannequin.c_back) + "|" + items[block_->mannequin.c_back].name + "|0|";
				if (block_->mannequin.c_hair != 0) ex += "\nadd_checkbox|checkbox_" + to_string(block_->mannequin.c_hair) + "|" + items[block_->mannequin.c_hair].name + "|0|";
				if (block_->mannequin.c_neck != 0) ex += "\nadd_checkbox|checkbox_" + to_string(block_->mannequin.c_neck) + "|" + items[block_->mannequin.c_neck].name + "|0|";
				if (not ex.empty()) ex += "\nadd_spacer|small|\nadd_button|clear_selected|`4Remove Selected Items``|noflags|0|0|\nadd_button|clear|`4Remove All Items``|noflags|0|0|";
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wEdit " + items[t_].name + "``|left|" + to_string(t_) + "|\nadd_textbox|To dress, select a clothing item then use on the mannequin. To remove clothes, punch it or select which item to remove.<CR><CR>It will go into your backpack if you have room.|" + ex + "\nadd_textbox|<CR><CR>What would you like to write on its sign?``|left|\nadd_text_input|sign_text||" + block_->txt + "|128|\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\nend_dialog|mannequin_edit|Cancel|OK|");
				p.CreatePacket(peer);
				break;
			}
			if (items[t_].dshelf) {
				bool can_take = (block_->shelf_1 != 0 or block_->shelf_2 != 0 or block_->shelf_3 != 0 or block_->shelf_4 != 0 ? true : false);
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\nadd_label_with_icon|big|`w" + items[t_].name + "``|left|" + to_string(t_) + "|\nadd_spacer|small|\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\n" + (block_->shelf_2 != 0 ? "add_item_picker|replace2|Item 1: `2" + items[block_->shelf_2].name + "``|Select any item to display|" : "add_item_picker|replace2|`4Display an item``|Select any item to display|") + "\n" + (block_->shelf_1 != 0 ? "add_item_picker|replace1|Item 2: `2" + items[block_->shelf_1].name + "``|Select any item to display|" : "add_item_picker|replace1|`4Display an item``|Select any item to display|") + "\n" + (block_->shelf_3 != 0 ? "add_item_picker|replace3|Item 3: `2" + items[block_->shelf_3].name + "``|Select any item to display|" : "add_item_picker|replace3|`4Display an item``|Select any item to display|") + "\n" + (block_->shelf_4 != 0 ? "add_item_picker|replace4|Item 4: `2" + items[block_->shelf_4].name + "``|Select any item to display|" : "add_item_picker|replace4|`4Display an item``|Select any item to display|") + (can_take ? "\nadd_button|remove|Take All Items|noflags|0|0|" : "") + "\nend_dialog|dispshelf|Okay||");
				p.CreatePacket(peer);
				break;
			}
			if (items[t_].vipentrance) {
				if (world_->owner_name.empty() and not block_->locked) {
					gamepacket_t p;
					p.Insert("OnDialogRequest");
					p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wEdit " + items[t_].name + "``|left|" + to_string(t_) + "|\nadd_textbox|This object has additional properties to edit if in a locked area.|left|\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\nend_dialog|vip_edit|Cancel|OK|");
					p.CreatePacket(peer);
				}
				else {
					string add_ = "";
					for (string own : block_->admins) {
						try {
							ifstream ifs("players/" + own + "_.json");
							if (ifs.is_open()) {
								string name_ = own;
								json j;
								ifs >> j;
								if (j["mod"] == 1) name_ = "`#@" + own;
								if (j["dev"] == 1) name_ = "`6@" + own;
								if (j["superdev"] == 1) name_ = "`b@" + own;
								add_ += "\nadd_checkbox|checkbox_" + own + "|" + name_ + "``|1";
							}
							ifs.close();
						}
						catch (exception) {
							continue;
						}
					}
					if (add_.empty()) add_ = "\nadd_label|small|Nobody!|left";
					gamepacket_t p;
					p.Insert("OnDialogRequest");
					p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wEdit " + items[t_].name + "``|left|" + to_string(t_) + "|\nadd_label|small|`wVIP list:``|left\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\nadd_spacer|small|" + add_ + "\nadd_spacer|small|\nadd_player_picker|playerNetID|`wAdd``|\nadd_checkbox|checkbox_public|Allow anyone to enter|" + (block_->limit_admins ? "1" : "0") + "\nend_dialog|vip_edit|Cancel|OK|");
					p.CreatePacket(peer);
				}
				break;
			}
			if (items[t_].portrait) {
				bool has_enough = false;
				int red = 0, yellow = 0, green = 0, aqua = 0, blue = 0, purple = 0, charcoal = 0, varnish = 0;
				{
					modify_inventory(peer, 3478, red);
					modify_inventory(peer, 3480, yellow);
					modify_inventory(peer, 3482, green);
					modify_inventory(peer, 3484, aqua);
					modify_inventory(peer, 3486, blue);
					modify_inventory(peer, 3488, purple);
					modify_inventory(peer, 3490, charcoal);
					modify_inventory(peer, 3492, varnish);
					if (red >= 2 and yellow >= 2 and green >= 2 and aqua >= 2 and blue >= 2 and purple >= 2 and charcoal >= 2 and varnish >= 2) {
						has_enough = true;
					}
				}
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				string erase = (varnish >= 4 ? "\nadd_button|erase|Erase Painting|noflags|0|0|\nadd_smalltext|`5(Erasing costs 4 Paint Bucket - Varnish)``|left|" : "\nadd_textbox|You'll need 4 Paint Bucket - Varnish to erase this.|left|");
				string tratata = (has_enough ? "\nadd_player_picker|playerNetID|`wPaint Someone``|\nadd_smalltext|`5(Painting costs 2 Paint Bucket of each color)``|left|" : "\nadd_textbox|You'll need 2 of each color of Paint Bucket to paint someone.|left|");
				p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wEdit " + items[t_].name + "``|left|" + to_string(t_) + "|\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "" + (block_->portrait.c_skin == 0 and block_->portrait.c_face == 0 and block_->portrait.c_hair == 0 and block_->portrait.c_head == 0 ? ("\nadd_textbox|The canvas is blank.|left|" + tratata) : "\nadd_textbox|This is a lovely portrait of a Growtopian.|left|" + erase + "\nadd_text_input|artname|Title:|" + block_->txt + "|60|\nadd_smalltext|If you'd like to touch up the painting slightly, you could change the expression:|left|\nadd_checkbox|chk1|Unconcerned|" + (block_->portrait.c_expression == 1 ? "1" : "0") + "|\nadd_checkbox|chk2|Happy|" + (block_->portrait.c_expression == 2 ? "1" : "0") + "|\nadd_checkbox|chk3|Sad|" + (block_->portrait.c_expression == 3 ? "1" : "0") + "|\nadd_checkbox|chk4|Tongue Out|" + (block_->portrait.c_expression == 4 ? "1" : "0") + "|\nadd_checkbox|chk5|Surprised|" + (block_->portrait.c_expression == 5 ? "1" : "0") + "|\nadd_checkbox|chk6|Angry|" + (block_->portrait.c_expression == 6 ? "1" : "0") + "|\nadd_checkbox|chk7|Talking|" + (block_->portrait.c_expression == 7 ? "1" : "0") + "|\nadd_checkbox|chk9|Ecstatic|" + (block_->portrait.c_expression == 9 ? "1" : "0") + "|\nadd_checkbox|chk11|Wry|" + (block_->portrait.c_expression == 11 ? "1" : "0") + "|\nadd_checkbox|chk12|Sleeping|" + (block_->portrait.c_expression == 12 ? "1" : "0") + "|\nadd_checkbox|chk14|Winking|" + (block_->portrait.c_expression == 14 ? "1" : "0") + "|\nadd_checkbox|chk16|Trolling|" + (block_->portrait.c_expression == 16 ? "1" : "0") + "\nadd_checkbox|chk18|Vampire|" + (block_->portrait.c_expression == 18 ? "1" : "0") + "\nadd_checkbox|chk22|Underwater|" + (block_->portrait.c_expression == 22 ? "1" : "0") + "|") + "\nend_dialog|portrait|Cancel|Update|");
				p.CreatePacket(peer);
				break;
			}
			if (t_ == 2452) {
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wClothing Compactor``|left|2452|\nadd_textbox|Use (almost) any clothing on this device to crush it down, permanently destroying it. If you just have extra clothes taking up space, crush 'em!|left|\nadd_textbox|The results may surprise you! But probably you will get seeds or gems.|left|\nend_dialog|compactor|Thanks for the info!||");
				p.CreatePacket(peer);
				break;
			}
			if (t_ == 4322) {
				string tools = "";
				for (int i_ = 0; i_ < pInfo(peer)->inv.size(); i_++) if (pInfo(peer)->inv[i_].count >= 20 && pInfo(peer)->inv[i_].id == 1258 || pInfo(peer)->inv[i_].id == 1260 || pInfo(peer)->inv[i_].id == 1262 || pInfo(peer)->inv[i_].id == 1264 || pInfo(peer)->inv[i_].id == 1266 || pInfo(peer)->inv[i_].id == 1268 || pInfo(peer)->inv[i_].id == 1270 || pInfo(peer)->inv[i_].id == 4308 || pInfo(peer)->inv[i_].id == 4310 || pInfo(peer)->inv[i_].id == 4312 || pInfo(peer)->inv[i_].id == 4314 || pInfo(peer)->inv[i_].id == 4316 || pInfo(peer)->inv[i_].id == 4318) tools += "\nadd_button_with_icon|tool" + to_string(pInfo(peer)->inv[i_].id) + "|`$" + items[pInfo(peer)->inv[i_].id].ori_name + "``|noflags|" + to_string(pInfo(peer)->inv[i_].id) + "|" + to_string(pInfo(peer)->inv[i_].count) + "|";
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\nadd_label_with_icon|big|`9Autoclave``|left|4322|\nadd_spacer|small|\nadd_textbox|With this device, you can exchange 20 of any one surgical tool for 1 each of all the other tools. Choose an instrument to dispose of:|left|" + (tools != "" ? "\ntext_scaling_string|Surgical Defibrillator|" + tools + "\nadd_button_with_icon||END_LIST|noflags|0||" : "") + "\nend_dialog|autoclave|Cancel||");
				p.CreatePacket(peer);
				break;
			}
			if (items[t_].easel) {
				bool has_enough = false;
				int red = 0, yellow = 0, green = 0, aqua = 0, blue = 0, purple = 0, charcoal = 0, varnish = 0;
				{
					modify_inventory(peer, 3478, red);
					modify_inventory(peer, 3480, yellow);
					modify_inventory(peer, 3482, green);
					modify_inventory(peer, 3484, aqua);
					modify_inventory(peer, 3486, blue);
					modify_inventory(peer, 3488, purple);
					modify_inventory(peer, 3490, charcoal);
					modify_inventory(peer, 3492, varnish);
					if (red >= 2 and yellow >= 2 and green >= 2 and aqua >= 2 and blue >= 2 and purple >= 2 and charcoal >= 2 and varnish >= 2) {
						has_enough = true;
					}
				}
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\nadd_label_with_icon|big|`w" + items[t_].name + "``|left|" + to_string(t_) + "|\nadd_spacer|small|\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\nadd_textbox|The canvas is blank.|left|" + (block_->id != 0 ? "\nadd_textbox|This is a lovely still-life of " + items[block_->id].name + ".|left|" + (varnish < 4 ? "\nadd_smalltext|You'll need 4 Paint Bucket - Varnish to erase this.|left|" : "\nadd_button|erase|Erase Painting|noflags|0|0|\nadd_smalltext|`5(Erasing costs 4 Paint Bucket - Varnish)``|left|") : (not has_enough ? "\nadd_textbox|You'll need 2 of each color of Paint Bucket to paint something.|left|" : "\nadd_item_picker|paint|`wPaint Something``|Select an item to paint|")) + "\nadd_text_input|artname|Signed:|" + block_->txt + "|60|\nend_dialog|artcanvas|Cancel|Update|");
				p.CreatePacket(peer);
				break;
			}
			if (items[t_].entrance or items[t_].can_be_changed_to_public) {
				if (world_->owner_name.empty() and not block_->locked) {
					gamepacket_t p;
					p.Insert("OnDialogRequest");
					p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wEdit " + items[t_].name + "``|left|" + to_string(t_) + "|\nadd_textbox|This object has additional properties to edit if in a locked area.|left|\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\nend_dialog|switcheroo_edit|Cancel|OK|");
					p.CreatePacket(peer);
				}
				else {
					gamepacket_t p;
					p.Insert("OnDialogRequest");
					p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wEdit " + items[t_].name + "``|left|" + to_string(t_) + "|\nadd_checkbox|checkbox_public|" + (items[t_].can_be_changed_to_public ? "Usable by public" : "Is open to public") + "|" + (block_->flags & 0x00800000 ? "1" : "0") + "\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\nend_dialog|switcheroo_edit|Cancel|OK|");
					p.CreatePacket(peer);
				}
				break;
			}
			if (t_ == 1436 || t_ == 8246 || t_ == 10258) {
				pInfo(peer)->lastwrenchb = t_;
				string logs = "", settings = "", a = "";
				bool show_item_taking = false, show_item_dropping = false, show_people_entering = false, show_people_exiting = false, dont_show_owner = false, dont_show_admins = false, dont_show_noaccess = false;
				for (int i_ = 0; i_ < world_->cctv.size(); i_++) if (world_->cctv[i_].x == x_ and world_->cctv[i_].y == y_) logs += world_->cctv[i_].logs;
				for (int i_ = 0; i_ < world_->cctv_settings.size(); i_++) if (world_->cctv_settings[i_].x == x_ and world_->cctv_settings[i_].y == y_) settings = a + "\nadd_checkbox|checkbox_showpick|Show Item Taking|" + (world_->cctv_settings[i_].show_item_taking ? "1" : "0") + "\nadd_checkbox|checkbox_itemdrop|Show Item Dropping|" + (world_->cctv_settings[i_].show_item_dropping ? "1" : "0") + "\nadd_checkbox|checkbox_showenter|Show People Entering|" + (world_->cctv_settings[i_].show_people_entering ? "1" : "0") + "\nadd_checkbox|checkbox_showexit|Show People Exiting|" + (world_->cctv_settings[i_].show_people_exiting ? "1" : "0") + "\nadd_checkbox|checkbox_noshowowner|Don't Show Owner|" + (world_->cctv_settings[i_].dont_show_owner ? "1" : "0") + "\nadd_checkbox|checkbox_noshowadmin|Don't Show Admins|" + (world_->cctv_settings[i_].dont_show_admins ? "1" : "0") + "\nadd_checkbox|checkbox_noshowother|Don't Show People Without Access|" + (world_->cctv_settings[i_].dont_show_noaccess ? "1" : "0");
				if (settings == "") {
					WorldCCTVSettings cctvs_{};
					cctvs_.x = pInfo(peer)->lastwrenchx, cctvs_.y = pInfo(peer)->lastwrenchy;
					cctvs_.show_item_taking = false, cctvs_.show_item_dropping = false, cctvs_.show_people_entering = true, cctvs_.show_people_exiting = false, cctvs_.dont_show_owner = dont_show_owner == 1 ? true : false, cctvs_.dont_show_admins = false, cctvs_.dont_show_noaccess = false;
					world_->cctv_settings.push_back(cctvs_);
					WorldCCTV cctv_{};
					cctv_.x = pInfo(peer)->lastwrenchx, cctv_.y = pInfo(peer)->lastwrenchy;
					cctv_.logs = "";
					world_->cctv.push_back(cctv_);
					settings = "\nadd_checkbox|checkbox_showpick|Show Item Taking|0\nadd_checkbox|checkbox_itemdrop|Show Item Dropping|0\nadd_checkbox|checkbox_showenter|Show People Entering|1\nadd_checkbox|checkbox_showexit|Show People Exiting|0\nadd_checkbox|checkbox_noshowowner|Don't Show Owner|0\nadd_checkbox|checkbox_noshowadmin|Don't Show Admins|0\nadd_checkbox|checkbox_noshowother|Don't Show People Without Access|0";
				}
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\nadd_label_with_icon|big|`w" + items[t_].name + "``|left|" + to_string(t_) + "|\nadd_spacer|small|" + (logs == "" ? "\nadd_textbox|The camera log is empty.|left|" : logs) + "" + settings + "" + (logs != "" ? "\nadd_button|clear|`4Clear Log``|noflags|0|0|" : "") + "\nend_dialog|camera_edit||OK|\nadd_quick_exit|");
				p.CreatePacket(peer);
				break;
			}
			if (t_ == 4296 || t_ == 8558) {
				if (has_playmod(pInfo(peer), "Malpractice")) {
					gamepacket_t p;
					p.Insert("OnTalkBubble");
					p.Insert(pInfo(peer)->netID);
					p.Insert("I know it's just a robot, but the authorities don't even trust you operating on that with your malpractice issues.");
					p.Insert(0), p.Insert(1);
					p.CreatePacket(peer);
				}
				else {
					pInfo(peer)->lastwrenchb = t_;
					gamepacket_t p;
					p.Insert("OnDialogRequest"), p.Insert("set_default_color|`o\nadd_label_with_icon|big|`9" + items[t_].name + "``|left|" + to_string(t_) + "|\nadd_spacer|small|\nadd_smalltext|Surgeon Skill: " + to_string(pInfo(peer)->surgery_skill) + "|left|\nadd_textbox|Are you sure you want to perform surgery on this robot? Whether you succeed or fail, the robot will be destroyed in the process.|left|\nend_dialog|surge|Cancel|Okay!|"), p.CreatePacket(peer);
				}
				break;
			}
			if (t_ == 4582) {
				gamepacket_t p;
				p.Insert("OnDialogRequest"), p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wFood Grinder``|left|4582|\nadd_textbox|Use items on here to try to grind them up into tasty food. Only certain things can be ground up.|left|\nadd_textbox|You might be surprised what you can grind!|left|\nend_dialog|grinder|Thanks for the info!||"), p.CreatePacket(peer);
				break;
			}
			if (t_ == 2646) {
				if (block_->spotlight != "") {
					string spotlight = "";
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world) continue;
						if (block_->spotlight == pInfo(currentPeer)->tankIDName) spotlight = pInfo(currentPeer)->tankIDName;
					}
					block_->spotlight = spotlight;
				}
				gamepacket_t p;
				p.Insert("OnDialogRequest"), p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wShine the Spotlight!``|left|2646|\nadd_spacer|small|\nadd_textbox|" + (block_->spotlight == "" ? "The light is currently off." : "The light is shining on " + block_->spotlight + ".") + "|left|\nadd_spacer|small|\nadd_player_picker|ID|`wChoose a " + (block_->spotlight == "" ? "superstar" : "new star") + "``|" + (block_->spotlight == "" ? "" : "\nadd_button|off|Turn it off|noflags|0|0|") + "\nend_dialog|2646|Nevermind||"), p.CreatePacket(peer);
				break;
			}
			if (items[t_].magplant or items[t_].item_sucker) {
				switch (t_) {
				case 6948: case 5638: case 6946:
				{
					gamepacket_t p;
					p.Insert("OnDialogRequest");
					p.Insert(get_sucker(peer, world_, block_, x_, y_));
					p.CreatePacket(peer);
					break;
				}
				case 6950: case 6952:
				{
					gamepacket_t p;
					p.Insert("OnDialogRequest");
					p.Insert("add_label_with_icon|big|`w" + items[block_->fg].name + "``|left|" + to_string(block_->fg) + "|\nadd_spacer|small|\nadd_smalltext|The device will consume 2300 Gems/hr while active!|left|\nadd_smalltext|Current Fuel = `w" + to_string(block_->pr) + "/8,000``|left|" + (block_->pr < 8000 ? "\nadd_smalltext|Refuel this with gems!|left|\nadd_text_input|refillfuel|Add Gems:|0|5|\nadd_button|addfuel|`wAdd Gems``|noflags|0|0|" : "") + "\nadd_spacer|small|\nadd_smalltext|" + (block_->id == 0 ? "No block type selected!" : "Target block is: `2" + items[block_->id].name + "``") + "|left|\nadd_item_picker|selecttarget|`wChoose Target Item``|Choose the target item!|\nadd_spacer|small|\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\nend_dialog|autoactionblock|Close|OK|\nadd_quick_exit|");
					p.CreatePacket(peer);
					break;
				}
				}
				break;
			}
			switch (items[t_].blockType) {
			case BlockTypes::WEATHER:
			{
				switch (t_) {
				case 3694:
				{
					gamepacket_t p;
					p.Insert("OnDialogRequest");
					p.Insert("set_default_color|`o\nadd_label_with_icon|big|`w" + items[t_].name + "``|left|" + to_string(t_) + "|\nadd_spacer|small|\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\nadd_textbox|Adjust the color of your heat wave here, by including 0-255 of Red, Green, and Blue.|left|\nadd_text_input|red|Red|" + to_string(block_->r) + "|3|\nadd_text_input|green|Green|" + to_string(block_->g) + "|3|\nadd_text_input|blue|Blue|" + to_string(block_->b) + "|3|\nend_dialog|weatherspcl|Cancel|Okay|");
					p.CreatePacket(peer);
					break;
				}
				case 5000:
				{
					gamepacket_t p;
					p.Insert("OnDialogRequest");
					p.Insert("set_default_color|`o\nadd_label_with_icon|big|`w" + items[t_].name + "``|left|" + to_string(t_) + "|\nadd_spacer|small|\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\nadd_textbox|You can scan any Background Block to set it up in your weather machine.|left|\nadd_item_picker|choose|Item: `2" + items[(block_->id != 0 ? block_->id : 14)].name + "``|Select any Background Block|\nend_dialog|weatherspcl|Cancel|Okay|");
					p.CreatePacket(peer);
					break;
				}
				case 5958:
				{
					gamepacket_t p;
					p.Insert("OnDialogRequest");
					p.Insert("set_default_color|`o\nadd_label_with_icon|big|`w" + items[t_].name + "``|left|" + to_string(t_) + "|\nadd_spacer|small|\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\nadd_textbox|Select your doom!|left|\nadd_checkbox|iceage|Ice Age``|" + (block_->ice_age ? "1" : "0") + "\nadd_checkbox|volcano|Volcano``|" + (block_->volcano ? "1" : "0") + "\nadd_checkbox|islands|Floating Islands``|" + (block_->islands ? "1" : "0") + "\nend_dialog|weatherspcl|Cancel|Okay|");
					p.CreatePacket(peer);
					break;
				}
				case 3832:
				{
					gamepacket_t p;
					p.Insert("OnDialogRequest");
					p.Insert("set_default_color|`o\nadd_label_with_icon|big|`w" + items[t_].name + "``|left|" + to_string(t_) + "|\nadd_spacer|small|\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\nadd_item_picker|choose|Item: `2" + items[(block_->id != 0 ? block_->id : 14)].name + "``|Select any item to rain down|\nadd_text_input|gravity|Gravity:|" + to_string(block_->gravity) + "|5|\nadd_checkbox|spin|Spin Items|" + (block_->spin ? "1" : "0") + "\nadd_checkbox|invert|Invert Sky Colors|" + (block_->invert ? "1" : "0") + "\nend_dialog|weatherspcl|Cancel|Okay|");
					p.CreatePacket(peer);
					break;
				}
				}
				break;
			}
			case BlockTypes::DISPLAY:
			{
				string owner_name = world_->owner_name, user_name = pInfo(peer)->tankIDName;
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\nadd_label_with_icon|big|`w" + items[t_].name + "``|left|" + to_string(t_) + "|\nadd_spacer|small|\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\nadd_textbox|" + (block_->id != 0 ? "A " + items[block_->id].ori_name + " is on display here." : "The Display Block is empty. Use an item on it to display the item!") + "|left|" + (block_->id != 0 and user_name == owner_name or owner_name.empty() ? "\nend_dialog|displayblock|Leave it|Pick it up|" : "\nend_dialog|displayblock|Okay||"));
				p.CreatePacket(peer);
				break;
			}
			case BlockTypes::LOCK:
			{
				if (t_ == 202 or t_ == 204 or t_ == 206 or t_ == 4994) {
					string access_list_ = "";
					for (int i_ = 0; i_ < block_->admins.size(); i_++) {
						access_list_ += "\nadd_checkbox|checkbox_/" + block_->admins[i_] + "|`w" + block_->admins[i_] + "``|1";
					}
					if (access_list_.empty())
						access_list_ = "\nadd_label|small|Currently, you're the only one with access.``|left";
					if (t_ == 4994) {
						gamepacket_t p;
						p.Insert("OnDialogRequest");
						p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wEdit " + items[t_].name + "``|left|" + to_string(t_) + "|\nadd_label|small|`wAccess list:``|left\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\nadd_spacer|small|" + access_list_ + "\nadd_spacer|small|\nadd_player_picker|playerNetID|`wAdd``|\nadd_checkbox|checkbox_public|Allow anyone to Build or Break|" + (block_->open_to_public ? "1" : "0") + "\nadd_checkbox|checkbox_ignore|Ignore empty air|" + (block_->empty_air ? "1" : "0") + "\nadd_button|recalcLock|`wRe-apply lock``|noflags|0|0|\nadd_spacer|small|\nadd_smalltext|This lock allows Building or Breaking.|left|\nadd_smalltext|(ONLY if 'Allow anyone to Build or Break' is checked above)!|left|\nadd_spacer|small|\nadd_smalltext|Leaving this box unchecked only allows Breaking.|left|\nadd_checkbox|checkbox_buildonly|Only Allow Building!|" + (block_->build_only ? "1" : "0") + "\nadd_smalltext|People with lock access can both build and break unless you check below. The lock owner can always build and break.|left|\nadd_checkbox|checkbox_admins|Admins Are Limited|" + (block_->limit_admins ? "1" : "0") + "\nend_dialog|lock_edit|Cancel|OK|");
						p.CreatePacket(peer);
					}
					else {
						gamepacket_t p;
						p.Insert("OnDialogRequest");
						p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wEdit " + items[t_].name + "``|left|" + to_string(t_) + "|\nadd_label|small|`wAccess list:``|left\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\nadd_spacer|small|" + access_list_ + "\nadd_spacer|small|\nadd_player_picker|playerNetID|`wAdd``|\nadd_checkbox|checkbox_public|Allow anyone to Build and Break|" + (block_->open_to_public ? "1" : "0") + "\nadd_checkbox|checkbox_ignore|Ignore empty air|" + (block_->empty_air ? "1" : "0") + "\nadd_button|recalcLock|`wRe-apply lock``|noflags|0|0|\nend_dialog|lock_edit|Cancel|OK|");
						p.CreatePacket(peer);
					}
				}
				else {
					if (t_ == 5814 and world_->guild_id != 0) {
						send_edit_lock(peer, world_, t_, x_, y_);
					}
					else {
						string access_list_ = "";
						for (int i_ = 0; i_ < world_->admins.size(); i_++) {
							access_list_ += "\nadd_checkbox|checkbox_/" + world_->admins[i_] + "|`w" + world_->admins[i_] + "``|1";
						}
						if (access_list_.empty())
							access_list_ = "\nadd_label|small|Currently, you're the only one with access.``|left";
						string world_key = "\nadd_button|getKey|Get World Key|noflags|0|0|";
						int c_ = 0;
						modify_inventory(peer, 1424, c_);
						if (c_ != 0) {
							world_key = "";
						}
						gamepacket_t p;
						p.Insert("OnDialogRequest");
						string e_ = "";
						//" + (t_ == 4802 ? "\nadd_label|small|Ye Royal Options|left\nadd_checkbox|checkbox_silence|Silence, Peasants!|" + e_ + (world_->silence ? "1" : "0") + "\nadd_checkbox|checkbox_rainbows|Royal Rainbows!|" + (world_->rainbows ? "1" : "0") : "") + "
						p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wEdit " + items[t_].name + "``|left|" + to_string(t_) + "|\nadd_label|small|`wAccess list:``|left\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\nadd_spacer|small|" + access_list_ + "\nadd_spacer|small|\nadd_player_picker|playerNetID|`wAdd``|\nadd_checkbox|checkbox_public|Allow anyone to Build and Break|" + (world_->open_to_public ? "1" : "0") + "\nadd_checkbox|checkbox_vending|Allow admins to edit vending|" + (world_->v_p ? "1" : "0") + "\nadd_checkbox|checkbox_disable_music|Disable Custom Music Blocks|" + (world_->disable_music_blocks ? "1" : "0") + "\nadd_text_input|tempo|Music BPM|" + to_string(world_->music_bpm) + "|3|\nadd_checkbox|checkbox_disable_music_render|Make Custom Music Blocks invisible|" + (world_->make_music_blocks_invisible ? "1" : "0") + (not pInfo(peer)->home_world.empty() ? "\nadd_smalltext|Your current home world is: " + pInfo(peer)->home_world + "|left|" : "") + "\nadd_checkbox|checkbox_set_as_home_world|Set as Home World|" + (pInfo(peer)->home_world == world_->name ? "1" : "0") + (t_ == 4802 ? "\nadd_label|small|Ye Royal Options|left\nadd_checkbox|checkbox_silence|Silence, Peasants!|" + e_ + (world_->silence ? "1" : "0") + "\nadd_checkbox|checkbox_rainbows|Royal Rainbows!|" + (world_->rainbows ? "1" : "0") : "") + "|\nadd_text_input|minimum_entry_level|World Level: |" + to_string(world_->entry_level) + "|3|\nadd_smalltext|Set minimum world entry level.|\nadd_button|sessionlength_dialog|`wSet World Timer``|noflags|0|0|\nadd_button|changecat|`wCategory: None``|noflags|0|0|" + world_key + "\nend_dialog|lock_edit|Cancel|OK|");
						p.CreatePacket(peer);
					}
				}
				break;
			}
			case BlockTypes::SIGN:
			{
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wEdit " + items[t_].name + "``|left|" + to_string(t_) + "|\nadd_textbox|" + (t_ == 1684 ? "Enter an ID. You can use this as a destination for Doors.``" : "What would you like to write on this sign?``") + "|left|\nadd_text_input|sign_text||" + (t_ == 1684 ? block_->door_id : block_->txt) + "|128|\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\nend_dialog|sign_edit|Cancel|OK|");
				p.CreatePacket(peer);
				break;
			}
			case BlockTypes::STORAGE:
			{
				if (pInfo(peer)->tankIDName == world_->owner_name || pInfo(peer)->dev == 1) {
					int got = 0;
					modify_inventory(peer, 1424, got);
					modify_inventory(peer, 1424, got *= -1);
					pInfo(peer)->lastwrenchb = t_;
					string dbox_item = "\nadd_spacer|small|\ntext_scaling_string|aaaaaaaaaaaaaaa|";
					int itemcount = 0;
					for (int i_ = 0; i_ < world_->sbox1.size(); i_++) if (world_->sbox1[i_].x == x_ and world_->sbox1[i_].y == y_) itemcount++, dbox_item += "\nadd_button_with_icon|itm" + to_string(itemcount) + "|" + items[world_->sbox1[i_].id].name + "|frame|" + to_string(world_->sbox1[i_].id) + "|" + to_string(world_->sbox1[i_].count) + "|";
					gamepacket_t p;
					p.Insert("OnDialogRequest");
					p.Insert("set_default_color|`o\nadd_label_with_icon|big|`w" + items[t_].name + "``|left|" + to_string(t_) + "|" + (dbox_item.size() > 56 ? dbox_item + "\nadd_button_with_icon||END_LIST|noflags|0||" : "") + "\nadd_textbox|`w" + to_string(itemcount) + "/" + to_string(items[pInfo(peer)->lastwrenchb].box_size) + "`` items stored.|left|" + (itemcount >= items[pInfo(peer)->lastwrenchb].box_size ? "" : "\nadd_spacer|small|\nadd_item_picker|itemid|`wDeposit Item``|Choose an item to store|") + "\nend_dialog|storageboxxtreme|Exit||\nadd_quick_exit|\n");
					p.CreatePacket(peer);
				}
				break;
			}
			case BlockTypes::DOOR: case BlockTypes::PORTAL:
			{
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				string open_ = (block_->open ? "1" : "0");
				p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wEdit " + items[t_].name + "``|left|" + to_string(t_) + "|\nadd_text_input|door_name|Label|" + block_->txt + "|100|\nadd_text_input|door_target|Destination|" + block_->door_destination + "|24|\nadd_smalltext|Enter a Destination in this format: `2WORLDNAME:ID``|left|\nadd_smalltext|Leave `2WORLDNAME`` blank (:ID) to go to the door with `2ID`` in the `2Current World``.|left|\nadd_text_input|door_id|" + (t_ == 762 ? "Password" : "ID") + "|" + block_->door_id + "|11|\nadd_smalltext|Set a unique `2ID`` to target this door as a Destination from another!|left|" + (not world_->owner_name.empty() ? "\nadd_checkbox|checkbox_locked|Is open to public|" + open_ + "" : "") + "\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\nend_dialog|door_edit|Cancel|OK|");
				p.CreatePacket(peer);
				break;
			}
			}
			// wrench
			break;
		}
		default:
		{
			if (items[block_->fg].charger and p_ == 2286 or p_ == 2204) {
				if (world_->owner_name != pInfo(peer)->tankIDName and not pInfo(peer)->superdev and (!guild_access(peer, world_->guild_id) and find(world_->admins.begin(), world_->admins.end(), pInfo(peer)->tankIDName) == world_->admins.end())) break;
				if (p_ == 2204) {
					gamepacket_t p;
					p.Insert("OnTalkBubble");
					p.Insert(pInfo(peer)->netID);
					p.Insert("Your " + items[p_].name + " doesn't need charging!");
					p.Insert(0), p.Insert(0);
					p.CreatePacket(peer);
				}
				else if (block_->id != 0) {
					gamepacket_t p;
					p.Insert("OnTalkBubble");
					p.Insert(pInfo(peer)->netID);
					p.Insert("That charger is already in use!");
					p.Insert(0), p.Insert(0);
					p.CreatePacket(peer);
				}
				else {
					int c_ = -1;
					if (modify_inventory(peer, p_, c_) == 0) {
						gamepacket_t p(0, pInfo(peer)->netID);
						p.Insert("OnPlayPositioned");
						p.Insert("audio/mlaunch.wav");
						block_->id = p_, block_->planted = time(nullptr) + 3600;
						PlayerMoving data_{};
						data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
						BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
						BYTE* blc = raw + 56;
						form_visual(blc, *block_, *world_, peer, false);
						PlayerMoving data_effect_{};
						data_effect_.packetType = 19;
						data_effect_.punchX = p_;
						data_effect_.punchY = pInfo(peer)->netID;
						data_effect_.x = x_ * 32 + 16, data_effect_.y = y_ * 32 + 16;
						BYTE* raw_effect = packPlayerMoving(&data_effect_, 56);
						raw_effect[8] = pInfo(peer)->netID, raw_effect[3] = 4;
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
							if (pInfo(currentPeer)->world == world_->name) {
								p.CreatePacket(currentPeer);
								send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
								send_raw(currentPeer, 4, raw_effect, 56, ENET_PACKET_FLAG_RELIABLE);
							}
						}
						delete[] raw, blc, raw_effect;
						if (block_->locked) {
							upd_lock(*block_, *world_, peer);
						}
					}
				}
				return true;
			}
			if (t_ == 5714) {
				pInfo(peer)->lastwrenchb = t_;
				int item = p_, got = 0;
				modify_inventory(peer, item, got);
				if (got == 0) break;
				if (items[item].untradeable == 1 || item == 1424 || items[item].rarity >= 363 || items[item].rarity == 0 || items[item].rarity < 1) {
					gamepacket_t p;
					p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("I'm sorry, we can't accept items without rarity!"), p.CreatePacket(peer);
				}
				else {
					pInfo(peer)->lastchoosenitem = item;
					gamepacket_t p;
					p.Insert("OnDialogRequest"), p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wGiant Pot O' Gold``|left|5714|\nadd_spacer|small|\nadd_textbox|How many `2" + items[item].name + "`` (rarity " + setGems(items[item].rarity) + ") do you want to drop in the pot? You are carrying " + to_string(got) + " right now.|left|\nadd_text_input|amt||" + to_string(got) + "|3|\nadd_textbox|Thanks for donating, the pot gets ever fuller!|left|\nend_dialog|giantpotogold|Exit|Donate!|");
					p.CreatePacket(peer);
				}
			}
			if (items[t_].blockType == BlockTypes::DONATION) {
				pInfo(peer)->lastwrenchb = t_;
				int item = p_, got = 0;
				modify_inventory(peer, item, got);
				if (got == 0) break;
				if (items[item].untradeable == 1 || item == 1424) {
					gamepacket_t p;
					p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("`7[```4You can't place that in the box, you need it!`7]``"), p.CreatePacket(peer);
				}
				else if (items[item].rarity == 1) {
					gamepacket_t p;
					p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("`7[```4This box only accepts items rarity 2+ or greater`7]``"), p.CreatePacket(peer);
				}
				else {
					pInfo(peer)->lastchoosenitem = item;
					gamepacket_t p;
					p.Insert("OnDialogRequest"), p.Insert("set_default_color|`o\nadd_label_with_icon|big|" + items[item].name + "``|left|" + to_string(item) + "|\nadd_textbox|How many to put in the box as a gift? (Note: You will `4LOSE`` the items you give!)|left|\nadd_text_input|count|Count:|" + to_string(got) + "|5|\nadd_text_input|sign_text|Optional Note:||128|\nadd_spacer|small|\nadd_button|give|`4Give the item(s)``|noflags|0|0|\nadd_spacer|small|\nadd_button|cancel|`wCancel``|noflags|0|0|\nend_dialog|give_item|||\n");
					p.CreatePacket(peer);
				}
				return false;
			}
			if (items[t_].mannequin) {
				if (world_->owner_name.empty() and not block_->locked) {
					gamepacket_t p;
					p.Insert("OnTalkBubble");
					p.Insert(pInfo(peer)->netID);
					p.Insert("`5[`2It's not safe to use an unlocked " + items[t_].name + "!``]``");
					p.Insert(0), p.Insert(0);
					p.CreatePacket(peer);
				}
				else if (not world_->open_to_public and world_->owner_name != pInfo(peer)->tankIDName and not pInfo(peer)->dev and not world_->owner_name.empty() and (!guild_access(peer, world_->guild_id) and find(world_->admins.begin(), world_->admins.end(), pInfo(peer)->tankIDName) == world_->admins.end())) {
					if (block_->locked) {
						WorldBlock* check_lock = &world_->blocks[block_->lock_origin];
						if (not check_lock->open_to_public and check_lock->owner_name != pInfo(peer)->tankIDName and (find(check_lock->admins.begin(), check_lock->admins.end(), pInfo(peer)->tankIDName) == check_lock->admins.end())) break;
					}
					else {
						break;
					}
				}
				else if (items[p_].blockType != CLOTHING) {
					gamepacket_t p;
					p.Insert("OnTalkBubble");
					p.Insert(pInfo(peer)->netID);
					p.Insert("`5[`2That would just be weird.  Try putting clothes on your " + items[t_].name + " instead!``]``");
					p.Insert(0), p.Insert(0);
					p.CreatePacket(peer);
				}
				else {
					if (items[p_].untradeable) {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(peer)->netID);
						p.Insert("`5[`2You cannot place " + items[p_].name + " on " + items[t_].name + "!``]``");
						p.Insert(0), p.Insert(0);
						p.CreatePacket(peer);
					}
					else if (items[p_].clothType == ClothTypes::ANCES) {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(peer)->netID);
						p.Insert("`5[`2It's not safe to place " + items[p_].name + " on " + items[t_].name + "!``]``");
						p.Insert(0), p.Insert(0);
						p.CreatePacket(peer);
					}
					else {
						uint16_t current_mannequin_item = 0;
						switch (items[p_].clothingType) {
						case 0: current_mannequin_item = block_->mannequin.c_hair;
							break;
						case 1: current_mannequin_item = block_->mannequin.c_shirt;
							break;
						case 2: current_mannequin_item = block_->mannequin.c_pants;
							break;
						case 3: current_mannequin_item = block_->mannequin.c_feet;
							break;
						case 4: current_mannequin_item = block_->mannequin.c_head;
							break;
						case 5: current_mannequin_item = block_->mannequin.c_hand;
							break;
						case 6: current_mannequin_item = block_->mannequin.c_back;
							break;
						case 7: current_mannequin_item = block_->mannequin.c_mask;
							break;
						case 8: current_mannequin_item = block_->mannequin.c_neck;
							break;
						case 9: {
							return false;
						}
						} if (current_mannequin_item == p_) {
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(peer)->netID);
							p.Insert("`5[`2You giggle as you swap two identical items``]``");
							p.Insert(0), p.Insert(0);
							p.CreatePacket(peer);
						}
						else {
							gamepacket_t p;
							p.Insert("OnDialogRequest");
							p.Insert("set_default_color|`o\nadd_label_with_icon|big|`w" + items[p_].name + "``|left|" + to_string(p_) + "|\nadd_textbox|Do you really want to put your " + items[p_].name + " on the " + items[t_].name + "?|left|\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\nembed_data|put|" + to_string(p_) + "\nend_dialog|mannequin_edit|No|Yes|");
							p.CreatePacket(peer);
						}
					}
				}
				return false;
			}
			if (t_ == 2452) {
				pInfo(peer)->lastwrenchb = t_;
				int item = p_, got = 0;
				modify_inventory(peer, item, got);
				if (got == 0) break;
				if (items[item].r_1 == 2037 || items[item].r_2 == 2037 || items[item].r_1 == 2035 || items[item].r_2 == 2035 || items[item].r_1 + items[item].r_2 == 0 || items[item].blockType != BlockTypes::CLOTHING || items[item].untradeable || item == 1424 || items[item].rarity > 200) {
					gamepacket_t p;
					p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("`5[`2Only spliceable clothing can be crushed!``]``"), p.CreatePacket(peer);
				}
				else {
					pInfo(peer)->lastchoosenitem = item;
					gamepacket_t p;
					p.Insert("OnDialogRequest"), p.Insert("set_default_color|`o\nadd_label_with_icon|big|`w" + items[item].name + "``|left|" + to_string(item) + "|\nadd_textbox|You have " + to_string(got) + " " + items[item].name + ". How many will you crush?|left|\nadd_textbox|`4Beware:`` If you don't have room in your inventory for the resulting items, they will drop on the floor.|left|\nadd_text_input|count||" + to_string(got) + "|5|\nend_dialog|compactor|Cancel|OK|");
					p.CreatePacket(peer);
				}
				break;
			}
			if (t_ == 4582) {
				pInfo(peer)->lastwrenchb = t_;
				int item = p_, got = 0;
				modify_inventory(peer, item, got);
				if (got == 0) break;
				gamepacket_t p;
				if (items[item].grindable_prize == 0) p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("`5[`2That's not grindable``]``");
				else if (items[item].grindable_prize != 0 && got < items[item].grindable_count) p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("`5[`2I need " + to_string(items[item].grindable_count) + " of those to grind them!``]``");
				else {
					pInfo(peer)->lastchoosenitem = item;
					p.Insert("OnDialogRequest"), p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wGrind " + items[item].name + "``|left|" + to_string(item) + "|\nadd_textbox|You have " + to_string(got) + " " + items[item].name + ". It takes " + to_string(items[item].grindable_count) + " per grind. How many times will you grind (max " + to_string(got / items[item].grindable_count) + ")?|left|\nadd_textbox|`4Beware:`` If you don't have room in your inventory for the resulting items, they will drop on the floor.|left|\nadd_text_input|count||" + to_string(got / items[item].grindable_count) + "|5|\nend_dialog|grinder|Cancel|OK|");
				}
				p.CreatePacket(peer);
				break;
			}
			if (items[t_].blockType == BlockTypes::DISPLAY) {
				string owner_name = world_->owner_name, user_name = pInfo(peer)->tankIDName;
				if (world_->owner_name.empty()) {
					gamepacket_t p;
					p.Insert("OnTalkBubble");
					p.Insert(pInfo(peer)->netID);
					p.Insert("This area must be locked to put your item on display!");
					p.Insert(0), p.Insert(0);
					p.CreatePacket(peer);
				}
				else if (owner_name != user_name and not pInfo(peer)->dev) {
					gamepacket_t p;
					p.Insert("OnTalkBubble");
					p.Insert(pInfo(peer)->netID);
					p.Insert("Only the block's owner can place items in it.");
					p.Insert(0), p.Insert(0);
					p.CreatePacket(peer);
				}
				else if (block_->id != 0) {
					gamepacket_t p;
					p.Insert("OnTalkBubble");
					p.Insert(pInfo(peer)->netID);
					p.Insert("Remove what's in there first!");
					p.Insert(0), p.Insert(0);
					p.CreatePacket(peer);
				}
				else if (p_ == 1424 or p_ == 5816) {
					gamepacket_t p;
					p.Insert("OnTalkBubble");
					p.Insert(pInfo(peer)->netID);
					p.Insert("No sir.");
					p.Insert(0), p.Insert(0);
					p.CreatePacket(peer);
				}
				else if (items[p_].untradeable) {
					gamepacket_t p;
					p.Insert("OnTalkBubble");
					p.Insert(pInfo(peer)->netID);
					p.Insert("You can't display untradeable items.");
					p.Insert(0), p.Insert(0);
					p.CreatePacket(peer);
				}
				else if (items[p_].blockType == BlockTypes::LOCK or items[p_].blockType == BlockTypes::DISPLAY) {
					gamepacket_t p;
					p.Insert("OnTalkBubble");
					p.Insert(pInfo(peer)->netID);
					p.Insert("Sorry, no displaying Display Blocks or Locks.");
					p.Insert(0), p.Insert(0);
					p.CreatePacket(peer);
				}
				else {
					int c_ = -1;
					if (modify_inventory(peer, p_, c_) == 0) {
						block_->id = p_;
						gamepacket_t p(0, pInfo(peer)->netID);
						p.Insert("OnPlayPositioned");
						p.Insert("audio/blorb.wav");

						// update item visual in display block
						PlayerMoving data_effect_{};
						data_effect_.packetType = 19;
						data_effect_.punchX = p_;
						data_effect_.punchY = pInfo(peer)->netID;
						data_effect_.x = x_ * 32 + 16, data_effect_.y = y_ * 32 + 16;
						BYTE* raw_effect = packPlayerMoving(&data_effect_, 56);
						raw_effect[8] = pInfo(peer)->netID, raw_effect[3] = 4;
						PlayerMoving data_{};
						data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
						BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
						BYTE* blc = raw + 56;
						form_visual(blc, *block_, *world_, peer, false);
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
							if (pInfo(currentPeer)->world == world_->name) {
								p.CreatePacket(currentPeer);
								send_raw(currentPeer, 4, raw_effect, 56, ENET_PACKET_FLAG_RELIABLE);
								send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
							}
						}
						delete[] raw, blc, raw_effect;
						if (block_->locked) {
							upd_lock(*block_, *world_, peer);
						}
						return true;
					}
				}
				return false;
			}
			switch (items[p_].blockType) {
			case BlockTypes::CLOTHING:
			{
				equip_clothes(peer, p_);
				break;
			}
			case BlockTypes::CONSUMABLE:
			{
				if (pInfo(peer)->last_consumable + 350 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) pInfo(peer)->last_consumable = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
				else break;
				if (find(world_->active_jammers.begin(), world_->active_jammers.end(), 3616) != world_->active_jammers.end()) {
					if (!guild_access(peer, world_->guild_id) and world_->owner_name != pInfo(peer)->tankIDName and find(world_->admins.begin(), world_->admins.end(), pInfo(peer)->tankIDName) == world_->admins.end()) {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(peer)->netID);
						p.Insert("Can't use consumables here!");
						p.Insert(0), p.Insert(1);
						p.CreatePacket(peer);
						break;
					}
				} switch (p_) {
				case 3098: case 3218: case 3014: case 3012: case 3018: case 5526: case 3020: case 2914: case 4248: case 5528: case 4246: case 3016:
				{
					int got = 0;
					modify_inventory(peer, p_, got);
					if (got == 0) break;
					if (block_->fg != 0) {
						gamepacket_t p, p2;
						p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("Something is blocking the way!"), p.CreatePacket(peer);
						p2.Insert("OnConsoleMessage"), p2.Insert("Something is blocking the way!"), p2.CreatePacket(peer);
					}
					else {
						if (pInfo(peer)->hand == 3040 || pInfo(peer)->hand == 3010 || pInfo(peer)->hand == 2912 || pInfo(peer)->hand == 3008 || pInfo(peer)->hand == 3100 || pInfo(peer)->hand == 5740 || pInfo(peer)->hand == 6254 || pInfo(peer)->hand == 6256 || pInfo(peer)->hand == 6932 || pInfo(peer)->hand == 10262) {
							if (block_->flags == 0x04000000 && pInfo(peer)->fishing_used == 0) {
								if (abs(pInfo(peer)->x / 32 - x_) <= 1 && abs(y_ - pInfo(peer)->y / 32) == 1 && pInfo(peer)->x / 32 != x_ && pInfo(peer)->y / 32 != y_) {
									if (pInfo(peer)->hair == 3042 && rand() % 100 < 5) {

									}
									else modify_inventory(peer, p_, got = -1);
									pInfo(peer)->fish_seconds = 1850;
									if (pInfo(peer)->hand == 3008) pInfo(peer)->fish_seconds *= 2;
									pInfo(peer)->fishing_used = p_, pInfo(peer)->f_x = x_, pInfo(peer)->f_y = y_, pInfo(peer)->move_warning = 0, pInfo(peer)->f_xy = pInfo(peer)->x + pInfo(peer)->y, pInfo(peer)->punch_warning = 0;
									FishMoving data_{};
									data_.stopped_fishing = 0, data_.netID = pInfo(peer)->netID, data_.x = pInfo(peer)->f_x, data_.y = pInfo(peer)->f_y;
									BYTE* raw = packFishMoving(&data_);
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world) continue;
										send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
									}
									delete[] raw;
								}
								else {
									gamepacket_t p, p2;
									p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("Sit still before you try to fish!"), p.CreatePacket(peer);
									p2.Insert("OnConsoleMessage"), p2.Insert("Sit still before you try to fish!"), p2.CreatePacket(peer);
								}
							}
							else if (block_->flags == 0x04000000 && pInfo(peer)->fishing_used != 0) stop_fishing(peer, false, "");
						}
						else {
							gamepacket_t p, p2;
							p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("You'll need a fishing rod to fish!"), p.CreatePacket(peer);
							p2.Insert("OnConsoleMessage"), p2.Insert("You'll need a fishing rod to fish!"), p2.CreatePacket(peer);
						}
					}
					break;
				}
				case 4132:
				{
					int got = 0;
					modify_inventory(peer, p_, got);
					if (got == 0) break;
					bool remove = false;
					for (int i_ = 0; i_ < world_->drop.size(); i_++) {
						if (world_->drop[i_].id == 0) continue;
						if (x_ == (world_->drop[i_].x / 32) && y_ == (world_->drop[i_].y / 32) && world_->drop[i_].id == 3936) {
							remove = true;
							PlayerMoving data_{};
							data_.effect_flags_check = 1, data_.packetType = 14, data_.netID = 0, data_.plantingTree = world_->drop[i_].uid;
							BYTE* raw = packPlayerMoving(&data_);
							for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != name_) continue;
								send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
							}
							delete[]raw;
							WorldDrop drop_block_{};
							drop_block_.id = 4134, drop_block_.count = world_->drop[i_].count, drop_block_.uid = uint16_t(world_->drop.size()) + 1, drop_block_.x = world_->drop[i_].x, drop_block_.y = world_->drop[i_].y;
							dropas_(world_, drop_block_);
							world_->drop[i_].id = 0, world_->drop[i_].x = -1, world_->drop[i_].y = -1;
						}
					}
					if (remove) modify_inventory(peer, p_, got = -1);
					else {
						gamepacket_t p;
						p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("You can only brush Fossils that have never been picked up!"), p.CreatePacket(peer);
					}
					break;
				}
				case 5664:
				{
					int got = 0;
					modify_inventory(peer, p_, got);
					if (got == 0) break;
					if (block_->fg == 0) {
						modify_inventory(peer, p_, got = -1);
						gamepacket_t p;
						p.Insert("OnAddNotification");
						p.Insert("interface/large/special_event.rttex");
						vector<int> list{ 5652, 3398, 386, 4422, 364, 9342, 9340, 9334, 9332, 9336, 9338, 4400, 7808, 7810, 4416, 7818, 7820, 7822, 7824, 5644, 390, 7826, 7830, 9324, 5658, 3396, 2384, 5660, 10654, 3400, 4418, 388, 3408, 1470, 3404, 3406, 10662, 2390, 5656, 5648, 2396, 384, 5664, 4424, 366 };
						int item = list[rand() % list.size()];
						WorldDrop drop_block_{};
						drop_block_.id = item, drop_block_.count = (item == 7810 || item == 7808 || item == 4400 || item == 390 || item == 3408 || item == 4422 || item == 3404 ? 5 : (item == 4418 || item == 5660 ? 2 : 1)), drop_block_.uid = uint16_t(world_->drop.size()) + 1, drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
						dropas_(world_, drop_block_);
						p.Insert("`2Valentine's Card:`` Cupid has just spawned a `#" + items[item].name + "``.");
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
							if (pInfo(currentPeer)->world == world_->name) p.CreatePacket(currentPeer);
						}
					}
					break;
				}
				case 3822: case 3824: case 3826: case 3828: case 3830:
				{
					auto color = pInfo(peer)->HairColor;
					auto r = color->get_red();
					auto g = color->get_green();
					auto b = color->get_blue();
					if (block_->fg == 230) {
						if (p_ == 3822) {
							if (g == 0 && b == 0 && r == 255) {
								gamepacket_t p;
								p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("Your hair is already that color!"), p.Insert(0), p.Insert(1), p.CreatePacket(peer);
								break;
							}
							else {
								int got = 0;
								modify_inventory(peer, p_, got);
								if (got == 0) break;
								modify_inventory(peer, p_, got = -1);
								if (r != 255) color->set_red(r + 17);
								if (g != 0) color->set_green(g - 17);
								if (b != 0) color->set_blue(b - 17);
								gamepacket_t p;
								p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("You dyed your hair!"), p.Insert(0), p.Insert(1), p.CreatePacket(peer);
								update_clothes(peer);
							}
						}
						if (p_ == 3826) {
							if (g == 0 && r == 0 && b == 255) {
								gamepacket_t p;
								p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("Your hair is already that color!"), p.Insert(0), p.Insert(1), p.CreatePacket(peer);
								break;
							}
							else {
								int got = 0;
								modify_inventory(peer, p_, got);
								if (got == 0) break;
								modify_inventory(peer, p_, got = -1);
								if (b != 255) color->set_blue(b + 17);
								if (g != 0) color->set_green(g - 17);
								if (r != 0) color->set_red(r - 17);
								gamepacket_t p;
								p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("You dyed your hair!"), p.Insert(0), p.Insert(1), p.CreatePacket(peer);
							}
						}
						if (p_ == 3824) {
							if (b == 0 && r == 0 && g == 255) {
								gamepacket_t p;
								p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("Your hair is already that color!"), p.Insert(0), p.Insert(1), p.CreatePacket(peer);
								break;
							}
							else {
								int got = 0;
								modify_inventory(peer, p_, got);
								if (got == 0) break;
								modify_inventory(peer, p_, got = -1);
								if (g != 255) color->set_green(g + 17);
								if (b != 0) color->set_blue(b - 17);
								if (r != 0) color->set_red(r - 17);
								gamepacket_t p;
								p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("You dyed your hair!"), p.Insert(0), p.Insert(1), p.CreatePacket(peer);
							}
						}
						if (p_ == 3828) {
							if (b == 0 && r == 0 && g == 0) {
								gamepacket_t p;
								p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("Your hair is already that color!"), p.Insert(0), p.Insert(1), p.CreatePacket(peer);
								break;
							}
							else {
								int got = 0;
								modify_inventory(peer, p_, got);
								if (got == 0) break;
								modify_inventory(peer, p_, got = -1);
								if (g != 0) color->set_green(g - 17);
								if (b != 0) color->set_blue(b - 17);
								if (r != 0) color->set_red(r - 17);
								gamepacket_t p;
								p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("You dyed your hair!"), p.Insert(0), p.Insert(1), p.CreatePacket(peer);
							}
						}
						if (p_ == 3830) {
							if (b == 255 && r == 255 && g == 255) {
								gamepacket_t p;
								p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("Your hair is already clean!"), p.Insert(0), p.Insert(1), p.CreatePacket(peer);
								break;
							}
							else {
								int got = 0;
								modify_inventory(peer, p_, got);
								if (got == 0) break;
								modify_inventory(peer, p_, got = -1);
								if (g != 255) color->set_green(g + 17);
								if (b != 255) color->set_blue(b + 17);
								if (r != 255) color->set_red(r + 17);
								gamepacket_t p;
								p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("You hair got cleaner!"), p.Insert(0), p.Insert(1), p.CreatePacket(peer);
							}
						}
						update_clothes(peer);
						punch_tile(peer, x_, y_, 0x8, 0, pInfo(peer)->netID, 0x0);
					}
					break;
				}

				case 5458: case 5460: case 5462: case 5464: case 5466:
				{
					auto color = pInfo(peer)->EyeColor;
					auto r = color->get_red();
					auto g = color->get_green();
					auto b = color->get_blue();
					if (block_->fg == 5468) {
						if (p_ == 5458) {
							if (g == 0 && b == 0 && r == 255) {
								gamepacket_t p;
								p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("Your eyes are already that color!"), p.Insert(0), p.Insert(1), p.CreatePacket(peer);
								break;
							}
							else {
								int got = 0;
								modify_inventory(peer, p_, got);
								if (got == 0) break;
								modify_inventory(peer, p_, got = -1);
								if (r != 255) color->set_red(r + 17);
								if (g != 0) color->set_green(g - 17);
								if (b != 0) color->set_blue(b - 17);
								gamepacket_t p;
								p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("You used eye drops!"), p.Insert(0), p.Insert(1), p.CreatePacket(peer);
								update_clothes(peer);
							}
						}
						if (p_ == 5462) {
							if (g == 0 && r == 0 && b == 255) {
								gamepacket_t p;
								p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("Your eyes are already that color!"), p.Insert(0), p.Insert(1), p.CreatePacket(peer);
								break;
							}
							else {
								int got = 0;
								modify_inventory(peer, p_, got);
								if (got == 0) break;
								modify_inventory(peer, p_, got = -1);
								if (b != 255) color->set_blue(b + 17);
								if (g != 0) color->set_green(g - 17);
								if (r != 0) color->set_red(r - 17);
								gamepacket_t p;
								p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("You used eye drops!"), p.Insert(0), p.Insert(1), p.CreatePacket(peer);
							}
						}
						if (p_ == 5460) {
							if (b == 0 && r == 0 && g == 255) {
								gamepacket_t p;
								p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("Your eyes are already that color!"), p.Insert(0), p.Insert(1), p.CreatePacket(peer);
								break;
							}
							else {
								int got = 0;
								modify_inventory(peer, p_, got);
								if (got == 0) break;
								modify_inventory(peer, p_, got = -1);
								if (g != 255) color->set_green(g + 17);
								if (b != 0) color->set_blue(b - 17);
								if (r != 0) color->set_red(r - 17);
								gamepacket_t p;
								p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("You used eye drops!"), p.Insert(0), p.Insert(1), p.CreatePacket(peer);
							}
						}
						if (p_ == 5464) {
							if (b == 0 && r == 0 && g == 0) {
								gamepacket_t p;
								p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("Your eyes are already that color!"), p.Insert(0), p.Insert(1), p.CreatePacket(peer);
								break;
							}
							else {
								int got = 0;
								modify_inventory(peer, p_, got);
								if (got == 0) break;
								modify_inventory(peer, p_, got = -1);
								if (g != 0) color->set_green(g - 17);
								if (b != 0) color->set_blue(b - 17);
								if (r != 0) color->set_red(r - 17);
								gamepacket_t p;
								p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("You used eye drops!"), p.Insert(0), p.Insert(1), p.CreatePacket(peer);
							}
						}
						if (p_ == 5466) {
							if (b == 255 && r == 255 && g == 255) {
								gamepacket_t p;
								p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("Your eyes is already clean!"), p.Insert(0), p.Insert(1), p.CreatePacket(peer);
								break;
							}
							else {
								int got = 0;
								modify_inventory(peer, p_, got);
								if (got == 0) break;
								modify_inventory(peer, p_, got = -1);
								if (g != 255) color->set_green(g + 17);
								if (b != 255) color->set_blue(b + 17);
								if (r != 255) color->set_red(r + 17);
								gamepacket_t p;
								p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("Your eyes got cleaner!"), p.Insert(0), p.Insert(1), p.CreatePacket(peer);
							}
						}
						update_clothes(peer);
					}
					break;
				}

				case 722:
				{
					int got = 0;
					modify_inventory(peer, p_, got);
					if (got == 0) break;
					if (block_->fg == 0) {
						modify_inventory(peer, p_, got = -1);
						block_->fg = 718;
						gamepacket_t p;
						p.Insert("OnAddNotification"), p.Insert("interface/large/special_event.rttex"), p.Insert("`2`4Pi`wna`2ta`` `wBash``!:`` `oSmash the `wUltra`` `4Pi`wna`2ta``! `#Get some help``!``"), p.Insert("audio/cumbia_horns.wav");
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != world_->name) continue;
							update_tile(currentPeer, x_, y_, 718, false, false);
							p.CreatePacket(currentPeer);
						}
					}
					break;
				}
				case 1220:
				{
					int got = 0;
					modify_inventory(peer, p_, got);
					if (got == 0) break;
					gamepacket_t p;
					p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
					if (world_->name == "GROWGANOTH") {
						modify_inventory(peer, p_, got = -1);
						p.Insert("`5Growganoth pulls you closer!``");
						gamepacket_t p2(0, pInfo(peer)->netID);
						p2.Insert("OnSetPos"), p2.Insert(1584, 432), p2.CreatePacket(peer);
					}
					else p.Insert("The sigil fizzles... try using it near Growganoth!");
					p.Insert(0), p.Insert(0);
					p.CreatePacket(peer);
					break;
				}
				case 822:
				{
					int got = 0;
					modify_inventory(peer, p_, got);
					if (got == 0) break;
					if (not world_->open_to_public and world_->owner_name != pInfo(peer)->tankIDName and not pInfo(peer)->dev and not world_->owner_name.empty() and (!guild_access(peer, world_->guild_id) and find(world_->admins.begin(), world_->admins.end(), pInfo(peer)->tankIDName) == world_->admins.end())) {
						if (block_->locked) {
							WorldBlock* check_lock = &world_->blocks[block_->lock_origin];
							if (not check_lock->open_to_public and check_lock->owner_name != pInfo(peer)->tankIDName and (find(check_lock->admins.begin(), check_lock->admins.end(), pInfo(peer)->tankIDName) == check_lock->admins.end())) break;
						}
						else {
							break;
						}
					}
					if (items[t_].blockType == BlockTypes::MAIN_DOOR or items[t_].blockType == BlockTypes::BEDROCK)return true;
					PlayerMoving data_{};
					data_.packetType = 19;
					data_.punchX = 822, data_.punchY = 1;
					data_.x = x_ * 32 + 16, data_.y = y_ * 32 + 16;
					BYTE* raw = packPlayerMoving(&data_);
					raw[3] = 4, raw[8] = pInfo(peer)->netID;
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
						if (pInfo(currentPeer)->world == world_->name) {
							send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
						}
					}
					delete[]raw;
					block_->flags = (block_->flags & 0x04000000 ? block_->flags ^ 0x04000000 : block_->flags | 0x04000000);
					{
						if (block_->flags & 0x04000000) {
							int c_ = -1;
							modify_inventory(peer, 822, c_);
						}
						else {
							// sansas gauti atgal    
							if (rand() % 100 < 50) {
								int c_ = 1;
								modify_inventory(peer, 822, c_);
							}
						}
						PlayerMoving data_{};
						data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
						BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
						BYTE* blc = raw + 56;
						form_visual(blc, *block_, *world_, peer, false);
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
							if (pInfo(currentPeer)->world == pInfo(peer)->world) {
								send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
							}
						}
						delete[] raw, blc;
						if (block_->locked) {
							upd_lock(*block_, *world_, peer);
						}
					}
					break;
				}
				case 3400:
				{
					int got = 0;
					modify_inventory(peer, p_, got);
					if (got == 0) break;
					if (block_->fg != 10) {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(peer)->netID);
						p.Insert("`4This potion is clearly labeled for use only on rocks.``");
						p.Insert(0), p.Insert(0);
						p.CreatePacket(peer);
						break;
					}
					int c_ = -1;
					if (modify_inventory(peer, 3400, c_) == 0) {
						block_->fg = 392;
						PlayerMoving data_{};
						data_.packetType = 17;
						data_.netID = 44;
						data_.YSpeed = 44;
						data_.x = x_ * 32 + 16;
						data_.y = y_ * 32 + 16;
						PlayerMoving data_2{};
						data_2.packetType = 5, data_2.punchX = x_, data_2.punchY = y_, data_2.characterState = 0x8;
						BYTE* raw2 = packPlayerMoving(&data_2, 112 + alloc_(world_, block_));
						BYTE* blc = raw2 + 56;
						form_visual(blc, *block_, *world_, peer, false);
						BYTE* raw = packPlayerMoving(&data_);
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
							if (pInfo(currentPeer)->world == world_->name) {
								packet_(currentPeer, "action|play_sfx\nfile|audio/terraform.wav\ndelayMS|0");
								send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
								send_raw(currentPeer, 4, raw2, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
							}
						}
						delete[] raw, raw2, blc;
						if (block_->locked) {
							upd_lock(*block_, *world_, peer);
						}
					}
					break;
				}
				case 7962:
				{
					if (items[t_].blockType == BlockTypes::PROVIDER) {
						long long time_ = time(NULL);
						uint32_t laikas = uint32_t((time_ - block_->planted <= items[block_->fg].growTime ? time_ - block_->planted : items[block_->fg].growTime));
						if (laikas < unsigned int(items[block_->fg].growTime)) {
							long long spray_time_ = 3600 * 6; // 6 hours
							block_->planted -= spray_time_;
							gamepacket_t p;
							p.Insert("OnTextOverlay");
							if (time_ - block_->planted <= items[block_->fg].growTime) {
								if (spray_time_ < 86400)
									p.Insert(items[block_->fg].name + " Provider `eaged`` `$" + to_string(spray_time_ / 60 / 60) + "`` hours");
								else
									p.Insert(items[block_->fg].name + " Provider `eaged`` `$" + to_string(spray_time_ / 86400) + "`` days");
							}
							else {
								p.Insert(items[block_->fg].name + " Provider is ready!");
							}
							p.CreatePacket(peer);
							{
								gamepacket_t p(0, pInfo(peer)->netID);
								p.Insert("OnPlayPositioned");
								p.Insert("audio/spray.wav");
								p.CreatePacket(peer);
							}
							PlayerMoving data_{};
							data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
							BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
							BYTE* blc = raw + 56;
							form_visual(blc, *block_, *world_, peer, false);
							for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
								if (pInfo(currentPeer)->world == world_->name) {
									send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
								}
							}
							delete[] raw, blc;
							if (block_->locked) {
								upd_lock(*block_, *world_, peer);
							}
							int c_ = -1;
							modify_inventory(peer, p_, c_);
						}
						else {
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(peer)->netID);
							p.Insert("This provider is already ready, don't waste your spray on it!");
							p.Insert(0);
							p.Insert(1);
							p.CreatePacket(peer);
						}
					}
					else {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(peer)->netID);
						p.Insert("Use this on a provider to speed it up.");
						p.Insert(0);
						p.Insert(1);
						p.CreatePacket(peer);
					}
					break;
				}
				case 228: case 1062: case 1778: case 5764: case 10672:
				{
					if (items[t_].blockType == BlockTypes::SEED) {
						long long time_ = time(NULL);
						uint32_t laikas = uint32_t((time_ - block_->planted <= items[block_->fg].growTime ? time_ - block_->planted : items[block_->fg].growTime));
						if (laikas < unsigned int(items[block_->fg].growTime)) {
							long long spray_time_ = 3600; // 1 hours
							if (p_ == 1062)
								spray_time_ = _int64(2.592e+6); // 30 days
							if (p_ == 1778)
								spray_time_ = 86400; // 24 hours
							if (p_ == 5764)
								spray_time_ = 259200; // 72 hours
							block_->planted -= spray_time_;
							gamepacket_t p, p2(0, pInfo(peer)->netID);
							p.Insert("OnTextOverlay");
							if (time_ - block_->planted <= items[block_->fg].growTime) {
								if (spray_time_ < 86400) p.Insert(items[block_->fg - 1].name + " Tree aged `$" + to_string(spray_time_ / 60 / 60) + "`` hours");
								else p.Insert(items[block_->fg - 1].name + " Tree aged `$" + to_string(spray_time_ / 86400) + "`` days");
							}
							else p.Insert(items[block_->fg - 1].name + " Tree grew to full size!");
							p.CreatePacket(peer);
							p2.Insert("OnPlayPositioned"), p2.Insert("audio/spray.wav"), p2.CreatePacket(peer);
							PlayerMoving data_{};
							data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
							BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
							BYTE* blc = raw + 56;
							form_visual(blc, *block_, *world_, peer, false);
							for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != world_->name) continue;
								send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
							}
							delete[] raw, blc;
							if (block_->locked) upd_lock(*block_, *world_, peer);
							int c_ = -1;
							modify_inventory(peer, p_, c_);
						}
						else {
							gamepacket_t p;
							p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("This tree has already bloomed, don't waste your spray on it!"), p.Insert(0), p.Insert(1), p.CreatePacket(peer);
						}
					}
					else {
						gamepacket_t p;
						p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("Use this on a growing tree to speed it's growth."), p.Insert(0), p.Insert(1), p.CreatePacket(peer);
					}
					break;
				}
				case 6336:
				{
					level_show(peer);
					break;
				}
				case 10394: case 5138: case 5140: case 5142:
				{
					int got = 0;
					modify_inventory(peer, p_, got);
					if (got == 0) break;
					modify_inventory(peer, p_, got = -1);
					gamepacket_t p;
					p.Insert("OnTalkBubble");
					p.Insert(pInfo(peer)->netID), p.Insert("`5GULP! You got " + setGems(items[p_].max_gems3) + " (gems)!``"), p.Insert(0), p.Insert(1), p.CreatePacket(peer);
					{
						gamepacket_t p;
						p.Insert("OnSetBux"), p.Insert(pInfo(peer)->gems += items[p_].max_gems3), p.Insert(1), p.Insert((pInfo(peer)->supp >= 1) ? 1 : 0);
						if (pInfo(peer)->supp >= 2) p.Insert((float)33796, (float)1, (float)0);
						p.CreatePacket(peer);
					}
					PlayerMoving data_{};
					data_.packetType = 17, data_.netID = 48, data_.YSpeed = 48, data_.x = pInfo(peer)->x + 16, data_.y = pInfo(peer)->y + 16;
					BYTE* raw = packPlayerMoving(&data_);
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world) continue;
						send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
					}
					delete[] raw;
					break;
				}
				case 1280: {
					/*birth certificate*/
					if (std::experimental::filesystem::exists("db/birth_certificate/" + PlayerDB::getProperName(pInfo(peer)->tankIDName) + "_.txt")) {
						ifstream fd("db/birth_certificate/" + PlayerDB::getProperName(pInfo(peer)->tankIDName) + "_.txt");
						long long timeremaining = 0;
						if (fd.fail()) {}
						else
						{
							fd >> timeremaining;
							fd.close();
						}
						string bobo = "\nadd_smalltext|`5(You changed recently, wait to change again)|left|";
						auto bantimeleft = calcBanDuration(timeremaining);
						if (bantimeleft < 1) {
							gamepacket_t p;
							p.Insert("OnDialogRequest");
							p.Insert("set_default_color|`o\n\nadd_label_with_icon|big|`wChange your GrowID`|left|1280|\nadd_smalltext|`oThis will change your GrowID `4permanently`o. You can't change it again after 7 days.|left|\nadd_smalltext|`oYour `wBirth Certificate `owill be consumed if you click `5Change it`o.|left|\nadd_smalltext|`oChoose an appropriate name or `6we will change it for you`o!|left|\nadd_smalltext|`4Warning `o: Worlds owned won't be transfered if you change your name!|left|\nadd_label|small|`oEnter your new name :|left|\nadd_text_input|newname|||14|\nend_dialog|changename|Cancel|`oChange it|\n");
							p.CreatePacket(peer);
							//Server::OnDialogRequest(peer, "set_default_color|`o\n\nadd_label_with_icon|big|`wChange your GrowID`|left|1280|\nadd_smalltext|`oThis will change your GrowID `4permanently`o. You can't change it again after 7 days.|left|\nadd_smalltext|`oYour `wBirth Certificate `owill be consumed if you click `5Change it`o.|left|\nadd_smalltext|`oChoose an appropriate name or `6we will change it for you`o!|left|\nadd_smalltext|`4Warning `o: Worlds owned won't be transfered if you change your name!|left|\nadd_label|small|`oEnter your new name :|left|\nadd_text_input|newname|||14|\nend_dialog|changename|Cancel|`oChange it|\n");
							break;
						}
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(peer)->netID);
						p.Insert("`wYou can't change your name yet!");
						p.Insert(0);
						p.Insert(1);
						p.CreatePacket(peer);
						//Server::OnTalkBubble(peer, pData->netID, "`wYou can't change your name yet!", 0, false);
					}
					else {
						gamepacket_t p;
						p.Insert("OnDialogRequest");
						p.Insert("set_default_color|`o\n\nadd_label_with_icon|big|`wChange your GrowID`|left|1280|\nadd_smalltext|`oThis will change your GrowID `4permanently`o. You can't change it again after 7 days.|left|\nadd_smalltext|`oYour `wBirth Certificate `owill be consumed if you click `5Change it`o.|left|\nadd_smalltext|`oChoose an appropriate name or `6we will change it for you`o!|left|\nadd_smalltext|`4Warning `o: Worlds owned won't be transfered if you change your name!|left|\nadd_label|small|`oEnter your new name :|left|\nadd_text_input|newname|||14|\nend_dialog|changename|Cancel|`oChange it|\n");
						p.CreatePacket(peer);
						//Server::OnDialogRequest(peer, "set_default_color|`o\n\nadd_label_with_icon|big|`wChange your GrowID`|left|1280|\nadd_smalltext|`oThis will change your GrowID `4permanently`o. You can't change it again after 7 days.|left|\nadd_smalltext|`oYour `wBirth Certificate `owill be consumed if you click `5Change it`o.|left|\nadd_smalltext|`oChoose an appropriate name or `6we will change it for you`o!|left|\nadd_smalltext|`4Warning `o: Worlds owned won't be transfered if you change your name!|left|\nadd_label|small|`oEnter your new name :|left|\nadd_text_input|newname|||14|\nend_dialog|changename|Cancel|`oChange it|\n");
					}
					break;
				}
				case 1488:
				{
					int got = 0;
					modify_inventory(peer, p_, got);
					if (got == 0) break;
					modify_inventory(peer, p_, got = -1);
					gamepacket_t p;
					p.Insert("OnTalkBubble");
					p.Insert(pInfo(peer)->netID);
					p.Insert("`5GULP! You got smarter!``");
					p.Insert(0);
					p.Insert(1);
					p.CreatePacket(peer);
					add_peer_xp(peer, 10000);
					break;
				}

				case 5706:
				{
					int got = 0;
					modify_inventory(peer, p_, got);
					if (got == 0) break;
					vector<int> list{ 3567, 13, 57, 17, 381, 1139, 21, 101, 379, 117, 27, 23, 581, 195, 105, 191, 377, 1307, 697, 881, 167, 185, 1323, 165, 3783, 369, 25, 171, 53, 103, 179, 29, 249, 177, 1325, 337, 189, 169, 55, 223, 175, 885, 119, 3573, 199, 549, 681, 655, 107, 163, 31, 671, 889, 887, 193, 127, 1433, 173, 7631, 413, 3571, 3569, 2809, 9393, 225, 111, 109, 201, 59, 607, 285, 2029, 2013, 2015, 1611, 995, 997, 963, 1481, 219, 197, 2023, 2021, 9331, 1305, 823, 1039, 231, 487, 483, 2019, 427, 1757, 2009, 281, 781, 329, 459, 1041, 421, 2787, 2789, 1043, 2797, 181, 613, 65, 4983, 283, 553, 425, 4635, 987, 627, 2017, 989, 61, 4639, 973, 3523, 331, 265, 859, 433, 253, 339, 1105, 439, 4567, 333, 677, 5673, 1427, 5603, 183, 10533, 5731, 7223, 10833, 6035, 6813, 1113, 1047, 653, 2811, 4703, 1429, 847, 665 };
					vector<pair<int, int>> receivingitems;
					int free = get_free_slots(pInfo(peer)), slot = 5, getcount = 1, inventoryfull = 0;
					if (free >= slot) {
						for (int i = 0; i < slot; i++) {
							int itemid = list[rand() % list.size()];
							receivingitems.push_back(make_pair(itemid, getcount));
						}
						for (int i = 0; i < slot; i++) {
							int itemcount = 0;
							modify_inventory(peer, receivingitems[i].first, itemcount);
							if (itemcount + getcount > 200) inventoryfull = 1;
						}
						if (inventoryfull == 0) {
							for (int i = 0; i < slot; i++) modify_inventory(peer, receivingitems[i].first, receivingitems[i].second);
							modify_inventory(peer, p_, got = -1);
						}
					}
					break;
				}
				case 9526:
				{
					int got = 0;
					modify_inventory(peer, p_, got);
					if (got == 0) break;
					vector<int> list{ 3831, 429, 1773, 4767, 667, 2835, 301, 1299, 361, 2709, 955, 461, 861, 9389, 5467, 2791, 2815, 1803, 555, 685, 741, 3931, 1775, 833, 2025, 621, 6401, 359, 309, 855, 1685, 1449, 1309, 441, 1111, 221, 1431, 3065, 9307, 1257, 1501, 1109, 4641, 3587, 1103, 742, 431, 3823, 3825, 1131, 727, 729, 187, 787, 5379, 5459, 4785, 3261, 3521, 2293, 5461, 3721, 2309, 327, 2321, 247, 63, 2333, 3479, 445, 4783, 299, 863, 8935, 1451, 261, 1871, 1499, 455, 9391, 683, 1159, 551, 1745, 411, 3005, 8239, 687, 4799, 559, 4643, 3899, 1605, 9309, 567, 565, 1155, 3827, 1327, 1767, 993, 1157, 563, 4721, 115, 1423, 10515, 1329, 6545, 287, 669, 777, 5463, 1655, 1599, 561, 4585, 3413, 4745, 1771, 2011, 1161, 1729, 3757, 3753, 321, 3265, 3263, 623, 775, 6397, 129, 4667, 759, 3767, 1529, 6543, 4707, 3835, 1435, 651, 8929, 569, 527, 3287, 1595, 6063, 2795, 1003, 1731, 4943, 4963, 597, 4669, 1531, 1523, 625, 4297, 599, 657, 571, 873, 3755, 2969, 1725, 4603, 1447, 3267, 5375, 1683, 1613 };
					vector<pair<int, int>> receivingitems;
					int free = get_free_slots(pInfo(peer)), slot = 5, getcount = 1, inventoryfull = 0;
					if (free >= slot) {
						for (int i = 0; i < slot; i++) {
							int itemid = list[rand() % list.size()];
							receivingitems.push_back(make_pair(itemid, getcount));
						}
						for (int i = 0; i < slot; i++) {
							int itemcount = 0;
							modify_inventory(peer, receivingitems[i].first, itemcount);
							if (itemcount + getcount > 200) inventoryfull = 1;
						}
						if (inventoryfull == 0) {
							for (int i = 0; i < slot; i++) modify_inventory(peer, receivingitems[i].first, receivingitems[i].second);
							modify_inventory(peer, p_, got = -1);
						}
					}
					break;
				}
				case 1828: case 11286: case 3870:
				{
					gamepacket_t p;
					p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert(p_ == 3870 ? "That's like a hundred years old. No." : "Ew, it has raisins! I'm not eating that."), p.Insert(0), p.Insert(1), p.CreatePacket(peer);
					break;
				}
				case 1066:
				{
					int got = 0;
					modify_inventory(peer, p_, got);
					if (got >= 1) {
						modify_inventory(peer, p_, got = -1);
						PlayerMoving data_{};
						data_.packetType = 17, data_.netID = 50, data_.YSpeed = 50, data_.x = (x_ * 32) + 16, data_.y = (y_ * 32) + 16;
						BYTE* raw = packPlayerMoving(&data_);
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world) continue;
							send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
						}
						delete[] raw;
					}
					break;
				}
				case 6140:
				{
					int got = 0;
					modify_inventory(peer, p_, got);
					if (got >= 1) {
						string foundlist = "";
						gamepacket_t p;
						if (world_->owner_name != pInfo(peer)->tankIDName and not pInfo(peer)->dev and (!guild_access(peer, world_->guild_id) and find(world_->admins.begin(), world_->admins.end(), pInfo(peer)->tankIDName) == world_->admins.end())) {
							p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("Only the owner of this tile has access!"), p.CreatePacket(peer);
							break;
						}
						for (int i_ = 0; i_ < world_->drop.size(); i_++) if (world_->drop[i_].id != 0 && world_->drop[i_].id != 112 && world_->drop[i_].x > 0 && world_->drop[i_].y > 0 && world_->drop[i_].x / 32 == x_ && world_->drop[i_].y / 32 == y_) foundlist += to_string(world_->drop[i_].id) + "," + to_string(world_->drop[i_].count) + "," + to_string(world_->drop[i_].uid) + ",";
						if (foundlist != "") p.Insert("OnDialogRequest"), p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wExtract-O-Snap``|left|6140|\nadd_spacer|small|\nadd_textbox|GrowTech: use the Extract-O-Snap to pick out the items from the floating items in your world! - Thanks, Technician Dave.|leftvadd_spacer|small|\nadd_textbox|Press on the icon to extract the item into your inventory.|left|\nadd_spacer|small|\nadd_textbox|`wItem List:|left|\nadd_label_with_icon_button_list|small|`w%s : %s|left|extractOnceObj_|itemID_itemAmount_worldObj|" + foundlist + "\nadd_spacer|small|\nend_dialog|extractor|Close||");
						else p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("There are no floating items in the extraction area!");
						p.CreatePacket(peer);
					}
					break;
				}
				case 1826:
				{
					int got = 0;
					modify_inventory(peer, p_, got);
					if (got >= 1) {
						modify_inventory(peer, p_, got = -1);
						PlayerMoving data_{};
						data_.packetType = 17, data_.netID = 92, data_.YSpeed = 92, data_.x = (x_ * 32) + 16, data_.y = (y_ * 32) + 16;
						BYTE* raw = packPlayerMoving(&data_);
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world) continue;
							send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
						}
						delete[] raw;
					}
					break;
				}
				case 4490: case 2036: case 2034: case 7590: case 11656: case 2290: case 3122: case 1152: case 1212: case 1234: case 3762: case 8534: case 2410: case 5256: case 3110: case 2000:
				{
					int got = 0, given = 1, needed = items[p_].consume_needed;
					modify_inventory(peer, p_, got);
					gamepacket_t p;
					p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
					if (got >= items[p_].consume_needed) {
						if (modify_inventory(peer, items[p_].consume_prize, given) == 0) {
							modify_inventory(peer, p_, needed *= -1);
							p.Insert("`5" + items[p_].name + " combine to create a`` `2" + items[items[p_].consume_prize].name + "```5!``");
						}
						else p.Insert("You don't have enough inventory space!");
					}
					else p.Insert("`4You'll need more " + items[p_].name + " than that!``");
					p.CreatePacket(peer);
					break;
				}
				case 10228:
				{
					if (get_free_slots(pInfo(peer)) >= 1) {
						int got = 0;
						modify_inventory(peer, p_, got);
						if (got == 0) break;
						vector<int> list{ 1828, 1096, 1098, 1094, 1058, 3870, 7058, 11286 };
						bool toobig = false;
						for (int i = 0; i < list.size(); i++) {
							int have = 0;
							modify_inventory(peer, list[i], have);
							if (have >= 199) toobig = true;
						}
						if (toobig) break;
						vector<pair<int, int>> receivingitems;
						int free = get_free_slots(pInfo(peer)), slot = 5, getcount = 1, inventoryfull = 0;
						if (free >= slot) {
							for (int i = 0; i < slot; i++) {
								int itemid = list[rand() % list.size()];
								if (itemid == 11286)receivingitems.push_back(make_pair(itemid, getcount = 1));
								receivingitems.push_back(make_pair(itemid, getcount = rand() % 10 + 1));
							}
							for (int i = 0; i < slot; i++) {
								int itemcount = 0;
								modify_inventory(peer, receivingitems[i].first, itemcount);
								if (itemcount + receivingitems[i].second > 200) inventoryfull = 1;
							}
							if (inventoryfull == 0) {
								string received = "";
								for (int i = 0; i < slot; i++) {
									int receiveds = receivingitems[i].second;
									modify_inventory(peer, receivingitems[i].first, receivingitems[i].second);
									if (i == 4)received += "`5" + to_string(receiveds) + " " + items[receivingitems[i].first].name + "``";
									else received += "`5" + to_string(receiveds) + " " + items[receivingitems[i].first].name + "`` ";
								}
								modify_inventory(peer, p_, got = -1);
								gamepacket_t p;
								p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("`0You got`` " + received + "`0.``");
								p.CreatePacket(peer);
							}
						}
					}
					break;
				}
				case 10756:
				{
					if (get_free_slots(pInfo(peer)) >= 2) {
						int got = 0;
						modify_inventory(peer, p_, got);
						if (got == 0) break;
						vector<int> shard{ 10766, 10768,10766, 10768,10766, 10768,10766, 10768,10766, 10768,10766, 10768,10766, 10768,10766, 10768,10766, 10768,10766, 10764 };
						vector<int> egg{ 8064, 8066, 8068, 2552, 9460, 2548, 2546, 2544, 2550,8064, 8066, 8068, 2552, 9460, 2548, 2546, 2544, 2550,8064, 8066, 8068, 2552, 9460, 2548, 2546, 2544, 2550,8064, 8066, 8068, 2552, 9460, 2548, 2546, 2544, 2550,8064, 8066, 8068, 2552, 9460, 2548, 2546, 2544, 2550,8064, 8066, 8068, 2552, 9460, 2548, 2546, 2544, 2550,8064, 8066, 8068, 2552, 9460, 2548, 2546, 2544, 2550,8064, 8066, 8068, 2552, 9460, 2548, 2546, 2544, 2550,8064, 8066, 8068, 2552, 9460, 2548, 2546, 2544, 2550, 2554 };
						bool toobig = false;
						for (int i = 0; i < shard.size(); i++) {
							int have = 0;
							modify_inventory(peer, shard[i], have);
							if (have >= 199) toobig = true;
						}
						for (int i = 0; i < egg.size(); i++) {
							int have = 0;
							modify_inventory(peer, egg[i], have);
							if (have >= 199) toobig = true;
						}
						if (toobig) break;
						vector<pair<int, int>> receivingitems;
						int free = get_free_slots(pInfo(peer)), slot = 2, getcount = 1, inventoryfull = 0;
						if (free >= slot) {
							for (int i = 0; i < slot; i++) {
								int itemid = i == 0 ? shard[rand() % shard.size()] : egg[rand() % egg.size()];
								receivingitems.push_back(make_pair(itemid, getcount = 1));
							}
							for (int i = 0; i < slot; i++) {
								int itemcount = 0;
								modify_inventory(peer, receivingitems[i].first, itemcount);
								if (itemcount + receivingitems[i].second > 200) inventoryfull = 1;
							}
							if (inventoryfull == 0) {
								string received = "";
								for (int i = 0; i < slot; i++) {
									int receiveds = receivingitems[i].second;
									modify_inventory(peer, receivingitems[i].first, receivingitems[i].second);
									if (i == 0)received += "`2" + to_string(receiveds) + " " + items[receivingitems[i].first].ori_name + "`` and ";
									else received += "`2" + to_string(receiveds) + " " + items[receivingitems[i].first].ori_name + "``";
								}
								modify_inventory(peer, p_, got = -1);
								gamepacket_t p;
								p.Insert("OnConsoleMessage"), p.Insert("You received " + received + " from a Golden Egg Carton."), p.CreatePacket(peer);
								{
									gamepacket_t p;
									p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("You received " + received + " from a Golden Egg Carton."), p.Insert(0), p.Insert(1), p.CreatePacket(peer);
								}
							}
						}
					}
					break;
				}
				
				case 5404: case 5402: case 10396: case 11476: case 7672: case 2306: case 5750: case 9286: case 7346: case 9680: case 11860: case 11036: case 1680: case 1360: case 10536: case 11758: case 11756: case 10386: case 9018: case 12566: case 11398: case 8410: case 8408: case 8414: case 8412: case 7954: case 7484: case 5948:
				{
					if (get_free_slots(pInfo(peer)) >= 1) {
						int got = 0, received = 0;
						modify_inventory(peer, p_, got);
						if (got == 0) break;
						bool toobig = false;
						for (int i = 0; i < items[p_].noob_item.size(); i++)for (int i_ = 0; i_ < pInfo(peer)->inv.size(); i_++) if (pInfo(peer)->inv[i_].id == items[p_].noob_item[i].first && pInfo(peer)->inv[i_].count + items[p_].noob_item[i].second >= 200) toobig = true;
						if (items[p_].newdropchance != 0) for (int i = 0; i < items[p_].rare_item.size(); i++)for (int i_ = 0; i_ < pInfo(peer)->inv.size(); i_++) if (pInfo(peer)->inv[i_].id == items[p_].rare_item[i].first && pInfo(peer)->inv[i_].count + items[p_].rare_item[i].second >= 200) toobig = true;
						if (p_ == 1680) {
							int got = 0;
							modify_inventory(peer, 834, got);
							if (got < 200) {
								gamepacket_t p;
								p.Insert("OnTalkBubble");
								p.Insert(pInfo(peer)->netID), p.Insert("Requires 200 Fireworks to launch!"), p.Insert(0), p.Insert(1), p.CreatePacket(peer);
								toobig = true;
							}
							else {
								toobig = false;
								modify_inventory(peer, 834, got = -200);
							}
						}
						if (toobig) break;
						int random = rand() % items[p_].noob_item.size(), itemid = items[p_].noob_item[random].first;
						got = items[p_].noob_item[random].second;
						if (items[p_].newdropchance != 0 && (rand() % items[p_].newdropchance) < 1) {
							if (items[p_].rare_item.size() != 0) {
								random = (rand() % items[p_].rare_item.size()), itemid = items[p_].rare_item[random].first, got = items[p_].rare_item[random].second;
							}
							if (p_ == 11758) {
								gamepacket_t p;
								p.Insert("OnConsoleMessage"), p.Insert(pInfo(peer)->name_color + pInfo(peer)->tankIDName + "`` has received a `5Rare " + items[itemid].name + "`` from Grow4Good Special Gift Hamper!");
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
									p.CreatePacket(currentPeer);
								}
							}

						}
						if (p_ == 1680) {
							modify_inventory(peer, p_, got = -1);
							WorldDrop drop_block_{};
							drop_block_.id = itemid, drop_block_.count = 1, drop_block_.x = pInfo(peer)->x, drop_block_.y = pInfo(peer)->y - 32, drop_block_.uid = uint16_t(world_->drop.size()) + 1;
							dropas_(world_, drop_block_);
							PlayerMoving data_{};
							data_.packetType = 17, data_.netID = 73, data_.YSpeed = 73, data_.x = pInfo(peer)->x + 16, data_.y = pInfo(peer)->y - 32;
							BYTE* raw = packPlayerMoving(&data_);
							for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world) continue;
								send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
							}
							delete[] raw;
						}
						else {
							received = got;
							if (modify_inventory(peer, itemid, got) == 0) {
								modify_inventory(peer, p_, got = -1);
								gamepacket_t p, p2;
								p.Insert("OnConsoleMessage"), p.Insert("You received `2" + to_string(received) + " " + items[itemid].name + "`` from the " + items[p_].name + "."), p.CreatePacket(peer);
								p2.Insert("OnTalkBubble"), p2.Insert(pInfo(peer)->netID), p2.Insert("You received `2" + to_string(received) + " " + items[itemid].name + "`` from the " + items[p_].name + "."), p2.Insert(0), p2.Insert(1), p2.CreatePacket(peer);
							}
						}
					}
					break;
				}
				case 834: case 5766: case 1406:
				{
					int got = 0;
					modify_inventory(peer, p_, got);
					if (got == 0) break;
					modify_inventory(peer, p_, got = -1);
					if (rand() % 100 < 2 and p_ == 834) {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(peer)->netID);
						p.Insert("Received 1 Summer Surprise!");
						p.Insert(0);
						p.Insert(1);
						p.CreatePacket(peer);
						WorldDrop drop_block_{};
						drop_block_.id = 836, drop_block_.count = 1, drop_block_.x = pInfo(peer)->x, drop_block_.y = pInfo(peer)->y, drop_block_.uid = uint16_t(world_->drop.size()) + 1;
						dropas_(world_, drop_block_);
					}
					PlayerMoving data_{};
					data_.packetType = 17, data_.netID = 40, data_.YSpeed = 40, data_.x = pInfo(peer)->x + 16, data_.y = pInfo(peer)->y;
					BYTE* raw = packPlayerMoving(&data_);
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
						if (pInfo(peer)->world != pInfo(currentPeer)->world) continue;
						send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
					}
					delete[] raw;
					break;
				}
				case 5804:
				case 5806:
				case 5808:
				case 5810:
				case 5812:
				case 6822:
				case 5770:
				case 5772:
				case 5774:
				case 5776:
				case 5778:
				case 6002:
				case 6052:
				case 6272:
				case 6274:
				case 6276:
				case 7232:
				case 7234:
				case 6122:
				case 6672:
				case 6322:
				case 7062:
				case 7130:
				case 6278:
				case 6824:
				case 6744:
				case 6894:
				case 7370:
				case 7474:
				case 7656:
				case 7684:
				case 7932:
				case 8416:
				case 10114:
				case 10116:
				{
					int got = 0;
					modify_inventory(peer, p_, got);
					if (got == 0) break;
					bool found = true;
					for (int i = 0; i < pInfo(peer)->gr.size(); i++) if (pInfo(peer)->gr[i] == items[p_].emoji) found = false;
					if (found) {
						modify_inventory(peer, p_, got = -1);
						pInfo(peer)->gr.push_back(items[p_].emoji);
						gamepacket_t p;
						p.Insert("OnAddNotification");
						p.Insert("interface/large/friend_button.rttex");
						p.Insert("You've unlocked `$" + items[p_].name + "``!");
						p.Insert("audio/hub_open.wav");
						p.Insert(0);
						p.CreatePacket(peer);
						{
							gamepacket_t p;
							p.Insert("OnEmoticonDataChanged");
							p.Insert(151749376);
							string other = "";
							for (int i = 0; i < pInfo(peer)->gr.size(); i++) other += pInfo(peer)->gr[i];
							p.Insert(other + "" + (pInfo(peer)->supp == 2 ? "(yes)|Ă|1" : "(yes)|Ă|0") + "&" + (pInfo(peer)->supp != 0 ? "(no)|ă|1" : "(no)|ă|0") + "&" + (pInfo(peer)->supp == 2 ? "(love)|Ą|1" : "(love)|Ą|0") + "&" + (pInfo(peer)->supp != 0 ? "(shy)|Ć|1&(wink)|ć|1" : "(shy)|Ć|0&(wink)|ć|0") + "&" + (pInfo(peer)->level >= 5 ? "(tongue)|Ĉ|1" : "(tongue)|Ĉ|0") + "&" + (pInfo(peer)->friends.size() >= 20 ? "(agree)|ĉ|1" : "(agree)|ĉ|0") + "&" + (pInfo(peer)->supp != 0 ? "(music)|Č|1" : "(music)|Č|0") + "&" + (pInfo(peer)->friends.size() >= 50 ? "(build)|č|1" : "(build)|č|0") + "&" + (pInfo(peer)->supp == 2 ? "(megaphone)|Ď|1" : "(megaphone)|Ď|0") + "&" + (pInfo(peer)->level >= 5 ? "(sigh)|ď|1&(mad)|Đ|1&(wow)|đ|1" : "(sigh)|ď|0&(mad)|Đ|0&(wow)|đ|0") + "&" + (pInfo(peer)->friends.size() >= 40 ? "(dance)|Ē|1" : "(dance)|Ē|0") + "&" + (pInfo(peer)->friends.size() >= 30 ? "(see-no-evil)|ē|1" : "(see-no-evil)|ē|0") + "&" + (pInfo(peer)->supp == 2 ? "(heart)|ĕ|1" : "(heart)|ĕ|0") + "&" + (pInfo(peer)->friends.size() >= 10 ? "(kiss)|Ę|1" : "(kiss)|Ę|0") + "&" + (pInfo(peer)->supp != 0 ? "(lol)|Ě|1" : "(lol)|Ě|1") + "&" + (pInfo(peer)->level >= 5 ? "(smile)|Ā|1" : "(smile)|Ā|0") + "&" + (pInfo(peer)->supp == 2 ? "(cool)|Ĝ|1" : "(cool)|Ĝ|0") + "&(lucky)|ĳ|1&");
							p.CreatePacket(peer);
						}
					}
					break;
				}
				case 830: case 9164: case 942: case 1060: case 1136: case 1402: case 1532: case 3562: case 4774: case 7380: case 7588: case 8556:
				{
					if (p_ == 830) {
						int got = 0;
						modify_inventory(peer, 834, got);
						if (got < 100) {
							gamepacket_t p;
							p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("Beach blast requires 100 Fireworks."), p.Insert(0), p.Insert(1);
							p.CreatePacket(peer);
							break;
						}
					}
					gamepacket_t p;
					p.Insert("OnDialogRequest");
					p.Insert("set_default_color|`o\nadd_label_with_icon|big|`0" + items[p_].name + "``|left|" + to_string(p_) + "|\nadd_textbox|This item creates a new world! Enter a unique name for it.|left||\nadd_text_input|name|New World Name||256|\nembed_data|itemID|" + to_string(p_) + "\nend_dialog|blast|Cancel|`5Create!``|\n");
					p.CreatePacket(peer);
					break;
				}
				case 2580: case 2480:
				{
					gamepacket_t p;
					p.Insert("OnDialogRequest");
					if (p_ == 2580) p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wSwap World Names``|left|2580|\nadd_smalltext|This will swap the name of the world you are standing in with another world `4permanently``.  You must own both worlds, with a World Lock in place.<CR>Your `wChange of Address`` will be consumed if you press `5Swap 'Em``.|left|\nadd_textbox|Enter the other world's name:|left|\nadd_text_input|name_box|||32|\nadd_spacer|small|\nend_dialog|world_swap|Cancel|Swap 'Em!|");
					if (p_ == 2480)p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wMegaphone``|left|2480|\nadd_textbox|Enter a message you want to broadcast to every player in Growtopia! This will use up 1 Megaphone.|left|\nadd_text_input|words|||128|\nembed_data|itemID|2480\nend_dialog|megaphone|Nevermind|Broadcast|\n");
					p.CreatePacket(peer);
					break;
				}
				case 1404:
				{
					if (world_->owner_name == pInfo(peer)->tankIDName or pInfo(peer)->dev) {
						int used = 0;
						if (y_ < 54 && y_ > 0) {
							if (block_->fg == 0 || block_->fg == 6 || block_->fg == 8) {
								WorldBlock* block2_ = &world_->blocks[x_ + ((y_ + 1) * 100)];
								if (block2_->fg == 0 || block2_->fg == 6 || block2_->fg == 8 and y_ < 54) {
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
										if (pInfo(currentPeer)->world != pInfo(peer)->world) continue;
										pInfo(currentPeer)->x = float(x_) * 32, pInfo(currentPeer)->y = float(y_) * 32;
										gamepacket_t p(0, pInfo(currentPeer)->netID);
										p.Insert("OnSetPos");
										p.Insert(float(x_) * 32, float(y_) * 32);
										p.CreatePacket(currentPeer);
									}
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(peer)->netID);
									p.Insert("You've moved the door!");
									p.Insert(0);
									p.Insert(1);
									p.CreatePacket(peer);
									used = 1;
									int c_ = -1;
									modify_inventory(peer, p_, c_);
									DoorMove(peer, x_, y_);
									PlayerMoving data_{};
									data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
									BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
									BYTE* blc = raw + 56;
									form_visual(blc, *block_, *world_, peer, false);
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
										if (pInfo(currentPeer)->world == world_->name) {
											send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
										}
									}
									delete[] raw, blc;
									if (block_->locked) {
										upd_lock(*block_, *world_, peer);
									}
								}
							}
						}
						if (used == 0) {
							packet_(peer, "action|play_sfx\nfile|audio/cant_place_tile.wav\ndelayMS|0");
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(peer)->netID);
							p.Insert("There's no room to put the door there! You need 2 empty spaces vertically.");
							p.Insert(0);
							p.Insert(1);
							p.CreatePacket(peer);
						}
					}
					else {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(peer)->netID);
						p.Insert("You can only use this in a world that you have world-locked!");
						p.Insert(0), p.Insert(0);
						p.CreatePacket(peer);
					}
					break;
				}
				case 1866:
				{
					int c_ = -1;
					if (modify_inventory(peer, p_, c_) == 0) {
						if (block_->flags & 0x08000000) {
							block_->flags ^= 0x08000000;
						}
						else {
							block_->flags |= 0x08000000;
						}
						PlayerMoving data_{};
						data_.packetType = 19;
						data_.punchX = 1866, data_.punchY = 1;
						data_.x = x_ * 32 + 16, data_.y = y_ * 32 + 16;
						BYTE* raw = packPlayerMoving(&data_);
						raw[3] = 4, raw[8] = pInfo(peer)->netID;
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
							if (pInfo(currentPeer)->world == world_->name) {
								send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
							}
						}
						delete[]raw;
						{
							PlayerMoving data_{};
							data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
							BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
							BYTE* blc = raw + 56;
							form_visual(blc, *block_, *world_, peer, false);
							for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
								if (pInfo(currentPeer)->world == pInfo(peer)->world) {
									send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
								}
							}
							delete[] raw, blc;
							if (block_->locked) {
								upd_lock(*block_, *world_, peer);
							}
						}
					}
					break;
				}

				case 3478: case 3480: case 3482: case 3484: case 3486: case 3488: case 3490: case 3492:
				{
					if (not world_->open_to_public and world_->owner_name != pInfo(peer)->tankIDName and not pInfo(peer)->dev and not world_->owner_name.empty() and (!guild_access(peer, world_->guild_id) and find(world_->admins.begin(), world_->admins.end(), pInfo(peer)->tankIDName) == world_->admins.end())) {
						if (block_->locked) {
							WorldBlock* check_lock = &world_->blocks[block_->lock_origin];
							if (not check_lock->open_to_public and check_lock->owner_name != pInfo(peer)->tankIDName and (find(check_lock->admins.begin(), check_lock->admins.end(), pInfo(peer)->tankIDName) == check_lock->admins.end())) break;
						}
						else {
							break;
						}
					}
					if (pInfo(peer)->hand != 3494 and pInfo(peer)->hand != 7938) {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(peer)->netID);
						p.Insert("You need a " + items[3494].name + " or a " + items[7938].name + " to apply paint!");
						p.Insert(0), p.Insert(0);
						p.CreatePacket(peer);
						break;
					} if (block_->fg == 0 and block_->bg == 0) {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(peer)->netID);
						p.Insert("There's nothing to paint!");
						p.Insert(0), p.Insert(0);
						p.CreatePacket(peer);
						break;
					} if (items[block_->fg].blockType == BlockTypes::MAIN_DOOR or items[block_->fg].blockType == BlockTypes::BEDROCK or items[block_->fg].blockType == BlockTypes::LOCK) {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(peer)->netID);
						p.Insert("That's too special to paint.");
						p.Insert(0), p.Insert(0);
						p.CreatePacket(peer);
						break;
					}
					bool alr_painted = false;
					if (block_->flags & 0x20000000 and block_->flags & 0x40000000 and block_->flags & 0x80000000) {
						if (p_ == 3490) alr_painted = true;
					}
					else if (block_->flags & 0x20000000 and block_->flags & 0x80000000) {
						if (p_ == 3488) alr_painted = true;
					}
					else if (block_->flags & 0x80000000) {
						if (p_ == 3486) alr_painted = true;
					}
					else if (block_->flags & 0x40000000 and block_->flags & 0x80000000) {
						if (p_ == 3484) alr_painted = true;
					}
					else if (block_->flags & 0x40000000) {
						if (p_ == 3482) alr_painted = true;
					}
					else if (block_->flags & 0x20000000 and block_->flags & 0x40000000) {
						if (p_ == 3480) alr_painted = true;
					}
					else if (block_->flags & 0x20000000) {
						if (p_ == 3478) alr_painted = true;
					}
					if (alr_painted) {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(peer)->netID);
						p.Insert("That block is already painted that color!");
						p.Insert(0), p.Insert(0);
						p.CreatePacket(peer);
						break;
					}
					{
						int colour = 0x00000000;
						float particle_ = 0;
						if (p_ == 3478) { // raudona spalva
							colour |= 0x20000000;
							particle_ = 65280.00;
						}
						else if (p_ == 3480) { // geltona spalva
							colour |= 0x20000000;
							colour |= 0x40000000;
							particle_ = 16776960.00;
						}
						else if (p_ == 3482) { // zalia spalva
							colour |= 0x40000000;
							particle_ = 16711680.00;
						}
						else if (p_ == 3484) { // sviesiai melyna spalva
							colour |= 0x40000000;
							colour |= 0x80000000;
							particle_ = 4294901760.00;
						}
						else if (p_ == 3486) { // melyna spalva
							colour |= 0x80000000;
							particle_ = 4278190080.00;
						}
						else if (p_ == 3488) { // rozine spalva
							colour |= 0x20000000;
							colour |= 0x80000000;
							particle_ = 4278255360.00;
						}
						else if (p_ == 3490) { // juoda spalva
							colour |= 0x20000000;
							colour |= 0x40000000;
							colour |= 0x80000000;
							particle_ = 1010580480.00;
						}
						else { // balta spalva
							bool has_something_to_change = false;
							if (block_->flags & 0x20000000 or block_->flags & 0x40000000 or block_->flags & 0x80000000) {
								has_something_to_change = true;
							} if (not has_something_to_change) {
								gamepacket_t p;
								p.Insert("OnTalkBubble");
								p.Insert(pInfo(peer)->netID);
								p.Insert("Don't waste your varnish on an unpainted block!");
								p.Insert(0), p.Insert(0);
								p.CreatePacket(peer);
								break;
							}
							particle_ = 3875520768.00;
						}
						int c_ = -1;
						if (modify_inventory(peer, p_, c_) == 0) {
							if (block_->flags & 0x20000000) block_->flags = block_->flags ^ 0x20000000;
							if (block_->flags & 0x40000000) block_->flags = block_->flags ^ 0x40000000;
							if (block_->flags & 0x80000000) block_->flags = block_->flags ^ 0x80000000;
							if (colour != 0x00000000) block_->flags |= colour;
							{
								PlayerMoving p_data_{};
								p_data_.packetType = 17;
								p_data_.netID = 168;
								p_data_.YSpeed = 168;
								p_data_.XSpeed = particle_;
								p_data_.x = (x_ * 32) + 16;
								p_data_.y = (y_ * 32) + 16;
								BYTE* p_raw = packPlayerMoving(&p_data_);
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
									if (pInfo(currentPeer)->world == world_->name) {
										send_raw(currentPeer, 4, p_raw, 56, ENET_PACKET_FLAG_RELIABLE);
									}
								}
								delete[] p_raw;
							}
							{
								PlayerMoving data_{};
								data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
								BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
								BYTE* blc = raw + 56;
								form_visual(blc, *block_, *world_, peer, false);
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
									if (pInfo(currentPeer)->world == world_->name) {
										send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
									}
								}
								delete[] raw, blc;
								if (block_->locked) {
									upd_lock(*block_, *world_, peer);
								}
							} if (items[block_->fg].collisionType != 1 and not items[block_->fg].entrance and not items[block_->fg].toggleable) {
								int c_ = rand() % (items[p_].max_gems + 1);
								if (c_ != 0) {
									bool no_seed = false, no_gems = false, no_block = false;
									for (int i_ = 0; i_ < world_->drop.size(); i_++) {
										if (abs(world_->drop[i_].y - y_ * 32) <= 16 and abs(world_->drop[i_].x - x_ * 32) <= 16) {
											if (world_->drop[i_].id == 112 and items[t_].rarity < 8) {
												no_gems = true;
											}
											else {
												no_seed = true, no_block = true;
											}
										}
									} if (rand() % 100 < 5 and not no_block) {
										WorldDrop drop_block_{};
										drop_block_.id = p_, drop_block_.count = 1, drop_block_.uid = uint16_t(world_->drop.size()) + 1, drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
										dropas_(world_, drop_block_);
									}
									else if (rand() % 100 < 35 and not no_seed) {
										WorldDrop drop_seed_{};
										drop_seed_.id = 3479, drop_seed_.count = 1, drop_seed_.uid = uint16_t(world_->drop.size()) + 1, drop_seed_.x = (x_ * 32) + rand() % 17, drop_seed_.y = (y_ * 32) + rand() % 17;
										dropas_(world_, drop_seed_);
									}
									else if (not no_gems) {
										int c_ = rand() % (items[p_].max_gems + 1);
										gems_(peer, world_, c_, x_ * 32, y_ * 32, p_);
									}
								}
							}
						}
					}
					break;
				}
				case 3560:
				{
					gamepacket_t p;
					p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
					if (world_->owner_name == pInfo(peer)->tankIDName or pInfo(peer)->dev) {
						int used = 0;
						if (block_->fg == 0) {
							if (LockMove(peer, x_, y_)) {
								p.Insert("You've moved the world lock!");
								used = 1;
								int c_ = -1;
								modify_inventory(peer, p_, c_);
								PlayerMoving data_{};
								data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
								BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
								BYTE* blc = raw + 56;
								form_visual(blc, *block_, *world_, peer, false);
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != world_->name) continue;
									send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
								}
								delete[] raw, blc;
								if (block_->locked) upd_lock(*block_, *world_, peer);
							}
						}
						if (used == 0) {
							packet_(peer, "action|play_sfx\nfile|audio/cant_place_tile.wav\ndelayMS|0");
							p.Insert("There's no room to put the lock there! You need 1 empty space vertically.");
						}
					}
					else p.Insert("You can only use this in a world that you have world-locked!");
					p.Insert(0), p.Insert(1), p.CreatePacket(peer);
					break;
				}

				default:
				{
					for (vector<string> get_ : info_about_playmods) {
						uint32_t playmod_id = atoi(get_[0].c_str());
						vector<string> id_items = explode("_", get_[1]);
						string playmod_name = get_[2];
						string playmod_on_add = get_[3];
						string playmod_sound = get_[7];
						string playmod_action = get_[9];
						string playmod_text = get_[11];
						string gravity_mod = get_[12];
						for (string item_and_time : id_items) {
							uint32_t item_id = atoi(id_items[0].c_str());
							uint32_t playmod_time = atoi(id_items[1].c_str());
							if (item_id == p_) {
								ENetPeer* clicked_on = get_clicked_on(world_, x_, y_);
								if (playmod_action == "drop" and clicked_on == NULL or playmod_action.empty() and clicked_on == NULL or playmod_action == "consume" and clicked_on == NULL or playmod_action == "cutewords" and clicked_on == NULL) {
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(peer)->netID);
									p.Insert("Must be used on a person.");
									p.Insert(0), p.Insert(1);
									p.CreatePacket(peer);
									return true;
								}
								if (p_ == 384 and pInfo(clicked_on)->netID == pInfo(peer)->netID) {
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(peer)->netID);
									p.Insert("Use that on somebody else!");
									p.Insert(0), p.Insert(1);
									p.CreatePacket(peer);
									return true;
								}
								if (playmod_action == "pet") {
									int c_ = playmod_time * -1;
									if (modify_inventory(peer, p_, c_) == 0) {
										uint32_t pet_id = atoi(playmod_name.c_str());
										int c_2 = 1;
										if (modify_inventory(peer, pet_id, c_2) != 0) {
											WorldDrop drop_block_{};
											drop_block_.id = pet_id, drop_block_.count = c_2, drop_block_.uid = uint16_t(world_->drop.size()) + 1, drop_block_.x = pInfo(peer)->x + rand() % 17, drop_block_.y = pInfo(peer)->y + rand() % 17;
											dropas_(world_, drop_block_);
										}
										else {
											pInfo(peer)->hand = pet_id;
											update_clothes(peer);
										}
										PlayerMoving data_{};
										data_.packetType = 17;
										data_.netID = 44;
										data_.YSpeed = 44;
										data_.x = pInfo(peer)->x + 10;
										data_.y = pInfo(peer)->y + 10 + 16;
										BYTE* raw = packPlayerMoving(&data_);
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
											if (pInfo(currentPeer)->world == world_->name) {
												packet_(currentPeer, "action|play_sfx\nfile|audio/terraform.wav\ndelayMS|0");
												send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
											}
										}
										delete[] raw;
									}
									else {
										gamepacket_t p;
										p.Insert("OnTalkBubble");
										p.Insert(pInfo(peer)->netID);
										p.Insert(playmod_text);
										p.Insert(0);
										p.CreatePacket(peer);
									}
									return true;
								}
								int c_ = -1;
								if (modify_inventory(peer, p_, c_) == 0) {
									if (playmod_action == "cutewords") {
										if (p_ == 276) SendRespawn(clicked_on, true, 0, 1);
										else if (p_ == 732) add_ban(clicked_on, 600, "Ban Wand Effect", pInfo(peer)->name_color + pInfo(peer)->tankIDName + "``");
										else if (p_ == 278) add_curse(clicked_on, 600, "Curse Wand Effect", pInfo(peer)->name_color + pInfo(peer)->tankIDName + "``");
										else if (p_ == 8500) {
											string malady_text = "The patient has no malady.";
											int give = 1;
											if (pInfo(clicked_on)->surgery_type == 18) malady_text = "The patient has a `5torn Punching Muscle``.";
											else if (pInfo(clicked_on)->surgery_type == 18) malady_text = "The patient has a `5Gemcuts``.";
											else if (pInfo(clicked_on)->surgery_type == 20) malady_text = "The patient has a `5Grumbleteeth``.";
											else if (pInfo(clicked_on)->surgery_type == 21) malady_text = "The patient has a `5Chicken Feet``.";
											else if (pInfo(clicked_on)->surgery_type == 22) malady_text = "The patient has a `5Broken Heart``.";
											else if (pInfo(clicked_on)->surgery_type == 24) malady_text = "The patient has a `5Ecto-Bones``.";
											else if (pInfo(clicked_on)->surgery_type == 25) malady_text = "The patient has a `5Moldy Guts``.";
											else if (pInfo(clicked_on)->surgery_type == 26) malady_text = "The patient has a `5Fatty Liver``.";
											else if (pInfo(clicked_on)->surgery_type == 27) malady_text = "The patient has a `5Chaos Infection``.";
											else if (pInfo(clicked_on)->surgery_type == 28) malady_text = "The patient has a `5Lupus``.";
											else {
												PlayerMoving extended_particle_data_{};
												extended_particle_data_.packetType = 36, extended_particle_data_.x = pInfo(clicked_on)->x + 16, extended_particle_data_.y = pInfo(clicked_on)->y + 16, extended_particle_data_.characterState = 0x8, extended_particle_data_.netID = 175;
												BYTE* ex_raw = packPlayerMoving(&extended_particle_data_);
												for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
													if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != pInfo(peer)->world) continue;
													send_raw(currentPeer, 4, ex_raw, 56, ENET_PACKET_FLAG_RELIABLE);
												}
												delete[] ex_raw;
												modify_inventory(peer, 8500, give);
											}
											gamepacket_t p;
											p.Insert("OnTalkBubble");
											p.Insert(pInfo(peer)->netID);
											p.Insert(malady_text);
											p.Insert(0), p.Insert(1);
											p.CreatePacket(peer);
										}
										else {
											gamepacket_t p2(p_ == 752 ? 500 : 0);
											p2.Insert("OnTalkBubble");
											p2.Insert(pInfo(clicked_on)->netID);
											vector<string> random_words{
												"`4'ADORE ME'``",
												"`4'SAY YES'``",
												"`4'MISS YOU'``"
											};
											if (p_ == 618) {
												random_words = { "`4'ARGH!!!'``" };
												SendRespawn(clicked_on, true, 0, 1);
											}
											if (p_ == 616) random_words = { "`4'Awwwww!'``" };
											if (p_ == 752) random_words = { "HEADS"  ,  "TAILS" };
											string random_phrase = random_words[rand() % random_words.size()];
											p2.Insert(random_phrase);
											p2.Insert(0);
											gamepacket_t p(0, pInfo(clicked_on)->netID);
											p.Insert("OnPlayPositioned");
											p.Insert("audio/eat.wav");
											gamepacket_t p3(0, pInfo(clicked_on)->netID);
											p3.Insert("OnAction");
											p3.Insert("/love");
											gamepacket_t p4;
											p4.Insert("OnConsoleMessage");
											if (p_ == 618) p4.Insert(pInfo(clicked_on)->tankIDName + " snuggled the wrong bunny!");
											else if (p_ != 616 and p_ != 752) p4.Insert(pInfo(clicked_on)->tankIDName + " shouts " + random_phrase + " uncontrollably!");
											for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != name_) continue;
												p.CreatePacket(currentPeer), p2.CreatePacket(currentPeer);
												if (p_ != 618 and p_ != 752) p3.CreatePacket(currentPeer);
												if (p_ != 616 and p_ != 752)p4.CreatePacket(currentPeer);
											}
										}
										PlayerMoving data_{};
										data_.packetType = 19, data_.plantingTree = 0, data_.netID = 0;
										data_.punchX = p_, data_.punchY = pInfo(peer)->netID;
										BYTE* raw;
										data_.x = pInfo(peer)->x + 10, data_.y = pInfo(peer)->y + 16;
										raw = packPlayerMoving(&data_);
										int32_t to_netid = pInfo(clicked_on)->netID;
										raw[3] = 5;
										memcpy(raw + 8, &to_netid, 4);
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
											if (pInfo(currentPeer)->world == name_) {
												send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
												update_clothes(currentPeer);
											}
										}
										delete[] raw;
										return true;
									}
									if (playmod_action == "consume") {
										gamepacket_t p2;
										p2.Insert("OnTalkBubble");
										p2.Insert(pInfo(clicked_on)->netID);
										p2.Insert(playmod_name);
										p2.Insert(0);
										gamepacket_t p(0, pInfo(clicked_on)->netID);
										p.Insert("OnPlayPositioned");
										p.Insert("audio/eat.wav");
										PlayerMoving data_{};
										data_.packetType = 19, data_.plantingTree = 0, data_.netID = 0;
										data_.punchX = p_;
										data_.punchY = pInfo(peer)->netID;
										BYTE* raw;
										data_.x = pInfo(peer)->x + 10, data_.y = pInfo(peer)->y + 16;
										raw = packPlayerMoving(&data_);
										int32_t to_netid = pInfo(clicked_on)->netID;
										raw[3] = 5;
										memcpy(raw + 8, &to_netid, 4);
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
											if (pInfo(currentPeer)->world == name_) {
												p.CreatePacket(currentPeer), p2.CreatePacket(currentPeer);
												send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
											}
										}
										int c_ = rand() % (items[p_].max_gems + 1);
										if (c_ != 0) {
											bool no_seed = false, no_gems = false, no_block = false;
											for (int i_ = 0; i_ < world_->drop.size(); i_++) {
												if (abs(world_->drop[i_].y - y_ * 32) <= 16 and abs(world_->drop[i_].x - x_ * 32) <= 16) {
													if (world_->drop[i_].id == 112 and items[t_].rarity < 8) {
														no_gems = true;
													}
													else {
														no_seed = true, no_block = true;
													}
												}
											}
											if (rand() % 100 < 5 and not no_block) {
												WorldDrop drop_block_{};
												drop_block_.id = p_, drop_block_.count = 1, drop_block_.uid = uint16_t(world_->drop.size()) + 1, drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
												if (not use_mag(world_, drop_block_, drop_block_.x, drop_block_.y)) dropas_(world_, drop_block_);
											}
											else if (rand() % 100 < 35 and not no_seed) {
												WorldDrop drop_seed_{};
												drop_seed_.id = p_ + 1, drop_seed_.count = 1, drop_seed_.uid = uint16_t(world_->drop.size()) + 1, drop_seed_.x = (x_ * 32) + rand() % 17, drop_seed_.y = (y_ * 32) + rand() % 17;
												if (not use_mag(world_, drop_seed_, drop_seed_.x, drop_seed_.y)) dropas_(world_, drop_seed_);
											}
											else if (not no_gems) {
												int c_ = rand() % (items[p_].max_gems + 1);
												gems_(peer, world_, c_, x_ * 32, y_ * 32, p_);
											}
										}
										delete[] raw;
										return true;

									}
									if (playmod_action == "drop") {
										if (p_ == 782) {
											gamepacket_t p;
											p.Insert("OnTalkBubble");
											p.Insert(pInfo(peer)->netID);
											p.Insert("`w[" + pInfo(clicked_on)->tankIDName + " `wfeels strangely better!]");
											p.Insert(0);
											gamepacket_t p2;
											p2.Insert("OnConsoleMessage");
											p2.Insert("`7[`w" + pInfo(clicked_on)->tankIDName + " `ofeels strangely better!`7]");
											p2.Insert(0);
											for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
												if (pInfo(currentPeer)->world == name_) {
													p.CreatePacket(currentPeer);
													p2.CreatePacket(currentPeer);
												}
											}
											for (int i_ = 0; i_ < pInfo(peer)->playmods.size(); i_++) {
												if (pInfo(peer)->playmods[i_].id == 28) {
													pInfo(peer)->playmods[i_].time = 0;
													break;
												}
											}
										}
										else {
											int c_ = rand() % (items[p_].max_gems + 1);
											if (c_ != 0) {
												bool no_seed = false, no_gems = false, no_block = false;
												for (int i_ = 0; i_ < world_->drop.size(); i_++) {
													if (abs(world_->drop[i_].y - y_ * 32) <= 16 and abs(world_->drop[i_].x - x_ * 32) <= 16) {
														if (world_->drop[i_].id == 112 and items[t_].rarity < 8) {
															no_gems = true;
														}
														else {
															no_seed = true, no_block = true;
														}
													}
												}
												if (rand() % 100 < 5 and not no_block) {
													WorldDrop drop_block_{};
													drop_block_.id = p_, drop_block_.count = 1, drop_block_.uid = uint16_t(world_->drop.size()) + 1, drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
													if (not use_mag(world_, drop_block_, drop_block_.x, drop_block_.y)) dropas_(world_, drop_block_);
												}
												else if (rand() % 100 < 35 and not no_seed) {
													WorldDrop drop_seed_{};
													drop_seed_.id = p_ + 1, drop_seed_.count = 1, drop_seed_.uid = uint16_t(world_->drop.size()) + 1, drop_seed_.x = (x_ * 32) + rand() % 17, drop_seed_.y = (y_ * 32) + rand() % 17;
													if (not use_mag(world_, drop_seed_, drop_seed_.x, drop_seed_.y)) dropas_(world_, drop_seed_);
												}
												else if (not no_gems) {
													int c_ = rand() % (items[p_].max_gems + 1);
													gems_(peer, world_, c_, x_ * 32, y_ * 32, p_);
												}
											}
										}
									}
									else if (not playmod_action.empty()) {
										if (playmod_action == "throw") {
											uint32_t playmod_effect = atoi(get_[10].c_str());
											PlayerMoving data_{};
											data_.packetType = 17;
											data_.netID = playmod_effect;
											data_.YSpeed = playmod_effect;
											data_.x = x_ * 32 + rand() % 17;
											data_.y = y_ * 32 + rand() % 17;
											BYTE* raw = packPlayerMoving(&data_);
											for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
												if (pInfo(currentPeer)->world == world_->name) {
													send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
												}
											}
											delete[] raw;
										}
										else {
											uint32_t playmod_effect = atoi(get_[10].c_str());
											PlayerMoving data_{};
											data_.packetType = 17;
											data_.netID = playmod_effect;
											data_.YSpeed = playmod_effect;
											data_.x = x_ * 32 + 16;
											data_.y = y_ * 32 + 16;
											BYTE* raw = packPlayerMoving(&data_);
											for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
												if (pInfo(currentPeer)->world == world_->name) {
													send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
												}
											}
											delete[] raw;
										}
									}
									if (clicked_on != NULL) {
										bool alr_have = false;
										for (PlayMods peer_playmod : pInfo(clicked_on)->playmods) {
											if (peer_playmod.id == playmod_id) {
												if (p_ == 384 and peer_playmod.user == pInfo(peer)->tankIDName) {
													alr_have = true;
													break;
												}
												else {
													alr_have = true;
													break;
												}
											}
										}
										if (not alr_have) {
											PlayMods new_playmod{};
											new_playmod.id = playmod_id;
											new_playmod.time = time(nullptr) + playmod_time;
											new_playmod.user = pInfo(peer)->tankIDName;
											pInfo(clicked_on)->playmods.push_back(new_playmod);
											gamepacket_t p;
											p.Insert("OnConsoleMessage");
											p.Insert(playmod_on_add + " (`$" + playmod_name + "`` mod added, `$" + to_playmod_time(playmod_time) + "``left)");
											p.CreatePacket(clicked_on);
											update_clothes(clicked_on);
											{
												gamepacket_t p;
												p.Insert("OnConsoleMessage");
												p.Insert("`4>> `#" + pInfo(clicked_on)->name_color + pInfo(clicked_on)->tankIDName + "```` is now `#" + pInfo(peer)->name_color + pInfo(peer)->tankIDName + "````'s valentine!``");
												for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
													if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
													if (pInfo(currentPeer)->world == name_) {
														if (p_ == 384) p.CreatePacket(currentPeer);
													}
												}
											}
										}
									}
									{
										PlayerMoving data_{};
										data_.packetType = 19, data_.plantingTree = 0, data_.netID = 0;
										data_.punchX = p_;
										data_.punchY = pInfo(peer)->netID;
										BYTE* raw;
										if (clicked_on != NULL and playmod_action.empty() or playmod_action == "drop" and clicked_on != NULL) {
											data_.x = pInfo(peer)->x + 10, data_.y = pInfo(peer)->y + 16;
											raw = packPlayerMoving(&data_);
											int32_t to_netid = pInfo(clicked_on)->netID;
											raw[3] = 5;
											memcpy(raw + 8, &to_netid, 4);
										}
										else {
											data_.x = x_ * 32 + 16, data_.y = y_ * 32 + 16;
											raw = packPlayerMoving(&data_);
											int32_t to_netid = pInfo(peer)->netID;
											raw[3] = 4;
											memcpy(raw + 8, &to_netid, 4);
										} if (not playmod_sound.empty() and clicked_on != NULL or playmod_action == "drop" and clicked_on != NULL) {
											gamepacket_t p(0, pInfo(clicked_on)->netID);
											p.Insert("OnPlayPositioned");
											p.Insert("audio/" + playmod_sound);
											for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
												if (pInfo(currentPeer)->world == name_) {
													p.CreatePacket(currentPeer);
													update_clothes(currentPeer);
												}
											}
										} if (not playmod_text.empty()) {
											gamepacket_t p;
											p.Insert("OnTalkBubble");
											p.Insert(pInfo(clicked_on)->netID);
											p.Insert(playmod_text);
											p.Insert(0);
											for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
												if (pInfo(currentPeer)->world == name_) {
													send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
													p.CreatePacket(currentPeer);
													update_clothes(currentPeer);
												}
											}
										}
										else {
											for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
												if (pInfo(currentPeer)->world == name_) {
													send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
													update_clothes(currentPeer);
												}
											}
										}
										delete[]raw;
									}

								}
								return true;
							}
						}
					}
					gamepacket_t p;
					p.Insert("OnTalkBubble");
					p.Insert(pInfo(peer)->netID);
					p.Insert(items[p_].name + " not implemented yet but will be soon!");
					p.Insert(0), p.Insert(1);
					p.CreatePacket(peer);
					{
						gamepacket_t p;
						p.Insert("OnConsoleMessage");
						p.Insert(items[p_].name + " not implemented yet but will be soon! If you want it faster let us know!");
						p.CreatePacket(peer);
					}
					break;
				}
				}
				break;
			}
			default:
			{
				if (items[p_].magplant or items[p_].mag_multiple) {
					if (world_->owner_name != pInfo(peer)->tankIDName) {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(peer)->netID);
						p.Insert("Only the world owner is allowed to place that here!");
						p.Insert(0), p.Insert(1);
						p.CreatePacket(peer);
						{
							gamepacket_t p;
							p.Insert("OnConsoleMessage");
							p.Insert("Only the world owner is allowed to place that here!");
							p.CreatePacket(peer);
						}
						return false;
					}
				}
				if (block_->locked) {
					WorldBlock* block2_ = &world_->blocks[block_->lock_origin];
					string owner_name = block2_->owner_name, user_name = pInfo(peer)->tankIDName;
					if (owner_name != user_name and not pInfo(peer)->dev) {
						if (block2_->fg == 4994 or find(block2_->admins.begin(), block2_->admins.end(), user_name) == block2_->admins.end() and not block2_->open_to_public) {
							if (block2_->fg == 4994) {
								if (not block2_->open_to_public) {
									gamepacket_t p(0, pInfo(peer)->netID);
									p.Insert("OnPlayPositioned");
									p.Insert("audio/punch_locked.wav");
									if (not pInfo(peer)->invis) {
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
											if (pInfo(currentPeer)->world == name_) {
												p.CreatePacket(currentPeer);
											}
										}
									}
									else {
										p.CreatePacket(peer);
									}
									if (p_ != 18) {
										gamepacket_t p;
										p.Insert("OnTalkBubble");
										p.Insert(pInfo(peer)->netID);
										p.Insert("That area is owned by " + block2_->owner_name);
										p.Insert(0);
										p.Insert(1);
										p.CreatePacket(peer);
									}
									return true;
								}
								if (not block2_->build_only and block2_->open_to_public) {
									gamepacket_t p(0, pInfo(peer)->netID);
									p.Insert("OnPlayPositioned");
									p.Insert("audio/punch_locked.wav");
									if (not pInfo(peer)->invis) {
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
											if (pInfo(currentPeer)->world == name_) {
												p.CreatePacket(currentPeer);
											}
										}
									}
									else {
										p.CreatePacket(peer);
									}
									if (p_ != 18) {
										gamepacket_t p;
										p.Insert("OnTalkBubble");
										p.Insert(pInfo(peer)->netID);
										p.Insert("This lock allows breaking only!");
										p.Insert(0);
										p.Insert(1);
										p.CreatePacket(peer);
									}
									return false;
								}
							}
							else {
								gamepacket_t p(0, pInfo(peer)->netID);
								p.Insert("OnPlayPositioned");
								p.Insert("audio/punch_locked.wav");
								if (not pInfo(peer)->invis) {
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
										if (pInfo(currentPeer)->world == name_) {
											p.CreatePacket(currentPeer);
										}
									}
								}
								else {
									p.CreatePacket(peer);
								}
								if (p_ != 18) {
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(peer)->netID);
									p.Insert("That area is owned by " + block2_->owner_name);
									p.Insert(0);
									p.Insert(1);
									p.CreatePacket(peer);
								}
								return false;
							}
						}
						if (items[p_].blockType == BlockTypes::LOCK) {
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(peer)->netID);
							p.Insert("`w" + block2_->owner_name + "`` allows public building here, but no locks.");
							p.Insert(0);
							p.Insert(0);
							p.CreatePacket(peer);
							{
								gamepacket_t p(0, pInfo(peer)->netID);
								p.Insert("OnPlayPositioned");
								p.Insert("audio/punch_locked.wav");
								if (not pInfo(peer)->invis) {
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
										if (pInfo(currentPeer)->world == name_) {
											p.CreatePacket(currentPeer);
										}
									}
								}
								else {
									p.CreatePacket(peer);
								}
							}
							return false;
						}
					}
				}
				else if (not world_->owner_name.empty() and items[p_].blockType != BlockTypes::CONSUMABLE) {
					string owner_name = world_->owner_name, user_name = pInfo(peer)->tankIDName;
					if (owner_name != user_name and not pInfo(peer)->dev) {
						if (!guild_access(peer, world_->guild_id) and find(world_->admins.begin(), world_->admins.end(), user_name) == world_->admins.end() and not world_->open_to_public) {
							gamepacket_t p(0, pInfo(peer)->netID);
							p.Insert("OnPlayPositioned");
							p.Insert("audio/punch_locked.wav");
							if (not pInfo(peer)->invis) {
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
									if (pInfo(currentPeer)->world == name_) {
										p.CreatePacket(currentPeer);
									}
								}
							}
							else {
								p.CreatePacket(peer);
							}
							if (p_ != 18) {
								gamepacket_t p;
								p.Insert("OnTalkBubble");
								p.Insert(pInfo(peer)->netID);
								p.Insert("That area is owned by " + (world_->owner_named.substr(0, 2) == "`o" ? "`w" + world_->owner_name : world_->owner_named) + "``");
								p.Insert(0);
								p.Insert(1);
								p.CreatePacket(peer);
							}
							return false;
						}
						if (items[p_].blockType == BlockTypes::LOCK) {
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(peer)->netID);
							p.Insert("`w" + world_->owner_name + "`` allows public building here, but no locks.");
							p.Insert(0);
							p.Insert(0);
							p.CreatePacket(peer);
							{
								gamepacket_t p(0, pInfo(peer)->netID);
								p.Insert("OnPlayPositioned");
								p.Insert("audio/punch_locked.wav");
								if (not pInfo(peer)->invis) {
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
										if (pInfo(currentPeer)->world == name_) {
											p.CreatePacket(currentPeer);
										}
									}
								}
								else {
									p.CreatePacket(peer);
								}
							}
							return false;
						}
					}
				}
				if (world_->owner_name.empty() and items[p_].item_sucker) {
					gamepacket_t p;
					p.Insert("OnTalkBubble");
					p.Insert(pInfo(peer)->netID);
					p.Insert("This item can only be used in World-Locked worlds!");
					p.Insert(0), p.Insert(1);
					p.CreatePacket(peer);
					return false;
				}
				// statymas
				if (items[block_->fg].blockType == BlockTypes::CRYSTAL and items[p_].blockType == BlockTypes::CRYSTAL) {
					vector<vector<int>> current_{ {2242, 0}, {2244, 0}, {2246, 0}, {2248, 0}, {2250, 0} };
					int abcc = -1;
					string mix_with = "";
					if (modify_inventory(peer, p_, abcc) == 0) {
						bool obtained_ = false;
						for (int i = 0; i < block_->crystals.size(); i++) {
							vector<int> c_ = block_->crystals[i];
							if (c_[0] == p_) {
								block_->crystals[i][1]++;
								obtained_ = true;
							} for (int a = 0; a < current_.size(); a++) {
								if (current_[a][0] == c_[0]) {
									current_[a][1] = block_->crystals[i][1];
									break;
								}
							}
						} if (not obtained_) {
							block_->crystals.push_back({ p_, 1 });
							for (int a = 0; a < current_.size(); a++) {
								if (current_[a][0] == p_) {
									current_[a][1] = 1;
									break;
								}
							}
						} vector<string> reply{};
						for (int i = 0; i < current_.size(); i++) {
							reply.push_back(to_string(current_[i][1]) + "x `$" + mix_with + (current_[i][0] == 2242 ? "R" : (current_[i][0] == 2244 ? "G" : (current_[i][0] == 2246 ? "B" : (current_[i][0] == 2248 ? "W" : "B")))) + "``");
						} {
							gamepacket_t p;
							p.Insert("OnConsoleMessage");
							p.Insert("This Crystal is currently mixed with " + join(reply, ", "));
							p.CreatePacket(peer);
						}
					}
					return true;
				}
				grow4good(peer, false, "place", 1);
				if (p_ == 611) p_ = 610;
				if (block_->fg == 610 and p_ == 610) {
					// add kazkas
					int a = -1;
					if (modify_inventory(peer, 611, a, true) == 0) {
						PlayerMoving data_{};
						data_.packetType = 17, data_.netID = 66, data_.YSpeed = 66, data_.x = x_ * 32 + 16, data_.y = y_ * 32 + 16;
						BYTE* raw_e = packPlayerMoving(&data_);
						if (block_->bunny_egg_progress < 2001) {
							pInfo(peer)->egg++;
							block_->bunny_egg_progress++;
						}
						if (block_->bunny_egg_progress > 1000) {
							int burst_chance = 350;
							if (block_->bunny_egg_progress > 1500) burst_chance = 125;
							gamepacket_t p;
							p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
							if (rand() % burst_chance < 1) {
								p.Insert("`6The egg has exploded!``");
								block_->fg = 0, block_->bunny_egg_progress = 0;
								update_tile(peer, x_, y_, 0, false, true);
							}
							else p.Insert(block_->bunny_egg_progress <= 1500 ? "This oversized egg has a fair chance to burst!" : "`6This over-sized egg has a good chance to burst!``");
							p.Insert(0), p.Insert(1), p.CreatePacket(peer);
						}
						data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
						BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
						BYTE* blc = raw + 56;
						form_visual(blc, *block_, *world_, peer, false);
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
							if (pInfo(currentPeer)->world == world_->name) {
								send_raw(currentPeer, 4, raw_e, 56, ENET_PACKET_FLAG_RELIABLE);
								send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
							}
						}
						delete[] raw, raw_e, blc;
						if (block_->locked) {
							upd_lock(*block_, *world_, peer);
						}
					}
					return true;
				}
				else if (items[p_].blockType == BlockTypes::SEED and items[block_->fg].blockType != BlockTypes::SEED and block_->fg != 0 or items[p_].blockType != BlockTypes::BACKGROUND and items[p_].blockType != BlockTypes::SEED and block_->fg != 0) {
					packet_(peer, "action|play_sfx\nfile|audio/cant_place_tile.wav\ndelayMS|0");
					return false;
				}
				else if (items[p_].blockType == BlockTypes::BACKGROUND and items[block_->fg].blockType == BlockTypes::BEDROCK or items[p_].blockType == BlockTypes::BACKGROUND and items[block_->fg].blockType == BlockTypes::MAIN_DOOR) {
					return false;
				}
				if (p_ == 4516) {
					if (world_->owner_name == "" || world_->owner_name != pInfo(peer)->tankIDName) {
						gamepacket_t p;
						p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
						p.Insert("Only the owner of the world can place this.");
						p.Insert(0), p.Insert(1), p.CreatePacket(peer);
						return false;
					}
				}
				if (p_ == 5000 or p_ == 3832 or p_ == 5958 or p_ == 226 or p_ == 3616 or p_ == 1276 or p_ == 1278 or p_ == 4758 or p_ == 3750 or p_ == 4992 or p_ == 3072 or p_ == 4884 or p_ == 1436 or p_ == 8246 or p_ == 10258) {
					bool block_place = false;
					int cctv_count = 0;
					for (int i_ = 0; i_ < world_->blocks.size(); i_++) {
						if (world_->blocks[i_].fg == p_) {
							if (p_ != 1436 and p_ != 8246 and p_ != 10258) block_place = true;
						}
						if (p_ == 1436 || p_ == 8246 || p_ == 10258) {
							if (world_->blocks[i_].fg == 1436 || world_->blocks[i_].fg == 8246 || world_->blocks[i_].fg == 10258)  cctv_count++;
						}
					}
					if (block_place or cctv_count >= 8) {
						gamepacket_t p;
						p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
						if (p_ == 1436 || p_ == 8246 || p_ == 10258) p.Insert("``You can only have 8 " + items[p_].name + " in a world.");
						else {
							if (p_ == 5000 or p_ == 3832 or p_ == 5958) {
								p.Insert("``You can only have one " + items[p_].name + " in a world.");
								{
									gamepacket_t p(0, pInfo(peer)->netID);
									p.Insert("OnPlayPositioned"), p.Insert("audio/punch_locked.wav");
									if (not pInfo(peer)->invis) {
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != name_) continue;
											p.CreatePacket(currentPeer);
										}
									}
									else p.CreatePacket(peer);
								}
							}
							else p.Insert("This world already has a `$" + items[p_].name + "`` somewhere on it, installing two would be dangerous!");
						}
						p.Insert(0), p.Insert(1), p.CreatePacket(peer);
						return false;
					}
				}
				if (items[p_].collisionType == 1) {
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
						if (pInfo(currentPeer)->world == name_ and not pInfo(currentPeer)->ghost) {
							if (y_ == pInfo(currentPeer)->y / 32) {
								if (pInfo(currentPeer)->state == 0 and x_ * 32 < pInfo(currentPeer)->x and abs(x_ * 32 - pInfo(currentPeer)->x) < 32 or pInfo(currentPeer)->state == 16 and abs(x_ * 32 - pInfo(currentPeer)->x) < 32 or pInfo(currentPeer)->state != 16 and abs(x_ * 32 - pInfo(currentPeer)->x) < 20) {
									return false;
								}
							}
						}
					}
				}
				int c_ = -1;
				switch (items[p_].blockType) {
				case BlockTypes::CRYSTAL:
				{
					block_->crystals.push_back({ p_, 1 });
					punch_tile(peer, x_, y_, 0x3, p_, mag_place ? -1 : pInfo(peer)->netID, 0x0);
					break;
				}
				case BlockTypes::PROVIDER:
				{
					punch_tile(peer, x_, y_, 0x3, p_, pInfo(peer)->netID, 0x0);
					long long time_ = time(nullptr);
					if (items[block_->fg].properties & Property_AutoPickup)
						block_->planted = time_;
					else {
						/*original:
							block_->planted = time_ - ((rand() % 14400) + 1);
							block_->planted -= ((rand() % 14400) + 1);
							*/
						block_->planted = time(nullptr) - (items[block_->fg].growTime / 2);
						// per real gt kai kurie provider greiciau auga
					}
					if (p_ == 5196) block_->planted = time_ - 39600;
					break;
				}
				case BlockTypes::SEED:
				{
					if (items[block_->fg].blockType == BlockTypes::SEED) {
						long long time_ = time(nullptr);
						int timed = items[block_->fg].growTime;
						if (has_playmod(pInfo(peer), "Reduced Growtime..") and rand() % items[pInfo(peer)->ances].chance < 1) timed *= 1.02;
						uint32_t laikas = uint32_t((time_ - block_->planted <= timed ? time_ - block_->planted : timed));
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(peer)->netID);
						if (block_->sp) {
							p.Insert("It would be too dangerous to try to mix three seeds."), p.Insert(0), p.Insert(1), p.CreatePacket(peer);
							return false;
						}
						if (laikas == items[block_->fg].growTime) {
							p.Insert("This tree is already too big to splice another seed with."), p.Insert(0), p.Insert(1), p.CreatePacket(peer);
							return false;
						}
						for (int i_ = 0; i_ < items.size(); i_++) {
							if (items[i_].r_1 == p_ and items[i_].r_2 == block_->fg or items[i_].r_2 == p_ and items[i_].r_1 == block_->fg) {
								p.Insert("`w" + items[p_].name + "`` and `w" + items[block_->fg].name + "`` have been spliced to make a `$" + items[i_].name + " Tree``!");
								p.Insert(0);
								p.Insert(1);
								p.CreatePacket(peer);
								packet_(peer, "action|play_sfx\nfile|audio/success.wav\ndelayMS|0");
								block_->fg = i_ + 1, block_->sp = 1;
								PlayerMoving data_{};
								data_.packetType = 13, data_.plantingTree = p_;
								BYTE* raw = packPlayerMoving(&data_);
								raw[2] = 1;
								send_raw(peer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
								delete[]raw;
								{
									PlayerMoving data_{};
									data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
									BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
									BYTE* blc = raw + 56;
									form_visual(blc, *block_, *world_, peer, false);
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
										if (pInfo(currentPeer)->world == world_->name) {
											send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
										}
									}
									delete[] raw, blc;
									if (block_->locked) {
										upd_lock(*block_, *world_, peer);
									}
								}
								if (not mag_place) modify_inventory(peer, p_, c_, false);
								return true;
							}
							else if (i_ + 1 == items.size()) {
								bool changed_ = false;
								if (p_ == 339 and block_->fg == 627 or block_->fg == 339 and p_ == 627) {
									uint32_t s_ = p_ == 339 ? block_->fg : p_;
									i_ = 742;
									changed_ = true;
								}
								else if (p_ == 743 and block_->fg == 253 or block_->fg == 743 and p_ == 253) {
									uint32_t s_ = p_ == 743 ? block_->fg : p_;
									i_ = 758;
									changed_ = true;
								}
								else if (p_ == 743 and block_->fg == 285 or block_->fg == 745 and p_ == 285) {
									uint32_t s_ = p_ == 745 ? block_->fg : p_;
									i_ = 6674;
									changed_ = true;
								} if (changed_) {
									p.Insert("`w" + items[p_].name + "`` and `w" + items[block_->fg].name + "`` have been spliced to make a `$" + items[i_].name + " Tree``!");
									p.Insert(0);
									p.Insert(1);
									p.CreatePacket(peer);
									packet_(peer, "action|play_sfx\nfile|audio/success.wav\ndelayMS|0");
									block_->fg = i_ + 1, block_->sp = 1;
									//plant_(peer, block_, x_, y_, p_, false);
									PlayerMoving data_{};
									data_.packetType = 13, data_.plantingTree = p_;
									BYTE* raw = packPlayerMoving(&data_);
									raw[2] = 1;
									send_raw(peer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
									delete[]raw;
									{
										PlayerMoving data_{};
										data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
										BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
										BYTE* blc = raw + 56;
										form_visual(blc, *block_, *world_, peer, false);
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
											if (pInfo(currentPeer)->world == world_->name) {
												send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
											}
										}
										delete[] raw, blc;
										if (block_->locked) {
											upd_lock(*block_, *world_, peer);
										}
									}
									if (not mag_place) modify_inventory(peer, p_, c_, false);
									return true;
								}
								p.Insert("Hmm, it looks like `w" + items[block_->fg].name + "`` and `w" + items[p_].name + "`` can't be spliced.");
								p.Insert(0);
								p.Insert(1);
								p.CreatePacket(peer);
								return false;
							}
						}
					}
					break;
				}
				case BlockTypes::LOCK:
				{
					if (p_ == 202 or p_ == 204 or p_ == 206 or p_ == 4994) {
						if (not world_->owner_name.empty() and world_->owner_name != pInfo(peer)->tankIDName) {
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(peer)->netID);
							p.Insert("You must be world owner to place locks!");
							p.Insert(0);
							p.CreatePacket(peer);
							return true;
						}
						int safe_dis = p_ == 206 ? 7 : p_ == 204 ? 3 : 0; // nes kitaip susipisa viskas
						if (x_ < safe_dis or y_ < safe_dis or 100 - safe_dis < x_ or 60 - safe_dis < y_) {
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(peer)->netID);
							p.Insert("You can't place that here, move " + to_string(x_ < safe_dis ? safe_dis - x_ : y_ < safe_dis ? safe_dis - y_ : 100 - safe_dis < x_ ? x_ - (100 - safe_dis) : 60 - safe_dis < y_ ? y_ - (60 - safe_dis) : 0) + " block away from border!");
							p.Insert(0);
							p.CreatePacket(peer);
							return true;
						}
						block_->owner_name = pInfo(peer)->tankIDName;
						if (pInfo(peer)->name_color != "`0") block_->owner_named = pInfo(peer)->name_color + pInfo(peer)->tankIDName + "``";
						if (pInfo(peer)->mod == 1 && pInfo(peer)->dev == 1) block_->owner_named = pInfo(peer)->name_color + pInfo(peer)->tankIDName + "``";
						int lock_size = p_ == 202 ? 10 : (p_ == 204 ? 48 : (p_ == 202 ? 200 : 200));
						vector<vector<int>> tiles_ = lock_tiles(world_, x_, y_, lock_size);
						lock_size = tiles_.size();
						PlayerMoving data_{};
						data_.packetType = 15, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
						data_.netID = pInfo(peer)->id;
						data_.plantingTree = p_;
						BYTE* raw;
						if (tiles_.size() != 0) {
							raw = packPlayerMoving(&data_, 112 + (lock_size * 2) + alloc_(world_, block_));
							int lalala = 8;
							memcpy(raw + 8, &lock_size, 2);
							memcpy(raw + 12, &lalala, 2);
							BYTE* blc = raw + 56;
							for (int i_ = 0; i_ < tiles_.size(); i_++) {
								vector<int> update_tiles = tiles_[i_];
								int x = update_tiles[0];
								int y = update_tiles[1];
								int sq_ = x + (y * 100);
								WorldBlock* block_ = &world_->blocks[sq_];
								if (block_->locked) {
								}
								else {
									block_->locked = true;
									block_->lock_origin = x_ + (y_ * 100);
									memcpy(blc + (i_ * 2), &sq_, 2);
								}
							}
							for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
								if (pInfo(currentPeer)->world == name_) {
									packet_(currentPeer, "action|play_sfx\nfile|audio/use_lock.wav\ndelayMS|0");
									send_raw(currentPeer, 4, raw, 112 + (lock_size * 2) + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
								}
							}
							delete[] raw, blc;
						}
						else {
							raw = packPlayerMoving(&data_, 56);
							for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
								if (pInfo(currentPeer)->world == name_) {
									packet_(currentPeer, "action|play_sfx\nfile|audio/use_lock.wav\ndelayMS|0");
									send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
								}
							}
							delete[] raw;
						}
						gamepacket_t p;
						p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("Area locked."), p.Insert(0), p.Insert(0), p.CreatePacket(peer);
						{
							PlayerMoving data_{};
							data_.packetType = 13, data_.plantingTree = p_;
							BYTE* raw = packPlayerMoving(&data_);
							raw[2] = 1;
							send_raw(peer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
							delete[]raw;
						}
						break;
					}
					if (not world_->owner_name.empty()) {
						gamepacket_t p;
						p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("Only one `$World Lock`` can be placed in a world, you'd have to remove the other one first."), p.Insert(0), p.Insert(0), p.CreatePacket(peer);
						return false;
					}
					for (int i_ = 0; i_ < world_->blocks.size(); i_++) {
						if (world_->blocks[i_].fg == 202 or world_->blocks[i_].fg == 204 or world_->blocks[i_].fg == 206 or world_->blocks[i_].fg == 4994) {
							if (world_->blocks[i_].owner_name != pInfo(peer)->tankIDName) {
								gamepacket_t p;
								p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("Your `$World Lock`` can't be placed in this world unless everyone else's locks are removed."), p.Insert(0), p.Insert(0), p.CreatePacket(peer);
								return false;
							}
						}
					}
					if (pInfo(peer)->w_d == today_day && pInfo(peer)->w_w >= 10) {
						gamepacket_t p;
						p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("You locked too many new worlds today, try tomorrow!"), p.Insert(0), p.Insert(0), p.CreatePacket(peer);
						return false;
					}
					else if (pInfo(peer)->w_d != today_day && pInfo(peer)->w_w != 0) pInfo(peer)->w_w = 0;
					pInfo(peer)->w_w++, pInfo(peer)->w_d = today_day;
					pInfo(peer)->worlds_owned.push_back(world_->name);
					world_->owner_name = pInfo(peer)->tankIDName;
					if (pInfo(peer)->name_color != "`0") world_->owner_named = pInfo(peer)->name_color + pInfo(peer)->tankIDName + "``";
					if (pInfo(peer)->mod == 1 && pInfo(peer)->dev == 1) world_->owner_named = pInfo(peer)->name_color + pInfo(peer)->tankIDName + "``";
					PlayerMoving data_{};
					data_.packetType = 15, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8, data_.netID = pInfo(peer)->id, data_.plantingTree = p_;
					BYTE* raw = packPlayerMoving(&data_, 56);
					world_->lockid = p_;
					if (p_ == 11550 || p_ == 11586 || p_ == 10410) {
						if (p_ == 11550) world_->weather = 54;
						if (p_ == 11586) world_->weather = 55;
						if (p_ == 10410) world_->weather = 53;
						gamepacket_t p;
						p.Insert("OnSetCurrentWeather"), p.Insert(world_->weather == 0 ? 80 : world_->weather);
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != name_) continue;
							pInfo(currentPeer)->lock = p_;
							p.CreatePacket(currentPeer);
						}
					}
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
						bool wlachi = std::experimental::filesystem::exists("db/alist/wl/" + (pInfo(peer)->tankIDName) + ".txt");
						if (wlachi == false) {
							ofstream myfile;
							myfile.open("db/alist/wl/" + (pInfo(peer)->tankIDName) + ".txt");
							myfile << "true";
							myfile.close();
							gamepacket_t p, p2;
							p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert(pInfo(peer)->name_color + pInfo(peer)->tankIDName + "`5 earned the achievement 'This Land Is My Land (Classic)'!");
							p2.Insert("OnConsoleMessage"), p2.Insert(pInfo(peer)->name_color + pInfo(peer)->tankIDName + "`5 earned the achievement 'This Land Is My Land (Classic)'!");
							pInfo(peer)->achievement_total++;
							PlayerMoving data_{};
							data_.packetType = 17, data_.netID = 46, data_.YSpeed = 46, data_.x = pInfo(peer)->x + 16, data_.y = pInfo(peer)->y + 16;
							BYTE* raw = packPlayerMoving(&data_);
							for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world) continue;
								p.CreatePacket(currentPeer);
								p2.CreatePacket(currentPeer);
								send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
							}
							delete[] raw;
						}
					}
					if (p_ == 1796) {
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
							bool wlachi = std::experimental::filesystem::exists("db/alist/dl/" + (pInfo(peer)->tankIDName) + ".txt");
							if (wlachi == false) {
								ofstream myfile;
								myfile.open("db/alist/dl/" + (pInfo(peer)->tankIDName) + ".txt");
								myfile << "true";
								myfile.close();
								gamepacket_t p, p2;
								p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert(pInfo(peer)->name_color + pInfo(peer)->tankIDName + "`5 earned the achievement 'Showoff'!");
								p2.Insert("OnConsoleMessage"), p2.Insert(pInfo(peer)->name_color + pInfo(peer)->tankIDName + "`5 earned the achievement 'Showoff'!");
								pInfo(peer)->achievement_total++;
								PlayerMoving data_{};
								data_.packetType = 17, data_.netID = 46, data_.YSpeed = 46, data_.x = pInfo(peer)->x + 16, data_.y = pInfo(peer)->y + 16;
								BYTE* raw = packPlayerMoving(&data_);
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world) continue;
									p.CreatePacket(currentPeer);
									p2.CreatePacket(currentPeer);
									send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
								}
								delete[] raw;
							}
						}
					}
					if (p_ == 7188) {
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
							bool wlachi = std::experimental::filesystem::exists("db/alist/bgl/" + (pInfo(peer)->tankIDName) + ".txt");
							if (wlachi == false) {
								ofstream myfile;
								myfile.open("db/alist/bgl/" + (pInfo(peer)->tankIDName) + ".txt");
								myfile << "true";
								myfile.close();
								gamepacket_t p, p2;
								p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert(pInfo(peer)->name_color + pInfo(peer)->tankIDName + "`5 earned the achievement 'Big Showoff'!");
								p2.Insert("OnConsoleMessage"), p2.Insert(pInfo(peer)->name_color + pInfo(peer)->tankIDName + "`5 earned the achievement 'Big Showoff'!");
								pInfo(peer)->achievement_total++;
								PlayerMoving data_{};
								data_.packetType = 17, data_.netID = 46, data_.YSpeed = 46, data_.x = pInfo(peer)->x + 16, data_.y = pInfo(peer)->y + 16;
								BYTE* raw = packPlayerMoving(&data_);
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world) continue;
									p.CreatePacket(currentPeer);
									p2.CreatePacket(currentPeer);
									send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
								}
								delete[] raw;
							}
						}
					}
					gamepacket_t p, p2;
					p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("`5[```w" + world_->name + "`` has been `$World Locked`` by " + (pInfo(peer)->name_color != "`0" ? pInfo(peer)->name_color : "`o") + "" + world_->owner_name + "```5]``"), p.Insert(0);
					p2.Insert("OnConsoleMessage"), p2.Insert("`5[```w" + world_->name + "`` has been `$World Locked`` by " + (pInfo(peer)->name_color != "`0" ? pInfo(peer)->name_color : "`o") + "" + world_->owner_name + "```5]``");
					gamepacket_t p3(0, pInfo(peer)->netID);
					{
						p3.Insert("OnNameChanged");
						if (pInfo(peer)->mod == 0 && pInfo(peer)->dev == 0)pInfo(peer)->name_color = "`2";
						p3.Insert((not pInfo(peer)->d_name.empty() ? pInfo(peer)->d_name : pInfo(peer)->name_color + pInfo(peer)->tankIDName) + (pInfo(peer)->is_legend ? " of Legend" : "") + "``");
					}
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
						if (pInfo(currentPeer)->world == name_) {
							packet_(currentPeer, "action|play_sfx\nfile|audio/use_lock.wav\ndelayMS|0");
							send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
							p.CreatePacket(currentPeer), p2.CreatePacket(currentPeer), p3.CreatePacket(currentPeer);
						}
					}
					delete[] raw;
					{
						PlayerMoving data_{};
						data_.packetType = 13, data_.plantingTree = p_;
						BYTE* raw = packPlayerMoving(&data_);
						raw[2] = 1;
						send_raw(peer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
						delete[]raw;
					}
					break;
				}
				default:
				{
					if (p_ == 610) {
						punch_tile(peer, x_, y_, 0x3, 611, mag_place ? -1 : pInfo(peer)->netID, 0x0);
						{
							punch_tile(peer, x_, y_, 0x3, p_, -1, 0x0);
						}
					}
					else {
						punch_tile(peer, x_, y_, 0x3, p_, mag_place ? -1 : pInfo(peer)->netID, 0x0);
					}
					break;
				}
				}
				if (items[p_].blockType == BlockTypes::BACKGROUND)
					block_->bg = p_;
				else {
					block_->fg = p_;
				}
				if (items[p_].blockType == BlockTypes::SEED) {
					plant_(world_, peer, block_, x_, y_, p_, true, mag_place);
				}
				if (items[p_].heart_monitor) {
					block_->heart_monitor = pInfo(peer)->name_color + pInfo(peer)->tankIDName + "``";
					GlobalMonitors new_monitor;
					new_monitor.active = 1, new_monitor.world_name = world_->name, new_monitor.x = x_, new_monitor.y = y_;
					monitors.push_back(new_monitor);
				}
				if (items[p_].blockType == BlockTypes::PROVIDER or items[p_].vipentrance or items[p_].heart_monitor) {
					PlayerMoving data_{};
					data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
					BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
					BYTE* blc = raw + 56;
					form_visual(blc, *block_, *world_, peer, false, false, x_, y_);
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != world_->name) continue;
						send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
					}
					delete[] raw, blc;
					if (block_->locked) upd_lock(*block_, *world_, peer);
				}
				block_->lp = 0;
				if (items[p_].multiple_sides and pInfo(peer)->state == 16) {
					block_->flags |= 0x00200000;
					PlayerMoving data_{};
					data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
					BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
					BYTE* blc = raw + 56;
					form_visual(blc, *block_, *world_, peer, false);
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != world_->name) continue;
						send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
					}
					delete[] raw, blc;
					if (block_->locked) upd_lock(*block_, *world_, peer);
				}
				add_builder_xp(peer, 1);
				if (not mag_place) modify_inventory(peer, (p_ == 610 ? 611 : p_), c_, false);
				break;
			}
			}
			break;

		}

		}
	}
	return true;
}
void move_(ENetPeer* peer, PlayerMoving* data) {
	data->netID = pInfo(peer)->netID;
	BYTE* raw = packPlayerMoving(data);
	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL || peer == currentPeer || pInfo(currentPeer)->world != pInfo(peer)->world) continue;
		send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
	}
	delete[]raw;
}